// automatically generated by ida2asm, do not edit!

#include "vm.h"
#include "defs.h"

#ifdef _MSC_VER
# pragma warning(disable: 4309 4146 4333 4805 4102)
#endif

using namespace SwosVM;

extern void ShowMenu();
extern void cseg_88183();
extern void GetPlayerAtIndex();
extern void VerifyTeamLoaded();
extern void GetPlayer();
extern void StringCopy();
extern void CalcMenuEntryAddress();
extern void GetTeamPointer();
extern void ExtractSurname();
extern void DrawMultipleItems();
extern void SetExitMenuFlag();

// first pass forward declarations
void dseg_1733C6();
void dseg_17343E();
void dseg_173472();
void InitHighestScorersTable();
void dseg_1735BC();
void dseg_1737EE();
void dseg_173888();
void SortHighestScorerTable();
void GetScorerSurname();
void CompetitionTopGoalScorersInit();
void CompetitionTopGoalScorersExit();
void TopGoalScorersInit();
void TopGoalScorersBeforeDrawCommon();
void TopGoalScorersExit();

// =============== S U B R O U T I N E =======================================

// in:
//      D0 -
//      A0 -> name of DIY competition
//
void dseg_1733C6()
{
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (!flags.zero)
        goto dseg_1733D9;                   // jnz short dseg_1733D9

    *(word *)&D0 = 0;                       // mov word ptr D0, 0

dseg_1733D9:;
    push(D0);                               // push D0
    push(A0);                               // push A0
    InitHighestScorersTable();              // call InitHighestScorersTable
    pop(A0);                                // pop A0
    pop(D0);                                // pop D0
    push(D0);                               // push D0
    push(A0);                               // push A0
    dseg_173472();                          // call dseg_173472
    pop(A0);                                // pop A0
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[337172] = eax;     // mov diyStatsName, eax
    SortHighestScorerTable();               // call SortHighestScorerTable
    A6 = 487959;                            // mov A6, offset competitionTopGoalScorersMenu
    push(A5);                               // push A5
    SWOS::ShowMenu();                       // call ShowMenu
    pop(A5);                                // pop A5
}

// =============== S U B R O U T I N E =======================================
//
void dseg_17343E()
{
    InitHighestScorersTable();              // call InitHighestScorersTable
    *(word *)&D0 = -1;                      // mov word ptr D0, -1
    dseg_173472();                          // call dseg_173472
    SortHighestScorerTable();               // call SortHighestScorerTable
    A6 = 489075;                            // mov A6, offset topGoalScorersMenu
    push(A0);                               // push A0
    SWOS::ShowMenu();                       // call ShowMenu
    pop(A5);                                // pop A5
}

// =============== S U B R O U T I N E =======================================
//
void dseg_173472()
{
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

l_teams_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto l_next_team;                   // jz short @@next_team

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(A0);                               // push A0
    dseg_1735BC();                          // call dseg_1735BC
    pop(A0);                                // pop A0
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

l_next_team:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 684
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_teams_loop;                  // jns short @@teams_loop

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        return;                             // jnz short @@out

    ax = *(word *)&g_memByte[129476];       // mov ax, dseg_E0052
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    A0 = 92798;                             // mov A0, offset careerTeam
    push(D0);                               // push D0
    dseg_1735BC();                          // call dseg_1735BC
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// Set team and player numbers of scorers to -1 (non existent) and
// goals scored to zero in highest scorers table.
//
void InitHighestScorersTable()
{
    A2 = 317494;                            // mov A2, offset highestScorersTable
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    *(word *)&D7 = 14;                      // mov word ptr D7, 14
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 30, 1, 0);            // mov byte ptr [esi+30], 0
    writeMemory(esi + 31, 1, 15);           // mov byte ptr [esi+31], 15
    eax = A2;                               // mov eax, A2
    A3 = eax;                               // mov A3, eax

l_loop:;
    ax = D6;                                // mov ax, word ptr D6
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 2
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 32, 2, -1);           // mov word ptr [esi+32], -1
    writeMemory(esi + 34, 1, -1);           // mov byte ptr [esi+34], -1
    writeMemory(esi + 35, 1, 0);            // mov byte ptr [esi+35], 0
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 4;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 4
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A2 = res;
    }                                       // add A2, 4
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_loop;                        // jns short @@loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 -
//
void dseg_1735BC()
{
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto dseg_1735E6;                   // jns short dseg_1735E6

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_SEASON
    if (flags.zero)
        goto l_season_or_career;            // jz short @@season_or_career

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto dseg_1735E6;                   // jnz short dseg_1735E6

l_season_or_career:;
    cseg_88183();                           // call cseg_88183
    if (!flags.zero)
        return;                             // jnz @@out

dseg_1735E6:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    A5 = 317494;                            // mov A5, offset highestScorersTable
    eax = A0;                               // mov eax, A0
    A2 = eax;                               // mov A2, eax
    A4 = eax;                               // mov A4, eax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 30, 1);     // mov al, [esi+30]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    *(word *)&D1 = 15;                      // mov word ptr D1, 0Fh
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (!flags.zero)
        goto dseg_173659;                   // jnz short dseg_173659

    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

dseg_173659:;
    *(word *)&D7 = 0;                       // mov word ptr D7, 0

l_players_loop:;
    push(D1);                               // push small [word ptr D1]
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (!flags.zero)
        goto dseg_17369F;                   // jnz short dseg_17369F

    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    eax = A0;                               // mov eax, A0
    A2 = eax;                               // mov A2, eax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D7 = ax;                      // mov word ptr D7, ax

dseg_17369F:;
    ax = D4;                                // mov ax, word ptr D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto dseg_173742;                   // jns dseg_173742

    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 109, 1);    // mov al, [esi+109]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    al = (byte)readMemory(esi + 110, 1);    // mov al, [esi+110]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    al = (byte)readMemory(esi + 111, 1);    // mov al, [esi+111]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    al = (byte)readMemory(esi + 112, 1);    // mov al, [esi+112]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 255;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0FFh
    if (flags.carry || flags.zero)
        goto dseg_173733;                   // jbe short dseg_173733

    *(word *)&D0 = 255;                     // mov word ptr D0, 0FFh

dseg_173733:;
    al = D0;                                // mov al, byte ptr D0
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_next_player;                 // jz @@next_player

    goto l_got_number_of_goals;             // jmp short @@got_number_of_goals

dseg_173742:;
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx + 109, 1); // mov al, [esi+ebx+109]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_next_player;                 // jz short @@next_player

l_got_number_of_goals:;
    al = D6;                                // mov al, byte ptr D6
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_next_player;                 // jb short @@next_player

    if (!flags.carry && !flags.zero)
        goto dseg_17377B;                   // ja short dseg_17377B

    esi = A4;                               // mov esi, A4
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto l_next_player;                 // jz short @@next_player

dseg_17377B:;
    dseg_173888();                          // call dseg_173888
    al = D0;                                // mov al, byte ptr D0
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 35, 1, al);           // mov [esi+35], al
    al = D7;                                // mov al, byte ptr D7
    writeMemory(esi + 34, 1, al);           // mov [esi+34], al
    ax = D5;                                // mov ax, word ptr D5
    writeMemory(esi + 32, 2, ax);           // mov [esi+32], ax
    al = D6;                                // mov al, byte ptr D6
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto l_next_player;                 // jz short @@next_player

    esi = A5;                               // mov esi, A5
    {
        byte src = (byte)readMemory(esi + 31, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 31, 1, src);
    }                                       // sub byte ptr [esi+31], 1
    if (!flags.zero)
        goto l_next_player;                 // jnz short @@next_player

    dseg_1737EE();                          // call dseg_1737EE

l_next_player:;
    {
        int32_t val = stack[stackTop++];
        *(word *)&D1 = val;
    }                                       // pop small [word ptr D1]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 38;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 38
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_players_loop;                // jns @@players_loop
}

// =============== S U B R O U T I N E =======================================
//
void dseg_1737EE()
{
    eax = A5;                               // mov eax, A5
    A0 = eax;                               // mov A0, eax
    *(byte *)&D3 = 255;                     // mov byte ptr D3, 0FFh
    *(byte *)&D1 = 0;                       // mov byte ptr D1, 0
    *(word *)&D2 = 14;                      // mov word ptr D2, 0Eh

dseg_17380F:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 35, 1);     // mov al, [esi+23h]
    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D3, al
    if (flags.carry)
        goto dseg_17384F;                   // jb short dseg_17384F

    al = (byte)readMemory(esi + 35, 1);     // mov al, [esi+23h]
    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D3, al
    if (!flags.zero)
        goto dseg_17383A;                   // jnz short dseg_17383A

    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, 1
    goto dseg_17384F;                       // jmp short dseg_17384F

dseg_17383A:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 35, 1);     // mov al, [esi+23h]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    *(byte *)&D1 = 1;                       // mov byte ptr D1, 1

dseg_17384F:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 4
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto dseg_17380F;                   // jns short dseg_17380F

    al = D3;                                // mov al, byte ptr D3
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 1, al);           // mov [esi+1Eh], al
    al = D1;                                // mov al, byte ptr D1
    writeMemory(esi + 31, 1, al);           // mov [esi+1Fh], al
    al = D3;                                // mov al, byte ptr D3
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
}

// =============== S U B R O U T I N E =======================================

// in:
//      D6 -  number of goals
//      A5 -> highest scorer table
// out:
//      A3 -> scorer that scored that number of goals
//
void dseg_173888()
{
    *(word *)&D1 = 14;                      // mov word ptr D1, 14
    eax = A5;                               // mov eax, A5
    A3 = eax;                               // mov A3, eax

l_scorers_loop:;
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 35, 1);     // mov al, [esi+35]
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D6, al
    if (!flags.zero)
        goto l_next;                        // jnz short @@next

    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+32], -1
    if (flags.zero)
        return;                             // jz @@out

    push(D0);                               // push small [word ptr D0]
    push(D1);                               // push small [word ptr D1]
    ax = (word)readMemory(esi + 32, 2);     // mov ax, [esi+32]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = (byte)readMemory(esi + 34, 1);     // mov al, [esi+34]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    {
        int32_t val = stack[stackTop++];
        *(word *)&D1 = val;
    }                                       // pop small [word ptr D1]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D0 = val;
    }                                       // pop small [word ptr D0]
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], 1
    if (flags.zero)
        return;                             // jz short @@out

l_next:;
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A3 = res;
    }                                       // add A3, 4
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_scorers_loop;                // jns @@scorers_loop

    eax = A5;                               // mov eax, A5
    A3 = eax;                               // mov A3, eax

l_next_scorer:;
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 35, 1);     // mov al, [esi+35]
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D6, al
    if (flags.zero)
        return;                             // jz short @@out

    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A3 = res;
    }                                       // add A3, 4
    goto l_next_scorer;                     // jmp short @@next_scorer
}

// =============== S U B R O U T I N E =======================================
//
void SortHighestScorerTable()
{
    A5 = 317494;                            // mov A5, offset highestScorersTable
    eax = A5;                               // mov eax, A5
    A3 = eax;                               // mov A3, eax
    *(word *)&D7 = 13;                      // mov word ptr D7, 13

l_outer_loop:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    eax = A3;                               // mov eax, A3
    A2 = eax;                               // mov A2, eax

l_inner_loop:;
    eax = A5;                               // mov eax, A5
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    eax = A5;                               // mov eax, A5
    A1 = eax;                               // mov A1, eax
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A1;                               // mov eax, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+32], -1
    if (flags.zero)
        goto l_exchange;                    // jz @@exchange

    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+32], -1
    if (flags.zero)
        goto l_order_ok;                    // jz @@order_ok

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 35, 1);     // mov al, [esi+35]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 35, 1);     // mov al, [esi+35]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.carry && !flags.zero)
        goto l_order_ok;                    // ja @@order_ok

    if (flags.carry)
        goto l_exchange;                    // jb short @@exchange

    GetScorerSurname();                     // call GetScorerSurname
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    eax = A6;                               // mov eax, A6
    A1 = eax;                               // mov A1, eax
    GetScorerSurname();                     // call GetScorerSurname

l_next_surname_char:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_order_ok;                    // jz short @@order_ok

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A6)++;                    // inc A6
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_order_ok;                    // jb short @@order_ok

    if (!flags.carry && !flags.zero)
        goto l_exchange;                    // ja short @@exchange

    goto l_next_surname_char;               // jmp short @@next_surname_char

l_exchange:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    writeMemory(esi, 2, ax);                // mov [esi], ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 2, 2, ax);            // mov [esi+2], ax

l_order_ok:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A2 = res;
    }                                       // add A2, 2
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto l_inner_loop;                  // jns @@inner_loop

    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_outer_loop;                  // jns @@outer_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 = player in highest_scorers_table
// out:
//      A6 -> player surname
//
void GetScorerSurname()
{
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 32, 2);     // mov ax, [esi+32]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = (byte)readMemory(esi + 34, 1);     // mov al, [esi+34]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, PlayerFile.playerName+4Ch
    A0 = eax;                               // mov A0, eax
    A6 = eax;                               // mov A6, eax

l_next_char:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        return;                             // jz short @@out

    (*(int32_t *)&A0)++;                    // inc A0
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = ' ';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], ' '
    if (!flags.zero)
        goto l_next_char;                   // jnz short @@next_char

    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    goto l_next_char;                       // jmp short @@next_char
}

// =============== S U B R O U T I N E =======================================
//
void CompetitionTopGoalScorersInit()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[337172];     // mov eax, diyStatsName
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    A2 = 317494;                            // mov A2, offset highestScorersTable
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 30, 1);     // mov al, [esi+30]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    eax = A2;                               // mov eax, A2
    *(word *)&D7 = 14;                      // mov word ptr D7, 14

l_scorers_loop:;
    A6 = 317494;                            // mov A6, offset highestScorersTable
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A6;                               // mov eax, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A6 = eax;                               // mov A6, eax
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+32], -1
    if (flags.zero)
        goto l_invisible_entries_loop;      // jz @@invisible_entries_loop

    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A5 = res;
    }                                       // add A5, 56
    ax = (word)readMemory(esi + 32, 2);     // mov ax, [esi+32]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A3 = eax;                               // mov A3, eax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 34, 1);     // mov al, [esi+34]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, PlayerFile.playerName+4Ch
    A0 = eax;                               // mov A0, eax
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A5 = res;
    }                                       // add A5, 56
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 10803;                             // mov A0, offset aLparen
    StringCopy();                           // call StringCopy
    eax = A3;                               // mov eax, A3
    A0 = eax;                               // mov A0, eax
    StringCopy();                           // call StringCopy
    A0 = 10805;                             // mov A0, offset aRparen
    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 35, 1);     // mov al, [esi+35]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A5 = res;
    }                                       // add A5, 56
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_scorers_loop;                // jns @@scorers_loop

    return;                                 // retn

l_invisible_entries_loop:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 38h
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 38h
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 38h
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A5 = res;
    }                                       // add A5, 38h
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_invisible_entries_loop;      // jns short @@invisible_entries_loop
}

// =============== S U B R O U T I N E =======================================
//
void CompetitionTopGoalScorersExit()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void TopGoalScorersInit()
{
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto dseg_173F90;                   // jnz dseg_173F90

    eax = A0;                               // mov eax, A0
    push(D0);                               // push D0
    D0 = 23;                                // mov D0, 17h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 24;                                // mov D0, 18h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 25;                                // mov D0, 19h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+14h]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 2, ax);           // mov [esi+14h], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+14h]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 20, 2, ax);           // mov [esi+14h], ax
    eax = A0;                               // mov eax, A0
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+14h]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 2, ax);           // mov [esi+14h], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+14h]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 20, 2, ax);           // mov [esi+14h], ax
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 22039);        // mov dword ptr [esi+26h], offset dseg_C5CA6

dseg_173F90:;
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        return;                             // jnz dseg_1740E5

    eax = A0;                               // mov eax, A0
    push(D0);                               // push D0
    D0 = 23;                                // mov D0, 17h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 24;                                // mov D0, 18h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+14h]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 2, ax);           // mov [esi+14h], ax
    eax = A0;                               // mov eax, A0
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+14h]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 2, ax);           // mov [esi+14h], ax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
}

// =============== S U B R O U T I N E =======================================
//
void TopGoalScorersBeforeDrawCommon()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 6
    {
        word res = *(word *)&D4 << 1;
        flags.carry = ((word)*(word *)&D4 >> 15) & 1;
        *(word *)&D4 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D4, 1
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 21;                                // mov D0, 15h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    A2 = 317494;                            // mov A2, offset highestScorersTable
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 30, 1);     // mov al, [esi+30]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    A6 = 317494;                            // mov A6, offset highestScorersTable
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A6;                               // mov eax, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A6 = eax;                               // mov A6, eax
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+20h], 0FFFFh
    if (flags.zero)
        goto dseg_17448A;                   // jz dseg_17448A

    ax = (word)readMemory(esi + 32, 2);     // mov ax, [esi+20h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    A3 = eax;                               // mov A3, eax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 34, 1);     // mov al, [esi+22h]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4Fh
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 21;                      // mov word ptr D0, 15h
    push(D7);                               // push D7
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A6);                               // push A6
    ExtractSurname();                       // call ExtractSurname
    pop(A6);                                // pop A6
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(D7);                                // pop D7
    eax = A0;                               // mov eax, A0
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    A0 = 10803;                             // mov A0, offset aLparen
    StringCopy();                           // call StringCopy
    eax = A3;                               // mov eax, A3
    A0 = eax;                               // mov A0, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    StringCopy();                           // call StringCopy
    A0 = 10805;                             // mov A0, offset aRparen
    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    ax = D7;                                // mov ax, word ptr D7
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto dseg_17434D;                   // jz short dseg_17434D

    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 109, 1);    // mov al, [esi+6Dh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

dseg_17434D:;
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto dseg_1743A3;                   // jz short dseg_1743A3

    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 110, 1);    // mov al, [esi+6Eh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

dseg_1743A3:;
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto dseg_1743F9;                   // jz short dseg_1743F9

    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 111, 1);    // mov al, [esi+6Fh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

dseg_1743F9:;
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 35, 1);     // mov al, [esi+23h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // add A4, 38h
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 21;                                // mov D0, 15h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    { SWOS::DrawMultipleItems(); return; }  // jmp DrawMultipleItems

dseg_17448A:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = D7;                                // mov ax, word ptr D7
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // add A4, 38h
}

// =============== S U B R O U T I N E =======================================
//
void TopGoalScorersExit()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

