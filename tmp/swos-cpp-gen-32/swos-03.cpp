// automatically generated by ida2asm, do not edit!

#include "vm.h"
#include "defs.h"

#ifdef _MSC_VER
# pragma warning(disable: 4309 4146 4333 4805 4102)
#endif

using namespace SwosVM;

extern void SelectTeamsFinalMenu();
extern void StringCopy();
extern void ChooseTeamForEditTactics();
extern void InitTeams();
extern void SelectFileToSaveDialog();
extern void StringCopyUntilChar();
extern void SetZeroFlag();
extern void RotatePlayersLeft();
extern void ExtractSurname();
extern void IsTeamNational();
extern void cseg_247C8();
extern void SetMenuEntryPlayerFace();
extern void SetupTeamSubstitutes();
extern void InitializeTacticsPositions();
extern void DrawSprite();
extern void DrawSpriteCentered();
extern void CalculateDeltaXAndY();
extern void WriteFile();
extern void GetFilenameAndExtension();
extern void ShowErrorMenu();
extern void LoadFile();
extern void CopyWholeSprite();
extern void ConvertSpriteColors();
extern void cseg_3A110();
extern void cseg_3A2CE();
extern void cseg_24132();
extern void LoadTeamFile();
extern void GetBankBalance();
extern void ShowMenu();
extern void CallDrawMenuItem();
extern void IsPlayerInCareerContest();
extern void FindForeignMarketPlayer();
extern void cseg_13DFB();
extern void FormTopSkillsString();
extern void cseg_3E04F();
extern void cseg_8DF16();
extern void cseg_8E23A();
extern void LoadPoolplyrDat();
extern void AddRandomForeignMarketPlayer();
extern void cseg_8E09A();
extern void AddCareerTeamPlayer();
extern void GetStringLength();
extern void cseg_3B7F8();
extern void cseg_3B842();
extern void SaveRand2State();
extern void GetPlayerRandomNum();
extern void Randomize2();
extern void GetPlayer();
extern void RestoreRand2State();
extern void GetTeamPointer();
extern void nullsub_17();
extern void DrawMultipleItems();
extern void VerifyTeamLoaded();
extern void SearchTeamInTmdFile();
extern void cseg_9423A();
extern void cseg_94193();
extern void IsPlayerInjured();
extern void cseg_3D5A7();
extern void FindTeamInDIY();
extern void Rand();
extern void ChooseTeamsDialog();
extern void SetCurrentEntry();
extern void DrawMenu();
extern void DrawMenuItem();
extern void SetExitMenuFlag();
extern void Rand2();
extern void GetTeamValueBase();
extern void WriteAccountBalance();
extern void Int2PoundsSigned();
extern void PrintFormatted();
extern void Int2Pounds();
extern void GetCurrentSeasonPointer();
extern void cseg_3AA17();
extern void CalcMenuEntryAddress();
extern void CheckContinueAbortPrompt();
extern void DoContinueAbortMenu();
extern void nullsub_9();
extern void CallDrawMultipleItems();
extern void InputText();
extern void InitAndPlayGame();
extern void GetPlayerAtIndex();
extern void cseg_33A1A();

// first pass forward declarations
void cseg_4C83A();
void ChooseTeamsFriendlyInitFinish();
void ViewSelected();
void ExitChooseTeams2();
void ChooseTeamsPlayMatchSelected();
void ChooseTeamsFriendlyCommon2();
void ChooseTeamsSetHeader();
void Bureaucracy();
void CheckNumTeamsAllowed();
void cseg_4D752();
void AddTeamToBuffer();
void DeselectTeam();
void FindTeam();
void SelectDiyLeagueMenu();
void SelectDiyCupMenu();
void SelectDiyTournamentMenu();
void SelectDiyExitMenu();
void EditTactics();
void ShowStandardChooseTacticsMenu();
void ChooseTacticsInit();
void User_A_Tactics();
void User_B_Tactics();
void User_C_Tactics();
void User_D_Tactics();
void User_E_Tactics();
void User_F_Tactics();
void ExitChooseTacticsMenu();
void EditTacticsInit();
void EditTacticsOnRestore();
void EditTacticsCommon();
void cseg_4E166();
void cseg_4E1F1();
void out3();
void EditTacticsPlayerNamesCommon();
void cseg_4E3DD();
void SelectCopyTactics();
void UndoTactics();
void AbortEditTactics();
void SaveAndExitEditTactics();
void ImportTactics();
void FlipOnOff();
void EnableOrDisablePlayerFacesItems();
void CopyCurrentTacticName();
void EditTacicsMovePlayersOrBall();
void CopyTactics();
void EditTactics2AfterDraw();
void EditTacticsOnSelect28();
void EditTacticsAfterDrawCommon();
void EditTactics28AfterDraw();
void cseg_4ECAD();
void EditTacticsAfterDrawPlayerNames();
void cseg_4F37E();
void DrawPlayerNamesAndFaces();
void EditTacticsMenuSavePlayerPositions();
void cseg_4FA3A();
void SetBigCheckSprite();
void ApplyCurrentEditedTactics();
void cseg_4FC28();
void SaveCurrentTactics();
void RestoreTactics();
void cseg_4FDC1();
void cseg_4FE17();
void GetPlayerQuadrant();
void cseg_4FEFF();
void GetBallXYPositionFromQuadrant();
void GetBallQuadrant();
void cseg_50093();
void cseg_50155();
void cseg_50391();
void DrawEditTacticsPitchAndPlayers();
void cseg_50501();
void EditTacticsReadControls();
void cseg_50AAE();
void cseg_50B6D();
void HandlePlayersOrBallInEditTactics();
void EditTacticsDrawCursor();
void GetPlayerXYPositionFromQuadrant();
void DrawLittlePlayersAndBall();
void cseg_515FD();
void cseg_516BB();
void cseg_51729();
void SortPlayerAreasByY();
void DrawPlayerDirections();
void WriteTacticsFile();
void nullsub_18();
void ImportTacticsSelectTactics();
void ExitImportTactics();
void LoadTactics();
void ReadTacticsFile();
void InitLittlePlayerSprites();
void ConvertPlayerDressColor();
void CopyCurrentTactics();
void GetPlayerGameBreakPosition();
void SetBenchPlayersNumbers();
void cseg_52588();
void cseg_52956();
void cseg_52A3E();
void cseg_52B6A();
void cseg_52D40();
void CheckIsTeamNational();
void cseg_52EA6();
void cseg_532BF();
void cseg_532D3();
void cseg_53312();
void GetTeamLeague();
void cseg_5353F();
void TransferMarketInit();
void TransferMarketFinish();
void TransferMenuSetBankState();
void BuyPlayerMenu();
void PutPlayerOnMarketMenu();
void ViewOffersMenu();
void GiveFreeTransfer();
void jmp_SetExitMenuFlag_8();
void TakeOffMarketMenu();
void TransferMarketCommon();
void CheckNumPlayersOnTransferMarket();
void CheckIfPlayerSelected();
void EnableDisableOffers();
void TransferMarketAfterDrawCommon();
void CheckForTransferOffers();
void cseg_53E64();
void cseg_53EF9();
void cseg_53F13();
void cseg_53F2D();
void ShowSquad();
void cseg_53F43();
void cseg_53FAE();
void cseg_5400D();
void cseg_54063();
void cseg_540A0();
void RemovePlayerFromTeam();
void cseg_54116();
void cseg_546DF();
void cseg_547AC();
void cseg_5493A();
void BuyOtherPlayersInit();
void BuyOtherPlayersFinish();
void j_SetExitMenuFlag_10();
void BuyOtherPlayersCommon();
void BuyOtherPlayersAfterDrawCommon();
void cseg_54C1E();
void BuyPlayerInit();
void ViewDomesticPlayerMarket();
void ViewForeignPlayerMarket();
void BuyOtherDomesticPlayer();
void BuyOtherForeignPlayer();
void BuyPlayerViewSquad();
void BuyPlayerExit();
void ShowDomesticPlayerMarket();
void cseg_54F34();
void cseg_54F7A();
void cseg_5509D();
void nullsub_19();
void OffersCommon();
void j_SetExitMenuFlag_11();
void OffersAfterDrawCommon();
void cseg_55F53();
void cseg_56129();
void cseg_56379();
void AddCareerPoolPlayer();
void cseg_56615();
void cseg_567B5();
void ThirdPartyOfferMenuInit();
void ThirdPartyOfferViewSquad();
void AcceptOffer();
void RejectOffer();
void AskForMore();
void ConsiderOffer();
void ThirdPartyOfferMenuExit();
void ThirdPartyOfferMenuAfterDrawCommon();
void ViewSquadInit();
void ViewSquadExitContinue();
void ViewSquadOnSelect21();
void ViewSquad21AfterDraw();
void ViewSquadCommon();
void ViewSquadAfterDrawCommon();
void PlayerOffersInit();
void cseg_57B61();
void PlayerOffersOnSelect8();
void PlayerOffersOnSelect10();
void PlayerOffersOnSelect11();
void PlayerOffersOnSelect12();
void cseg_580EF();
void cseg_5834E();
void PlayerOffersOnSelect13();
void PlayerOffersAfterDrawCommon();
void cseg_584D7();
void cseg_58F21();
void cseg_59015();
void nullsub_20();
void cseg_59296();
void cseg_592D5();
void cseg_59494();
void TransferPlayerInit();
void TransferPlayerOnSelect10();
void TransferPlayerOnSelect11();
void TransferPlayerOnSelect12();
void TransferPlayerAfterDrawCommon();
void cseg_59B41();
void ShowPlayerMarket();
void cseg_59BFE();
void cseg_59CA2();
void cseg_59CC7();
void cseg_59D28();
void cseg_59D8E();
void jmp_SetExitMenuFlag_9();
void cseg_59E31();
void cseg_59E62();
void cseg_59E7C();
void cseg_59F61();
void cseg_5A017();
void cseg_5A227();
void cseg_5A4FE();
void cseg_5A666();
void cseg_5A6A1();
void cseg_5A8DE();
void cseg_5A90B();
void nullsub_35();
void cseg_5AB36();
void cseg_5B3B5();
void cseg_5B468();
void cseg_5B518();
void cseg_5B687();
void cseg_5B705();
void cseg_5C304();
void IsPlayerOkForNationalSelector();
void NotOkForNationalSelector();
void cseg_5C3CB();
void GetNationalityAndTeamFile();
void cseg_5C46D();
void GetNationalTeamNumber();
void GetNationalityRecordPtr();
void cseg_5C57C();
void cseg_5C5EF();
void cseg_5C72F();
void AddInternationalPlayerHome();
void AddInternationalPlayerAbroad();
void cseg_5C7D3();
void cseg_5CC6F();
void GetPlayerPositionFromCurrent();
void cseg_5CDF2();
void ShowSelectRepresentationMenu();
void SelectNationalTeamInit();
void SelectNationalTeamFinish();
void cseg_5CFE2();
void cseg_5D281();
void cseg_5D380();
void NationalTeamAddPlayer();
void NationalTeamRemovePlayers();
void SelectNationalTeamExit();
void SelectNationalTeamAbort();
void SelectNationalTeamOnSelect25();
void SelectNationalTeam25AfterDraw();
void SelectNationalTeamCommon();
void SelectNationalTeamAfterDrawCommon();
void nullsub_21();
void NationalTeamAddPlayerHomeOnSelect();
void NationalTeamAddPlayerAbroadOnSelect();
void NationalTeamAddPlayerExit();
void GetPlayerPosition();
void CalculateStartingBalance();
void cseg_5DB56();
void GetAveragePlayerPrice();
void cseg_5DEB9();
void cseg_5E2E0();
void cseg_5E345();
void cseg_5E48C();
void cseg_5E4B4();
void cseg_5E535();
void ShowChairmanMessage();
void ChairmanMemosInit();
void ChairmanMemosOnReturn();
void ChairmanMemosContinue();
void ShowClubBussinesMenu();
void ClubBusinessInit();
void j_SetExitMenuFlag13();
void GotJobOfferInit();
void GotJobOfferFinish();
void AcceptJobOffer();
void j_SetExitMenuFlag_14();
void RejectJobOffer();
void ViewFutureTeam();
void cseg_60003();
void ViewFutureTeamLeague();
void ConsiderJobOffer();
void cseg_6010B();
void cseg_601FA();
void IsOldJobOffer();
void GetJobOfferPtr();
void AddJobOffer();
void RemoveJobOffer();
void IsNewJobOffer();
void GetNewJobOfferPtr();
void JobOffersInit();
void JobOffersFinish();
void JobOffersCommon();
void cseg_605C0();
void JobOffersExit();
void cseg_6065E();
void cseg_6087D();
void JobOffersAfterDrawCommon();
void cseg_60E1C();
void PlayChairmanScene();
void EditCustomTeam();
void EditTeamsCallback();
void nullsub_36();
void EditTeamsInit();
void EditTeamsFinish();
void ImportTeamsMenu();
void EditTeamsUndo();
void EditTeamsOK();
void EditTeamsChangeShirtsPrimary();
void EditTeamsChangeShirtsSecondary();
void EditTeamsChangeShortsPrimary();
void EditTeamsChangeShortsSecondary();
void EditTeamsChangeSocksPrimary();
void EditTeamsChangeSocksSecondary();
void EditTeamsSelectPrimaryShirtType();
void EditTeamsSelectSecondaryShirtType();
void EditTeamsChangePlayerName();
void EditTeamsSelectTeamName();
void EditTeamsSelectCoachName();
void EditTeamsChangePlayerFace();
void InitEditTeamsMenu();
void EditTeamsPlayersBeforeDraw();
void PrimaryKitColorConversion();
void SecondaryKitColorConversion();
void MarkFirstKitShirt();
void MarkSecondKitShirt();
void EditTeamsGetPlayerPointer();
void nullsub_22();
void ResetAnimatedPatternsForBothTeams();
void cseg_63919();
void cseg_639F9();
void cseg_63D46();
void cseg_63E05();
void cseg_63EC4();
void cseg_63F6F();
void CheckIfTeamIsChanged();
void PlayTrainingGame();
void cseg_64161();
void cseg_6481C();
void cseg_648C7();
void cseg_649E3();
void cseg_64A65();
void cseg_64B06();
void nullsub_37();
void AddTrialPlayer();
void cseg_64B80();
void cseg_64D5A();
void cseg_64E3E();
void CheckPlayersLeavingComing();
void PlayerJoinedClubOnTrial();
void TrialPlayerLeftClubMessage();
void ReservePlayerLeftClubMessage();
void cseg_65608();
void cseg_6575A();
void cseg_658AC();
void cseg_659FE();
void cseg_65B50();
void cseg_65CA2();
void cseg_65FE6();
void cseg_6604A();
void cseg_66354();
void cseg_664BB();
void cseg_6652C();
void cseg_66682();
void cseg_667D8();
void cseg_66947();
void cseg_66A98();
void cseg_66B23();
void cseg_66CF8();
void cseg_66E6C();
void cseg_66FE1();
void cseg_67156();
void cseg_672CB();

// =============== S U B R O U T I N E =======================================

// in:
//     D0 - nationality
//     A0
//
void cseg_4C83A()
{
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[330640] = ax;       // mov showClubTeams, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[330642] = ax;       // mov showNationalTeams, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&g_memByte[330644] = ax;       // mov showOrigCustomTeams, ax
    *(dword *)&g_memByte[330202] = 0;       // mov gameTypeStr, 0
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[330658] = eax;     // mov chooseTeamsHeader1stPart, eax
    eax = A1;                               // mov eax, A1
    *(dword *)&g_memByte[330666] = eax;     // mov chooseTeamsFunc, eax
    *(word *)&g_memByte[330670] = 0;        // mov dseg_113491, 0
    g_memByte[330670] = 0;                  // mov byte ptr dseg_113491, 0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, 0
    if (!flags.zero)
        goto cseg_4C89C;                    // jnz short cseg_4C89C

    g_memByte[330670] = 255;                // mov byte ptr dseg_113491, 0FFh

cseg_4C89C:;
    *(dword *)&g_memByte[330654] = 18712;   // mov playWhatStr, offset aStatistics
    *(word *)&g_memByte[330674] = 1;        // mov numNeededTeams, 1
    *(word *)&g_memByte[330672] = 1;        // mov selectTamsNoLimit, 1
    *(word *)&g_memByte[330692] = 65535;    // mov selectedTeamCountryNumber, 0FFFFh
    *(dword *)&g_memByte[330688] = 0;       // mov selectedTeamPtr, 0
    A6 = 504785;                            // mov A6, offset chooseTeamsMenu
    push(D0);                               // push D0
    SWOS::ShowMenu();                       // call ShowMenu
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[330638];       // mov ax, teamsType
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_4C911;                    // js short cseg_4C911

    *(word *)&g_memByte[330630] = 1;        // mov loadTeam, 1
    *(word *)&g_memByte[330632] = 0;        // mov showCupsAndOther, 0
    *(word *)&g_memByte[330634] = 0;        // mov playSeason, 0
    SelectTeamsFinalMenu();                 // call SelectTeamsFinalMenu

cseg_4C911:;
    ax = *(word *)&g_memByte[330692];       // mov ax, selectedTeamCountryNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(dword *)&g_memByte[330688];     // mov eax, selectedTeamPtr
    A0 = eax;                               // mov A0, eax
}

// =============== S U B R O U T I N E =======================================
//
void ChooseTeamsFriendlyInitFinish()
{
    ax = *(word *)&g_memByte[330526];       // mov ax, topOfStackMark
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_4C97F;                    // jns short cseg_4C97F

    push(D0);                               // push D0
    D0 = 57;                                // mov D0, 57
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17196);        // mov [esi+MenuEntry.fg.string], offset aAbort
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 10
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

cseg_4C97F:;
    ax = *(word *)&g_memByte[330672];       // mov ax, selectTamsNoLimit
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_some_teams_selected;         // jz short @@some_teams_selected

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 60, 2, 1);            // mov [esi+(MenuEntry.isInvisible+38h)], 1
    writeMemory(esi + 116, 2, 1);           // mov [esi+(MenuEntry.isInvisible+70h)], 1
    writeMemory(esi + 172, 2, 1);           // mov [esi+(MenuEntry.isInvisible+0A8h)], 1
    writeMemory(esi + 228, 2, 1);           // mov [esi+(MenuEntry.isInvisible+0E0h)], 1
    writeMemory(esi + 284, 2, 1);           // mov [esi+(MenuEntry.isInvisible+118h)], 1

l_some_teams_selected:;
    A4 = 330804;                            // mov A4, offset teamsIndex
    A5 = 331205;                            // mov A5, offset teamsPtrTable
    ax = *(word *)&g_memByte[252466];       // mov ax, word ptr teamFileBuffer
    {
        byte tmp = al;
        al = ah;
        ah = tmp;
    }                                       // xchg ah, al
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    A0 = 252468;                            // mov A0, (offset teamFileBuffer+2)
    ax = *(word *)&g_memByte[330652];       // mov ax, leagueNumber
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D3 = ax;                      // mov word ptr D3, ax

cseg_4CA3E:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 25, 1);     // mov al, [esi+TeamFile.league]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_4CA9B;                    // jnz short cseg_4CA9B

    ax = *(word *)&g_memByte[129468];       // mov ax, inFriendlyMenu
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4CA6C;                    // jnz short cseg_4CA6C

    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (flags.zero)
        goto cseg_4CA9B;                    // jz short cseg_4CA9B

cseg_4CA6C:;
    al = D2;                                // mov al, byte ptr D2
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A4)++;                    // inc A4
    eax = A0;                               // mov eax, A0
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 4
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1

cseg_4CA9B:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 684
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_4CA3E;                    // jns short cseg_4CA3E

    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[330682] = ax;       // mov dseg_11349D, ax
    ax = *(word *)&g_memByte[330682];       // mov ax, dseg_11349D
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 2
    if (flags.sign)
        goto cseg_4CC0D;                    // js cseg_4CC0D

    A3 = 331205;                            // mov A3, offset teamsPtrTable

cseg_4CADE:;
    A2 = 330804;                            // mov A2, offset teamsIndex
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_4CAFD:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    A1 = eax;                               // mov A1, eax

cseg_4CB8B:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_4CBF1;                    // jz short cseg_4CBF1

    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_4CBF1;                    // jb short cseg_4CBF1

    if (!flags.carry && !flags.zero)
        goto cseg_4CBBC;                    // ja short cseg_4CBBC

    goto cseg_4CB8B;                        // jmp short cseg_4CB8B

cseg_4CBBC:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    writeMemory(esi + -1, 1, al);           // mov [esi-1], al
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi, 1, al);                // mov [esi], al
    *(word *)&D3 = 1;                       // mov word ptr D3, 1

cseg_4CBF1:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_4CAFD;                    // jns cseg_4CAFD

    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4CADE;                    // jnz cseg_4CADE

cseg_4CC0D:;
    A0 = 330704;                            // mov A0, offset teamsTable
    *(word *)&D0 = 99;                      // mov word ptr D0, 63h

cseg_4CC20:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_4CC20;                    // jns short cseg_4CC20

    {
        word src = *(word *)&g_memByte[330674];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numNeededTeams, 1
    if (flags.zero)
        goto cseg_4CD0E;                    // jz cseg_4CD0E

    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4CD0E;                    // jz cseg_4CD0E

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D3 = res;
    }                                       // sub word ptr D3, 1
    A1 = 330704;                            // mov A1, offset teamsTable
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax
    al = g_memByte[316572];                 // mov al, lastLoadedExtNumber
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    ax = *(word *)&g_memByte[330652];       // mov ax, leagueNumber
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    D0 = 0;                                 // mov D0, 0

cseg_4CC97:;
    {
        byte src = g_memByte[316572];
        int8_t dstSigned = src;
        int8_t srcSigned = 100;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp lastLoadedExtNumber, 64h
    if (flags.zero)
        goto cseg_4CCCB;                    // jz short cseg_4CCCB

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_4CCFB;                    // jnz short cseg_4CCFB

    al = (byte)readMemory(esi + 25, 1);     // mov al, [esi+25]
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.zero)
        goto cseg_4CCFB;                    // jnz short cseg_4CCFB

cseg_4CCCB:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    bl = (byte)readMemory(esi + 4, 1);      // mov bl, [esi+4]
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    writeMemory(esi + eax, 1, bl);          // mov [esi+eax], bl

cseg_4CCFB:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 684
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_4CC97;                    // jns short cseg_4CC97

cseg_4CD0E:;
    {
        word src = *(word *)&g_memByte[330682];
        int16_t dstSigned = src;
        int16_t srcSigned = 48;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_11349D, 30h
    if (flags.carry)
        goto cseg_4CD38;                    // jb short cseg_4CD38

    *(word *)&g_memByte[330676] = 16;       // mov dseg_113497, 10h
    *(word *)&g_memByte[330678] = 16;       // mov dseg_113499, 10h
    *(word *)&g_memByte[330680] = 16;       // mov dseg_11349B, 10h
    goto cseg_4CE03;                        // jmp cseg_4CE03

cseg_4CD38:;
    {
        word src = *(word *)&g_memByte[330682];
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_11349D, 8
    if (!flags.carry && !flags.zero)
        goto cseg_4CD65;                    // ja short cseg_4CD65

    *(word *)&g_memByte[330676] = 0;        // mov dseg_113497, 0
    ax = *(word *)&g_memByte[330682];       // mov ax, dseg_11349D
    *(word *)&g_memByte[330678] = ax;       // mov dseg_113499, ax
    *(word *)&g_memByte[330680] = 0;        // mov dseg_11349B, 0
    goto cseg_4CE03;                        // jmp cseg_4CE03

cseg_4CD65:;
    ax = *(word *)&g_memByte[330682];       // mov ax, dseg_11349D
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 3;                                 // mov bx, 3
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[330676] = ax;       // mov dseg_113497, ax
    *(word *)&g_memByte[330678] = ax;       // mov dseg_113499, ax
    *(word *)&g_memByte[330680] = ax;       // mov dseg_11349B, ax
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_4CDE9;                    // jnz short cseg_4CDE9

    {
        word src = *(word *)&g_memByte[330678];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[330678] = src;
    }                                       // add dseg_113499, 1
    goto cseg_4CE03;                        // jmp short cseg_4CE03

cseg_4CDE9:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (!flags.zero)
        goto cseg_4CE03;                    // jnz short cseg_4CE03

    {
        word src = *(word *)&g_memByte[330676];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[330676] = src;
    }                                       // add dseg_113497, 1
    {
        word src = *(word *)&g_memByte[330678];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[330678] = src;
    }                                       // add dseg_113499, 1

cseg_4CE03:;
    cseg_4D752();                           // call cseg_4D752
    ChooseTeamsSetHeader();                 // call ChooseTeamsSetHeader
    CheckNumTeamsAllowed();                 // call CheckNumTeamsAllowed
    A4 = 330804;                            // mov A4, offset teamsIndex
    A5 = 331205;                            // mov A5, offset teamsPtrTable
    A3 = 330704;                            // mov A3, offset teamsTable
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    *(word *)&D5 = 0;                       // mov word ptr D5, 0

cseg_4CE7F:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1

cseg_4CE8B:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 7
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 16;                                // mov bx, 10h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4CEE3;                    // jnz short cseg_4CEE3

    ax = *(word *)&g_memByte[330676];       // mov ax, dseg_113497
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    goto cseg_4CF13;                        // jmp short cseg_4CF13

cseg_4CEE3:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_4CEFB;                    // jnz short cseg_4CEFB

    ax = *(word *)&g_memByte[330678];       // mov ax, dseg_113499
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    goto cseg_4CF13;                        // jmp short cseg_4CF13

cseg_4CEFB:;
    ax = *(word *)&g_memByte[330680];       // mov ax, dseg_11349B
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_4CF13:;
    ax = D0;                                // mov ax, word ptr D0
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto cseg_4CF5E;                    // jb short cseg_4CF5E

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 38h
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 55;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2], 37h
    if (flags.zero)
        return;                             // jz cseg_4D0C1

    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    goto cseg_4CE8B;                        // jmp cseg_4CE8B

cseg_4CF5E:;
    *(word *)&D2 = 9;                       // mov word ptr D2, 9
    ax = *(word *)&g_memByte[330672];       // mov ax, selectTamsNoLimit
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4CF7B;                    // jz short cseg_4CF7B

    *(word *)&D2 = 5;                       // mov word ptr D2, 5

cseg_4CF7B:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    A4 = 330804;                            // mov A4, offset teamsIndex
    A5 = 331205;                            // mov A5, offset teamsPtrTable
    esi = A4;                               // mov esi, A4
    eax = *(word *)&D5;                     // movzx eax, word ptr D5
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A5;                               // mov esi, A5
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    A1 = eax;                               // mov A1, eax
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_4D06D;                    // jz short cseg_4D06D

    *(word *)&D1 = 10;                      // mov word ptr D1, 0Ah
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    {
        byte src = (byte)readMemory(esi + eax, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+eax], 1
    if (flags.zero)
        goto cseg_4D06D;                    // jz short cseg_4D06D

    *(word *)&D1 = 11;                      // mov word ptr D1, 0Bh
    {
        byte src = (byte)readMemory(esi + eax, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+eax], 2
    if (flags.zero)
        goto cseg_4D06D;                    // jz short cseg_4D06D

    *(word *)&D1 = 13;                      // mov word ptr D1, 0Dh

cseg_4D06D:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax

cseg_4D07D:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 38h
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 55;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2], 37h
    if (flags.zero)
        return;                             // jz short cseg_4D0C1

    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    ax = *(word *)&g_memByte[330682];       // mov ax, dseg_11349D
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (!flags.carry)
        goto cseg_4D07D;                    // jnb short cseg_4D07D

    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 1
    goto cseg_4CE7F;                        // jmp cseg_4CE7F
}

// =============== S U B R O U T I N E =======================================
//
void ViewSelected()
{
    *(word *)&g_memByte[330698] = 1;        // mov viewSelectedTeams, 1
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    *(word *)&g_memByte[330700] = 0;        // mov abortSelectTeams, 0
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ExitChooseTeams2()
{
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
    *(word *)&g_memByte[330698] = 0;        // mov viewSelectedTeams, 0
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    ax = *(word *)&g_memByte[330526];       // mov ax, topOfStackMark
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_4D133;                    // js short cseg_4D133

    *(word *)&g_memByte[330702] = 1;        // mov exitSelectTeams, 1
    *(word *)&g_memByte[330700] = 0;        // mov abortSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
    return;                                 // retn

cseg_4D133:;
    *(word *)&g_memByte[330700] = 1;        // mov abortSelectTeams, 1
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ChooseTeamsPlayMatchSelected()
{
    *(word *)&g_memByte[330694] = 1;        // mov chooseTeamsResult, 1
    *(word *)&g_memByte[330698] = 0;        // mov viewSelectedTeams, 0
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    *(word *)&g_memByte[330700] = 0;        // mov abortSelectTeams, 0
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ChooseTeamsFriendlyCommon2()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 16
    if (flags.carry)
        goto l_less_than_16;                // jb short @@less_than_16

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 32
    if (flags.carry)
        goto l_16_x_32;                     // jb short @@16_x_32

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 16
    ax = *(word *)&g_memByte[330678];       // mov ax, dseg_113499
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax

l_16_x_32:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 16
    ax = *(word *)&g_memByte[330676];       // mov ax, dseg_113497
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax

l_less_than_16:;
    A0 = 330804;                            // mov A0, offset teamsIndex
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 331205;                            // mov A0, offset teamsPtrTable
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    A0 = eax;                               // mov A0, eax
    *(dword *)&g_memByte[330688] = eax;     // mov selectedTeamPtr, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&g_memByte[330692] = ax;       // mov selectedTeamCountryNumber, ax
    eax = *(dword *)&g_memByte[330666];     // mov eax, chooseTeamsFunc
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_4D265;                    // jz short cseg_4D265

    eax = *(dword *)&g_memByte[330666];     // mov eax, chooseTeamsFunc
    A6 = eax;                               // mov A6, eax
    invokeProc(A6);                         // call A6
    ax = *(word *)&g_memByte[330670];       // mov ax, dseg_113491
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4D270;                    // jz short cseg_4D270

    return;                                 // retn

cseg_4D265:;
    ax = *(word *)&g_memByte[330670];       // mov ax, dseg_113491
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4D288;                    // jz short cseg_4D288

cseg_4D270:;
    *(word *)&g_memByte[330700] = 1;        // mov abortSelectTeams, 1
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
    return;                                 // retn

cseg_4D288:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        word res = *(word *)&D2 & 255;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 0FFh
    A1 = 330704;                            // mov A1, offset teamsTable
    eax = A1;                               // mov eax, A1
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_will_be_computer;            // jz @@will_be_computer

    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 1
    if (flags.zero)
        goto l_will_be_player_coach;        // jz short @@will_be_player_coach

    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 2
    if (flags.zero)
        goto l_will_be_coach;               // jz short @@will_be_coach

    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 2, 9);            // mov word ptr [esi+30], 9
    DeselectTeam();                         // call DeselectTeam
    goto l_common_out;                      // jmp short @@common_out

l_will_be_player_coach:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 2);                 // mov byte ptr [esi], 2
    FindTeam();                             // call FindTeam
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 1, 2);             // mov byte ptr [esi+4], 2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 2, 11);           // mov word ptr [esi+30], 11
    goto l_common_out;                      // jmp short @@common_out

l_will_be_coach:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 3);                 // mov byte ptr [esi], 3
    FindTeam();                             // call FindTeam
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 1, 3);             // mov byte ptr [esi+4], 3
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 2, 13);           // mov word ptr [esi+30], 13
    goto l_common_out;                      // jmp short @@common_out

l_will_be_computer:;
    {
        word src = *(word *)&g_memByte[131757];
        int16_t dstSigned = src;
        int16_t srcSigned = 64;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_numSelectedTeams, 64
    if (flags.zero)
        return;                             // jz short @@out

    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 1);                 // mov byte ptr [esi], 1
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 2, 10);           // mov word ptr [esi+30], 10
    AddTeamToBuffer();                      // call AddTeamToBuffer
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 1, 1);             // mov byte ptr [esi+4], 1

l_common_out:;
    Bureaucracy();                          // call Bureaucracy
}

// =============== S U B R O U T I N E =======================================
//
void ChooseTeamsSetHeader()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[330658];     // mov eax, chooseTeamsHeader1stPart
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (!flags.zero)
        goto cseg_4D40C;                    // jnz short cseg_4D40C

    A0 = 16545;                             // mov A0, offset aChooseTeamsFor
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[330674];       // mov ax, numNeededTeams
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_4D40C;                    // jnz short cseg_4D40C

    A0 = 16563;                             // mov A0, offset aChangeTeamsFor

cseg_4D40C:;
    StringCopy();                           // call StringCopy
    eax = *(dword *)&g_memByte[330202];     // mov eax, gameTypeStr
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        goto cseg_4D429;                    // jz short cseg_4D429

    StringCopy();                           // call StringCopy

cseg_4D429:;
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A0 = eax;                               // mov A0, eax
    GetStringLength();                      // call GetStringLength
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = *(dword *)&g_memByte[330206];     // mov eax, curCountryStr
    A0 = eax;                               // mov A0, eax
    GetStringLength();                      // call GetStringLength
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 47;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 47
    if (!flags.carry && !flags.zero)
        return;                             // ja short @@out

    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, '-');               // mov byte ptr [esi], '-'
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    eax = *(dword *)&g_memByte[330206];     // mov eax, curCountryStr
    A0 = eax;                               // mov A0, eax
    StringCopy();                           // call StringCopy
}

// =============== S U B R O U T I N E =======================================
//
void Bureaucracy()
{
    push(A5);                               // push A5
    ChooseTeamsSetHeader();                 // call ChooseTeamsSetHeader
    CheckNumTeamsAllowed();                 // call CheckNumTeamsAllowed
    A0 = 3427;                              // mov A0, offset cseg_4D4D1
    nullsub_17();                           // call nullsub_17
    pop(A5);                                // pop A5
}

// =============== S U B R O U T I N E =======================================
//
void CheckNumTeamsAllowed()
{
    ax = *(word *)&g_memByte[330672];       // mov ax, selectTamsNoLimit
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_teams_selected;              // jz short @@teams_selected

    push(D0);                               // push D0
    D0 = 55;                                // mov D0, 55
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 58;                                // mov D0, 58
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 56;                                // mov D0, 56
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    return;                                 // retn

l_teams_selected:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 55;                                // mov D0, 55
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 58;                                // mov D0, 58
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[330674];       // mov ax, numNeededTeams
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_play_allowed;                // jz short @@play_allowed

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    goto l_disallow_play;                   // jmp short @@disallow_play

l_play_allowed:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 34, 2, 2);            // mov word ptr [esi+34], 2
    eax = *(dword *)&g_memByte[330654];     // mov eax, playWhatStr
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax

l_disallow_play:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 56;                                // mov D0, 56
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_some_teams_selected;         // jnz short @@some_teams_selected

    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1

l_some_teams_selected:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 58;                                // mov D0, 58
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[330674];       // mov ax, numNeededTeams
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        goto l_error;                       // jz short @@error

    if (!flags.sign)
        goto cseg_4D71E;                    // jns short cseg_4D71E

    *(int16_t *)&D0 = -*(int16_t *)&D0;     // neg word ptr D0
    A0 = 16368;                             // mov A0, offset aSelect1MoreTea
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto l_strcopy;                     // jz short @@strcopy

    A0 = 16346;                             // mov A0, offset aSelect0MoreTea
    goto l_printf;                          // jmp short @@printf

cseg_4D71E:;
    A0 = 16412;                             // mov A0, offset aSelect1LessTea
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto l_strcopy;                     // jz short @@strcopy

    A0 = 16390;                             // mov A0, offset aSelect0LessTea

l_printf:;
    PrintFormatted();                       // call PrintFormatted
    return;                                 // retn

l_error:;
    A0 = 331620;                            // mov A0, offset aError

l_strcopy:;
    StringCopy();                           // call StringCopy
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4D752()
{
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+1Ah]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[330684] = ax;       // mov dseg_11349F, ax
    push(D0);                               // push D0
    D0 = 57;                                // mov D0, 39h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&g_memByte[330686] = ax;       // mov dseg_1134A1, ax
    ax = *(word *)&g_memByte[330676];       // mov ax, dseg_113497
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[330678];       // mov ax, dseg_113499
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto cseg_4D7E6;                    // ja short cseg_4D7E6

    ax = *(word *)&g_memByte[330678];       // mov ax, dseg_113499
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_4D7E6:;
    ax = *(word *)&g_memByte[330680];       // mov ax, dseg_11349B
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto cseg_4D801;                    // ja short cseg_4D801

    ax = *(word *)&g_memByte[330680];       // mov ax, dseg_11349B
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_4D801:;
    ax = D0;                                // mov ax, word ptr D0
    bx = 10;                                // mov bx, 0Ah
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    ax = *(word *)&g_memByte[330686];       // mov ax, dseg_1134A1
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[330684];       // mov ax, dseg_11349F
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+1Ah]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D1 = eax;                               // mov D1, eax
    dx = *(word *)((byte *)&D1 + 2);        // mov dx, word ptr D1+2
    bx = 3;                                 // mov bx, 3
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[330684];       // mov ax, dseg_11349F
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 38h
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+1Ah]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D2 = 2;                       // mov word ptr D2, 2

cseg_4D99A:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D3 = 15;                      // mov word ptr D3, 0Fh

cseg_4D9AF:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ah
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 38h
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_4D9AF;                    // jns short cseg_4D9AF

    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_4D99A;                    // jns short cseg_4D99A
}

// =============== S U B R O U T I N E =======================================

// in:
//     A0 -> team to add
//
// Adds team to selected teams buffer.
//
void AddTeamToBuffer()
{
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    *(word *)&D0 = 341;                     // mov word ptr D0, 341

l_copy_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_loop;                   // jns short @@copy_loop

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 684;
        dword res = dstSigned - srcSigned;
        A1 = res;
    }                                       // sub A1, 684
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    {
        word src = *(word *)&g_memByte[131757];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[131757] = src;
    }                                       // add g_numSelectedTeams, 1
}

// =============== S U B R O U T I N E =======================================
//
void DeselectTeam()
{
    FindTeam();                             // call FindTeam
    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_out;                         // jz short @@out

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 684
    A1 = eax;                               // mov A1, eax
    ax = D2;                                // mov ax, word ptr D2
    bx = 342;                               // mov bx, 342
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx

l_move_loop:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // sub D2, 1
    if (!flags.zero)
        goto l_move_loop;                   // jnz short @@move_loop

l_out:;
    {
        word src = *(word *)&g_memByte[131757];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[131757] = src;
    }                                       // sub g_numSelectedTeams, 1
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team to search for
// out:
//      A0 -> team in selected teams buffer
//      D2 = index of team in sel. teams buffer
//
void FindTeam()
{
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_error_no_teams;              // jz short @@error_no_teams

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax

l_search_teams_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 684
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto l_search_teams_loop;           // jns short @@search_teams_loop

    goto l_error_no_teams;                  // jmp short @@error_no_teams

l_out:;
    return;                                 // retn

l_error_no_teams:;
    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================
//
void SelectDiyLeagueMenu()
{
    *(word *)&g_memByte[336406] = 0;        // mov diySelected, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void SelectDiyCupMenu()
{
    *(word *)&g_memByte[336406] = 1;        // mov diySelected, 1
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void SelectDiyTournamentMenu()
{
    *(word *)&g_memByte[336406] = 2;        // mov diySelected, 2
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void SelectDiyExitMenu()
{
    *(word *)&g_memByte[336406] = -1;       // mov diySelected, -1
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void EditTactics()
{
    *(word *)&g_memByte[131753] = 1;        // mov inEditTactics, 1
    A0 = 92798;                             // mov A0, offset careerTeam
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (flags.zero)
        goto l_show_menu;                   // jz @@show_menu

    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_selected_teams;           // jz @@no_selected_teams

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax
    A1 = 508222;                            // mov A1, offset editTacticsCountryBuffer
    *(word *)&D0 = 0;                       // mov word ptr D0, 0

l_teams_loop:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        goto l_next_team;                   // jz short @@next_team

    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    eax = A0;                               // mov eax, A0
    A2 = eax;                               // mov A2, eax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1

l_next_team:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 684
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_teams_loop;                  // jns short @@teams_loop

    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_player_teams;             // jz short @@no_player_teams

    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto l_show_menu;                   // jz short @@show_menu

    A0 = 17454;                             // mov A0, offset aEditTacticsSel
    A1 = 508222;                            // mov A1, offset editTacticsCountryBuffer
    ChooseTeamForEditTactics();             // call ChooseTeamForEditTactics
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (!flags.zero)
        goto l_show_menu;                   // jnz short @@show_menu

    return;                                 // jmp short @@out

l_no_player_teams:;
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_computer_teams_only;         // jnz short @@computer_teams_only

l_no_selected_teams:;
    *(byte *)&D0 = 8;                       // mov byte ptr D0, 8
    LoadTeamFile();                         // call LoadTeamFile
    A0 = 264096;                            // mov A0, (offset teamFileBuffer+2D6Eh)
    AddTeamToBuffer();                      // call AddTeamToBuffer
    InitTeams();                            // call InitTeams
    goto l_to_career_game;                  // jmp short @@to_career_game

l_computer_teams_only:;
    A0 = 92798;                             // mov A0, offset careerTeam
    {
        word src = *(word *)&g_memByte[91720];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp selTeamNumber, -1
    if (!flags.zero)
        goto l_show_menu;                   // jnz short @@show_menu

l_to_career_game:;
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax

l_show_menu:;
    ShowStandardChooseTacticsMenu();        // call ShowStandardChooseTacticsMenu
}

// =============== S U B R O U T I N E =======================================

// in:
//     A0 -> selected team
//
// Show edit tactics menu, from both main menu and setup teams menu.
//
void ShowStandardChooseTacticsMenu()
{
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[378864] = eax;     // mov chooseTacticsTeamPtr, eax
    A6 = 508560;                            // mov A6, offset chooseTacticsMenu
    SWOS::ShowMenu();                       // call ShowMenu
    {
        word src = *(word *)&g_memByte[508540];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp chosenTactics, -1
    if (flags.zero)
        goto l_tactics_aborted;             // jz short @@tactics_aborted

    InitLittlePlayerSprites();              // call InitLittlePlayerSprites
    A6 = 509414;                            // mov A6, offset editTacticsMenu
    SWOS::ShowMenu();                       // call ShowMenu

l_tactics_aborted:;
    *(dword *)&g_memByte[378864] = 0;       // mov chooseTacticsTeamPtr, 0
}

// =============== S U B R O U T I N E =======================================

// Init choose tactics menu. Set menu item names to names of tactics - simply put
// addresses of tactics into item name pointers - because tactics structure
// begins with zero terminated string (tactics name).
//
void ChooseTacticsInit()
{
    CheckIsTeamNational();                  // call CheckIsTeamNational
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 129478);       // mov [esi+MenuEntry.fg.string], offset USER_A
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 129848);       // mov [esi+MenuEntry.fg.string], offset USER_B
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 130218);       // mov [esi+MenuEntry.fg.string], offset USER_C
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 130588);       // mov [esi+MenuEntry.fg.string], offset USER_D
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 130958);       // mov [esi+MenuEntry.fg.string], offset USER_E
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 131328);       // mov [esi+MenuEntry.fg.string], offset USER_F
}

// =============== S U B R O U T I N E =======================================
//
void User_A_Tactics()
{
    *(word *)&g_memByte[508540] = 12;       // mov chosenTactics, TACTIC_USER_A
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void User_B_Tactics()
{
    *(word *)&g_memByte[508540] = 13;       // mov chosenTactics, TACTIC_USER_B
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void User_C_Tactics()
{
    *(word *)&g_memByte[508540] = 14;       // mov chosenTactics, TACTIC_USER_C
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void User_D_Tactics()
{
    *(word *)&g_memByte[508540] = 15;       // mov chosenTactics, TACTIC_USER_D
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void User_E_Tactics()
{
    *(word *)&g_memByte[508540] = 16;       // mov chosenTactics, TACTIC_USER_E
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void User_F_Tactics()
{
    *(word *)&g_memByte[508540] = 17;       // mov chosenTactics, TACTIC_USER_F
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ExitChooseTacticsMenu()
{
    *(word *)&g_memByte[508540] = -1;       // mov chosenTactics, -1
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void EditTacticsInit()
{
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    SetBenchPlayersNumbers();               // call SetBenchPlayersNumbers
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -1
    if (flags.zero)
        goto l_16_players;                  // jz short @@16_players

    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_4DE93;                    // jz short cseg_4DE93

l_16_players:;
    *(word *)&D0 = 16;                      // mov word ptr D0, 16
    goto cseg_4DE9F;                        // jmp short cseg_4DE9F

cseg_4DE93:;
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_4DE9F:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[508360] = ax;       // mov editTacticsNumPlayers, ax
    *(word *)&g_memByte[508370] = -1;       // mov dseg_179952, -1
    *(dword *)&g_memByte[508366] = 0;       // mov dseg_17994E, 0
    *(word *)&g_memByte[508362] = -1;       // mov dseg_17994A, -1
    cseg_4FA3A();                           // call cseg_4FA3A
    EditTacticsMenuSavePlayerPositions();   // call EditTacticsMenuSavePlayerPositions

    EditTacticsOnRestore();
}

// =============== S U B R O U T I N E =======================================
//
void EditTacticsOnRestore()
{
    EnableOrDisablePlayerFacesItems();      // call EnableOrDisablePlayerFacesItems
    CopyCurrentTacticName();                // call CopyCurrentTacticName
    cseg_4ECAD();                           // call cseg_4ECAD
    SetBigCheckSprite();                    // call SetBigCheckSprite
}

// =============== S U B R O U T I N E =======================================
//
void EditTacticsCommon()
{
    ax = *(word *)&g_memByte[508362];       // mov ax, dseg_17994A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        { out3(); return; }                 // jns out3

    push(D0);                               // push D0
    D0 = 29;                                // mov D0, 29
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, ax
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    al = g_memByte[379241];                 // mov al, editTacticsCurrentTactics.ballOutOfPlayTactics
    writeMemory(esi + 24, 1, al);           // mov [esi+TeamFile.tactics], al
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    push(A0);                               // push A0
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    pop(A0);                                // pop A0
    al = D7;                                // mov al, byte ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 24, 1, al);           // mov [esi+TeamFile.tactics], al
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = *(word *)&g_memByte[508370];       // mov ax, dseg_179952
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_4E0CD;                    // js cseg_4E0CD

    ax = *(word *)&g_memByte[508370];       // mov ax, dseg_179952
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (flags.zero)
        goto cseg_4E0B3;                    // jz cseg_4E0B3

    A6 = 379231;                            // mov A6, offset editTacticsCurrentTactics.someTable
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    ax = *(word *)&g_memByte[508370];       // mov ax, dseg_179952
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_4E1F1();                           // call cseg_4E1F1
    ax = *(word *)&g_memByte[508370];       // mov ax, dseg_179952
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_4E1F1();                           // call cseg_4E1F1
    al = D4;                                // mov al, byte ptr D4
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_4E06D;                    // js short cseg_4E06D

    al = D5;                                // mov al, byte ptr D5
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_4E06D;                    // js short cseg_4E06D

    al = D4;                                // mov al, byte ptr D4
    {
        int8_t dstSigned = *(byte *)&D5;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D5, al
    if (flags.zero)
        goto cseg_4E0A8;                    // jz short cseg_4E0A8

cseg_4E06D:;
    cseg_4E166();                           // call cseg_4E166
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    ax = *(word *)&g_memByte[508370];       // mov ax, dseg_179952
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    al = D0;                                // mov al, byte ptr D0
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al

cseg_4E0A8:;
    *(word *)&g_memByte[508370] = -1;       // mov dseg_179952, -1
    goto cseg_4E10D;                        // jmp short cseg_4E10D

cseg_4E0B3:;
    *(word *)&g_memByte[508370] = -1;       // mov dseg_179952, -1
    eax = *(dword *)&g_memByte[508372];     // mov eax, some_menu_entry_ptr
    A5 = eax;                               // mov A5, eax
    { CallDrawMenuItem(); return; }         // jmp CallDrawMenuItem

    goto cseg_4E10D;                        // jmp short cseg_4E10D

cseg_4E0CD:;
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&g_memByte[508370] = ax;       // mov dseg_179952, ax
    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    *(dword *)&g_memByte[508372] = eax;     // mov some_menu_entry_ptr, eax
    { CallDrawMenuItem(); return; }         // jmp CallDrawMenuItem

cseg_4E10D:;
    eax = *(dword *)&g_memByte[508372];     // mov eax, some_menu_entry_ptr
    A5 = eax;                               // mov A5, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 29;                                // mov D0, 29
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CallDrawMultipleItems();                // call CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================

// out:
//      D0 -
//      D2 -
//
void cseg_4E166()
{
    A0 = 379231;                            // mov A0, offset editTacticsCurrentTactics.someTable
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    *(word *)&D1 = 9;                       // mov word ptr D1, 9

l_loop:;
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto l_next;                        // js short @@next

    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cx = D0;                                // mov cx, word ptr D0
    ax = 1;                                 // mov ax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            word res = ax << shiftCount;
            ax = res;
        }
    }                                       // shl ax, cl
    *(word *)&D2 |= ax;
    flags.carry = false;                    // or word ptr D2, ax

l_next:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_loop;                        // jns short @@loop

    *(word *)&D0 = 0;                       // mov word ptr D0, 0

l_loop2:;
    cx = D0;                                // mov cx, word ptr D0
    ax = 1;                                 // mov ax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            word res = ax << shiftCount;
            ax = res;
        }
    }                                       // shl ax, cl
    {
        word res = *(word *)&D2 & ax;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D2, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    goto l_loop2;                           // jmp short @@loop2
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - byte from table at ofs359
//
void cseg_4E1F1()
{
    A0 = 379231;                            // mov A0, offset editTacticsCurrentTactics.someTable
    *(word *)&D1 = 9;                       // mov word ptr D1, 9

l_loop:;
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto l_next;                        // jnz short @@next

    writeMemory(esi + ebx, 1, -1);          // mov byte ptr [esi+ebx], -1

l_next:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_loop;                        // jns short @@loop

    out3();
}

// =============== S U B R O U T I N E =======================================
//
void out3()
{
}

// =============== S U B R O U T I N E =======================================

// Called when player name is selected in edit tactics menu.
//
void EditTacticsPlayerNamesCommon()
{
    ax = *(word *)&g_memByte[508370];       // mov ax, dseg_179952
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        return;                             // jns @@out

    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, ax
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    al = g_memByte[379241];                 // mov al, editTacticsCurrentTactics.ballOutOfPlayTactics
    writeMemory(esi + 24, 1, al);           // mov [esi+TeamFile.tactics], al
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    push(A0);                               // push A0
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    pop(A0);                                // pop A0
    al = D7;                                // mov al, byte ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 24, 1, al);           // mov [esi+TeamFile.tactics], al
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    ax = *(word *)&g_memByte[508362];       // mov ax, dseg_17994A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_4E37D;                    // js cseg_4E37D

    ax = *(word *)&g_memByte[508362];       // mov ax, dseg_17994A
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (flags.zero)
        goto cseg_4E374;                    // jz short cseg_4E374

    ax = *(word *)&g_memByte[508362];       // mov ax, dseg_17994A
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[508364];       // mov ax, dseg_17994C
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    cseg_4E3DD();                           // call cseg_4E3DD
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    SetBenchPlayersNumbers();               // call SetBenchPlayersNumbers
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 59, 1, 1);            // mov byte ptr [esi+59], 1
    cseg_4FA3A();                           // call cseg_4FA3A
    *(word *)&g_memByte[508362] = -1;       // mov dseg_17994A, -1
    { SWOS::DrawMenu(); return; }           // jmp DrawMenu

cseg_4E374:;
    *(word *)&D7 = -1;                      // mov word ptr D7, -1

cseg_4E37D:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&g_memByte[508362] = ax;       // mov dseg_17994A, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&g_memByte[508364] = ax;       // mov dseg_17994C, ax
    eax = *(dword *)&g_memByte[508366];     // mov eax, dseg_17994E
    A0 = eax;                               // mov A0, eax
    eax = A5;                               // mov eax, A5
    *(dword *)&g_memByte[508366] = eax;     // mov dseg_17994E, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        goto cseg_4E3CD;                    // jz short cseg_4E3CD

    push(A5);                               // push A5
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
    pop(A5);                                // pop A5

cseg_4E3CD:;
    CallDrawMenuItem();                     // call CallDrawMenuItem
    EditTacticsMenuSavePlayerPositions();   // call EditTacticsMenuSavePlayerPositions
    DrawPlayerNamesAndFaces();              // call DrawPlayerNamesAndFaces
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4E3DD()
{
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 16
    if (!flags.carry)
        goto cseg_4E419;                    // jnb short cseg_4E419

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 16
    if (!flags.carry)
        goto cseg_4E419;                    // jnb short cseg_4E419

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 11
    if (!flags.carry)
        goto cseg_4E40B;                    // jnb short cseg_4E40B

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 11
    if (flags.carry)
        goto cseg_4E505;                    // jb cseg_4E505

    goto cseg_4E419;                        // jmp short cseg_4E419

cseg_4E40B:;
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 11
    if (!flags.carry)
        goto cseg_4E505;                    // jnb cseg_4E505

cseg_4E419:;
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    A2 = 378790;                            // mov A2, offset playerPositionsArray
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    al = D0;                                // mov al, byte ptr D0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+4Eh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+4Eh]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al
    al = D0;                                // mov al, byte ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al

cseg_4E505:;
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (!flags.zero)
        goto cseg_4E564;                    // jnz short cseg_4E564

    A0 = 92766;                             // mov A0, offset currentMatchPlayers

cseg_4E519:;
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    al = D0;                                // mov al, byte ptr D0
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    return;                                 // retn

cseg_4E564:;
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 3Ch
    A0 = eax;                               // mov A0, eax
    goto cseg_4E519;                        // jmp short cseg_4E519
}

// =============== S U B R O U T I N E =======================================
//
void SelectCopyTactics()
{
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void UndoTactics()
{
    RestoreTactics();                       // call RestoreTactics
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
    cseg_4FA3A();                           // call cseg_4FA3A
    DrawPlayerNamesAndFaces();              // call DrawPlayerNamesAndFaces
}

// =============== S U B R O U T I N E =======================================
//
void AbortEditTactics()
{
    EditTacticsMenuSavePlayerPositions();   // call EditTacticsMenuSavePlayerPositions
    ax = *(word *)&g_memByte[508556];       // mov ax, tacticsChangedFlag
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_exit_menu;                   // jz short @@exit_menu

    A0 = 17429;                             // mov A0, offset aEditTactics
    A1 = 14765;                             // mov A1, offset editedTacticsWillBeLost
    A2 = 16899;                             // mov A2, offset aContinue
    A3 = 17196;                             // mov A3, offset aAbort
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    SWOS::DoContinueAbortMenu();            // call DoContinueAbortMenu
    if (!flags.zero)
        return;                             // jnz short @@out

l_exit_menu:;
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void SaveAndExitEditTactics()
{
    EditTacticsMenuSavePlayerPositions();   // call EditTacticsMenuSavePlayerPositions
    ax = *(word *)&g_memByte[508556];       // mov ax, tacticsChangedFlag
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_change;                   // jz short @@no_change

    ApplyCurrentEditedTactics();            // call ApplyCurrentEditedTactics
    cseg_4FE17();                           // call cseg_4FE17
    A0 = 17578;                             // mov A0, offset aSaveEditedTact
    A1 = 14729;                             // mov A1, offset tacticsHaveBeenChanged
    A2 = 19661;                             // mov A2, offset aSave
    A3 = 16956;                             // mov A3, offset aExit
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    SWOS::DoContinueAbortMenu();            // call DoContinueAbortMenu
    if (flags.zero)
        goto l_save_edited_tactics;         // jz short @@save_edited_tactics

l_no_change:;
    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

l_save_edited_tactics:;
    A0 = 17578;                             // mov A0, offset aSaveEditedTact
    SetZeroFlag();                          // call SetZeroFlag
    if (!flags.zero)
        return;                             // jnz @@out

    A1 = 316902;                            // mov A1, offset importTacticsFilename
    A0 = 378872;                            // mov A0, offset editTacticsCurrentTactics
    StringCopy();                           // call StringCopy
    D0 = 777273667;                         // mov D0, '.TAC'
    {
        D0 = (D0 << 8) | ((dword)D0 >> 24);
    }                                       // rol D0, 8
    al = D0;                                // mov al, byte ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    {
        D0 = (D0 << 8) | ((dword)D0 >> 24);
    }                                       // rol D0, 8
    al = D0;                                // mov al, byte ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    {
        D0 = (D0 << 8) | ((dword)D0 >> 24);
    }                                       // rol D0, 8
    al = D0;                                // mov al, byte ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    {
        dword newCarry = (D0 >> 24) & 1;
        D0 = (D0 << 8) | ((dword)D0 >> 24);
        flags.carry = newCarry != 0;
    }                                       // rol D0, 8
    al = D0;                                // mov al, byte ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    A0 = 316902;                            // mov A0, offset importTacticsFilename
    A1 = 17578;                             // mov A1, offset aSaveEditedTact
    SWOS::SelectFileToSaveDialog();         // call SelectFileToSaveDialog
    if (!flags.zero)
        goto l_cancel_save;                 // jnz @@cancel_save

    eax = A0;                               // mov eax, A0
    A2 = eax;                               // mov A2, eax
    A1 = 378872;                            // mov A1, offset editTacticsCurrentTactics
    *(byte *)&D0 = '.';                     // mov byte ptr D0, '.'
    StringCopyUntilChar();                  // call StringCopyUntilChar
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    A1 = 378872;                            // mov A1, offset editTacticsCurrentTactics
    push(A0);                               // push A0
    WriteTacticsFile();                     // call WriteTacticsFile
    pop(A0);                                // pop A0
    if (!flags.zero)
        goto l_cancel_save;                 // jnz short @@cancel_save

    push(A0);                               // push A0
    CopyCurrentTacticName();                // call CopyCurrentTacticName
    pop(A0);                                // pop A0
    A1 = 316902;                            // mov A1, offset importTacticsFilename
    StringCopy();                           // call StringCopy
    ApplyCurrentEditedTactics();            // call ApplyCurrentEditedTactics
    A0 = 17578;                             // mov A0, offset aSaveEditedTact
    SetZeroFlag();                          // call SetZeroFlag
    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

l_cancel_save:;
    A0 = 17578;                             // mov A0, offset aSaveEditedTact
    SetZeroFlag();                          // call SetZeroFlag
}

// =============== S U B R O U T I N E =======================================
//
void ImportTactics()
{
    EditTacticsMenuSavePlayerPositions();   // call EditTacticsMenuSavePlayerPositions
    A6 = 508838;                            // mov A6, offset importTacticsMenu
    SWOS::ShowMenu();                       // call ShowMenu
    ax = *(word *)&g_memByte[508220];       // mov ax, importMenuSelectedTactics
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js @@out

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1000;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, TACTIC_IMPORTED
    if (flags.zero)
        goto l_imported_tactic;             // jz @@imported_tactic

    push(D0);                               // push D0
    SaveCurrentTactics();                   // call SaveCurrentTactics
    pop(D0);                                // pop D0
    *(word *)&g_memByte[508556] = 1;        // mov tacticsChangedFlag, 1
    A0 = 372768;                            // mov A0, offset g_tacticsTable
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 9;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 9
    A0 = eax;                               // mov A0, eax
    A1 = 378881;                            // mov A1, offset editTacticsCurrentTactics.playerPos
    *(word *)&D0 = 369;                     // mov word ptr D0, 369

l_copy_tactic_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_tactic_loop;            // jns short @@copy_tactic_loop

l_imported_tactic:;
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 59, 1, 1);            // mov [esi+TeamFile.someFlag], 1
    cseg_4FE17();                           // call cseg_4FE17
    CopyCurrentTacticName();                // call CopyCurrentTacticName
    cseg_4FA3A();                           // call cseg_4FA3A
}

// =============== S U B R O U T I N E =======================================
//
void FlipOnOff()
{
    EditTacticsMenuSavePlayerPositions();   // call EditTacticsMenuSavePlayerPositions
    {
        word src = *(word *)&g_memByte[508554];
        src ^= 1;
        *(word *)&g_memByte[508554] = src;
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor flipOnOff, 1
    EnableOrDisablePlayerFacesItems();      // call EnableOrDisablePlayerFacesItems
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================

// Enable or disable player faces items in edit tactics menu, depending
// wheter flip is on or off.
//
void EnableOrDisablePlayerFacesItems()
{
    push(D0);                               // push D0
    D0 = 29;                                // mov D0, 29
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D7 = 9;                       // mov word ptr D7, 9

l_next:;
    ax = *(word *)&g_memByte[508554];       // mov ax, flipOnOff
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_flip_on_enable_item;         // jnz short @@flip_on_enable_item

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    goto l_next_entry;                      // jmp short @@next_entry

l_flip_on_enable_item:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 0);             // mov [esi+MenuEntry.isDisabled], 0

l_next_entry:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_next;                        // jns short @@next
}

// =============== S U B R O U T I N E =======================================

// Sets edit tactics menu header to name of current tactics.
//
void CopyCurrentTacticName()
{
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 17429;                             // mov A0, offset aEditTactics
    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, '(');               // mov byte ptr [esi], '('
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    A0 = 378872;                            // mov A0, offset editTacticsCurrentTactics
    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ')');               // mov byte ptr [esi], ')'
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
}

// =============== S U B R O U T I N E =======================================
//
void EditTacicsMovePlayersOrBall()
{
    ax = *(word *)&g_memByte[508558];       // mov ax, dseg_179A0E
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4E9C9;                    // jnz short cseg_4E9C9

    EditTacticsMenuSavePlayerPositions();   // call EditTacticsMenuSavePlayerPositions
    DrawPlayerNamesAndFaces();              // call DrawPlayerNamesAndFaces

cseg_4E9C9:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    cseg_50391();                           // call cseg_50391
    ax = *(word *)&g_memByte[508558];       // mov ax, dseg_179A0E
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void CopyTactics()
{
    ax = *(word *)&g_memByte[508558];       // mov ax, dseg_179A0E
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4EADB;                    // jnz cseg_4EADB

    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
    EditTacticsMenuSavePlayerPositions();   // call EditTacticsMenuSavePlayerPositions
    DrawPlayerNamesAndFaces();              // call DrawPlayerNamesAndFaces
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&g_memByte[508544] = ax;       // mov editTacticsPlayerX, ax

cseg_4EADB:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    cseg_50391();                           // call cseg_50391
    ax = *(word *)&g_memByte[508558];       // mov ax, dseg_179A0E
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+30]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Eh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+30], ax
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
    cseg_4FA3A();                           // call cseg_4FA3A
    DrawPlayerNamesAndFaces();              // call DrawPlayerNamesAndFaces
}

// =============== S U B R O U T I N E =======================================
//
void EditTactics2AfterDraw()
{
    DrawEditTacticsPitchAndPlayers();       // jmp DrawEditTacticsPitchAndPlayers
}

// =============== S U B R O U T I N E =======================================
//
void EditTacticsOnSelect28()
{
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    RotatePlayersLeft();                    // call RotatePlayersLeft
    A0 = 3437;                              // mov A0, offset cseg_4EC02
    nullsub_17();                           // jmp nullsub_17
}

// DATA XREF: EditTacticsOnSelect28+18o

// =============== S U B R O U T I N E =======================================
//
void EditTacticsAfterDrawCommon()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 29;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 29
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    cseg_4F37E();                           // call cseg_4F37E
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 39;                                // mov D0, 39
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    SWOS::DrawMenuItem();                   // jmp DrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void EditTactics28AfterDraw()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 27;                                // mov D0, 27
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    SWOS::DrawMenuItem();                   // jmp DrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4ECAD()
{
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A6 = eax;                               // mov A6, eax
    *(word *)&D0 = 27;                      // mov word ptr D0, 27
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 28;                      // mov word ptr D0, 28
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = *(word *)&g_memByte[508360];       // mov ax, editTacticsNumPlayers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 16
    if (flags.zero)
        return;                             // jz short @@out

    *(word *)&D0 = 27;                      // mov word ptr D0, 27
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1
    if (flags.zero)
        return;                             // jz short @@out

    *(word *)&D0 = 28;                      // mov word ptr D0, 28
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
}

// =============== S U B R O U T I N E =======================================
//
void EditTacticsAfterDrawPlayerNames()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 11
    push(D7);                               // push D7
    cseg_4F37E();                           // call cseg_4F37E
    pop(D7);                                // pop D7
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 16
    if (!flags.zero)
        goto cseg_4EDC6;                    // jnz short cseg_4EDC6

    *(word *)&D5 = 1;                       // mov word ptr D5, 1
    push(D0);                               // push D0
    D0 = 41;                                // mov D0, 41
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    goto cseg_4EF08;                        // jmp cseg_4EF08

cseg_4EDC6:;
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 0Bh
    if (!flags.carry)
        goto cseg_4EE7C;                    // jnb cseg_4EE7C

    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4EE32;                    // jz short cseg_4EE32

    push(D0);                               // push D0
    D0 = 41;                                // mov D0, 29h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 13;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Dh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    goto cseg_4EF08;                        // jmp cseg_4EF08

cseg_4EE32:;
    push(D0);                               // push D0
    D0 = 41;                                // mov D0, 29h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Eh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    goto cseg_4EF08;                        // jmp cseg_4EF08

cseg_4EE7C:;
    push(D0);                               // push D0
    D0 = 41;                                // mov D0, 29h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Bh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    goto cseg_4EF08;                        // jmp short cseg_4EF08

    push(D0);                               // push D0
    D0 = 41;                                // mov D0, 29h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Eh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax

cseg_4EF08:;
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+18h]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    al = g_memByte[379241];                 // mov al, editTacticsCurrentTactics.ballOutOfPlayTactics
    writeMemory(esi + 24, 1, al);           // mov [esi+18h], al
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    al = D6;                                // mov al, byte ptr D6
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 24, 1, al);           // mov [esi+18h], al
    ax = *(word *)&g_memByte[131753];       // mov ax, inEditTactics
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    push(D1);                               // push D1
    IsPlayerInjured();                      // call IsPlayerInjured
    pop(D1);                                // pop D1
    if (flags.zero)
        goto cseg_4EFDB;                    // jz short cseg_4EFDB

    push(D0);                               // push D0
    D0 = 41;                                // mov D0, 29h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ah
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax

cseg_4EFDB:;
    ax = *(word *)&g_memByte[508362];       // mov ax, dseg_17994A
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto cseg_4F02F;                    // jnz short cseg_4F02F

    push(D0);                               // push D0
    D0 = 41;                                // mov D0, 29h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 6
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax

cseg_4F02F:;
    ax = *(word *)&g_memByte[508370];       // mov ax, dseg_179952
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_4F09C;                    // js short cseg_4F09C

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.zero)
        goto cseg_4F09C;                    // jnz short cseg_4F09C

    push(D0);                               // push D0
    D0 = 41;                                // mov D0, 29h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 12;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ch
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax

cseg_4F09C:;
    push(D0);                               // push D0
    D0 = 40;                                // mov D0, 28h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4F111;                    // jnz short cseg_4F111

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+4Eh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_4F111:;
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    push(A0);                               // push A0
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4Fh
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 32781;                   // mov word ptr D0, 800Dh
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A6);                               // push A6
    ExtractSurname();                       // call ExtractSurname
    pop(A6);                                // pop A6
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    eax = A0;                               // mov eax, A0
    pop(A0);                                // pop A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    A2 = 332080;                            // mov A2, offset playerPositionsStringTable
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    FormTopSkillsString();                  // call FormTopSkillsString
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    push(A0);                               // push A0
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A1 = eax;                               // mov A1, eax
    IsTeamNational();                       // call IsTeamNational
    if (flags.zero)
        goto cseg_4F279;                    // jz short cseg_4F279

    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    cseg_3E04F();                           // call cseg_3E04F
    pop(A0);                                // pop A0
    goto cseg_4F2A5;                        // jmp short cseg_4F2A5

cseg_4F279:;
    A1 = 316574;                            // mov A1, offset fundsBuffer
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    cseg_247C8();                           // call cseg_247C8
    pop(A0);                                // pop A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 316574);       // mov dword ptr [esi+26h], offset fundsBuffer

cseg_4F2A5:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D1 = 13;                      // mov word ptr D1, 0Dh
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_4F2F9;                    // jz short cseg_4F2F9

    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_4F2F9;                    // jz short cseg_4F2F9

    *(word *)&D1 = 2;                       // mov word ptr D1, 2
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+66h], 2
    if (flags.zero)
        goto cseg_4F2F9;                    // jz short cseg_4F2F9

    *(word *)&D1 = 15;                      // mov word ptr D1, 0Fh

cseg_4F2F9:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+24h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+24h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 38h
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 39;                                // mov D0, 27h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    SWOS::DrawMultipleItems();              // jmp DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================

// in:
//      D7 - player ordinal
//
void cseg_4F37E()
{
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 16
    if (!flags.zero)
        goto l_not_player_16;               // jnz short @@not_player_16

    push(D0);                               // push D0
    D0 = 39;                                // mov D0, 39
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, BLUE_TO_BLACK_8
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    goto cseg_4F50B;                        // jmp cseg_4F50B

l_not_player_16:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 11
    if (!flags.carry)
        goto l_players;                     // jnb @@players

    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_first_goalkeeper;            // jz short @@first_goalkeeper

    push(D0);                               // push D0
    D0 = 39;                                // mov D0, 39
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 13;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, BRIGHT_BLUE_TO_BLUE_13
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    goto cseg_4F50B;                        // jmp cseg_4F50B

l_first_goalkeeper:;
    push(D0);                               // push D0
    D0 = 39;                                // mov D0, 39
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, YELLOW_GREEN_BLACK_14
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    goto cseg_4F50B;                        // jmp cseg_4F50B

l_players:;
    push(D0);                               // push D0
    D0 = 39;                                // mov D0, 39
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 11
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    goto cseg_4F50B;                        // jmp short cseg_4F50B

    push(D0);                               // push D0
    D0 = 39;                                // mov D0, 39
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 14
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

cseg_4F50B:;
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    al = g_memByte[379241];                 // mov al, editTacticsCurrentTactics.ballOutOfPlayTactics
    writeMemory(esi + 24, 1, al);           // mov [esi+TeamFile.tactics], al
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    al = D6;                                // mov al, byte ptr D6
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 24, 1, al);           // mov [esi+TeamFile.tactics], al
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+103]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto cseg_4F5EC;                    // jz short cseg_4F5EC

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 32
    if (flags.zero)
        goto cseg_4F5EC;                    // jz short cseg_4F5EC

    push(D0);                               // push D0
    D0 = 39;                                // mov D0, 39
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 10
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

cseg_4F5EC:;
    ax = *(word *)&g_memByte[508362];       // mov ax, dseg_17994A
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto cseg_4F640;                    // jnz short cseg_4F640

    push(D0);                               // push D0
    D0 = 39;                                // mov D0, 39
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 6
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

cseg_4F640:;
    ax = *(word *)&g_memByte[508370];       // mov ax, dseg_179952
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_4F6AD;                    // js short cseg_4F6AD

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.zero)
        goto cseg_4F6AD;                    // jnz short cseg_4F6AD

    push(D0);                               // push D0
    D0 = 39;                                // mov D0, 39
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 12;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ch
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

cseg_4F6AD:;
    ax = *(word *)&g_memByte[508554];       // mov ax, flipOnOff
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4F7CD;                    // jz cseg_4F7CD

    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4F788;                    // jz cseg_4F788

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 11
    if (!flags.carry)
        goto cseg_4F788;                    // jnb cseg_4F788

    A0 = 379231;                            // mov A0, offset editTacticsCurrentTactics.someTable
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    al = (byte)readMemory(esi + ebx + -1, 1); // mov al, [esi+ebx-1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_4F788;                    // js cseg_4F788

    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 508350;                            // mov A0, offset dseg_17993E
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    push(D0);                               // push D0
    D0 = 39;                                // mov D0, 39
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    goto cseg_4F7CD;                        // jmp short cseg_4F7CD

cseg_4F788:;
    push(D0);                               // push D0
    D0 = 39;                                // mov D0, 39
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0FFF0h
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

cseg_4F7CD:;
    push(D0);                               // push D0
    D0 = 39;                                // mov D0, 39
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    SetMenuEntryPlayerFace();               // call SetMenuEntryPlayerFace
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 11
    if (!flags.carry)
        return;                             // jnb short @@out

    A1 = 378790;                            // mov A1, offset playerPositionsArray
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D5;                     // movzx ebx, word ptr D5
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    A1 = 378822;                            // mov A1, offset oldPlayerPositionsArray
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.carry && !flags.zero)
        goto l_check_it_ok;                 // ja short @@check_it_ok

    if (flags.zero)
        return;                             // jz short @@out

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, 209);          // mov [esi+MenuEntry.fg.sprite2], SPR_NOT_CHECK_SMALL
    return;                                 // retn

l_check_it_ok:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, 208);          // mov [esi+MenuEntry.fg.sprite2], SPR_CHECK_SMALL
}

// =============== S U B R O U T I N E =======================================

// In tactics menu.
//
void DrawPlayerNamesAndFaces()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 29;                                // mov D0, 29
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CallDrawMultipleItems();                // call CallDrawMultipleItems
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================

// [edit tactics menu procedure]
// Copies player positions into savedPositionsArray and sets big check sprite if necessary.
//
void EditTacticsMenuSavePlayerPositions()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ax = *(word *)&g_memByte[378786];       // mov ax, oldPlayerSkill
    *(word *)&g_memByte[378788] = ax;       // mov newPlayerSkill, ax
    A0 = 378790;                            // mov A0, offset playerPositionsArray
    A1 = 378822;                            // mov A1, offset oldPlayerPositionsArray
    *(word *)&D0 = 31;                      // mov word ptr D0, 31

l_copy_positions:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_positions;              // jns short @@copy_positions

    SetBigCheckSprite();                    // call SetBigCheckSprite
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4FA3A()
{
    ax = *(word *)&g_memByte[378786];       // mov ax, oldPlayerSkill
    *(word *)&g_memByte[378788] = ax;       // mov newPlayerSkill, ax
    A0 = 378790;                            // mov A0, offset playerPositionsArray
    A1 = 378822;                            // mov A1, offset oldPlayerPositionsArray
    *(word *)&D0 = 31;                      // mov word ptr D0, 31

l_copy_skills_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_skills_loop;            // jns short @@copy_skills_loop

    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 59, 1, 1);            // mov [esi+TeamFile.someFlag], 1
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    writeMemory(esi + 24, 1, 18);           // mov [esi+TeamFile.tactics], 18
    push(D7);                               // push D7
    push(A0);                               // push A0
    SetupTeamSubstitutes();                           // call SetupTeamSubstitutes
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    al = D7;                                // mov al, byte ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 24, 1, al);           // mov [esi+TeamFile.tactics], al

    SetBigCheckSprite();
}

// =============== S U B R O U T I N E =======================================

// [edit tactics menu procedure]
//
void SetBigCheckSprite()
{
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 57343;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0DFFFh
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    ax = *(word *)&g_memByte[378786];       // mov ax, oldPlayerSkill
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[378788];       // mov ax, newPlayerSkill
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry && !flags.zero)
        goto l_new_player_better;           // ja short @@new_player_better

    ax = *(word *)&g_memByte[378788];       // mov ax, newPlayerSkill
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.carry)
        goto l_new_player_worse;            // jb short @@new_player_worse

    return;                                 // retn

l_new_player_worse:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, 207);          // mov [esi+MenuEntry.fg.sprite2], SPR_NOT_CHECK_BIG
    goto l_make_marker_visible;             // jmp short @@make_marker_visible

l_new_player_better:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, 206);          // mov [esi+MenuEntry.fg.sprite2], SPR_CHECK_BIG

l_make_marker_visible:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D1 |= 8192;
    flags.carry = false;
    flags.sign = (*(word *)&D1 & 0x8000) != 0;
    flags.zero = *(word *)&D1 == 0;         // or word ptr D1, 2000h
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
}

// =============== S U B R O U T I N E =======================================
//
void ApplyCurrentEditedTactics()
{
    A1 = 372768;                            // mov A1, offset g_tacticsTable
    ax = *(word *)&g_memByte[508540];       // mov ax, chosenTactics
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A1 = eax;                               // mov A1, eax
    A0 = 378872;                            // mov A0, offset editTacticsCurrentTactics
    *(word *)&D0 = 369;                     // mov word ptr D0, 369

l_copy_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    flags.carry = false;                    // or al, al
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_loop;                   // jns short @@copy_loop

    InitializeTacticsPositions();           // call InitializeTacticsPositions
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4FC28()
{
    *(word *)&g_memByte[508556] = 1;        // mov tacticsChangedFlag, 1
    ax = *(word *)&g_memByte[508544];       // mov ax, editTacticsPlayerX
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    cseg_4FDC1();                           // call cseg_4FDC1
    ax = *(word *)&g_memByte[508544];       // mov ax, editTacticsPlayerX
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 5;                                 // mov bx, 5
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 2
    if (flags.zero)
        return;                             // jz cseg_4FD3A

    ax = D1;                                // mov ax, word ptr D1
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D1 = eax;                               // mov D1, eax
    dx = *(word *)((byte *)&D1 + 2);        // mov dx, word ptr D1+2
    bx = 5;                                 // mov bx, 5
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 2
    if (flags.zero)
        return;                             // jz short cseg_4FD3A

    if (!flags.sign)
        goto cseg_4FD0D;                    // jns short cseg_4FD0D

    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_4FD18;                    // jns short cseg_4FD18

    goto cseg_4FD29;                        // jmp short cseg_4FD29

cseg_4FD0D:;
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_4FD29;                    // jns short cseg_4FD29

cseg_4FD18:;
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    cseg_50155();                           // call cseg_50155

cseg_4FD29:;
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_50093();                           // call cseg_50093
}

// =============== S U B R O U T I N E =======================================

// Saves current tactics in edit tactics menu.
//
void SaveCurrentTactics()
{
    A0 = 378872;                            // mov A0, offset editTacticsCurrentTactics
    A1 = 379242;                            // mov A1, offset savedCurrentTactics
    *(word *)&D0 = 369;                     // mov word ptr D0, 369

l_copy_tactic_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_tactic_loop;            // jns short @@copy_tactic_loop
}

// =============== S U B R O U T I N E =======================================
//
void RestoreTactics()
{
    A0 = 379242;                            // mov A0, offset savedCurrentTactics
    A1 = 378872;                            // mov A1, offset editTacticsCurrentTactics
    *(word *)&D0 = 369;                     // mov word ptr D0, 369

l_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_loop;                        // jns short @@loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4FDC1()
{
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)&D7 = 1;                       // mov word ptr D7, 1

cseg_4FDD6:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerQuadrant();                    // call GetPlayerQuadrant
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_4FEFF();                           // call cseg_4FEFF
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 0Bh
    if (!flags.zero)
        goto cseg_4FDD6;                    // jnz short cseg_4FDD6
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> selected teams buffer
//
void cseg_4FE17()
{
    {
        word src = *(word *)&g_memByte[91720];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp selTeamNumber, -1
    if (flags.zero)
        goto cseg_4FE28;                    // jz short cseg_4FE28

    g_memByte[92857] = 1;                   // mov careerTeam+3Bh, 1

cseg_4FE28:;
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[508540];       // mov ax, chosenTactics
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_teams_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_4FE72;                    // jnz short cseg_4FE72

    writeMemory(esi + 59, 1, 1);            // mov [esi+TeamFile.someFlag], 1

cseg_4FE72:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 684
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_teams_loop;                  // jns short @@teams_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - player number
//      D1 - ball location
// out:
//      D0 - (player number - 1) * 35
//      D1 - x quadrant
//      D2 - y quadrant
//
void GetPlayerQuadrant()
{
    A0 = 378881;                            // mov A0, offset editTacticsCurrentTactics.playerPos
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    bx = 35;                                // mov bx, 35
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 255;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFh
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        word res = *(word *)&D1 >> 4;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 4
    {
        word res = *(word *)&D2 & 15;
        *(word *)&D2 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D2, 0Fh
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4FEFF()
{
    *(word *)&g_memByte[508556] = 1;        // mov tacticsChangedFlag, 1
    A0 = 378881;                            // mov A0, offset editTacticsCurrentTactics.playerPos
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    bx = 35;                                // mov bx, 35
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    {
        word res = *(word *)&D1 << 4;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 4
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 |= ax;
    flags.carry = false;
    flags.sign = (*(word *)&D1 & 0x8000) != 0;
    flags.zero = *(word *)&D1 == 0;         // or word ptr D1, ax
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
}

// =============== S U B R O U T I N E =======================================

// in:
//      D1 - ball row
//      D2 - ball column
// out:
//      D1 - ball x coordinate
//      D2 - ball y coordinate
//
void GetBallXYPositionFromQuadrant()
{
    {
        word res = *(word *)&D1 << 1;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 1
    A0 = 508376;                            // mov A0, offset ballXQuadrantCoordinates
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    *(word *)&D1 = 129;                     // mov word ptr D1, 129
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 6;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 6
    {
        word res = *(word *)&D2 << 1;
        *(word *)&D2 = res;
    }                                       // shl word ptr D2, 1
    A0 = 508386;                            // mov A0, offset ballYQuadrantCoordinates
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    *(word *)&D2 = 199;                     // mov word ptr D2, 199
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - ball location
// out:
//      D1 - ball column
//      D2 - ball row
//
void GetBallQuadrant()
{
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 5;                                 // mov bx, 5
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    eax = D0;                               // mov eax, D0
    D1 = eax;                               // mov D1, eax
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_50093()
{
    ax = *(word *)&g_memByte[508554];       // mov ax, flipOnOff
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_50154

    ax = D1;                                // mov ax, word ptr D1
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D3 = eax;                               // mov D3, eax
    dx = *(word *)((byte *)&D3 + 2);        // mov dx, word ptr D3+2
    bx = 5;                                 // mov bx, 5
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    *(word *)((byte *)&D3 + 2) = dx;        // mov word ptr D3+2, dx
    eax = D3;                               // mov eax, D3
    D0 = eax;                               // mov D0, eax
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (flags.zero)
        return;                             // jz short cseg_50154

    ax = D3;                                // mov ax, word ptr D3
    bx = 5;                                 // mov bx, 5
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    *(word *)((byte *)&D3 + 2) = dx;        // mov word ptr D3+2, dx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 4;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 4
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, ax
    cseg_4FDC1();                           // call cseg_4FDC1
    cseg_50155();                           // call cseg_50155
}

// =============== S U B R O U T I N E =======================================
//
void cseg_50155()
{
    ax = *(word *)&g_memByte[508554];       // mov ax, flipOnOff
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_50390

    ax = D3;                                // mov ax, word ptr D3
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 5;                                 // mov bx, 5
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (flags.zero)
        return;                             // jz cseg_50390

    A0 = 378881;                            // mov A0, offset editTacticsCurrentTactics.playerPos
    *(word *)&D2 = 9;                       // mov word ptr D2, 9

cseg_501D1:;
    *(byte *)&D0 = 239;                     // mov byte ptr D0, 0EFh
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        word res = *(word *)&D0 & 240;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0F0h
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 15;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0Fh
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 |= al;                     // or byte ptr D0, al
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 35;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 23h
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_501D1;                    // jns short cseg_501D1

    A0 = 379231;                            // mov A0, offset editTacticsCurrentTactics.someTable
    A1 = 378881;                            // mov A1, offset editTacticsCurrentTactics.playerPos
    *(word *)&D7 = 4;                       // mov word ptr D7, 4

cseg_50267:;
    *(word *)&D1 = 9;                       // mov word ptr D1, 9

cseg_50270:;
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, al
    if (!flags.zero)
        goto cseg_50376;                    // jnz cseg_50376

    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_502A0:;
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, al
    if (flags.zero)
        goto cseg_502C4;                    // jz short cseg_502C4

    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_502A0;                    // jns short cseg_502A0

    debugBreak();                           // int 3

cseg_502C2:;
    goto cseg_502C2;                        // jmp short cseg_502C2

cseg_502C4:;
    ax = D1;                                // mov ax, word ptr D1
    bx = 35;                                // mov bx, 23h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)((byte *)&D4 + 2) = dx;        // mov word ptr D4+2, dx
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, ax
    ax = D2;                                // mov ax, word ptr D2
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    *(word *)((byte *)&D5 + 2) = dx;        // mov word ptr D5+2, dx
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, ax
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ebx = *(word *)&D5;                     // movzx ebx, word ptr D5
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    al = D0;                                // mov al, byte ptr D0
    ebx = *(word *)&D5;                     // movzx ebx, word ptr D5
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    goto cseg_50383;                        // jmp short cseg_50383

cseg_50376:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_50270;                    // jns cseg_50270

cseg_50383:;
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_50267;                    // jns cseg_50267
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - edit tactics status
//
void cseg_50391()
{
    ax = *(word *)&g_memByte[508558];       // mov ax, dseg_179A0E
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_503C6;                    // jnz short cseg_503C6

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[508538] = ax;       // mov editTacticsPitchStatus, ax
    *(word *)&g_memByte[508536] = 0;        // mov markedPlayerNumber, 0
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&g_memByte[508534] = ax;       // mov prevGameTime, ax
    *(word *)&g_memByte[508558] = 1;        // mov dseg_179A0E, 1

cseg_503C6:;
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[508534];       // mov ax, prevGameTime
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
    }                                       // cmp word ptr D0, 2
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&g_memByte[508534] = ax;       // mov prevGameTime, ax
    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 0
    if (!flags.zero)
        goto cseg_50411;                    // jnz short cseg_50411

    ax = *(word *)&g_memByte[252384];       // mov ax, fire
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_fire;                        // jnz short @@fire

    *(word *)&g_memByte[508538] = 2;        // mov editTacticsPitchStatus, 2

cseg_50411:;
    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 1
    if (!flags.zero)
        goto cseg_5042F;                    // jnz short cseg_5042F

    ax = *(word *)&g_memByte[252384];       // mov ax, fire
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_fire;                        // jnz short @@fire

    *(word *)&g_memByte[508538] = 6;        // mov editTacticsPitchStatus, 6

cseg_5042F:;
    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, -1
    if (flags.zero)
        goto l_out;                         // jz short @@out

    ax = *(word *)&g_memByte[508536];       // mov ax, markedPlayerNumber
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5044B;                    // jz short cseg_5044B

    cseg_50501();                           // call cseg_50501
    goto l_fire;                            // jmp short @@fire

cseg_5044B:;
    EditTacticsReadControls();              // call EditTacticsReadControls

l_fire:;
    DrawEditTacticsPitchAndPlayers();       // call DrawEditTacticsPitchAndPlayers
    return;                                 // retn

l_out:;
    *(word *)&g_memByte[508558] = 0;        // mov dseg_179A0E, 0
}

// =============== S U B R O U T I N E =======================================
//
void DrawEditTacticsPitchAndPlayers()
{
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    *(word *)&D3 = 1;                       // mov word ptr D3, 1
    *(word *)&D4 = 211;                     // mov word ptr D4, 211
    *(word *)&D0 = 226;                     // mov word ptr D0, SPR_TACTICS_PITCH
    *(word *)&D1 = 6;                       // mov word ptr D1, 6
    DrawSprite();                           // call DrawSprite
    DrawPlayerDirections();                 // call DrawPlayerDirections
    EditTacticsDrawCursor();                // call EditTacticsDrawCursor
    DrawLittlePlayersAndBall();             // call DrawLittlePlayersAndBall
    cseg_51729();                           // call cseg_51729
}

// =============== S U B R O U T I N E =======================================
//
void cseg_50501()
{
    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 4
    if (flags.zero)
        goto cseg_506E0;                    // jz cseg_506E0

    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 5
    if (flags.zero)
        goto cseg_50551;                    // jz short cseg_50551

    ax = *(word *)&g_memByte[252384];       // mov ax, fire
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_50542;                    // jnz short cseg_50542

    ax = *(word *)&g_memByte[252378];       // mov ax, fireCounter
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        { HandlePlayersOrBallInEditTactics(); return; } // jz HandlePlayersOrBallInEditTactics

    {
        word src = *(word *)&g_memByte[252378];
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp fireCounter, 7
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_5085C;                    // jle cseg_5085C

    return;                                 // retn

cseg_50542:;
    {
        word src = *(word *)&g_memByte[252378];
        int16_t dstSigned = src;
        int16_t srcSigned = -14;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp fireCounter, -14
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_508D2;                    // jle cseg_508D2

    return;                                 // retn

cseg_50551:;
    ax = *(word *)&g_memByte[252384];       // mov ax, fire
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_50575;                    // jnz short cseg_50575

    ax = *(word *)&g_memByte[252378];       // mov ax, fireCounter
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_50575;                    // jz short cseg_50575

    {
        word src = *(word *)&g_memByte[252378];
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp fireCounter, 7
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_508C8;                    // jle cseg_508C8

cseg_50575:;
    {
        word src = *(word *)&g_memByte[508542];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[508542] = src;
    }                                       // add dseg_1799FE, 1
    {
        word src = *(word *)&g_memByte[508542];
        word res = src & 1;
        src = res;
        *(word *)&g_memByte[508542] = src;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and dseg_1799FE, 1
    if (!flags.zero)
        return;                             // jnz cseg_5085B

    al = g_memByte[252392];                 // mov al, up
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_50642;                    // jnz cseg_50642

    al = g_memByte[252393];                 // mov al, down
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_5060F;                    // jnz short cseg_5060F

    al = g_memByte[252394];                 // mov al, left
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_505DF;                    // jnz short cseg_505DF

    al = g_memByte[252395];                 // mov al, right
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        return;                             // jz cseg_5085B

    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    if (!flags.sign)
        goto cseg_5067B;                    // jns cseg_5067B

    *(word *)&D0 = 34;                      // mov word ptr D0, 22h
    goto cseg_5067B;                        // jmp cseg_5067B

cseg_505DF:;
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 35;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 23h
    if (!flags.zero)
        goto cseg_5067B;                    // jnz short cseg_5067B

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    goto cseg_5067B;                        // jmp short cseg_5067B

cseg_5060F:;
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 5
    if (!flags.sign)
        goto cseg_5067B;                    // jns short cseg_5067B

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 34;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 22h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 29;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1Dh
    if (!flags.zero)
        goto cseg_5067B;                    // jnz short cseg_5067B

    *(word *)&D0 = 34;                      // mov word ptr D0, 22h
    goto cseg_5067B;                        // jmp short cseg_5067B

cseg_50642:;
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 35;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 23h
    if (flags.carry)
        goto cseg_5067B;                    // jb short cseg_5067B

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 34;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 22h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 5
    if (!flags.zero)
        goto cseg_5067B;                    // jnz short cseg_5067B

    *(word *)&D0 = 0;                       // mov word ptr D0, 0

cseg_5067B:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[378862] = ax;       // mov editTacticsBallLocation, ax
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 5;                                 // mov bx, 5
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[378860] = ax;       // mov ballColumn, ax
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[378858] = ax;       // mov ballRow, ax
    return;                                 // retn

cseg_506E0:;
    ax = *(word *)&g_memByte[252384];       // mov ax, fire
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_50706;                    // jnz short cseg_50706

    ax = *(word *)&g_memByte[252378];       // mov ax, fireCounter
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_50714;                    // jz short cseg_50714

    {
        word src = *(word *)&g_memByte[252378];
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp fireCounter, 7
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_50875;                    // jle cseg_50875

    goto cseg_50714;                        // jmp short cseg_50714

cseg_50706:;
    {
        word src = *(word *)&g_memByte[252378];
        int16_t dstSigned = src;
        int16_t srcSigned = 65522;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp fireCounter, 65522
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_508D2;                    // jle cseg_508D2

cseg_50714:;
    ax = *(word *)&g_memByte[252382];       // mov ax, menuControlsDirection
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js cseg_5085B

    cseg_50B6D();                           // call cseg_50B6D
    ax = *(word *)&g_memByte[508536];       // mov ax, markedPlayerNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerQuadrant();                    // call GetPlayerQuadrant
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    if (flags.sign)
        goto cseg_50776;                    // js short cseg_50776

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0Fh
    if (!flags.carry)
        goto cseg_50776;                    // jnb short cseg_50776

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_50776:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    if (flags.sign)
        goto cseg_507A7;                    // js short cseg_507A7

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 10h
    if (!flags.carry)
        goto cseg_507A7;                    // jnb short cseg_507A7

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax

cseg_507A7:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1

cseg_507C8:;
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    push(D0);                               // push D0
    GetPlayerQuadrant();                    // call GetPlayerQuadrant
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (!flags.zero)
        goto cseg_50803;                    // jnz short cseg_50803

    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (flags.zero)
        return;                             // jz short cseg_5085B

cseg_50803:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0Bh
    if (!flags.zero)
        goto cseg_507C8;                    // jnz short cseg_507C8

    ax = *(word *)&g_memByte[508536];       // mov ax, markedPlayerNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    cseg_4FEFF();                           // call cseg_4FEFF
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_50093();                           // call cseg_50093

cseg_5085B:;
    return;                                 // retn

cseg_5085C:;
    SaveCurrentTactics();                   // call SaveCurrentTactics
    *(word *)&g_memByte[508538] = 4;        // mov editTacticsPitchStatus, 4
    EditTacticsMenuSavePlayerPositions();   // call EditTacticsMenuSavePlayerPositions
    DrawPlayerNamesAndFaces();              // call DrawPlayerNamesAndFaces
    return;                                 // retn

cseg_50875:;
    *(word *)&g_memByte[508538] = 7;        // mov editTacticsPitchStatus, 7
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
    cseg_4FA3A();                           // call cseg_4FA3A
    DrawPlayerNamesAndFaces();              // call DrawPlayerNamesAndFaces

cseg_508C8:;
    *(word *)&g_memByte[508538] = 2;        // mov editTacticsPitchStatus, 2
    return;                                 // retn

cseg_508D2:;
    *(word *)&g_memByte[508542] = 0;        // mov dseg_1799FE, 0
    *(word *)&g_memByte[508538] = 5;        // mov editTacticsPitchStatus, 5
}

// =============== S U B R O U T I N E =======================================
//
void EditTacticsReadControls()
{
    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 6
    if (flags.zero)
        goto cseg_509CE;                    // jz cseg_509CE

    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 3
    if (flags.zero)
        goto cseg_50943;                    // jz short cseg_50943

    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 4
    if (flags.zero)
        goto cseg_509ED;                    // jz cseg_509ED

    ax = *(word *)&g_memByte[252384];       // mov ax, fire
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_50934;                    // jnz short cseg_50934

    ax = *(word *)&g_memByte[252378];       // mov ax, fireCounter
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        { HandlePlayersOrBallInEditTactics(); return; } // jz HandlePlayersOrBallInEditTactics

    {
        word src = *(word *)&g_memByte[252378];
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp fireCounter, 7
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_50A6C;                    // jle cseg_50A6C

    return;                                 // retn

cseg_50934:;
    {
        word src = *(word *)&g_memByte[252378];
        int16_t dstSigned = src;
        int16_t srcSigned = -7;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp fireCounter, -7
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_50A76;                    // jle cseg_50A76

    return;                                 // retn

cseg_50943:;
    ax = *(word *)&g_memByte[252384];       // mov ax, fire
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_50977;                    // jnz short cseg_50977

    ax = *(word *)&g_memByte[508546];       // mov ax, editTacticsBallRow
    *(word *)&g_memByte[378858] = ax;       // mov ballRow, ax
    ax = *(word *)&g_memByte[508548];       // mov ax, editTacticsBallColumn
    *(word *)&g_memByte[378860] = ax;       // mov ballColumn, ax
    ax = *(word *)&g_memByte[508550];       // mov ax, editTacticsLastBallLocation
    *(word *)&g_memByte[378862] = ax;       // mov editTacticsBallLocation, ax
    goto cseg_50AA4;                        // jmp cseg_50AA4

cseg_50977:;
    ax = *(word *)&g_memByte[252382];       // mov ax, menuControlsDirection
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js cseg_50A6B

    ax = *(word *)&g_memByte[508546];       // mov ax, editTacticsBallRow
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[508548];       // mov ax, editTacticsBallColumn
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    cseg_50AAE();                           // call cseg_50AAE
    if (!flags.zero)
        return;                             // jnz cseg_50A6B

    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[508546] = ax;       // mov editTacticsBallRow, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[508548] = ax;       // mov editTacticsBallColumn, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[508550] = ax;       // mov editTacticsLastBallLocation, ax
    return;                                 // retn

cseg_509CE:;
    ax = *(word *)&g_memByte[252384];       // mov ax, fire
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_50A1D;                    // jz short cseg_50A1D

    SaveCurrentTactics();                   // call SaveCurrentTactics
    cseg_4FC28();                           // call cseg_4FC28
    *(word *)&g_memByte[508538] = -1;       // mov editTacticsPitchStatus, -1
    return;                                 // retn

cseg_509ED:;
    ax = *(word *)&g_memByte[252384];       // mov ax, fire
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_50A13;                    // jnz short cseg_50A13

    ax = *(word *)&g_memByte[252378];       // mov ax, fireCounter
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_50A1D;                    // jz short cseg_50A1D

    {
        word src = *(word *)&g_memByte[252378];
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp fireCounter, 7
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_50AA4;                    // jle cseg_50AA4

    goto cseg_50A1D;                        // jmp short cseg_50A1D

cseg_50A13:;
    {
        word src = *(word *)&g_memByte[252378];
        int16_t dstSigned = src;
        int16_t srcSigned = -7;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp fireCounter, -7
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_50A76;                    // jle short cseg_50A76

cseg_50A1D:;
    ax = *(word *)&g_memByte[252382];       // mov ax, menuControlsDirection
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js short cseg_50A6B

    ax = *(word *)&g_memByte[378858];       // mov ax, ballRow
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[378860];       // mov ax, ballColumn
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    cseg_50AAE();                           // call cseg_50AAE
    if (!flags.zero)
        return;                             // jnz short cseg_50A6B

    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[378858] = ax;       // mov ballRow, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[378860] = ax;       // mov ballColumn, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[378862] = ax;       // mov editTacticsBallLocation, ax

cseg_50A6B:;
    return;                                 // retn

cseg_50A6C:;
    *(word *)&g_memByte[508538] = 4;        // mov editTacticsPitchStatus, 4
    return;                                 // retn

cseg_50A76:;
    ax = *(word *)&g_memByte[378858];       // mov ax, ballRow
    *(word *)&g_memByte[508546] = ax;       // mov editTacticsBallRow, ax
    ax = *(word *)&g_memByte[378860];       // mov ax, ballColumn
    *(word *)&g_memByte[508548] = ax;       // mov editTacticsBallColumn, ax
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&g_memByte[508550] = ax;       // mov editTacticsLastBallLocation, ax
    *(word *)&g_memByte[508538] = 3;        // mov editTacticsPitchStatus, 3
    return;                                 // retn

cseg_50AA4:;
    *(word *)&g_memByte[508538] = 2;        // mov editTacticsPitchStatus, 2
}

// =============== S U B R O U T I N E =======================================
//
void cseg_50AAE()
{
    cseg_50B6D();                           // call cseg_50B6D
    *(word *)&D5 = 1;                       // mov word ptr D5, 1
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    if (flags.sign)
        goto cseg_50AF6;                    // js short cseg_50AF6

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 5
    if (!flags.carry)
        goto cseg_50AF6;                    // jnb short cseg_50AF6

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D5 = 0;                       // mov word ptr D5, 0

cseg_50AF6:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    if (flags.sign)
        goto cseg_50B30;                    // js short cseg_50B30

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 7
    if (!flags.carry)
        goto cseg_50B30;                    // jnb short cseg_50B30

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)&D5 = 0;                       // mov word ptr D5, 0

cseg_50B30:;
    ax = D2;                                // mov ax, word ptr D2
    bx = 5;                                 // mov bx, 5
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    *(word *)((byte *)&D3 + 2) = dx;        // mov word ptr D3+2, dx
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, ax
    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_50B6D()
{
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    ax = *(word *)&g_memByte[252380];       // mov ax, menuControlsDirection2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js short @@out

    A0 = 510428;                            // mov A0, offset dseg_17A15C
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    al = (byte)readMemory(esi + ebx + 1, 1); // mov al, [esi+ebx+1]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(int16_t *)&D3 = -*(int16_t *)&D3;     // neg word ptr D3
    flags.carry = *(int16_t *)&D4 != 0;
    *(int16_t *)&D4 = -*(int16_t *)&D4;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // neg word ptr D4
}

// =============== S U B R O U T I N E =======================================
//
void HandlePlayersOrBallInEditTactics()
{
    ax = *(word *)&g_memByte[252382];       // mov ax, menuControlsDirection
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js @@out

    ax = *(word *)&g_memByte[508536];       // mov ax, markedPlayerNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_moving_ball;                 // jz short @@moving_ball

    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerXYPositionFromQuadrant();      // call GetPlayerXYPositionFromQuadrant
    goto cseg_50C45;                        // jmp short cseg_50C45

l_moving_ball:;
    ax = *(word *)&g_memByte[378858];       // mov ax, ballRow
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[378860];       // mov ax, ballColumn
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    GetBallXYPositionFromQuadrant();        // call GetBallXYPositionFromQuadrant

cseg_50C45:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)&D3 = -1;                      // mov word ptr D3, -1
    D4 = -1;                                // mov D4, -1
    *(word *)&g_memByte[510444] = 384;      // mov pitchWidth, 384

cseg_50C79:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0

cseg_50C82:;
    ax = *(word *)&g_memByte[508536];       // mov ax, markedPlayerNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_marked_player;               // jz @@marked_player

    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_50D07;                    // jnz short cseg_50D07

    ax = *(word *)&g_memByte[378858];       // mov ax, ballRow
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[378860];       // mov ax, ballColumn
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    push(D0);                               // push D0
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    GetBallXYPositionFromQuadrant();        // call GetBallXYPositionFromQuadrant
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D0);                                // pop D0
    goto cseg_50D60;                        // jmp short cseg_50D60

cseg_50D07:;
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    push(D0);                               // push D0
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    GetPlayerXYPositionFromQuadrant();      // call GetPlayerXYPositionFromQuadrant
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D0);                                // pop D0

cseg_50D60:;
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
    ax = *(word *)&g_memByte[252382];       // mov ax, menuControlsDirection
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        word res = *(word *)&D7 & 6;
        *(word *)&D7 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D7, 6
    if (flags.zero)
        goto l_not_going_left;              // jz @@not_going_left

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 4
    if (flags.zero)
        goto l_going_down;                  // jz @@going_down

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 6
    if (flags.zero)
        goto l_going_left;                  // jz short @@going_left

    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_marked_player;               // js @@marked_player

    bx = *(word *)&g_memByte[510444];       // mov bx, pitchWidth
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    {
        dword res = D7 >> 8;
        D7 = res;
    }                                       // shr D7, 8
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_marked_player;               // jg @@marked_player

    *(int16_t *)&D7 = -*(int16_t *)&D7;     // neg word ptr D7
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.sign != flags.overflow)
        goto l_marked_player;               // jl @@marked_player

    goto cseg_50F64;                        // jmp cseg_50F64

l_going_left:;
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign == flags.overflow)
        goto l_marked_player;               // jge @@marked_player

    bx = *(word *)&g_memByte[510444];       // mov bx, pitchWidth
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    {
        dword res = D7 >> 8;
        D7 = res;
    }                                       // shr D7, 8
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.sign != flags.overflow)
        goto l_marked_player;               // jl @@marked_player

    *(int16_t *)&D7 = -*(int16_t *)&D7;     // neg word ptr D7
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_marked_player;               // jg @@marked_player

    goto cseg_50F64;                        // jmp cseg_50F64

l_going_down:;
    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_marked_player;               // js @@marked_player

    bx = *(word *)&g_memByte[510444];       // mov bx, pitchWidth
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    {
        dword res = D7 >> 8;
        D7 = res;
    }                                       // shr D7, 8
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_marked_player;               // jg @@marked_player

    *(int16_t *)&D7 = -*(int16_t *)&D7;     // neg word ptr D7
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.sign != flags.overflow)
        goto l_marked_player;               // jl @@marked_player

    goto cseg_50F64;                        // jmp short cseg_50F64

l_not_going_left:;
    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign == flags.overflow)
        goto l_marked_player;               // jge @@marked_player

    bx = *(word *)&g_memByte[510444];       // mov bx, pitchWidth
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    {
        dword res = D7 >> 8;
        D7 = res;
    }                                       // shr D7, 8
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.sign != flags.overflow)
        goto l_marked_player;               // jl @@marked_player

    *(int16_t *)&D7 = -*(int16_t *)&D7;     // neg word ptr D7
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_marked_player;               // jg short @@marked_player

cseg_50F64:;
    ax = D1;                                // mov ax, word ptr D1
    bx = D1;                                // mov bx, word ptr D1
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    ax = D2;                                // mov ax, word ptr D2
    bx = D2;                                // mov bx, word ptr D2
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    eax = D2;                               // mov eax, D2
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, eax
    if (!flags.carry)
        goto l_marked_player;               // jnb short @@marked_player

    eax = D1;                               // mov eax, D1
    D4 = eax;                               // mov D4, eax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D3 = ax;                      // mov word ptr D3, ax

l_marked_player:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0Bh
    if (!flags.zero)
        goto cseg_50C82;                    // jnz cseg_50C82

    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_51045;                    // jns short cseg_51045

    {
        word src = *(word *)&g_memByte[510444];
        int16_t dstSigned = src;
        int16_t srcSigned = 64;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[510444] = src;
    }                                       // add pitchWidth, 64
    {
        word src = *(word *)&g_memByte[510444];
        int16_t dstSigned = src;
        int16_t srcSigned = 1280;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp pitchWidth, 1280
    if (flags.carry)
        goto cseg_50C79;                    // jb cseg_50C79

    {
        word src = *(word *)&g_memByte[510444];
        int16_t dstSigned = src;
        int16_t srcSigned = 192;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[510444] = src;
    }                                       // add pitchWidth, 192
    {
        word src = *(word *)&g_memByte[510444];
        int16_t dstSigned = src;
        int16_t srcSigned = 7680;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp pitchWidth, 7680
    if (flags.carry)
        goto cseg_50C79;                    // jb cseg_50C79

    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_51045;                    // jns short cseg_51045

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 2
    if (flags.carry)
        return;                             // jb short @@out

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 4
    if (!flags.carry && !flags.zero)
        return;                             // ja short @@out

    *(word *)&g_memByte[508538] = -1;       // mov editTacticsPitchStatus, -1
    return;                                 // retn

cseg_51045:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[508536] = ax;       // mov markedPlayerNumber, ax
}

// =============== S U B R O U T I N E =======================================

// Draws cursor on pitch sprite, in edit tactics menu.
//
void EditTacticsDrawCursor()
{
    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 2
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[508536];       // mov ax, markedPlayerNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_cursor_on_ball;              // jz short @@cursor_on_ball

    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerXYPositionFromQuadrant();      // call GetPlayerXYPositionFromQuadrant
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    goto l_draw_cursor;                     // jmp short @@draw_cursor

l_cursor_on_ball:;
    ax = *(word *)&g_memByte[378858];       // mov ax, ballRow
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[378860];       // mov ax, ballColumn
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    GetBallXYPositionFromQuadrant();        // call GetBallXYPositionFromQuadrant
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

l_draw_cursor:;
    A0 = 508212;                            // mov A0, offset tacticCursorFrames
    {
        int16_t src = *(word *)&g_memByte[485382];
        (src)++;
        *(word *)&g_memByte[485382] = src;
    }                                       // inc menuCursorFrame
    ax = *(word *)&g_memByte[485382];       // mov ax, menuCursorFrame
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 3
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    DrawSpriteCentered();                   // call DrawSpriteCentered
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - player number
//      D1 - ball location
// out:
//      D1 - x position on pitch sprite
//      D2 - y position on pitch sprite
//      (or ball position if quadrant is 15x15)
//
// Uses current_tactics.
//
void GetPlayerXYPositionFromQuadrant()
{
    push(D1);                               // push small [word ptr D1]
    GetPlayerQuadrant();                    // call GetPlayerQuadrant
    {
        int32_t val = stack[stackTop++];
        *(word *)&D0 = val;
    }                                       // pop small [word ptr D0]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 15
    if (!flags.zero)
        goto l_not_first_quadrant;          // jnz short @@not_first_quadrant

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 15
    if (!flags.zero)
        goto l_not_first_quadrant;          // jnz short @@not_first_quadrant

    GetBallQuadrant();                      // call GetBallQuadrant
    GetBallXYPositionFromQuadrant();        // call GetBallXYPositionFromQuadrant
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 3
    return;                                 // retn

l_not_first_quadrant:;
    {
        word res = *(word *)&D1 << 1;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 1
    A0 = 508400;                            // mov A0, offset xQuadrantToCoordinates
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    *(word *)&D1 = 129;                     // mov word ptr D1, 129
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 6;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 6
    {
        word res = *(word *)&D2 << 1;
        *(word *)&D2 = res;
    }                                       // shl word ptr D2, 1
    A0 = 508430;                            // mov A0, offset yQuadrantToCoordinates
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    *(word *)&D2 = 199;                     // mov word ptr D2, 199
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 3
}

// =============== S U B R O U T I N E =======================================
//
void DrawLittlePlayersAndBall()
{
    ax = *(word *)&g_memByte[508552];       // mov ax, dseg_179A08
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    cseg_515FD();                           // call cseg_515FD
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    A3 = 508510;                            // mov A3, offset editTacticsPlayerPositions
    eax = *(dword *)&g_memByte[378868];     // mov eax, editTacticsPlayerNumbers
    A4 = eax;                               // mov A4, eax
    *(word *)&D5 = 11;                      // mov word ptr D5, 11

l_draw_ball_and_players_loop:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_draw_ball;                   // js @@draw_ball

    if (!flags.zero)
        goto l_draw_player_position;        // jnz @@draw_player_position

    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 6
    if (flags.zero)
        goto cseg_51243;                    // jz short cseg_51243

    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 4
    if (!flags.zero)
        goto cseg_5124E;                    // jnz short cseg_5124E

cseg_51243:;
    ax = *(word *)&g_memByte[508536];       // mov ax, markedPlayerNumber
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax

cseg_5124E:;
    ax = *(word *)&g_memByte[378858];       // mov ax, ballRow
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[378860];       // mov ax, ballColumn
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    push(A0);                               // push A0
    GetBallXYPositionFromQuadrant();        // call GetBallXYPositionFromQuadrant
    pop(A0);                                // pop A0
    *(word *)&D0 = 123;                     // mov word ptr D0, 123
    push(D5);                               // push D5
    push(A0);                               // push A0
    push(A3);                               // push A3
    push(A4);                               // push A4
    DrawSpriteCentered();                   // call DrawSpriteCentered
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A0);                                // pop A0
    pop(D5);                                // pop D5
    goto l_next_player;                     // jmp @@next_player

l_draw_ball:;
    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 3
    if (!flags.zero)
        goto l_next_player;                 // jnz @@next_player

    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[508546];       // mov ax, editTacticsBallRow
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_next_player;                 // jz @@next_player

    ax = *(word *)&g_memByte[508546];       // mov ax, editTacticsBallRow
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[508548];       // mov ax, editTacticsBallColumn
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    push(A0);                               // push A0
    GetBallXYPositionFromQuadrant();        // call GetBallXYPositionFromQuadrant
    pop(A0);                                // pop A0
    *(word *)&D0 = 123;                     // mov word ptr D0, 123
    push(D5);                               // push D5
    push(A0);                               // push A0
    push(A3);                               // push A3
    push(A4);                               // push A4
    DrawSpriteCentered();                   // call DrawSpriteCentered
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A0);                                // pop A0
    pop(D5);                                // pop D5
    goto l_next_player;                     // jmp @@next_player

l_draw_player_position:;
    esi = A4;                               // mov esi, A4
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 5
    if (!flags.zero)
        goto cseg_51385;                    // jnz short cseg_51385

    ax = *(word *)&g_memByte[508536];       // mov ax, markedPlayerNumber
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (!flags.zero)
        goto l_next_player;                 // jnz @@next_player

cseg_51385:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 6
    if (!flags.zero)
        goto cseg_513B3;                    // jnz short cseg_513B3

    ax = *(word *)&g_memByte[508544];       // mov ax, editTacticsPlayerX
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_513B3:;
    push(A0);                               // push A0
    GetPlayerXYPositionFromQuadrant();      // call GetPlayerXYPositionFromQuadrant
    pop(A0);                                // pop A0
    al = D4;                                // mov al, byte ptr D4
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 38
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)((byte *)&D4 + 2) = dx;        // mov word ptr D4+2, dx
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx + 102, 1); // mov al, [esi+ebx+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 24;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 18h
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 124;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, SPR_EDIT_TACTICS_SMALL_PL_WHITE_GUY
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(A0);                               // push A0
    push(A3);                               // push A3
    push(A4);                               // push A4
    DrawSpriteCentered();                   // call DrawSpriteCentered
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A0);                                // pop A0
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 4
    if (!flags.zero)
        goto cseg_514AC;                    // jnz short cseg_514AC

    ax = *(word *)&g_memByte[508536];       // mov ax, markedPlayerNumber
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (!flags.zero)
        goto cseg_514AC;                    // jnz short cseg_514AC

    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 4;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 4

cseg_514AC:;
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx + 78, 1); // mov al, [esi+ebx+(PlayerFile.shirtNumber+4Ch)]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 161;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, SPR_NOT_PLAYING_WHOLE_SEASON
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 9;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 9
    push(D5);                               // push D5
    push(A0);                               // push A0
    push(A3);                               // push A3
    push(A4);                               // push A4
    DrawSpriteCentered();                   // call DrawSpriteCentered
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A0);                                // pop A0
    pop(D5);                                // pop D5

l_next_player:;
    (*(int16_t *)&D5)--;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto l_draw_ball_and_players_loop;  // jns @@draw_ball_and_players_loop

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 38
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx + 102, 1); // mov al, [esi+ebx+102]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 24;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 18h
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 127;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 127
    *(word *)&D1 = 71;                      // mov word ptr D1, 71
    *(word *)&D2 = 198;                     // mov word ptr D2, 198
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(A0);                               // push A0
    push(A3);                               // push A3
    push(A4);                               // push A4
    DrawSpriteCentered();                   // call DrawSpriteCentered
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A0);                                // pop A0
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_515FD()
{
_l_start:;
    A4 = 508510;                            // mov A4, offset editTacticsPlayerPositions
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    *(word *)&D6 = 10;                      // mov word ptr D6, 10

cseg_51619:;
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // add A4, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_516BB();                           // call cseg_516BB
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_516BB();                           // call cseg_516BB
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.carry)
        goto cseg_5169E;                    // jnb short cseg_5169E

    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + -2, 2);     // mov ax, [esi-2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    writeMemory(esi + -2, 2, ax);           // mov [esi-2], ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    *(word *)&D3 = 1;                       // mov word ptr D3, 1

cseg_5169E:;
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto cseg_51619;                    // jns cseg_51619

    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto _l_start;                      // jnz cseg_515FD
}

// =============== S U B R O U T I N E =======================================
//
void cseg_516BB()
{
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_516E5;                    // js short cseg_516E5

    if (!flags.zero)
        goto cseg_51702;                    // jnz short cseg_51702

    ax = *(word *)&g_memByte[378858];       // mov ax, ballRow
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[378860];       // mov ax, ballColumn
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    { GetBallXYPositionFromQuadrant(); return; } // jmp GetBallXYPositionFromQuadrant

cseg_516E5:;
    ax = *(word *)&g_memByte[508546];       // mov ax, editTacticsBallRow
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[508548];       // mov ax, editTacticsBallColumn
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    { GetBallXYPositionFromQuadrant(); return; } // jmp GetBallXYPositionFromQuadrant

cseg_51702:;
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 6
    if (!flags.zero)
        goto cseg_51724;                    // jnz short cseg_51724

    ax = *(word *)&g_memByte[508544];       // mov ax, editTacticsPlayerX
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_51724:;
    GetPlayerXYPositionFromQuadrant();      // jmp GetPlayerXYPositionFromQuadrant
}

// =============== S U B R O U T I N E =======================================
//
void cseg_51729()
{
    ax = *(word *)&g_memByte[508552];       // mov ax, dseg_179A08
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    ax = *(word *)&g_memByte[508536];       // mov ax, markedPlayerNumber
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    SortPlayerAreasByY();                   // call SortPlayerAreasByY
    A3 = 3443;                              // mov A3, offset playerAreas
    eax = *(dword *)&g_memByte[378868];     // mov eax, editTacticsPlayerNumbers
    A4 = eax;                               // mov A4, eax
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[508536];       // mov ax, markedPlayerNumber
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    esi = A4;                               // mov esi, A4
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 38
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)((byte *)&D4 + 2) = dx;        // mov word ptr D4+2, dx
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx + 102, 1); // mov al, [esi+ebx+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    {
        word res = *(word *)&D3 & 24;
        *(word *)&D3 = res;
    }                                       // and word ptr D3, 18h
    {
        word res = *(word *)&D3 >> 3;
        *(word *)&D3 = res;
    }                                       // shr word ptr D3, 3
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 124;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, SPR_EDIT_TACTICS_SMALL_PL_WHITE_GUY
    al = (byte)readMemory(esi + ebx + 78, 1); // mov al, [esi+ebx+(PlayerFile.shirtNumber+4Ch)]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 161;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 161
    *(word *)&D5 = 34;                      // mov word ptr D5, 34

l_draw_players_loop:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A3 = res;
    }                                       // add A3, 2
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = *(word *)&g_memByte[508536];       // mov ax, markedPlayerNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerXYPositionFromQuadrant();      // call GetPlayerXYPositionFromQuadrant
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(A0);                               // push A0
    push(A3);                               // push A3
    push(A4);                               // push A4
    DrawSpriteCentered();                   // call DrawSpriteCentered
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A0);                                // pop A0
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 4
    if (!flags.zero)
        goto l_draw_player_numbers_loop;    // jnz short @@draw_player_numbers_loop

    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (!flags.zero)
        goto l_draw_player_numbers_loop;    // jnz short @@draw_player_numbers_loop

    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 4;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 4

l_draw_player_numbers_loop:;
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 9;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 9
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(A0);                               // push A0
    push(A3);                               // push A3
    push(A4);                               // push A4
    DrawSpriteCentered();                   // call DrawSpriteCentered
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A0);                                // pop A0
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    (*(int16_t *)&D5)--;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto l_draw_players_loop;           // jns @@draw_players_loop
}

// =============== S U B R O U T I N E =======================================

// Using shake sort algorithm.
//
void SortPlayerAreasByY()
{
_l_start:;
    A4 = 3443;                              // mov A4, offset playerAreas
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    *(word *)&D6 = 33;                      // mov word ptr D6, 33

l_positions_loop:;
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // add A4, 2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[508536];       // mov ax, markedPlayerNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayerXYPositionFromQuadrant();      // call GetPlayerXYPositionFromQuadrant
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[508536];       // mov ax, markedPlayerNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayerXYPositionFromQuadrant();      // call GetPlayerXYPositionFromQuadrant
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.carry)
        goto l_next_position;               // jnb short @@next_position

    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + -2, 2);     // mov ax, [esi-2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    writeMemory(esi + -2, 2, ax);           // mov [esi-2], ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    *(word *)&D3 = 1;                       // mov word ptr D3, 1

l_next_position:;
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto l_positions_loop;              // jns @@positions_loop

    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto _l_start;                      // jnz SortPlayerAreasByY
}

// =============== S U B R O U T I N E =======================================
//
void DrawPlayerDirections()
{
    {
        word src = *(word *)&g_memByte[508538];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp editTacticsPitchStatus, 3
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[508550];       // mov ax, editTacticsLastBallLocation
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        return;                             // jz @@out

    *(word *)&D7 = 1;                       // mov word ptr D7, 1

l_players_loop:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[378862];       // mov ax, editTacticsBallLocation
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerXYPositionFromQuadrant();      // call GetPlayerXYPositionFromQuadrant
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[508550];       // mov ax, editTacticsLastBallLocation
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerXYPositionFromQuadrant();      // call GetPlayerXYPositionFromQuadrant
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    SWOS::CalculateDeltaXAndY();            // call CalculateDeltaXAndY
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    if (flags.sign)
        goto l_next_player;                 // js @@next_player

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 16;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 16
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    A0 = 508462;                            // mov A0, offset arrowSpritesOffsets
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    al = (byte)readMemory(esi + ebx + 1, 1); // mov al, [esi+ebx+1]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 173;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 173
    push(D7);                               // push D7
    push(A0);                               // push A0
    DrawSpriteCentered();                   // call DrawSpriteCentered
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7

l_next_player:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 11
    if (flags.carry)
        goto l_players_loop;                // jb @@players_loop
}

// =============== S U B R O U T I N E =======================================

// in:  A0 -> filename
//      A1 -> buffer
//
// out: D0 = 0 - success
//           1 - failure
//      zero flag set - all ok
//        -||-  clear - error
//
void WriteTacticsFile()
{
    D1 = 370;                               // mov D1, 370
    SWOS::WriteFile();                      // call WriteFile
    if (flags.zero)
        return;                             // jz short @@out

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_18()
{
}

// =============== S U B R O U T I N E =======================================
//
void ImportTacticsSelectTactics()
{
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[508220] = ax;       // mov importMenuSelectedTactics, ax
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ExitImportTactics()
{
    *(word *)&g_memByte[508220] = -1;       // mov importMenuSelectedTactics, -1
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void LoadTactics()
{
    *(word *)&g_memByte[508220] = -1;       // mov importMenuSelectedTactics, -1
    A0 = 17549;                             // mov A0, offset aLoadEditedTact
    SetZeroFlag();                          // call SetZeroFlag
    if (!flags.zero)
        goto l_out;                         // jnz @@out

    D0 = 777273667;                         // mov D0, '.TAC'
    A1 = 17549;                             // mov A1, offset aLoadEditedTact
    SWOS::GetFilenameAndExtension();        // call GetFilenameAndExtension
    if (!flags.zero)
        goto l_error_no_file;               // jnz short @@error_no_file

    {
        int32_t dstSigned = D1;
        int32_t srcSigned = 777273667;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, '.TAC'
    if (!flags.zero)
        goto l_not_a_tactics_file;          // jnz short @@not_a_tactics_file

    push(A0);                               // push A0
    SaveCurrentTactics();                   // call SaveCurrentTactics
    pop(A0);                                // pop A0
    A1 = 378872;                            // mov A1, offset editTacticsCurrentTactics
    push(A0);                               // push A0
    ReadTacticsFile();                      // call ReadTacticsFile
    pop(A0);                                // pop A0
    if (!flags.zero)
        goto l_error_no_file;               // jnz short @@error_no_file

    A1 = 316902;                            // mov A1, offset importTacticsFilename
    StringCopy();                           // call StringCopy
    *(word *)&g_memByte[508220] = 1000;     // mov importMenuSelectedTactics, 1000
    *(word *)&g_memByte[508556] = 1;        // mov tacticsChangedFlag, 1
    goto l_error_no_file;                   // jmp short @@error_no_file

l_not_a_tactics_file:;
    A0 = 19919;                             // mov A0, offset aNotATacticsFil
    SWOS::ShowErrorMenu();                  // call ShowErrorMenu

l_error_no_file:;
    A0 = 17549;                             // mov A0, offset aLoadEditedTact
    SetZeroFlag();                          // call SetZeroFlag

l_out:;
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================

// Reads tactics file into g_pitchDatBuffer.
// in:
//     A0 -> tactics file name
// out:
//     zero flag - clear - OK
//                 set - error
//
void ReadTacticsFile()
{
    A1 = 337268;                            // mov A1, offset g_pitchDatBuffer
    SWOS::LoadFile();                       // call LoadFile
    if (!flags.zero)
        goto l_err_out;                     // jnz short @@err_out

    A0 = 337268;                            // mov A0, offset g_pitchDatBuffer
    A1 = 378872;                            // mov A1, offset editTacticsCurrentTactics
    *(word *)&D1 = 369;                     // mov word ptr D1, 369

l_copy_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_copy_loop;                   // jns short @@copy_loop

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

l_err_out:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void InitLittlePlayerSprites()
{
    *(word *)&g_memByte[508558] = 0;        // mov dseg_179A0E, 0
    *(word *)&g_memByte[508556] = 0;        // mov tacticsChangedFlag, 0
    *(word *)&g_memByte[508536] = 0;        // mov markedPlayerNumber, 0
    *(word *)&g_memByte[378858] = 2;        // mov ballRow, 2
    *(word *)&g_memByte[378860] = 3;        // mov ballColumn, 3
    *(word *)&g_memByte[378862] = 17;       // mov editTacticsBallLocation, 17
    CopyCurrentTactics();                   // call CopyCurrentTactics
    SaveCurrentTactics();                   // call SaveCurrentTactics
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 60
    A1 = eax;                               // mov A1, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto cseg_52169;                    // jnz short cseg_52169

    A1 = 92766;                             // mov A1, offset currentMatchPlayers

cseg_52169:;
    eax = A1;                               // mov eax, A1
    *(dword *)&g_memByte[378868] = eax;     // mov editTacticsPlayerNumbers, eax
    eax = *(dword *)&g_memByte[378864];     // mov eax, chooseTacticsTeamPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ConvertPlayerDressColor();              // call ConvertPlayerDressColor
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[508500] = ax;       // mov littlePlayersConvertTable+16h, ax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ConvertPlayerDressColor();              // call ConvertPlayerDressColor
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 26, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.prShirtType], SHIRT_ORDINARY
    if (!flags.zero)
        goto l_stripes;                     // jnz short @@stripes

    ax = *(word *)&g_memByte[508500];       // mov ax, littlePlayersConvertTable+16h
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

l_stripes:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[508498] = ax;       // mov littlePlayersConvertTable+14h, ax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 29, 1);     // mov al, [esi+TeamFile.prShortsColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ConvertPlayerDressColor();              // call ConvertPlayerDressColor
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[508506] = ax;       // mov littlePlayersConvertTable+1Ch, ax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 30, 1);     // mov al, [esi+TeamFile.prSocksColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ConvertPlayerDressColor();              // call ConvertPlayerDressColor
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[508508] = ax;       // mov littlePlayersConvertTable+1Eh, ax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 26, 1);     // mov al, [esi+TeamFile.prShirtType]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 3;                                 // mov bx, 3
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 130;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 130
    *(word *)&D1 = 124;                     // mov word ptr D1, 124
    push(D0);                               // push D0
    CopyWholeSprite();                      // call CopyWholeSprite
    pop(D0);                                // pop D0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    *(word *)&D1 = 125;                     // mov word ptr D1, 125
    push(D0);                               // push D0
    CopyWholeSprite();                      // call CopyWholeSprite
    pop(D0);                                // pop D0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    *(word *)&D1 = 126;                     // mov word ptr D1, 126
    push(D0);                               // push D0
    CopyWholeSprite();                      // call CopyWholeSprite
    pop(D0);                                // pop D0
    *(word *)&D0 = 124;                     // mov word ptr D0, 124
    A0 = 508478;                            // mov A0, offset littlePlayersConvertTable
    ConvertSpriteColors();                  // call ConvertSpriteColors
    *(word *)&D0 = 125;                     // mov word ptr D0, 125
    A0 = 508478;                            // mov A0, offset littlePlayersConvertTable
    ConvertSpriteColors();                  // call ConvertSpriteColors
    *(word *)&D0 = 126;                     // mov word ptr D0, 126
    A0 = 508478;                            // mov A0, offset littlePlayersConvertTable
    ConvertSpriteColors();                  // call ConvertSpriteColors
    *(word *)&D0 = 142;                     // mov word ptr D0, 142
    *(word *)&D1 = 127;                     // mov word ptr D1, 127
    push(D0);                               // push D0
    CopyWholeSprite();                      // call CopyWholeSprite
    pop(D0);                                // pop D0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    *(word *)&D1 = 128;                     // mov word ptr D1, 128
    push(D0);                               // push D0
    CopyWholeSprite();                      // call CopyWholeSprite
    pop(D0);                                // pop D0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    *(word *)&D1 = 129;                     // mov word ptr D1, 129
    push(D0);                               // push D0
    CopyWholeSprite();                      // call CopyWholeSprite
    pop(D0);                                // pop D0
    *(word *)&D0 = 127;                     // mov word ptr D0, 127
    A0 = 508478;                            // mov A0, offset littlePlayersConvertTable
    ConvertSpriteColors();                  // call ConvertSpriteColors
    *(word *)&D0 = 128;                     // mov word ptr D0, 128
    A0 = 508478;                            // mov A0, offset littlePlayersConvertTable
    ConvertSpriteColors();                  // call ConvertSpriteColors
    *(word *)&D0 = 129;                     // mov word ptr D0, 129
    A0 = 508478;                            // mov A0, offset littlePlayersConvertTable
    ConvertSpriteColors();                  // call ConvertSpriteColors
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0 - color
// out:
//     D0 - converted color
//
void ConvertPlayerDressColor()
{
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A1 = 252402;                            // mov A1, offset shirtColorTable
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0FFh
}

// =============== S U B R O U T I N E =======================================

// Copies curently selected tactics into
// current_tactic array.
//
void CopyCurrentTactics()
{
    A0 = 372768;                            // mov A0, offset g_tacticsTable
    ax = *(word *)&g_memByte[508540];       // mov ax, chosenTactics
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    A1 = 378872;                            // mov A1, offset editTacticsCurrentTactics
    *(word *)&D0 = 369;                     // mov word ptr D0, 369

l_copy_tactics_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_tactics_loop;           // jns short @@copy_tactics_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      D1 - player ordinal
//      A0 -> team (file)
// out:
//      D0 - player index in tactics
//      D1 - player index in team (file)
//      A0 -> player (file) + header
//
// Returns a player at a given position when the ball is out of play.
//
void GetPlayerGameBreakPosition()
{
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 11
    if (!flags.carry)
        goto l_reserves;                    // jnb @@reserves

    push(A0);                               // push A0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 372768;                            // mov A0, offset g_tacticsTable
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 369, 1);    // mov al, [esi+Tactics.ballOutOfPlayTactics]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 331628;                            // mov A0, offset positionsTable
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D1 = res;
    }                                       // sub byte ptr D1, 1
    pop(A0);                                // pop A0

l_reserves:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push small [word ptr D1]
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    {
        int32_t val = stack[stackTop++];
        *(word *)&D0 = val;
    }                                       // pop small [word ptr D0]
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team
//
void SetBenchPlayersNumbers()
{
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 11;                      // mov word ptr D1, 11

l_players_loop:;
    push(D0);                               // push D0
    push(D1);                               // push D1
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 78, 1, al);           // mov [esi+(PlayerFile.shirtNumber+4Ch)], al
    {
        byte src = (byte)readMemory(esi + 78, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 78, 1, src);
    }                                       // add [esi+(PlayerFile.shirtNumber+4Ch)], 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 16
    if (!flags.zero)
        goto l_players_loop;                // jnz short @@players_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 -
//      D1 -
//      A0 -> team
//
void cseg_52588()
{
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_a_training;              // jz short @@not_a_training

    {
        word res = *(word *)&D1 << 1;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 1

l_not_a_training:;
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_training_game;               // jnz @@training_game

    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    eax = A6;                               // mov eax, A6
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(A6);                               // push A6
    cseg_3A110();                           // call cseg_3A110
    pop(A6);                                // pop A6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 2
    if (flags.carry || flags.zero)
        goto cseg_526CB;                    // jbe cseg_526CB

    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_52644:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (!flags.zero)
        goto cseg_52696;                    // jnz short cseg_52696

    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+66h], 2
    if (!flags.zero)
        goto cseg_526A2;                    // jnz short cseg_526A2

cseg_52696:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1
    if (!flags.sign)
        goto cseg_52644;                    // jns short cseg_52644

    goto cseg_526CB;                        // jmp short cseg_526CB

cseg_526A2:;
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(A6);                               // push A6
    cseg_52EA6();                           // call cseg_52EA6
    pop(A6);                                // pop A6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4

cseg_526CB:;
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(A6);                               // push A6
    cseg_3A2CE();                           // call cseg_3A2CE
    pop(A6);                                // pop A6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 10h
    if (flags.carry || flags.zero)
        goto l_training_game;               // jbe @@training_game

    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_5272C:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto cseg_5277E;                    // jz short cseg_5277E

    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+66h], 2
    if (!flags.zero)
        goto cseg_5278A;                    // jnz short cseg_5278A

cseg_5277E:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1
    if (!flags.sign)
        goto cseg_5272C;                    // jns short cseg_5272C

    goto l_training_game;                   // jmp short @@training_game

cseg_5278A:;
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(A6);                               // push A6
    cseg_52EA6();                           // call cseg_52EA6
    pop(A6);                                // pop A6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4

l_training_game:;
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 30
    if (!flags.carry)
        goto cseg_5286A;                    // jnb cseg_5286A

    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(A6);                               // push A6
    cseg_3A110();                           // call cseg_3A110
    pop(A6);                                // pop A6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 2
    if (!flags.carry)
        goto cseg_5286A;                    // jnb short cseg_5286A

    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_52833;                    // jz short cseg_52833

    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 0Bh
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 2
    if (flags.carry || flags.zero)
        goto cseg_5286A;                    // jbe short cseg_5286A

cseg_52833:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(A6);                               // push A6
    cseg_52956();                           // call cseg_52956
    pop(A6);                                // pop A6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    goto l_training_game;                   // jmp @@training_game

cseg_5286A:;
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 1Eh
    if (!flags.carry)
        return;                             // jnb @@out

    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(A6);                               // push A6
    cseg_3A2CE();                           // call cseg_3A2CE
    pop(A6);                                // pop A6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    *(word *)&D0 = 11;                      // mov word ptr D0, 0Bh
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_528D4;                    // jz short cseg_528D4

    *(word *)&D0 = 22;                      // mov word ptr D0, 16h

cseg_528D4:;
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 2
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (flags.sign == flags.overflow)
        return;                             // jge short @@out

    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 7;                                 // mov bx, 7
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(A6);                               // push A6
    cseg_52956();                           // call cseg_52956
    pop(A6);                                // pop A6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    goto cseg_5286A;                        // jmp cseg_5286A
}

// =============== S U B R O U T I N E =======================================
//
void cseg_52956()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    A0 = 92766;                             // mov A0, offset currentMatchPlayers
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

cseg_52975:;
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

l_players_loop:;
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_529AB;                    // jnz short cseg_529AB

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    goto cseg_52975;                        // jmp short cseg_52975

cseg_529AB:;
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_players_loop;                // jns short @@players_loop

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayer();                            // call GetPlayer
    cseg_63919();                           // call cseg_63919
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 102, 1);
        src |= 4;
        writeMemory(esi + 102, 1, src);
    }                                       // or byte ptr [esi+66h], 4
    writeMemory(esi + 78, 1, 16);           // mov byte ptr [esi+4Eh], 10h
    {
        word res = *(word *)&D7 << 5;
        flags.carry = ((word)*(word *)&D7 >> 11) & 1;
        *(word *)&D7 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D7, 5
    al = D7;                                // mov al, byte ptr D7
    writeMemory(esi + 102, 1, al);          // mov [esi+66h], al
    push(D1);                               // push D1
    cseg_52A3E();                           // call cseg_52A3E
    pop(D1);                                // pop D1
    A0 = 92766;                             // mov A0, offset currentMatchPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[94090] = src;
    }                                       // add careerNumPlayers, 1
    cseg_5E345();                           // call cseg_5E345
}

// =============== S U B R O U T I N E =======================================
//
void cseg_52A3E()
{
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    cseg_52B6A();                           // call cseg_52B6A
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    al = D0;                                // mov al, byte ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 76, 1, al);           // mov [esi+4Ch], al
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        byte res = *(byte *)&D0 & 231;
        *(byte *)&D0 = res;
    }                                       // and byte ptr D0, 0E7h
    al = D3;                                // mov al, byte ptr D3
    *(byte *)&D0 |= al;                     // or byte ptr D0, al
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 102, 1, al);          // mov [esi+66h], al
    eax = A1;                               // mov eax, A1
    A3 = eax;                               // mov A3, eax
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4Fh
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 109, 1, 0);           // mov byte ptr [esi+6Dh], 0
    writeMemory(esi + 110, 1, 0);           // mov byte ptr [esi+6Eh], 0
    writeMemory(esi + 111, 1, 0);           // mov byte ptr [esi+6Fh], 0
    writeMemory(esi + 112, 1, 0);           // mov byte ptr [esi+70h], 0
    writeMemory(esi + 103, 1, 0);           // mov byte ptr [esi+67h], 0
    writeMemory(esi + 104, 4, 0);           // mov dword ptr [esi+68h], 0
    writeMemory(esi + 108, 1, 0);           // mov byte ptr [esi+6Ch], 0
    {
        byte src = (byte)readMemory(esi + 102, 1);
        src |= 2;
        writeMemory(esi + 102, 1, src);
        flags.carry = false;
        flags.sign = (src & 0x80) != 0;
        flags.zero = src == 0;
    }                                       // or byte ptr [esi+66h], 2
    writeMemory(esi + 113, 1, 0);           // mov byte ptr [esi+71h], 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_52B6A()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D6 = ax;                      // mov word ptr D6, ax

cseg_52B82:;
    A2 = 511056;                            // mov A2, offset dseg_17A3D0
    cseg_52D40();                           // call cseg_52D40
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0Fh
    ax = D0;                                // mov ax, word ptr D0
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 76, 1);     // mov al, [esi+4Ch]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    {
        byte res = *(byte *)&D3 & 24;
        *(byte *)&D3 = res;
    }                                       // and byte ptr D3, 18h
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4Fh
    A0 = eax;                               // mov A0, eax

cseg_52BFB:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_52D2C;                    // jz cseg_52D2C

    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 32;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 20h
    if (flags.zero)
        goto cseg_52C44;                    // jz short cseg_52C44

    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A2)++;                    // inc A2
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 511079;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset dseg_17A3E7
    if (flags.zero)
        goto cseg_52B82;                    // jz cseg_52B82

    goto cseg_52BFB;                        // jmp short cseg_52BFB

cseg_52C44:;
    cseg_52D40();                           // call cseg_52D40
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0Fh
    ax = D0;                                // mov ax, word ptr D0
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 76, 1);     // mov al, [esi+4Ch]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    {
        byte res = *(byte *)&D3 & 24;
        *(byte *)&D3 = res;
    }                                       // and byte ptr D3, 18h
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4Fh
    A0 = eax;                               // mov A0, eax
    A1 = eax;                               // mov A1, eax

cseg_52CBD:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_52CBD;                    // jnz short cseg_52CBD

cseg_52CCF:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, eax
    if (flags.zero)
        goto cseg_52B82;                    // jz cseg_52B82

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        A0 = res;
    }                                       // sub A0, 1
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 32;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 20h
    if (!flags.zero)
        goto cseg_52CCF;                    // jnz short cseg_52CCF

cseg_52CF2:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_52D2C;                    // jz short cseg_52D2C

    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A2)++;                    // inc A2
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 511079;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset dseg_17A3E7
    if (flags.zero)
        goto cseg_52B82;                    // jz cseg_52B82

    goto cseg_52CF2;                        // jmp short cseg_52CF2

cseg_52D2C:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    A2 = 511056;                            // mov A2, offset dseg_17A3D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_52D40()
{
    *(word *)&D1 = 100;                     // mov word ptr D1, 64h

cseg_52D49:;
    ax = *(word *)&g_memByte[36606];        // mov ax, careerFileBuffer
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_52DE2;                    // jz cseg_52DE2

    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[36606];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul careerFileBuffer
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        dword res = D0 >> 8;
        D0 = res;
    }                                       // shr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    bx = 684;                               // mov bx, 2ACh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A0 = 36608;                             // mov A0, offset tmdFileBuffer
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (flags.zero)
        goto cseg_52DD3;                    // jz short cseg_52DD3

    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, al
    if (flags.zero)
        return;                             // jz cseg_52E71

cseg_52DD3:;
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_52E71

cseg_52DE2:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[131757];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        dword res = D0 >> 8;
        D0 = res;
    }                                       // shr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    bx = 684;                               // mov bx, 2ACh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (flags.zero)
        goto cseg_52E59;                    // jz short cseg_52E59

    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, al
    if (flags.zero)
        return;                             // jz short cseg_52E71

cseg_52E59:;
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_52E71

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    goto cseg_52D49;                        // jmp cseg_52D49
}

// =============== S U B R O U T I N E =======================================

// out:
//      is_national_team - 0 no, 1 yes
//
// Checks if selected team is national.
//
void CheckIsTeamNational()
{
    *(word *)&g_memByte[129470] = 0;        // mov isNationalTeam, 0
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    ebx = *(dword *)&g_memByte[131738];     // mov ebx, selTeamsPtr
    {
        byte src = (byte)readMemory(ebx, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [ebx], CN_EUROPE
    if (flags.carry)
        return;                             // jb short @@out

    ebx = *(dword *)&g_memByte[131738];     // mov ebx, selTeamsPtr
    {
        byte src = (byte)readMemory(ebx, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 85;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [ebx], CN_OCEANIA
    if (!flags.carry && !flags.zero)
        return;                             // ja short @@out

    *(word *)&g_memByte[129470] = 1;        // mov isNationalTeam, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_52EA6()
{
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    GetPlayer();                            // call GetPlayer
    pop(D1);                                // pop D1
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 109, 1);    // mov al, [esi+6Dh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[94094];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[94094] = src;
    }                                       // add dseg_D761C, ax
    al = (byte)readMemory(esi + 110, 1);    // mov al, [esi+6Eh]
    {
        word src = *(word *)&g_memByte[94094];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[94094] = src;
    }                                       // add dseg_D761C, ax
    al = (byte)readMemory(esi + 111, 1);    // mov al, [esi+6Fh]
    {
        word src = *(word *)&g_memByte[94094];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[94094] = src;
    }                                       // add dseg_D761C, ax
    al = (byte)readMemory(esi + 112, 1);    // mov al, [esi+70h]
    {
        word src = *(word *)&g_memByte[94094];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[94094] = src;
    }                                       // add dseg_D761C, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    cseg_5E48C();                           // call cseg_5E48C
    pop(D1);                                // pop D1
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_24132();                           // call cseg_24132
    A6 = 92766;                             // mov A6, offset currentMatchPlayers
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0Bh
    if (flags.carry)
        goto cseg_52FBA;                    // jb short cseg_52FBA

    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 10h
    if (flags.carry)
        goto cseg_5309B;                    // jb cseg_5309B

    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    goto cseg_531E0;                        // jmp cseg_531E0

cseg_52FBA:;
    cseg_532BF();                           // call cseg_532BF
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    al = D0;                                // mov al, byte ptr D0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+4Eh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+4Eh]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al
    al = D0;                                // mov al, byte ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al

cseg_5309B:;
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 10h
    if (!flags.zero)
        goto cseg_530EA;                    // jnz short cseg_530EA

    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    cseg_52A3E();                           // call cseg_52A3E
    pop(D1);                                // pop D1
    cseg_5E345();                           // call cseg_5E345
    return;                                 // retn

cseg_530EA:;
    cseg_532D3();                           // call cseg_532D3
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    al = D0;                                // mov al, byte ptr D0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+4Eh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+4Eh]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al
    al = D0;                                // mov al, byte ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al

cseg_531E0:;
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    eax = A6;                               // mov eax, A6
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 2
    if (flags.sign)
        goto cseg_53236;                    // js short cseg_53236

cseg_53216:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_53216;                    // jns short cseg_53216

cseg_53236:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 255);               // mov byte ptr [esi], 0FFh
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 4Fh
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 42);                // mov byte ptr [esi], 2Ah
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 69);                // mov byte ptr [esi], 45h
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 82);                // mov byte ptr [esi], 52h
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 82);                // mov byte ptr [esi], 52h
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 42);                // mov byte ptr [esi], 2Ah
    (*(int32_t *)&A0)++;
    flags.sign = (*(int32_t *)&A0 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A0 == 0;      // inc A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 32);                // mov byte ptr [esi], 20h
    cseg_639F9();                           // call cseg_639F9
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[94090] = src;
    }                                       // sub careerNumPlayers, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_532BF()
{
    *(word *)&D5 = 11;                      // mov word ptr D5, 0Bh
    *(word *)&D6 = 16;                      // mov word ptr D6, 10h
    cseg_53312();                           // jmp short cseg_53312
}

// =============== S U B R O U T I N E =======================================
//
void cseg_532D3()
{
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D5 = 16;                      // mov word ptr D5, 10h
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    cseg_53312();                           // call cseg_53312
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_53312()
{
    push(D1);                               // push small [word ptr D1]
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    A5 = 511079;                            // mov A5, offset dseg_17A3E7
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A5 = eax;                               // mov A5, eax

cseg_53368:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_534A6;                    // js cseg_534A6

    *(byte *)&D3 = 255;                     // mov byte ptr D3, 0FFh
    *(word *)&D2 = 65535;                   // mov word ptr D2, 0FFFFh
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_5339F:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    pop(D1);                                // pop D1
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    al = D0;                                // mov al, byte ptr D0
    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D4, al
    if (!flags.zero)
        goto cseg_53474;                    // jnz cseg_53474

    al = D3;                                // mov al, byte ptr D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_5343F;                    // js short cseg_5343F

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_5340D;                    // jz short cseg_5340D

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (!flags.zero)
        goto cseg_53427;                    // jnz short cseg_53427

cseg_5340D:;
    esi = A3;                               // mov esi, A3
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_5343F;                    // jz short cseg_5343F

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_5343F;                    // jz short cseg_5343F

    goto cseg_53474;                        // jmp short cseg_53474

cseg_53427:;
    esi = A3;                               // mov esi, A3
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_53450;                    // jz short cseg_53450

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_53450;                    // jz short cseg_53450

cseg_5343F:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D3, al
    if (flags.sign == flags.overflow)
        goto cseg_53474;                    // jge short cseg_53474

cseg_53450:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    eax = A0;                               // mov eax, A0
    A3 = eax;                               // mov A3, eax

cseg_53474:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto cseg_5339F;                    // jnz cseg_5339F

    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_53368;                    // js cseg_53368

    {
        int32_t val = stack[stackTop++];
        *(word *)&D1 = val;
    }                                       // pop small [word ptr D1]
    return;                                 // retn

cseg_534A6:;
    debugBreak();                           // int 3

cseg_534A7:;
    goto cseg_534A7;                        // jmp short cseg_534A7
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - selected team number
// out:
//      D0 - selected team league
//
void GetTeamLeague()
{
    push(D1);                               // push D1
    push(D2);                               // push D2
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)&g_memByte[323894] = 0;        // mov teamsLoaded, 0
    *(word *)&g_memByte[487679] = 1;        // mov skipLeagueNumbers, 1
    LoadTeamFile();                         // call LoadTeamFile
    *(word *)&g_memByte[487679] = 0;        // mov skipLeagueNumbers, 0
    *(word *)&g_memByte[323894] = 0;        // mov teamsLoaded, 0
    A0 = 252468;                            // mov A0, (offset teamFileBuffer+2)

l_search_team_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto l_team_found;                  // jz short @@team_found

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 684
    A0 = eax;                               // mov A0, eax
    goto l_search_team_loop;                // jmp short @@search_team_loop

l_team_found:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 25, 1);     // mov al, [esi+TeamFile.league]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
}

// =============== S U B R O U T I N E =======================================

// in:
//     D6 -
//     D7 -
//
void cseg_5353F()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[92022];        // mov ax, dseg_D6E04
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1
    A6 = 111782;                            // mov A6, offset careerForeignMarketPlayers
    ax = *(word *)&g_memByte[92020];        // mov ax, numForeignMarketPlayers2
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    ax = *(word *)&g_memByte[92022];        // mov ax, dseg_D6E04
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, ax
    ax = D5;                                // mov ax, word ptr D5
    bx = 42;                                // mov bx, 42
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    *(word *)((byte *)&D5 + 2) = dx;        // mov word ptr D5+2, dx
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, eax

cseg_535B2:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 3, 1);      // mov al, [esi+3]
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D6, al
    if (!flags.carry && !flags.zero)
        goto l_next_career_player;          // ja @@next_career_player

    al = (byte)readMemory(esi + 3, 1);      // mov al, [esi+3]
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, al
    if (flags.carry)
        goto l_next_career_player;          // jb @@next_career_player

    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A5 = eax;                               // mov A5, eax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D3 = res;
    }                                       // sub word ptr D3, 1

l_teams_loop:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D5;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D5, al
    if (!flags.zero)
        goto l_next_team;                   // jnz @@next_team

    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D4, al
    if (!flags.zero)
        goto l_next_team;                   // jnz @@next_team

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, size PlayerFile
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.players
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A4 = eax;                               // mov A4, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4
    A3 = eax;                               // mov A3, eax
    *(word *)&D0 = 18;                      // mov word ptr D0, 18

cseg_5369F:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 2
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A4 = res;
    }                                       // add A4, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_5369F;                    // jns short cseg_5369F

    goto l_next_career_player;              // jmp short @@next_career_player

l_next_team:;
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 684
    A5 = eax;                               // mov A5, eax
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto l_teams_loop;                  // jns @@teams_loop

l_next_career_player:;
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 42;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 42
    A6 = eax;                               // mov A6, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_535B2;                    // jns cseg_535B2
}

// =============== S U B R O U T I N E =======================================
//
void TransferMarketInit()
{
    *(word *)&g_memByte[511838] = 0;        // mov dseg_17A6DE, 0
    *(word *)&g_memByte[511840] = -1;       // mov playerSelected, -1
    CheckNumPlayersOnTransferMarket();      // call CheckNumPlayersOnTransferMarket
    CheckForTransferOffers();               // call CheckForTransferOffers
    if (!flags.zero)
        { TransferMarketFinish(); return; } // jnz short TransferMarketFinish

    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

    TransferMarketFinish();
}

// =============== S U B R O U T I N E =======================================
//
void TransferMarketFinish()
{
    TransferMenuSetBankState();             // call TransferMenuSetBankState
    CheckNumPlayersOnTransferMarket();      // call CheckNumPlayersOnTransferMarket
    CheckIfPlayerSelected();                // call CheckIfPlayerSelected
    EnableDisableOffers();                  // call EnableDisableOffers
}

// =============== S U B R O U T I N E =======================================
//
void TransferMenuSetBankState()
{
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    GetBankBalance();                       // jmp GetBankBalance
}

// =============== S U B R O U T I N E =======================================
//
void BuyPlayerMenu()
{
    cseg_53EF9();                           // call cseg_53EF9
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 2
    if (!flags.carry)
        goto cseg_5378F;                    // jnb short cseg_5378F

    *(word *)&g_memByte[337240] = 1;        // mov currentMessage, CLUB_UNWILLING_TO_PURCHASE_PLAYERS
    { ShowChairmanMessage(); return; }      // jmp ShowChairmanMessage

cseg_5378F:;
    *(word *)&g_memByte[511838] = 0;        // mov dseg_17A6DE, 0
    A6 = 512438;                            // mov A6, offset buyPlayerMenu
    SWOS::ShowMenu();                       // call ShowMenu
    {
        word src = *(word *)&g_memByte[511838];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_17A6DE, 1
    if (flags.zero)
        goto cseg_537B2;                    // jz short cseg_537B2

    return;                                 // retn

cseg_537B2:;
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void PutPlayerOnMarketMenu()
{
    *(word *)&D3 = 65535;                   // mov word ptr D3, 0FFFFh
    *(word *)&D4 = 65535;                   // mov word ptr D4, 0FFFFh

cseg_537C9:;
    D7 = 0;                                 // mov D7, 0
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_537E7:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+66h], 2
    if (flags.zero)
        goto cseg_53824;                    // jz short cseg_53824

    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D7 |= eax;
    flags.carry = false;                    // or D7, eax

cseg_53824:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_537E7;                    // jns short cseg_537E7

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = D7;                               // mov eax, D7
    D0 = eax;                               // mov D0, eax
    D1 = 0;                                 // mov D1, 0
    A2 = 92302;                             // mov A2, offset playersOnTransferMarket
    ax = *(word *)&g_memByte[92300];        // mov ax, numPlayersOnTransferMarket
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_538A8;                    // jz short cseg_538A8

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_53875:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    cx = D5;                                // mov cx, word ptr D5
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D1 |= eax;
    flags.carry = false;                    // or D1, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_53875;                    // jns short cseg_53875

cseg_538A8:;
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    A1 = 20467;                             // mov A1, offset aPutPlayerOnTra
    ShowSquad();                            // call ShowSquad
    if (flags.sign)
        goto cseg_538FE;                    // js short cseg_538FE

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_53FAE();                           // call cseg_53FAE
    if (!flags.zero)
        goto cseg_538DF;                    // jnz short cseg_538DF

    cseg_5400D();                           // call cseg_5400D
    goto cseg_537C9;                        // jmp cseg_537C9

cseg_538DF:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_540A0();                           // call cseg_540A0
    {
        word src = *(word *)&g_memByte[92300];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numPlayersOnTransferMarket, 5
    if (!flags.zero)
        goto cseg_537C9;                    // jnz cseg_537C9

cseg_538FE:;
    CheckNumPlayersOnTransferMarket();      // call CheckNumPlayersOnTransferMarket
    {
        word src = *(word *)&g_memByte[92300];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numPlayersOnTransferMarket, 5
    if (!flags.zero)
        return;                             // jnz short cseg_5391B

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void ViewOffersMenu()
{
    A6 = 512700;                            // mov A6, offset offersMenu
    SWOS::ShowMenu();                       // call ShowMenu
    ax = *(word *)&g_memByte[511838];       // mov ax, dseg_17A6DE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5393B;                    // jz short cseg_5393B

    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

cseg_5393B:;
    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void GiveFreeTransfer()
{
    ax = *(word *)&g_memByte[511840];       // mov ax, playerSelected
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    A0 = 92302;                             // mov A0, offset playersOnTransferMarket
    {
        word res = *(word *)&D1 << 1;
        flags.carry = ((word)*(word *)&D1 >> 15) & 1;
        *(word *)&D1 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D1, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    RemovePlayerFromTeam();                 // call RemovePlayerFromTeam
    *(word *)&g_memByte[511840] = -1;       // mov playerSelected, -1
    CheckNumPlayersOnTransferMarket();      // call CheckNumPlayersOnTransferMarket
    CheckIfPlayerSelected();                // call CheckIfPlayerSelected
    EnableDisableOffers();                  // call EnableDisableOffers
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void jmp_SetExitMenuFlag_8()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void TakeOffMarketMenu()
{
    ax = *(word *)&g_memByte[511840];       // mov ax, playerSelected
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    A0 = 92302;                             // mov A0, offset playersOnTransferMarket
    {
        word res = *(word *)&D1 << 1;
        flags.carry = ((word)*(word *)&D1 >> 15) & 1;
        *(word *)&D1 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D1, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_5400D();                           // call cseg_5400D
    *(word *)&g_memByte[511840] = -1;       // mov playerSelected, -1
    CheckNumPlayersOnTransferMarket();      // call CheckNumPlayersOnTransferMarket
    CheckIfPlayerSelected();                // call CheckIfPlayerSelected
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void TransferMarketCommon()
{
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    ax = *(word *)&g_memByte[511840];       // mov ax, playerSelected
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.zero)
        goto cseg_53A7A;                    // jnz short cseg_53A7A

    *(word *)&D7 = 65535;                   // mov word ptr D7, 0FFFFh

cseg_53A7A:;
    ax = *(word *)&g_memByte[511840];       // mov ax, playerSelected
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&g_memByte[511840] = ax;       // mov playerSelected, ax
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_53AC5;                    // js short cseg_53AC5

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    push(A5);                               // push A5
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
    pop(A5);                                // pop A5

cseg_53AC5:;
    CallDrawMenuItem();                     // call CallDrawMenuItem
    CheckIfPlayerSelected();                // call CheckIfPlayerSelected
    A0 = 3513;                              // mov A0, offset cseg_53ADF
    nullsub_17();                           // call nullsub_17
}

// =============== S U B R O U T I N E =======================================
//
void CheckNumPlayersOnTransferMarket()
{
    {
        word src = *(word *)&g_memByte[92300];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numPlayersOnTransferMarket, 5
    if (!flags.zero)
        goto l_not_filled_max_players;      // jnz short @@not_filled_max_players

    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    goto l_check_if_any_players;            // jmp short @@check_if_any_players

l_not_filled_max_players:;
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0

l_check_if_any_players:;
    ax = *(word *)&g_memByte[92300];        // mov ax, numPlayersOnTransferMarket
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
}

// =============== S U B R O U T I N E =======================================
//
void CheckIfPlayerSelected()
{
    ax = *(word *)&g_memByte[511840];       // mov ax, playerSelected
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_no_player_selected;          // js short @@no_player_selected

    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    return;                                 // retn

l_no_player_selected:;
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
}

// =============== S U B R O U T I N E =======================================
//
void EnableDisableOffers()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    CheckForTransferOffers();               // call CheckForTransferOffers
    if (!flags.zero)
        goto l_no_offers;                   // jnz short @@no_offers

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D0 |= 8192;                   // or word ptr D0, 2000h
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax

l_no_offers:;
    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    esi = A1;                               // mov esi, A1
    writeMemory(esi + 38, 4, 20750);        // mov [esi+MenuEntry.fg.string], offset aNoOffers
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
}

// =============== S U B R O U T I N E =======================================
//
void TransferMarketAfterDrawCommon()
{
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, ax
    ax = *(word *)&g_memByte[92300];        // mov ax, numPlayersOnTransferMarket
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (flags.carry)
        goto cseg_53CFE;                    // jb short cseg_53CFE

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1
    A6 = 0;                                 // mov A6, 0
    goto cseg_53D7D;                        // jmp cseg_53D7D

cseg_53CFE:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 0);             // mov word ptr [esi+6], 0
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    ax = *(word *)&g_memByte[511840];       // mov ax, playerSelected
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (!flags.zero)
        goto cseg_53D2B;                    // jnz short cseg_53D2B

    *(word *)&D5 = 13;                      // mov word ptr D5, 0Dh

cseg_53D2B:;
    A0 = 92302;                             // mov A0, offset playersOnTransferMarket
    {
        word res = *(word *)&D6 << 1;
        *(word *)&D6 = res;
    }                                       // shl word ptr D6, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D6 >> 1;
        flags.carry = ((word)*(word *)&D6 >> 15) & 1;
        *(word *)&D6 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D6, 1
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1

cseg_53D7D:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    push(D0);                               // push D0
    D0 = 14;                                // mov D0, 0Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    A4 = 0;                                 // mov A4, 0
    cseg_54116();                           // call cseg_54116
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 14;                                // mov D0, 0Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 12;                      // mov word ptr D0, 0Ch
    SWOS::DrawMultipleItems();              // jmp DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================

// out:
//      got offers: D0 = 0, zf = 1
//      no offers: D0 = 1, zf = 0
//
void CheckForTransferOffers()
{
    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_offers;                   // jz short @@no_offers

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    A0 = 91948;                             // mov A0, offset dseg_D6DBA

cseg_53E23:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 13, 1);     // mov al, [esi+13]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_got_offers;                  // jz short @@got_offers

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 14;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 14
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_53E23;                    // jns short cseg_53E23

l_no_offers:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    return;                                 // retn

l_got_offers:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_53E64()
{
    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 2
    if (flags.sign)
        goto cseg_53EF0;                    // js short cseg_53EF0

    bx = 14;                                // mov bx, 0Eh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A0 = 91948;                             // mov A0, offset dseg_D6DBA
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax

cseg_53EBE:;
    *(word *)&D0 = 13;                      // mov word ptr D0, 0Dh

cseg_53EC7:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 14, 1);     // mov al, [esi+0Eh]
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_53EC7;                    // jns short cseg_53EC7

    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_53EBE;                    // jns short cseg_53EBE

cseg_53EF0:;
    {
        word src = *(word *)&g_memByte[91786];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91786] = src;
    }                                       // sub numOffers, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_53EF9()
{
    ax = *(word *)&g_memByte[92026];        // mov ax, dseg_D6E08
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[92030];        // mov ax, dseg_D6E0C
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_53F13()
{
    ax = *(word *)&g_memByte[92028];        // mov ax, dseg_D6E0A
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[92032];        // mov ax, dseg_D6E0E
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_53F2D()
{
    eax = D4;                               // mov eax, D4
    *(dword *)&g_memByte[511202] = eax;     // mov dseg_17A462, eax
    cseg_53F43();                           // jmp short cseg_53F43
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team pointer
//      A1 -> menu title
//
void ShowSquad()
{
    *(dword *)&g_memByte[511202] = 0;       // mov dseg_17A462, 0

    cseg_53F43();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_53F43()
{
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[511194] = eax;     // mov squadTeamPtr, eax
    eax = A1;                               // mov eax, A1
    *(dword *)&g_memByte[511198] = eax;     // mov viewSquadTitle, eax
    eax = D0;                               // mov eax, D0
    *(dword *)&g_memByte[511206] = eax;     // mov dseg_17A466, eax
    eax = D1;                               // mov eax, D1
    *(dword *)&g_memByte[511210] = eax;     // mov dseg_17A46A, eax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[511214] = ax;       // mov dseg_17A46E, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[511216] = ax;       // mov dseg_17A470, ax
    A6 = 513770;                            // mov A6, offset viewSquadMenu
    SWOS::ShowMenu();                       // call ShowMenu
    ax = *(word *)&g_memByte[511222];       // mov ax, dseg_17A476
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = *(word *)&g_memByte[511220];       // mov ax, dseg_17A474
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_53FAE()
{
    ax = *(word *)&g_memByte[92300];        // mov ax, numPlayersOnTransferMarket
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_53FFC;                    // jz short cseg_53FFC

    A1 = 92302;                             // mov A1, offset playersOnTransferMarket
    *(word *)&D2 = 0;                       // mov word ptr D2, 0

cseg_53FCC:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        return;                             // jz short cseg_5400C

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    ax = *(word *)&g_memByte[92300];        // mov ax, numPlayersOnTransferMarket
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_53FCC;                    // jnz short cseg_53FCC

cseg_53FFC:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5400D()
{
    cseg_53FAE();                           // call cseg_53FAE
    if (!flags.zero)
        return;                             // jnz short cseg_54062

    ax = *(word *)&g_memByte[92300];        // mov ax, numPlayersOnTransferMarket
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 2
    if (flags.sign)
        goto cseg_5405A;                    // js short cseg_5405A

cseg_54037:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_54037;                    // jns short cseg_54037

cseg_5405A:;
    {
        word src = *(word *)&g_memByte[92300];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[92300] = src;
    }                                       // sub numPlayersOnTransferMarket, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_54063()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    IsPlayerInCareerContest();              // call IsPlayerInCareerContest
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    if (flags.zero)
        return;                             // jz short cseg_5409F

    push(D0);                               // push D0
    push(D1);                               // push D1
    FindForeignMarketPlayer();              // call FindForeignMarketPlayer
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_540A0()
{
    {
        word src = *(word *)&g_memByte[92300];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numPlayersOnTransferMarket, 5
    if (flags.zero)
        return;                             // jz short cseg_540E6

    A0 = 92302;                             // mov A0, offset playersOnTransferMarket
    ax = *(word *)&g_memByte[92300];        // mov ax, numPlayersOnTransferMarket
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 << 1;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 1
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    writeMemory(esi + ebx, 2, ax);          // mov [esi+ebx], ax
    {
        word src = *(word *)&g_memByte[92300];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[92300] = src;
    }                                       // add numPlayersOnTransferMarket, 1
}

// =============== S U B R O U T I N E =======================================
//
void RemovePlayerFromTeam()
{
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_546DF();                           // call cseg_546DF
    push(D1);                               // push D1
    cseg_52EA6();                           // call cseg_52EA6
    pop(D1);                                // pop D1
    g_memByte[92857] = 1;                   // mov careerTeam+3Bh, 1
    cseg_547AC();                           // call cseg_547AC
}

// =============== S U B R O U T I N E =======================================
//
void cseg_54116()
{
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, 0
    if (flags.zero)
        goto cseg_546A9;                    // jz cseg_546A9

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = D6;                                // mov ax, word ptr D6
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_541B8;                    // js short cseg_541B8

    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_541B8:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 79, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 255;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4Fh], 0FFh
    if (!flags.zero)
        goto cseg_541D9;                    // jnz short cseg_541D9

    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    goto cseg_546B2;                        // jmp cseg_546B2

cseg_541D9:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    cseg_13DFB();                           // call cseg_13DFB
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    eax = A0;                               // mov eax, A0
    A2 = eax;                               // mov A2, eax
    *(word *)&D1 = 16;                      // mov word ptr D1, 10h
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, 0
    if (flags.zero)
        goto cseg_54250;                    // jz short cseg_54250

    eax = A4;                               // mov eax, A4
    A0 = eax;                               // mov A0, eax
    GetStringLength();                      // call GetStringLength
    *(word *)&D1 = 16;                      // mov word ptr D1, 10h
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax

cseg_54250:;
    *(word *)&D0 = 13;                      // mov word ptr D0, 0Dh
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4Fh
    A0 = eax;                               // mov A0, eax
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A4);                               // push A4
    push(A6);                               // push A6
    ExtractSurname();                       // call ExtractSurname
    pop(A6);                                // pop A6
    pop(A4);                                // pop A4
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    eax = A2;                               // mov eax, A2
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, 0
    if (flags.zero)
        goto cseg_54370;                    // jz short cseg_54370

    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 40);                // mov byte ptr [esi], 28h
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 1
    eax = A0;                               // mov eax, A0
    A2 = eax;                               // mov A2, eax
    eax = A4;                               // mov eax, A4
    A0 = eax;                               // mov A0, eax
    StringCopy();                           // call StringCopy
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 41);                // mov byte ptr [esi], 29h
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_54370:;
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    A2 = 332080;                            // mov A2, offset playerPositionsStringTable
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    FormTopSkillsString();                  // call FormTopSkillsString
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 76, 1);     // mov al, [esi+(PlayerFile.nationality+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    A2 = 25865;                             // mov A2, offset shortCountryNames
    eax = A2;                               // mov eax, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A2 = eax;                               // mov A2, eax
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 40);                // mov byte ptr [esi], 28h
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 1
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 41);                // mov byte ptr [esi], 29h
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    push(A0);                               // push A0
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_545DC;                    // jz short cseg_545DC

    ax = *(word *)&g_memByte[456650];       // mov ax, dseg_168A6F
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_545DC;                    // jnz short cseg_545DC

    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    cseg_3E04F();                           // call cseg_3E04F
    pop(A0);                                // pop A0
    goto cseg_54608;                        // jmp short cseg_54608

cseg_545DC:;
    A1 = 316574;                            // mov A1, offset fundsBuffer
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    cseg_247C8();                           // call cseg_247C8
    pop(A0);                                // pop A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 316574);       // mov dword ptr [esi+26h], offset fundsBuffer

cseg_54608:;
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D1 = 13;                      // mov word ptr D1, 0Dh
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_5466C;                    // jz short cseg_5466C

    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_5466C;                    // jz short cseg_5466C

    *(word *)&D1 = 2;                       // mov word ptr D1, 2
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+66h], 2
    if (flags.zero)
        goto cseg_5466C;                    // jz short cseg_5466C

    *(word *)&D1 = 15;                      // mov word ptr D1, 0Fh

cseg_5466C:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+24h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+24h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 38h
    return;                                 // retn

cseg_546A9:;
    *(word *)&D0 = 11;                      // mov word ptr D0, 0Bh

cseg_546B2:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 38h
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_546B2;                    // jns short cseg_546B2
}

// =============== S U B R O U T I N E =======================================
//
void cseg_546DF()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    cseg_5493A();                           // call cseg_5493A
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_54759;                    // jnz short cseg_54759

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    cseg_5400D();                           // call cseg_5400D
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[94092];        // mov ax, dseg_D761A
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        return;                             // jnz short cseg_54758

    *(word *)&g_memByte[94092] = -1;        // mov dseg_D761A, -1

cseg_54758:;
    return;                                 // retn

cseg_54759:;
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    cseg_8DF16();                           // call cseg_8DF16
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    cseg_8E09A();                           // call cseg_8E09A
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_547AC()
{
    push(D1);                               // push D1
    push(D3);                               // push D3

cseg_547B8:;
    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_54898;                    // jz cseg_54898

    cseg_53F13();                           // call cseg_53F13
    if (!flags.zero)
        goto cseg_547DC;                    // jnz short cseg_547DC

    *(word *)&g_memByte[91786] = 0;         // mov numOffers, 0
    goto cseg_54898;                        // jmp cseg_54898

cseg_547DC:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    cseg_53EF9();                           // call cseg_53EF9
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    A0 = 91948;                             // mov A0, offset dseg_D6DBA

cseg_54800:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 3, 1);      // mov al, [esi+3]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_54817;                    // js short cseg_54817

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 1
    if (flags.zero)
        goto cseg_54846;                    // jz short cseg_54846

cseg_54817:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 4, 1);      // mov al, [esi+4]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_54870;                    // js short cseg_54870

    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_54846;                    // jz short cseg_54846

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 2
    if (!flags.carry)
        goto cseg_54870;                    // jnb short cseg_54870

    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_54870;                    // js short cseg_54870

cseg_54846:;
    eax = D1;                               // mov eax, D1
    {
        dword tmp = D0;
        D0 = eax;
        eax = tmp;
    }                                       // xchg eax, D0
    D1 = eax;                               // mov D1, eax
    cseg_53E64();                           // call cseg_53E64
    eax = D1;                               // mov eax, D1
    {
        dword tmp = D0;
        D0 = eax;
        eax = tmp;
    }                                       // xchg eax, D0
    D1 = eax;                               // mov D1, eax
    goto cseg_547B8;                        // jmp cseg_547B8

cseg_54870:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 14;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0Eh
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto cseg_54800;                    // jnz cseg_54800

cseg_54898:;
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 20h
    if (flags.carry)
        goto cseg_5492D;                    // jb cseg_5492D

cseg_548A6:;
    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5492D;                    // jz short cseg_5492D

    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    A0 = 91948;                             // mov A0, offset dseg_D6DBA

cseg_548C8:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_54909;                    // js short cseg_54909

    al = (byte)readMemory(esi + 3, 1);      // mov al, [esi+3]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.sign)
        goto cseg_54909;                    // jns short cseg_54909

    eax = D2;                               // mov eax, D2
    {
        dword tmp = D0;
        D0 = eax;
        eax = tmp;
    }                                       // xchg eax, D0
    D2 = eax;                               // mov D2, eax
    cseg_53E64();                           // call cseg_53E64
    eax = D2;                               // mov eax, D2
    {
        dword tmp = D0;
        D0 = eax;
        eax = tmp;
    }                                       // xchg eax, D0
    D2 = eax;                               // mov D2, eax
    goto cseg_548A6;                        // jmp short cseg_548A6

cseg_54909:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 14;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0Eh
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_548C8;                    // jnz short cseg_548C8

cseg_5492D:;
    pop(D3);                                // pop D3
    pop(D1);                                // pop D1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5493A()
{
_l_start:;
    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    A0 = 91948;                             // mov A0, offset dseg_D6DBA

cseg_5495C:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_549C3;                    // jnz short cseg_549C3

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto cseg_5498D;                    // jz short cseg_5498D

    al = (byte)readMemory(esi + 3, 1);      // mov al, [esi+3]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_549F7;                    // jnz short cseg_549F7

cseg_5498D:;
    eax = D2;                               // mov eax, D2
    {
        dword tmp = D0;
        D0 = eax;
        eax = tmp;
    }                                       // xchg eax, D0
    D2 = eax;                               // mov D2, eax
    push(D1);                               // push D1
    cseg_53E64();                           // call cseg_53E64
    pop(D1);                                // pop D1
    eax = D2;                               // mov eax, D2
    {
        dword tmp = D0;
        D0 = eax;
        eax = tmp;
    }                                       // xchg eax, D0
    D2 = eax;                               // mov D2, eax
    goto _l_start;                          // jmp cseg_5493A

cseg_549C3:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_549F7;                    // jnz short cseg_549F7

    al = (byte)readMemory(esi + 4, 1);      // mov al, [esi+4]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto cseg_5498D;                    // jz short cseg_5498D

    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto cseg_5498D;                    // jz short cseg_5498D

cseg_549F7:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 14;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0Eh
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_5495C;                    // jnz cseg_5495C
}

// =============== S U B R O U T I N E =======================================
//
void BuyOtherPlayersInit()
{
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[511846] = eax;     // mov dseg_17A6E6, eax

    BuyOtherPlayersFinish();
}

// =============== S U B R O U T I N E =======================================
//
void BuyOtherPlayersFinish()
{
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = *(dword *)&g_memByte[511842];     // mov eax, dseg_17A6E2
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = *(dword *)&g_memByte[511846];     // mov eax, dseg_17A6E6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 5
    A1 = eax;                               // mov A1, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
}

// =============== S U B R O U T I N E =======================================
//
void j_SetExitMenuFlag_10()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void BuyOtherPlayersCommon()
{
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    eax = *(dword *)&g_memByte[511846];     // mov eax, dseg_17A6E6
    A0 = eax;                               // mov A0, eax
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_54C1E();                           // call cseg_54C1E
    ax = *(word *)&g_memByte[511838];       // mov ax, dseg_17A6DE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_54B16;                    // jz short cseg_54B16

    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

cseg_54B16:;
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void BuyOtherPlayersAfterDrawCommon()
{
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    eax = *(dword *)&g_memByte[511846];     // mov eax, dseg_17A6E6
    A0 = eax;                               // mov A0, eax
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    A4 = 0;                                 // mov A4, 0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 13h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    cseg_54116();                           // call cseg_54116
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 13h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 12;                      // mov word ptr D0, 0Ch
    SWOS::DrawMultipleItems();              // jmp DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - number of team to search for
//
void cseg_54C1E()
{
    GetTeamPointer();                       // call GetTeamPointer
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&g_memByte[511820] = ax;       // mov teamOffering, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[511822] = ax;       // mov dseg_17A6CE, ax
    *(word *)&g_memByte[511824] = 65535;    // mov numExtraPlayersWanted, 0FFFFh
    *(word *)&g_memByte[511826] = 65535;    // mov dseg_17A6D2, 0FFFFh
    *(word *)&g_memByte[511828] = 65535;    // mov dseg_17A6D4, 0FFFFh
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    cseg_8E23A();                           // call cseg_8E23A
    ax = D0;                                // mov ax, word ptr D0
    bx = 1000;                              // mov bx, 3E8h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    eax = *(dword *)&g_memByte[91354];      // mov eax, newBalance
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, eax
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_54CD4;                    // jle short cseg_54CD4

    eax = *(dword *)&g_memByte[91354];      // mov eax, newBalance
    D0 = eax;                               // mov D0, eax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.sign)
        goto cseg_54CC1;                    // jns short cseg_54CC1

    D0 = 0;                                 // mov D0, 0

cseg_54CC1:;
    edx ^= edx;                             // xor edx, edx
    eax = D0;                               // mov eax, D0
    ebx = 1000;                             // mov ebx, 3E8h
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D0 = eax;                               // mov D0, eax

cseg_54CD4:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[511830] = ax;       // mov offerAmount, ax
    A6 = 3519;                              // mov A6, offset playerOffersMenu
    SWOS::ShowMenu();                       // jmp ShowMenu
}

// =============== S U B R O U T I N E =======================================
//
void BuyPlayerInit()
{
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    GetBankBalance();                       // call GetBankBalance
}

// =============== S U B R O U T I N E =======================================
//
void ViewDomesticPlayerMarket()
{
    ShowDomesticPlayerMarket();             // call ShowDomesticPlayerMarket
    ax = *(word *)&g_memByte[511838];       // mov ax, dseg_17A6DE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { BuyPlayerExit(); return; }        // jnz BuyPlayerExit

    ax = *(word *)&g_memByte[511838];       // mov ax, dseg_17A6DE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        BuyPlayerExit();                    // jnz BuyPlayerExit
}

// =============== S U B R O U T I N E =======================================
//
void ViewForeignPlayerMarket()
{
    cseg_54F34();                           // call cseg_54F34
    ax = *(word *)&g_memByte[511838];       // mov ax, dseg_17A6DE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { BuyPlayerExit(); return; }        // jnz BuyPlayerExit

    ax = *(word *)&g_memByte[511838];       // mov ax, dseg_17A6DE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        BuyPlayerExit();                    // jnz BuyPlayerExit
}

// =============== S U B R O U T I N E =======================================
//
void BuyOtherDomesticPlayer()
{
    A0 = 16644;                             // mov A0, offset aBuyOtherDomest
    A1 = 0;                                 // mov A1, 0
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_4C83A();                           // call cseg_4C83A
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0FFFFh
    if (flags.zero)
        return;                             // jz short cseg_54DF1

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[511820] = ax;       // mov teamOffering, ax
    *(dword *)&g_memByte[511842] = 16644;   // mov dseg_17A6E2, offset aBuyOtherDomest
    A6 = 511850;                            // mov A6, offset buyOtherPlayersMenu
    SWOS::ShowMenu();                       // call ShowMenu
    ax = *(word *)&g_memByte[511838];       // mov ax, dseg_17A6DE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { BuyPlayerExit(); return; }        // jnz BuyPlayerExit

    ax = *(word *)&g_memByte[511838];       // mov ax, dseg_17A6DE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        BuyPlayerExit();                    // jnz BuyPlayerExit
}

// =============== S U B R O U T I N E =======================================
//
void BuyOtherForeignPlayer()
{
    A0 = 16673;                             // mov A0, offset aBuyOtherForeig
    A1 = 0;                                 // mov A1, 0
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    ChooseTeamsDialog();                    // call ChooseTeamsDialog
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0FFFFh
    if (flags.zero)
        return;                             // jz short cseg_54E73

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[511820] = ax;       // mov teamOffering, ax
    *(dword *)&g_memByte[511842] = 16673;   // mov dseg_17A6E2, offset aBuyOtherForeig
    A6 = 511850;                            // mov A6, offset buyOtherPlayersMenu
    SWOS::ShowMenu();                       // call ShowMenu
    ax = *(word *)&g_memByte[511838];       // mov ax, dseg_17A6DE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { BuyPlayerExit(); return; }        // jnz BuyPlayerExit

    ax = *(word *)&g_memByte[511838];       // mov ax, dseg_17A6DE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        BuyPlayerExit();                    // jnz BuyPlayerExit
}

// =============== S U B R O U T I N E =======================================
//
void BuyPlayerViewSquad()
{
    A0 = 92798;                             // mov A0, offset careerTeam
    A1 = 18798;                             // mov A1, offset aViewSquad
    D0 = 0;                                 // mov D0, 0
    A2 = 92302;                             // mov A2, offset playersOnTransferMarket
    ax = *(word *)&g_memByte[92300];        // mov ax, numPlayersOnTransferMarket
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_54EE8;                    // jz short cseg_54EE8

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_54EB5:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D0 |= eax;
    flags.carry = false;                    // or D0, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_54EB5;                    // jns short cseg_54EB5

cseg_54EE8:;
    D1 = 0;                                 // mov D1, 0
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    *(word *)&D3 = 65535;                   // mov word ptr D3, 0FFFFh
    *(word *)&D4 = 65535;                   // mov word ptr D4, 0FFFFh
    ShowSquad();                            // jmp ShowSquad
}

// =============== S U B R O U T I N E =======================================
//
void BuyPlayerExit()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ShowDomesticPlayerMarket()
{
    cseg_5509D();                           // call cseg_5509D
    *(word *)&g_memByte[511836] = 1;        // mov showDomesticPlayerMarket, 1
    A6 = 515126;                            // mov A6, offset showPlayerMarketMenu
    SWOS::ShowMenu();                       // jmp ShowMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_54F34()
{
    LoadPoolplyrDat();                      // call LoadPoolplyrDat
    ax = *(word *)&g_memByte[91774];        // mov ax, dseg_D6D0C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_54F5D;                    // jz short cseg_54F5D

    {
        word src = *(word *)&g_memByte[91774];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91774] = src;
    }                                       // sub dseg_D6D0C, 1
    push(D7);                               // push D7
    AddRandomForeignMarketPlayer();         // call AddRandomForeignMarketPlayer
    pop(D7);                                // pop D7

cseg_54F5D:;
    cseg_54F7A();                           // call cseg_54F7A
    *(word *)&g_memByte[511836] = 0;        // mov showDomesticPlayerMarket, 0
    A6 = 515126;                            // mov A6, offset showPlayerMarketMenu
    SWOS::ShowMenu();                       // jmp ShowMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_54F7A()
{
_l_start:;
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_5509C

    ax = *(word *)&g_memByte[91778];        // mov ax, dseg_D6D10
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_5509C

    {
        word src = *(word *)&g_memByte[91778];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[91778] = src;
    }                                       // sub dseg_D6D10, 1
    ax = *(word *)&g_memByte[91782];        // mov ax, numForeignMarketPlayers
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_5509C

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 15;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 0Fh
    {
        word res = *(word *)&D7 >> 4;
        flags.carry = ((word)*(word *)&D7 >> 12) & 1;
        *(word *)&D7 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D7, 4
    if (flags.zero)
        return;                             // jz cseg_5509C

    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1

cseg_54FDF:;
    ax = *(word *)&g_memByte[91782];        // mov ax, numForeignMarketPlayers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_55073;                    // jz cseg_55073

    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[91782];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul numForeignMarketPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    A0 = 91788;                             // mov A0, offset foreignMarketPlayers
    ax = D0;                                // mov ax, word ptr D0
    bx = 4;                                 // mov bx, 4
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    cseg_8E09A();                           // call cseg_8E09A
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto cseg_54FDF;                    // jns cseg_54FDF

cseg_55073:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_5507B:;
    {
        word src = *(word *)&g_memByte[91782];
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numForeignMarketPlayers, 0Fh
    if (flags.zero)
        goto _l_start;                      // jz cseg_54F7A

    AddRandomForeignMarketPlayer();         // call AddRandomForeignMarketPlayer
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_5507B;                    // jns short cseg_5507B

    goto _l_start;                          // jmp cseg_54F7A
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5509D()
{
_l_start:;
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_551BF

    ax = *(word *)&g_memByte[91776];        // mov ax, dseg_D6D0E
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_551BF

    {
        word src = *(word *)&g_memByte[91776];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[91776] = src;
    }                                       // sub dseg_D6D0E, 1
    ax = *(word *)&g_memByte[91784];        // mov ax, numHomeMarketPlayers
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_551BF

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 15;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 0Fh
    {
        word res = *(word *)&D7 >> 4;
        flags.carry = ((word)*(word *)&D7 >> 12) & 1;
        *(word *)&D7 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D7, 4
    if (flags.zero)
        return;                             // jz cseg_551BF

    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1

cseg_55102:;
    ax = *(word *)&g_memByte[91784];        // mov ax, numHomeMarketPlayers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_55196;                    // jz cseg_55196

    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[91784];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul numHomeMarketPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    A0 = 91848;                             // mov A0, offset homeMarketPlayers
    ax = D0;                                // mov ax, word ptr D0
    bx = 4;                                 // mov bx, 4
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    cseg_8DF16();                           // call cseg_8DF16
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto cseg_55102;                    // jns cseg_55102

cseg_55196:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_5519E:;
    {
        word src = *(word *)&g_memByte[91784];
        int16_t dstSigned = src;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numHomeMarketPlayers, 19h
    if (flags.zero)
        goto _l_start;                      // jz cseg_5509D

    AddCareerTeamPlayer();                  // call AddCareerTeamPlayer
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_5519E;                    // jns short cseg_5519E

    goto _l_start;                          // jmp cseg_5509D
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_19()
{
}

// =============== S U B R O U T I N E =======================================
//
void OffersCommon()
{
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax

cseg_551FD:;
    A5 = 91948;                             // mov A5, offset dseg_D6DBA
    ax = D7;                                // mov ax, word ptr D7
    bx = 14;                                // mov bx, 14
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    esi = A5;                               // mov esi, A5
    {
        word src = (word)readMemory(esi + 8, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = -2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+8], -2
    if (flags.zero)
        goto cseg_5528B;                    // jz short cseg_5528B

    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    {
        word src = (word)readMemory(esi + 10, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+10], -1
    if (flags.zero)
        goto cseg_5528B;                    // jz short cseg_5528B

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    {
        word src = (word)readMemory(esi + 8, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+8], -1
    if (flags.zero)
        goto cseg_5528B;                    // jz short cseg_5528B

    *(word *)&D0 = 0;                       // mov word ptr D0, 0

cseg_5528B:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[513010] = ax;       // mov offerStatus, ax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&g_memByte[511820] = ax;       // mov teamOffering, ax
    ax = (word)readMemory(esi + 6, 2);      // mov ax, [esi+6]
    *(word *)&g_memByte[511830] = ax;       // mov offerAmount, ax
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&g_memByte[511822] = ax;       // mov dseg_17A6CE, ax
    al = (byte)readMemory(esi + 3, 1);      // mov al, [esi+3]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&g_memByte[511824] = ax;       // mov numExtraPlayersWanted, ax
    al = (byte)readMemory(esi + 4, 1);      // mov al, [esi+4]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&g_memByte[511826] = ax;       // mov dseg_17A6D2, ax
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[511828] = ax;       // mov dseg_17A6D4, ax
    A6 = 513118;                            // mov A6, offset thirdPartyOfferMenu
    push(D7);                               // push D7
    push(A5);                               // push A5
    SWOS::ShowMenu();                       // call ShowMenu
    pop(A5);                                // pop A5
    pop(D7);                                // pop D7
    ax = *(word *)&g_memByte[513012];       // mov ax, dseg_17AB74
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5547B;                    // jz cseg_5547B

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto cseg_5545F;                    // jz cseg_5545F

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (flags.zero)
        goto cseg_55486;                    // jz cseg_55486

    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 8, 2);      // mov ax, [esi+8]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5541A;                    // jz short cseg_5541A

    {
        word src = (word)readMemory(esi + 8, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+8], 0FFFFh
    if (flags.zero)
        goto cseg_553E5;                    // jz short cseg_553E5

    ax = (word)readMemory(esi + 8, 2);      // mov ax, [esi+8]
    writeMemory(esi + 6, 2, ax);            // mov [esi+6], ax
    writeMemory(esi + 8, 2, 65535);         // mov word ptr [esi+8], 0FFFFh
    goto cseg_551FD;                        // jmp cseg_551FD

cseg_553E5:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 10, 2);     // mov ax, [esi+0Ah]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5541A;                    // jz short cseg_5541A

    {
        word src = (word)readMemory(esi + 10, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+0Ah], 0FFFFh
    if (flags.zero)
        goto cseg_5541A;                    // jz short cseg_5541A

    ax = (word)readMemory(esi + 10, 2);     // mov ax, [esi+0Ah]
    writeMemory(esi + 6, 2, ax);            // mov [esi+6], ax
    writeMemory(esi + 10, 2, 65535);        // mov word ptr [esi+0Ah], 0FFFFh
    goto cseg_551FD;                        // jmp cseg_551FD

cseg_5541A:;
    SWOS::Rand2();                          // call Rand2
    {
        byte res = *(byte *)&D0 & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr D0, 1
    if (flags.zero)
        goto cseg_55439;                    // jz short cseg_55439

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 8, 2, 65534);         // mov word ptr [esi+8], 0FFFEh
    goto cseg_551FD;                        // jmp cseg_551FD

cseg_55439:;
    *(word *)&g_memByte[513010] = -1;       // mov offerStatus, -1
    A6 = 513118;                            // mov A6, offset thirdPartyOfferMenu
    push(D7);                               // push D7
    SWOS::ShowMenu();                       // call ShowMenu
    pop(D7);                                // pop D7
    goto cseg_55486;                        // jmp short cseg_55486

cseg_5545F:;
    cseg_55F53();                           // call cseg_55F53
    {
        word src = *(word *)&g_memByte[92298];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[92298] = src;
    }                                       // sub timeToNegotiate, 1
    *(word *)&g_memByte[511838] = 1;        // mov dseg_17A6DE, 1
    SetExitMenuFlag();                      // jmp SetExitMenuFlag

    return;                                 // retn

cseg_5547B:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 13, 1, 1);            // mov byte ptr [esi+13], 1
    return;                                 // retn

cseg_55486:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_53E64();                           // call cseg_53E64
    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        { j_SetExitMenuFlag_11(); return; } // jz short j_SetExitMenuFlag_11

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void j_SetExitMenuFlag_11()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void OffersAfterDrawCommon()
{
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+16h], 2
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+16h], 0Bh
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 0Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+16h], 7
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    {
        word src = (word)readMemory(esi + 38, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 38, 2, src);
    }                                       // add word ptr [esi+26h], 1
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1
    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.carry)
        goto cseg_55F09;                    // jnb cseg_55F09

    A6 = 91948;                             // mov A6, offset dseg_D6DBA
    ax = D7;                                // mov ax, word ptr D7
    bx = 14;                                // mov bx, 0Eh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A6;                               // mov eax, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A6 = eax;                               // mov A6, eax
    writeMemory(esi + 6, 2, 0);             // mov word ptr [esi+6], 0
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 10;                      // mov word ptr D0, 0Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 13, 1);     // mov al, [esi+0Dh]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_55713;                    // jz short cseg_55713

    *(word *)&D1 = 6;                       // mov word ptr D1, 6

cseg_55713:;
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+24h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+24h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+24h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+24h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+24h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+24h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+24h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+24h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 38h
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    *(dword *)&g_memByte[512962] = 10807;   // mov dseg_17AB42, offset aAOfferForB
    *(dword *)&g_memByte[512966] = 10823;   // mov dseg_17AB46, offset aAOfferForBAndC
    *(dword *)&g_memByte[512970] = 10846;   // mov dseg_17AB4A, offset aAExchangeOffer
    *(dword *)&g_memByte[512974] = 10871;   // mov dseg_17AB4E, offset aAExchangeOff_0
    *(dword *)&g_memByte[512978] = 10903;   // mov dseg_17AB52, offset aAOfferFor
    *(dword *)&g_memByte[512982] = 10916;   // mov dseg_17AB56, offset aB
    *(dword *)&g_memByte[512986] = 10919;   // mov dseg_17AB5A, offset aAOfferFor_0
    *(dword *)&g_memByte[512990] = 10932;   // mov dseg_17AB5E, offset aBAndC
    *(dword *)&g_memByte[512994] = 10942;   // mov dseg_17AB62, offset aAExchangeOff_1
    *(dword *)&g_memByte[512998] = 10964;   // mov dseg_17AB66, offset aB_0
    *(dword *)&g_memByte[513002] = 10967;   // mov dseg_17AB6A, offset aAExchangeOff_2
    *(dword *)&g_memByte[513006] = 10989;   // mov dseg_17AB6E, offset aBAndC_0
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 10, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+0Ah], 0FFFFh
    if (!flags.zero)
        goto cseg_55953;                    // jnz cseg_55953

    *(dword *)&g_memByte[512962] = 11263;   // mov dseg_17AB42, offset aAFurtherImprov
    *(dword *)&g_memByte[512966] = 11296;   // mov dseg_17AB46, offset aAFurtherImpr_0
    *(dword *)&g_memByte[512970] = 11336;   // mov dseg_17AB4A, offset aAFurtherImpr_1
    *(dword *)&g_memByte[512974] = 11378;   // mov dseg_17AB4E, offset aAFurtherImpr_2
    *(dword *)&g_memByte[512978] = 11427;   // mov dseg_17AB52, offset aAFurtherImpr_3
    *(dword *)&g_memByte[512982] = 11457;   // mov dseg_17AB56, offset aB_1
    *(dword *)&g_memByte[512986] = 11460;   // mov dseg_17AB5A, offset aAFurtherImpr_4
    *(dword *)&g_memByte[512990] = 11490;   // mov dseg_17AB5E, offset aBAndC_1
    *(dword *)&g_memByte[512994] = 11500;   // mov dseg_17AB62, offset aAFurtherImpr_5
    *(dword *)&g_memByte[512998] = 11529;   // mov dseg_17AB66, offset aOfferForB
    *(dword *)&g_memByte[513002] = 11542;   // mov dseg_17AB6A, offset aAFurtherImpr_6
    *(dword *)&g_memByte[513006] = 11572;   // mov dseg_17AB6E, offset aBAndC_2
    goto cseg_559D8;                        // jmp cseg_559D8

cseg_55953:;
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 8, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+8], 0FFFFh
    if (!flags.zero)
        goto cseg_559D8;                    // jnz short cseg_559D8

    *(dword *)&g_memByte[512962] = 10999;   // mov dseg_17AB42, offset aAImprovedOffer
    *(dword *)&g_memByte[512966] = 11024;   // mov dseg_17AB46, offset aAImprovedOff_0
    *(dword *)&g_memByte[512970] = 11056;   // mov dseg_17AB4A, offset aAImprovedExcha
    *(dword *)&g_memByte[512974] = 11090;   // mov dseg_17AB4E, offset aAImprovedExc_0
    *(dword *)&g_memByte[512978] = 11131;   // mov dseg_17AB52, offset aAImprovedOff_1
    *(dword *)&g_memByte[512982] = 11153;   // mov dseg_17AB56, offset aB_2
    *(dword *)&g_memByte[512986] = 11156;   // mov dseg_17AB5A, offset aAImprovedOff_2
    *(dword *)&g_memByte[512990] = 11178;   // mov dseg_17AB5E, offset aBAndC_3
    *(dword *)&g_memByte[512994] = 11188;   // mov dseg_17AB62, offset aAImprovedExc_1
    *(dword *)&g_memByte[512998] = 11219;   // mov dseg_17AB66, offset aB_3
    *(dword *)&g_memByte[513002] = 11222;   // mov dseg_17AB6A, offset aAImprovedExc_2
    *(dword *)&g_memByte[513006] = 11253;   // mov dseg_17AB6E, offset aBAndC_4

cseg_559D8:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    A2 = eax;                               // mov A2, eax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 3, 1);      // mov al, [esi+3]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.sign)
        goto cseg_55A65;                    // jns short cseg_55A65

    eax = *(dword *)&g_memByte[512962];     // mov eax, dseg_17AB42
    A5 = eax;                               // mov A5, eax
    al = (byte)readMemory(esi + 4, 1);      // mov al, [esi+4]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_55A27;                    // js short cseg_55A27

    eax = *(dword *)&g_memByte[512970];     // mov eax, dseg_17AB4A
    A5 = eax;                               // mov A5, eax

cseg_55A27:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4Fh
    A3 = eax;                               // mov A3, eax
    goto cseg_55AF8;                        // jmp cseg_55AF8

cseg_55A65:;
    eax = *(dword *)&g_memByte[512966];     // mov eax, dseg_17AB46
    A5 = eax;                               // mov A5, eax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 4, 1);      // mov al, [esi+4]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_55A86;                    // js short cseg_55A86

    eax = *(dword *)&g_memByte[512974];     // mov eax, dseg_17AB4E
    A5 = eax;                               // mov A5, eax

cseg_55A86:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4Fh
    A3 = eax;                               // mov A3, eax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 3, 1);      // mov al, [esi+3]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4Fh
    A4 = eax;                               // mov A4, eax

cseg_55AF8:;
    eax = A5;                               // mov eax, A5
    A0 = eax;                               // mov A0, eax
    A1 = 316574;                            // mov A1, offset fundsBuffer
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    PrintFormatted();                       // call PrintFormatted
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(A0);                               // push A0
    GetStringLength();                      // call GetStringLength
    pop(A0);                                // pop A0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 47;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2Fh
    if (!flags.carry && !flags.zero)
        goto cseg_55C84;                    // ja cseg_55C84

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+16h], 5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    goto cseg_55F09;                        // jmp cseg_55F09

cseg_55C84:;
    eax = A0;                               // mov eax, A0
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A6 = eax;                               // mov A6, eax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[512966];     // mov eax, dseg_17AB46
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, eax
    if (flags.zero)
        goto cseg_55D33;                    // jz short cseg_55D33

    eax = *(dword *)&g_memByte[512970];     // mov eax, dseg_17AB4A
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, eax
    if (flags.zero)
        goto cseg_55D49;                    // jz short cseg_55D49

    eax = *(dword *)&g_memByte[512974];     // mov eax, dseg_17AB4E
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, eax
    if (flags.zero)
        goto cseg_55D5F;                    // jz short cseg_55D5F

    eax = *(dword *)&g_memByte[512982];     // mov eax, dseg_17AB56
    A5 = eax;                               // mov A5, eax
    eax = *(dword *)&g_memByte[512978];     // mov eax, dseg_17AB52
    A1 = eax;                               // mov A1, eax
    goto cseg_55D73;                        // jmp short cseg_55D73

cseg_55D33:;
    eax = *(dword *)&g_memByte[512990];     // mov eax, dseg_17AB5E
    A5 = eax;                               // mov A5, eax
    eax = *(dword *)&g_memByte[512986];     // mov eax, dseg_17AB5A
    A1 = eax;                               // mov A1, eax
    goto cseg_55D73;                        // jmp short cseg_55D73

cseg_55D49:;
    eax = *(dword *)&g_memByte[512998];     // mov eax, dseg_17AB66
    A5 = eax;                               // mov A5, eax
    eax = *(dword *)&g_memByte[512994];     // mov eax, dseg_17AB62
    A1 = eax;                               // mov A1, eax
    goto cseg_55D73;                        // jmp short cseg_55D73

cseg_55D5F:;
    eax = *(dword *)&g_memByte[513006];     // mov eax, dseg_17AB6E
    A5 = eax;                               // mov A5, eax
    eax = *(dword *)&g_memByte[513002];     // mov eax, dseg_17AB6A
    A1 = eax;                               // mov A1, eax

cseg_55D73:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    PrintFormatted();                       // call PrintFormatted
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    eax = A6;                               // mov eax, A6
    A1 = eax;                               // mov A1, eax
    eax = A5;                               // mov eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    PrintFormatted();                       // call PrintFormatted
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

cseg_55F09:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    SWOS::DrawMultipleItems();              // jmp DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void cseg_55F53()
{
    cseg_5E2E0();                           // call cseg_5E2E0
    ax = *(word *)&g_memByte[511830];       // mov ax, offerAmount
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ebx = 1000;                             // mov ebx, 3E8h
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    D0 = eax;                               // mov D0, eax
    {
        dword src = *(dword *)&g_memByte[91354];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91354] = src;
    }                                       // add newBalance, eax
    {
        dword src = *(dword *)&g_memByte[91366];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(dword *)&g_memByte[91366] = src;
    }                                       // add playerSales, eax
    cseg_3B7F8();                           // call cseg_3B7F8
    cseg_3B842();                           // call cseg_3B842
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_56002;                    // js short cseg_56002

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    cseg_56379();                           // call cseg_56379
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_56129();                           // call cseg_56129
    goto cseg_5601F;                        // jmp short cseg_5601F

cseg_56002:;
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_56129();                           // call cseg_56129

cseg_5601F:;
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_5605B;                    // jns short cseg_5605B

    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_560E3;                    // js cseg_560E3

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_56379();                           // call cseg_56379
    goto cseg_560E3;                        // jmp cseg_560E3

cseg_5605B:;
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_560C6;                    // js short cseg_560C6

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    cseg_56379();                           // call cseg_56379
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_56129();                           // call cseg_56129
    goto cseg_560E3;                        // jmp short cseg_560E3

cseg_560C6:;
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_56129();                           // call cseg_56129

cseg_560E3:;
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 59, 1, 1);            // mov byte ptr [esi+3Bh], 1
    g_memByte[92857] = 1;                   // mov careerTeam+3Bh, 1
    cseg_547AC();                           // call cseg_547AC
    cseg_53F13();                           // call cseg_53F13
    if (!flags.zero)
        return;                             // jnz short cseg_56128

    *(word *)&g_memByte[91786] = 0;         // mov numOffers, 0
    *(word *)&g_memByte[337240] = 4;        // mov currentMessage, NO_MORE_PLAYER_SALES
    ShowChairmanMessage();                  // call ShowChairmanMessage
}

// =============== S U B R O U T I N E =======================================
//
void cseg_56129()
{
    push(D1);                               // push D1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_546DF();                           // call cseg_546DF
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    A2 = eax;                               // mov A2, eax
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 3;
        flags.carry = ((word)*(word *)&D0 >> 13) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 3
    A5 = 513014;                            // mov A5, offset dseg_17AB76
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A5 = eax;                               // mov A5, eax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = A0;                               // mov eax, A0
    A4 = eax;                               // mov A4, eax

cseg_561C0:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_56376;                    // js cseg_56376

    eax = A4;                               // mov eax, A4
    A0 = eax;                               // mov A0, eax
    *(byte *)&D3 = 255;                     // mov byte ptr D3, 0FFh
    *(word *)&D2 = 0;                       // mov word ptr D2, 0

cseg_561F5:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    al = D0;                                // mov al, byte ptr D0
    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D4, al
    if (!flags.zero)
        goto cseg_56256;                    // jnz short cseg_56256

    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D3, al
    if (flags.carry)
        goto cseg_56256;                    // jb short cseg_56256

    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    eax = A0;                               // mov eax, A0
    A3 = eax;                               // mov A3, eax

cseg_56256:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 38;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 26h
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 10h
    if (!flags.zero)
        goto cseg_561F5;                    // jnz short cseg_561F5

    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = 255;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D3, 0FFh
    if (flags.zero)
        goto cseg_561C0;                    // jz cseg_561C0

    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    eax = A3;                               // mov eax, A3
    A1 = eax;                               // mov A1, eax
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+4Eh]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+4Eh]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4Ch
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4Ch
    *(word *)&D0 = 18;                      // mov word ptr D0, 12h

cseg_562C3:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_562C3;                    // jns short cseg_562C3

    al = D2;                                // mov al, byte ptr D2
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al
    al = D3;                                // mov al, byte ptr D3
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al
    {
        byte src = (byte)readMemory(esi + 102, 1);
        src |= 4;
        writeMemory(esi + 102, 1, src);
    }                                       // or byte ptr [esi+66h], 4
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 254;
        src = res;
        writeMemory(esi + 102, 1, src);
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and byte ptr [esi+66h], 0FEh
    writeMemory(esi + 113, 1, 0);           // mov byte ptr [esi+71h], 0
    writeMemory(esi + 109, 1, 0);           // mov byte ptr [esi+6Dh], 0
    writeMemory(esi + 110, 1, 0);           // mov byte ptr [esi+6Eh], 0
    writeMemory(esi + 111, 1, 0);           // mov byte ptr [esi+6Fh], 0
    writeMemory(esi + 112, 1, 0);           // mov byte ptr [esi+70h], 0
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(A3);                               // push A3
    cseg_546DF();                           // call cseg_546DF
    pop(A3);                                // pop A3
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A3;                               // mov eax, A3
    A0 = eax;                               // mov A0, eax
    AddCareerPoolPlayer();                  // call AddCareerPoolPlayer
    {
        word src = *(word *)&g_memByte[92032];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[92032] = src;
    }                                       // add dseg_D6E0E, 1
    pop(D1);                                // pop D1
    cseg_52EA6();                           // call cseg_52EA6
    return;                                 // retn

cseg_56376:;
    debugBreak();                           // int 3

cseg_56377:;
    goto cseg_56377;                        // jmp short cseg_56377
}

// =============== S U B R O U T I N E =======================================
//
void cseg_56379()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    cseg_546DF();                           // call cseg_546DF
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    A0 = 92766;                             // mov A0, offset currentMatchPlayers
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

cseg_563AC:;
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_563C0:;
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_563E2;                    // jnz short cseg_563E2

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    goto cseg_563AC;                        // jmp short cseg_563AC

cseg_563E2:;
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_563C0;                    // jns short cseg_563C0

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayer();                            // call GetPlayer
    cseg_63919();                           // call cseg_63919
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 102, 1);
        src |= 4;
        writeMemory(esi + 102, 1, src);
    }                                       // or byte ptr [esi+66h], 4
    writeMemory(esi + 109, 1, 0);           // mov byte ptr [esi+6Dh], 0
    writeMemory(esi + 110, 1, 0);           // mov byte ptr [esi+6Eh], 0
    writeMemory(esi + 111, 1, 0);           // mov byte ptr [esi+6Fh], 0
    writeMemory(esi + 112, 1, 0);           // mov byte ptr [esi+70h], 0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4Ch
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4Ch
    *(word *)&D0 = 18;                      // mov word ptr D0, 12h

cseg_56432:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_56432;                    // jns short cseg_56432

    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 2
    if (flags.zero)
        goto cseg_56483;                    // jz short cseg_56483

    ax = (word)readMemory(esi + 101, 2);    // mov ax, [esi+65h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    goto cseg_56493;                        // jmp short cseg_56493

cseg_56483:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 77, 2);     // mov ax, [esi+4Dh]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax

cseg_56493:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 0Bh
    A0 = 92766;                             // mov A0, offset currentMatchPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        goto cseg_564FC;                    // jz short cseg_564FC

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_564DB:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        A0 = res;
    }                                       // sub A0, 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_564DB;                    // jns short cseg_564DB

cseg_564FC:;
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    A0 = 92798;                             // mov A0, offset careerTeam
    push(D1);                               // push D1
    SetBenchPlayersNumbers();               // call SetBenchPlayersNumbers
    pop(D1);                                // pop D1
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[94090] = src;
    }                                       // add careerNumPlayers, 1
    cseg_5E345();                           // call cseg_5E345
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    cseg_56615();                           // call cseg_56615
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0 - team number
//     D1 - player ordinal in team
//     A1 -> team (file)
//
void AddCareerPoolPlayer()
{
    ax = *(word *)&g_memByte[92020];        // mov ax, numForeignMarketPlayers2
    bx = 42;                                // mov bx, 42
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    A6 = 111782;                            // mov A6, offset careerForeignMarketPlayers
    eax = A6;                               // mov eax, A6
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A6 = eax;                               // mov A6, eax
    al = g_memByte[129466];                 // mov al, dseg_E0048
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 3, 1, al);            // mov [esi+3], al
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    al = D1;                                // mov al, byte ptr D1
    writeMemory(esi + 2, 1, al);            // mov [esi+2], al
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4
    A1 = eax;                               // mov A1, eax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.players
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 18;                      // mov word ptr D0, 18

l_copy_player_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_player_loop;            // jns short @@copy_player_loop

    {
        word src = *(word *)&g_memByte[92020];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[92020] = src;
    }                                       // add numForeignMarketPlayers2, 1
    {
        word src = *(word *)&g_memByte[92022];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[92022] = src;
    }                                       // add dseg_D6E04, 1
    g_memByte[316572] = 255;                // mov lastLoadedExtNumber, 255
}

// =============== S U B R O U T I N E =======================================
//
void cseg_56615()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    ax = D4;                                // mov ax, word ptr D4
    ah ^= ah;
    flags.carry = false;
    flags.sign = (ah & 0x80) != 0;
    flags.zero = ah == 0;                   // xor ah, ah
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    cseg_52B6A();                           // call cseg_52B6A
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    al = D0;                                // mov al, byte ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 76, 1, al);           // mov [esi+4Ch], al
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        byte res = *(byte *)&D0 & 231;
        *(byte *)&D0 = res;
    }                                       // and byte ptr D0, 0E7h
    al = D3;                                // mov al, byte ptr D3
    *(byte *)&D0 |= al;                     // or byte ptr D0, al
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 102, 1, al);          // mov [esi+66h], al
    eax = A1;                               // mov eax, A1
    A3 = eax;                               // mov A3, eax
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4Fh
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 109, 1, 0);           // mov byte ptr [esi+6Dh], 0
    writeMemory(esi + 110, 1, 0);           // mov byte ptr [esi+6Eh], 0
    writeMemory(esi + 111, 1, 0);           // mov byte ptr [esi+6Fh], 0
    writeMemory(esi + 112, 1, 0);           // mov byte ptr [esi+70h], 0
    writeMemory(esi + 103, 1, 0);           // mov byte ptr [esi+67h], 0
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4Ch
    A0 = eax;                               // mov A0, eax
    A1 = 380186;                            // mov A1, offset dseg_11FB02
    *(word *)&D3 = 37;                      // mov word ptr D3, 25h

cseg_56733:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 1
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_56733;                    // jns short cseg_56733

    cseg_567B5();                           // call cseg_567B5
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (flags.zero)
        goto cseg_5679E;                    // jz short cseg_5679E

    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = A3;                               // mov eax, A3
    A0 = eax;                               // mov A0, eax
    AddCareerPoolPlayer();                  // call AddCareerPoolPlayer
    {
        word src = *(word *)&g_memByte[92030];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[92030] = src;
    }                                       // add dseg_D6E0C, 1
    return;                                 // retn

cseg_5679E:;
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 113, 1, 155);         // mov byte ptr [esi+71h], 9Bh
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 253;
        src = res;
        writeMemory(esi + 102, 1, src);
    }                                       // and byte ptr [esi+66h], 0FDh
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 251;
        src = res;
        writeMemory(esi + 102, 1, src);
    }                                       // and byte ptr [esi+66h], 0FBh
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 254;
        src = res;
        writeMemory(esi + 102, 1, src);
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and byte ptr [esi+66h], 0FEh
}

// =============== S U B R O U T I N E =======================================
//
void cseg_567B5()
{
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (flags.zero)
        goto cseg_567D9;                    // jz short cseg_567D9

    *(word *)&D1 = 16;                      // mov word ptr D1, 10h

cseg_567D9:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    {
        word res = *(word *)&D4 & 224;
        *(word *)&D4 = res;
    }                                       // and word ptr D4, 0E0h
    {
        word res = *(word *)&D4 >> 5;
        flags.carry = ((word)*(word *)&D4 >> 11) & 1;
        *(word *)&D4 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D4, 5

cseg_56812:;
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    pop(D1);                                // pop D1
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (flags.zero)
        goto cseg_5686A;                    // jz short cseg_5686A

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    al = D0;                                // mov al, byte ptr D0
    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D4, al
    if (!flags.zero)
        goto cseg_56896;                    // jnz short cseg_56896

cseg_5686A:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 1

cseg_56896:;
    (*(int16_t *)&D1)--;
    flags.overflow = (int16_t)(*(int16_t *)&D1) == INT16_MIN;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_56812;                    // jns cseg_56812

    ax = D2;                                // mov ax, word ptr D2
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D2 = eax;                               // mov D2, eax
    dx = *(word *)((byte *)&D2 + 2);        // mov dx, word ptr D2+2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D3);
        word rem = (word)(dividend % *(word *)&D3);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D3
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D2 = eax;                               // mov D2, eax
    dx = *(word *)((byte *)&D2 + 2);        // mov dx, word ptr D2+2
    bx = 3;                                 // mov bx, 3
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 0Fh
    if (flags.carry || flags.zero)
        goto cseg_56910;                    // jbe short cseg_56910

    *(word *)&D2 = 15;                      // mov word ptr D2, 0Fh

cseg_56910:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (flags.zero)
        goto cseg_56946;                    // jz short cseg_56946

    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    goto cseg_56B30;                        // jmp cseg_56B30

cseg_56946:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[131757];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    bx = 684;                               // mov bx, 2ACh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto cseg_56946;                    // jnz short cseg_56946

    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0Fh
    ax = D0;                                // mov ax, word ptr D0
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 100;                               // mov bx, 64h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    A0 = 510448;                            // mov A0, offset dseg_17A170
    *(word *)&D1 = 65446;                   // mov word ptr D1, 0FFA6h

cseg_56A45:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_56A74;                    // jb short cseg_56A74

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 0Ah
    goto cseg_56A45;                        // jmp short cseg_56A45

cseg_56A74:;
    A0 = 92798;                             // mov A0, offset careerTeam
    push(D1);                               // push D1
    push(D2);                               // push D2
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    if (flags.sign)
        goto cseg_56ABB;                    // js short cseg_56ABB

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 64h
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_56AC8;                    // jle short cseg_56AC8

cseg_56ABB:;
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax

cseg_56AC8:;
    ax = D2;                                // mov ax, word ptr D2
    tmp = ax * *(word *)&D0;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D0
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D2 = eax;                               // mov D2, eax
    dx = *(word *)((byte *)&D2 + 2);        // mov dx, word ptr D2+2
    bx = 3;                                 // mov bx, 3
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx

cseg_56B30:;
    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_56B46;                    // jns short cseg_56B46

    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    goto cseg_56B59;                        // jmp short cseg_56B59

cseg_56B46:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 0Fh
    if (flags.carry || flags.zero)
        goto cseg_56B59;                    // jbe short cseg_56B59

    *(word *)&D2 = 15;                      // mov word ptr D2, 0Fh

cseg_56B59:;
    {
        word res = *(word *)&D2 << 5;
        *(word *)&D2 = res;
    }                                       // shl word ptr D2, 5
    A0 = 510500;                            // mov A0, offset dseg_17A1A4
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        word res = *(word *)&D2 & 224;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 0E0h
    {
        word res = *(word *)&D2 >> 5;
        *(word *)&D2 = res;
    }                                       // shr word ptr D2, 5
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 << 2;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    D0 = eax;                               // mov D0, eax
    A0 = 510468;                            // mov A0, offset dseg_17A184
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    D1 = eax;                               // mov D1, eax
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4Ch
    A1 = eax;                               // mov A1, eax
    A0 = 380186;                            // mov A0, offset dseg_11FB02
    *(word *)&D3 = 37;                      // mov word ptr D3, 25h

cseg_56C05:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 1
    (*(int16_t *)&D3)--;
    flags.overflow = (int16_t)(*(int16_t *)&D3) == INT16_MIN;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_56C05;                    // jns short cseg_56C05

    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, 0
    if (!flags.zero)
        goto cseg_56C51;                    // jnz short cseg_56C51

    al = D0;                                // mov al, byte ptr D0
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 108, 1, al);          // mov [esi+6Ch], al
    writeMemory(esi + 104, 4, 0);           // mov dword ptr [esi+68h], 0
    return;                                 // retn

cseg_56C51:;
    eax = D0;                               // mov eax, D0
    ebx = D1;                               // mov ebx, D1
    eax |= ebx;                             // or eax, ebx
    D1 = eax;                               // mov D1, eax
    esi = A3;                               // mov esi, A3
    ax = *(word *)((byte *)&D1 + 2);        // mov ax, word ptr D1+2
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    writeMemory(esi + 104, 2, ax);          // mov [esi+68h], ax
    ax = D1;                                // mov ax, word ptr D1
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    writeMemory(esi + 106, 2, ax);          // mov [esi+6Ah], ax
    *(word *)&D3 = 6;                       // mov word ptr D3, 6
    *(byte *)&D1 = 0;                       // mov byte ptr D1, 0
    ebx = D0;                               // mov ebx, D0

cseg_56C97:;
    *(byte *)&D2 = bl;                      // mov byte ptr D2, bl
    {
        byte res = *(byte *)&D2 & 15;
        *(byte *)&D2 = res;
    }                                       // and byte ptr D2, 0Fh
    al = D2;                                // mov al, byte ptr D2
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, al
    {
        dword res = ebx >> 4;
        flags.carry = ((dword)ebx >> 28) & 1;
        ebx = res;
    }                                       // shr ebx, 4
    (*(int16_t *)&D3)--;
    flags.overflow = (int16_t)(*(int16_t *)&D3) == INT16_MIN;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_56C97;                    // jns short cseg_56C97

    al = D1;                                // mov al, byte ptr D1
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 108, 1, al);          // mov [esi+6Ch], al
}

// =============== S U B R O U T I N E =======================================
//
void ThirdPartyOfferMenuInit()
{
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[511830];       // mov ax, offerAmount
    bx = 1000;                              // mov bx, 1000
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    Int2Pounds();                           // call Int2Pounds
    A2 = 91736;                             // mov A2, offset managerSexBuffer
    A3 = 91750;                             // mov A3, offset managerSurnameBuffer
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 11650;                             // mov A0, offset aDearAB
    PrintFormatted();                       // call PrintFormatted
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A2 = eax;                               // mov A2, eax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[513010];       // mov ax, offerStatus
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_not_buy_offer;               // jnz short @@not_buy_offer

    A0 = 11669;                             // mov A0, offset aWeHereAtAWishT
    PrintFormatted();                       // call PrintFormatted
    goto l_no_second_line;                  // jmp @@no_second_line

l_not_buy_offer:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub [esi+MenuEntry.y], 8
    A0 = 11706;                             // mov A0, offset aWeHereAtAWis_0
    A3 = 11743;                             // mov A3, offset aOurOfferToBuy
    {
        word src = *(word *)&g_memByte[513010];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp offerStatus, 1
    if (flags.zero)
        goto l_printf_it;                   // jz short @@printf_it

    A0 = 11780;                             // mov A0, offset aWeHereAtAWis_1
    A3 = 11817;                             // mov A3, offset aImproveOurOffe
    {
        word src = *(word *)&g_memByte[513010];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp offerStatus, 2
    if (flags.zero)
        goto l_printf_it;                   // jz short @@printf_it

    A0 = 11965;                             // mov A0, offset aWeHereAtARefus
    A3 = 12002;                             // mov A3, offset aImproveOnOurOf
    {
        word src = *(word *)&g_memByte[513010];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp offerStatus, 3
    if (flags.zero)
        goto l_printf_it;                   // jz short @@printf_it

    A0 = 11891;                             // mov A0, offset aWeHereAtAWithd
    A3 = 11928;                             // mov A3, offset aOfferOn

l_printf_it:;
    push(A2);                               // push A2
    PrintFormatted();                       // call PrintFormatted
    pop(A2);                                // pop A2
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    eax = A3;                               // mov eax, A3
    A0 = eax;                               // mov A0, eax
    PrintFormatted();                       // call PrintFormatted
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub [esi+MenuEntry.y], 8

l_no_second_line:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A2 = eax;                               // mov A2, eax
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 11854;                             // mov A0, offset aFromAInExchang
    PrintFormatted();                       // call PrintFormatted
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_no_extra_players;            // js short @@no_extra_players

    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0

l_no_extra_players:;
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_56F98;                    // js short cseg_56F98

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0

cseg_56F98:;
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_56FD7;                    // js short cseg_56FD7

    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0

cseg_56FD7:;
    ax = *(word *)&g_memByte[513010];       // mov ax, offerStatus
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_have_offer;                  // jns @@have_offer

    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 17;                      // mov word ptr D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 18;                      // mov word ptr D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 12;                      // mov word ptr D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 13;                      // mov word ptr D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 14;                      // mov word ptr D0, 14
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 14;                      // mov word ptr D0, 14
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

l_have_offer:;
    {
        word src = *(word *)&g_memByte[513010];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp offerStatus, 3
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 24, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 50;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 24, 2, src);
    }                                       // add [esi+MenuEntry.dwWidth], 50
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 51;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+MenuEntry.x], 51
    {
        word src = (word)readMemory(esi + 24, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 51;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 24, 2, src);
    }                                       // add [esi+MenuEntry.dwWidth], 51
}

// =============== S U B R O U T I N E =======================================
//
void ThirdPartyOfferViewSquad()
{
    A0 = 92798;                             // mov A0, offset careerTeam
    A1 = 18798;                             // mov A1, offset aViewSquad
    D0 = 0;                                 // mov D0, 0
    A2 = 92302;                             // mov A2, offset playersOnTransferMarket
    ax = *(word *)&g_memByte[92300];        // mov ax, numPlayersOnTransferMarket
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_players_on_transfer_market; // jz short @@no_players_on_transfer_market

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

l_next_player:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D0 |= eax;
    flags.carry = false;                    // or D0, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto l_next_player;                 // jns short @@next_player

l_no_players_on_transfer_market:;
    D1 = 0;                                 // mov D1, 0
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    *(word *)&D3 = -1;                      // mov word ptr D3, -1
    *(word *)&D4 = -1;                      // mov word ptr D4, -1
    ShowSquad();                            // jmp ShowSquad
}

// =============== S U B R O U T I N E =======================================
//
void AcceptOffer()
{
    *(word *)&g_memByte[513012] = 1;        // mov dseg_17AB74, 1
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void RejectOffer()
{
    *(word *)&g_memByte[513012] = 2;        // mov dseg_17AB74, 2
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void AskForMore()
{
    *(word *)&g_memByte[513012] = 3;        // mov dseg_17AB74, 3
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ConsiderOffer()
{
    *(word *)&g_memByte[513012] = 0;        // mov dseg_17AB74, 0
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ThirdPartyOfferMenuExit()
{
    *(word *)&g_memByte[513012] = 0;        // mov dseg_17AB74, 0
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ThirdPartyOfferMenuAfterDrawCommon()
{
    push(D0);                               // push D0
    D0 = 15;                                // mov D0, 15
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 2
    if (flags.carry)
        goto cseg_572EA;                    // jb short cseg_572EA

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_572EA:;
    {
        word res = *(word *)&D7 << 1;
        *(word *)&D7 = res;
    }                                       // shl word ptr D7, 1
    A6 = 0;                                 // mov A6, 0
    A0 = 511822;                            // mov A0, offset dseg_17A6CE
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_57330;                    // js short cseg_57330

    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax

cseg_57330:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    A4 = 0;                                 // mov A4, 0
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 13h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D5 = 13;                      // mov word ptr D5, 0Dh
    *(word *)&D6 = 65535;                   // mov word ptr D6, 0FFFFh
    cseg_54116();                           // call cseg_54116
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 13h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 12;                      // mov word ptr D0, 0Ch
    SWOS::DrawMultipleItems();              // jmp DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void ViewSquadInit()
{
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -1
    if (flags.zero)
        goto cseg_5743F;                    // jz short cseg_5743F

    eax = *(dword *)&g_memByte[511194];     // mov eax, squadTeamPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_5743F;                    // jnz short cseg_5743F

    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 16
    if (flags.zero)
        goto cseg_5743F;                    // jz short cseg_5743F

    *(word *)&D0 = 20;                      // mov word ptr D0, 20
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 17;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 17
    if (flags.carry || flags.zero)
        goto cseg_5743F;                    // jbe short cseg_5743F

    *(word *)&D0 = 21;                      // mov word ptr D0, 21
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0

cseg_5743F:;
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = *(dword *)&g_memByte[511198];     // mov eax, viewSquadTitle
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = *(dword *)&g_memByte[511194];     // mov eax, squadTeamPtr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A1 = eax;                               // mov A1, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    ax = *(word *)&g_memByte[511214];       // mov ax, dseg_17A46E
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_574F5;                    // jz short cseg_574F5

    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

cseg_574F5:;
    ax = *(word *)&g_memByte[511216];       // mov ax, dseg_17A470
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js short @@out

    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 16
    if (flags.carry)
        goto cseg_5752B;                    // jb short cseg_5752B

    *(word *)&D0 = 20;                      // mov word ptr D0, 20
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    return;                                 // retn

cseg_5752B:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 4
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void ViewSquadExitContinue()
{
    *(word *)&g_memByte[511220] = -1;       // mov dseg_17A474, -1
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ViewSquadOnSelect21()
{
    eax = *(dword *)&g_memByte[511194];     // mov eax, squadTeamPtr
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    RotatePlayersLeft();                    // call RotatePlayersLeft
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 20;                                // mov D0, 14h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void ViewSquad21AfterDraw()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 20;                                // mov D0, 14h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    SWOS::DrawMenuItem();                   // jmp DrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void ViewSquadCommon()
{
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[511222] = ax;       // mov dseg_17A476, ax
    eax = *(dword *)&g_memByte[511194];     // mov eax, squadTeamPtr
    A0 = eax;                               // mov A0, eax
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[511220] = ax;       // mov dseg_17A474, ax
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ViewSquadAfterDrawCommon()
{
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 10h
    if (!flags.zero)
        goto cseg_576AB;                    // jnz short cseg_576AB

    *(word *)&D6 = 65535;                   // mov word ptr D6, 0FFFFh

cseg_576AB:;
    eax = *(dword *)&g_memByte[511194];     // mov eax, squadTeamPtr
    A0 = eax;                               // mov A0, eax
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 0);             // mov word ptr [esi+6], 0
    eax = *(dword *)&g_memByte[511206];     // mov eax, dseg_17A466
    D0 = eax;                               // mov D0, eax
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        dword res = D0 & eax;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D0, eax
    if (flags.zero)
        goto cseg_5770E;                    // jz short cseg_5770E

    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1
    *(word *)&D5 = 9;                       // mov word ptr D5, 9

cseg_5770E:;
    eax = *(dword *)&g_memByte[511202];     // mov eax, dseg_17A462
    D0 = eax;                               // mov D0, eax
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        dword res = D0 & eax;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D0, eax
    if (flags.zero)
        goto cseg_57743;                    // jz short cseg_57743

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1
    *(word *)&D5 = 4;                       // mov word ptr D5, 4

cseg_57743:;
    eax = *(dword *)&g_memByte[511210];     // mov eax, dseg_17A46A
    D0 = eax;                               // mov D0, eax
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        dword res = D0 & eax;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D0, eax
    if (flags.zero)
        goto cseg_5776C;                    // jz short cseg_5776C

    *(word *)&D5 = 13;                      // mov word ptr D5, 0Dh

cseg_5776C:;
    ax = *(word *)&g_memByte[511214];       // mov ax, dseg_17A46E
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_57783;                    // jz short cseg_57783

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1

cseg_57783:;
    A4 = 0;                                 // mov A4, 0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    push(D0);                               // push D0
    D0 = 23;                                // mov D0, 17h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    cseg_54116();                           // call cseg_54116
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 23;                                // mov D0, 17h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 12;                      // mov word ptr D0, 0Ch
    SWOS::DrawMultipleItems();              // jmp DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void PlayerOffersInit()
{
    cseg_5834E();                           // call cseg_5834E
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    GetBankBalance();                       // call GetBankBalance
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 5
    A2 = eax;                               // mov A2, eax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    A0 = 11669;                             // mov A0, offset aWeHereAtAWishT
    PrintFormatted();                       // call PrintFormatted
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 5
    A2 = eax;                               // mov A2, eax
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    A0 = 11854;                             // mov A0, offset aFromAInExchang
    PrintFormatted();                       // call PrintFormatted
    cseg_57B61();                           // call cseg_57B61
}

// =============== S U B R O U T I N E =======================================
//
void cseg_57B61()
{
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17227);        // mov dword ptr [esi+26h], offset aPlus
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_57BA1;                    // js short cseg_57BA1

    writeMemory(esi + 38, 4, 17229);        // mov dword ptr [esi+26h], offset aMinus

cseg_57BA1:;
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 0Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 0Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17227);        // mov dword ptr [esi+26h], offset aPlus
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 38, 4, 17227);        // mov dword ptr [esi+26h], offset aPlus
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_57C41;                    // js short cseg_57C41

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17229);        // mov dword ptr [esi+26h], offset aMinus
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_57C41;                    // js short cseg_57C41

    esi = A1;                               // mov esi, A1
    writeMemory(esi + 38, 4, 17229);        // mov dword ptr [esi+26h], offset aMinus

cseg_57C41:;
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_57C80;                    // js short cseg_57C80

    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_57C80:;
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 11;                      // mov word ptr D0, 0Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_57CF3;                    // js short cseg_57CF3

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 11;                      // mov word ptr D0, 0Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_57CF3:;
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js short cseg_57D32

    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
}

// =============== S U B R O U T I N E =======================================
//
void PlayerOffersOnSelect8()
{
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    A1 = 20401;                             // mov A1, offset aSelectPlayerTo
    D0 = 0;                                 // mov D0, 0
    D1 = 0;                                 // mov D1, 0
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    cx = D2;                                // mov cx, word ptr D2
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D0 |= eax;                              // or D0, eax
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_57D9E;                    // js short cseg_57D9E

    *(word *)&g_memByte[511824] = 65535;    // mov numExtraPlayersWanted, 0FFFFh
    goto cseg_57DCC;                        // jmp short cseg_57DCC

cseg_57D9E:;
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    *(word *)&D3 = 65535;                   // mov word ptr D3, 0FFFFh
    *(word *)&D4 = 65535;                   // mov word ptr D4, 0FFFFh
    ShowSquad();                            // call ShowSquad
    if (flags.sign)
        goto cseg_57DCC;                    // js short cseg_57DCC

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[511824] = ax;       // mov numExtraPlayersWanted, ax

cseg_57DCC:;
    cseg_57B61();                           // call cseg_57B61
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void PlayerOffersOnSelect10()
{
    A1 = 20434;                             // mov A1, offset aSelectPlayer_0
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_57E0B;                    // js short cseg_57E0B

    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    *(word *)&g_memByte[511826] = ax;       // mov dseg_17A6D2, ax
    *(word *)&g_memByte[511828] = 65535;    // mov dseg_17A6D4, 0FFFFh
    goto cseg_57EDA;                        // jmp cseg_57EDA

cseg_57E0B:;
    D7 = 0;                                 // mov D7, 0
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_57E29:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_57E6A;                    // jz short cseg_57E6A

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_57E6A;                    // jz short cseg_57E6A

    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+66h], 2
    if (flags.zero)
        goto cseg_57E7E;                    // jz short cseg_57E7E

cseg_57E6A:;
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D7 |= eax;
    flags.carry = false;                    // or D7, eax

cseg_57E7E:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_57E29;                    // jns short cseg_57E29

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = D7;                               // mov eax, D7
    D0 = eax;                               // mov D0, eax
    D1 = 0;                                 // mov D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    *(word *)&D3 = 65535;                   // mov word ptr D3, 0FFFFh
    *(word *)&D4 = 65535;                   // mov word ptr D4, 0FFFFh
    ShowSquad();                            // call ShowSquad
    if (flags.sign)
        goto cseg_57EDA;                    // js short cseg_57EDA

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[511826] = ax;       // mov dseg_17A6D2, ax

cseg_57EDA:;
    cseg_57B61();                           // call cseg_57B61
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void PlayerOffersOnSelect11()
{
    A1 = 20434;                             // mov A1, offset aSelectPlayer_0
    D7 = 0;                                 // mov D7, 0
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    cx = D2;                                // mov cx, word ptr D2
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D7 |= eax;                              // or D7, eax
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_57F37;                    // js short cseg_57F37

    *(word *)&g_memByte[511828] = 65535;    // mov dseg_17A6D4, 0FFFFh
    goto cseg_57FFC;                        // jmp cseg_57FFC

cseg_57F37:;
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_57F4B:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_57F8C;                    // jz short cseg_57F8C

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_57F8C;                    // jz short cseg_57F8C

    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+66h], 2
    if (flags.zero)
        goto cseg_57FA0;                    // jz short cseg_57FA0

cseg_57F8C:;
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D7 |= eax;
    flags.carry = false;                    // or D7, eax

cseg_57FA0:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_57F4B;                    // jns short cseg_57F4B

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = D7;                               // mov eax, D7
    D0 = eax;                               // mov D0, eax
    D1 = 0;                                 // mov D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    *(word *)&D3 = 65535;                   // mov word ptr D3, 0FFFFh
    *(word *)&D4 = 65535;                   // mov word ptr D4, 0FFFFh
    ShowSquad();                            // call ShowSquad
    if (flags.sign)
        goto cseg_57FFC;                    // js short cseg_57FFC

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[511828] = ax;       // mov dseg_17A6D4, ax

cseg_57FFC:;
    cseg_57B61();                           // call cseg_57B61
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void PlayerOffersOnSelect12()
{
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[92312];        // mov ax, dseg_D6F26
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_58072;                    // jnz short cseg_58072

    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[92314];        // mov ax, dseg_D6F28
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_58072;                    // jnz short cseg_58072

    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[92316];        // mov ax, dseg_D6F2A
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_58072;                    // jnz short cseg_58072

    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[92318];        // mov ax, dseg_D6F2C
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_580B3;                    // jz short cseg_580B3

cseg_58072:;
    *(word *)&g_memByte[92320] = 0;         // mov dseg_D6F2E, 0
    {
        word src = *(word *)&g_memByte[92298];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[92298] = src;
    }                                       // sub timeToNegotiate, 1
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&g_memByte[92312] = ax;        // mov dseg_D6F26, ax
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&g_memByte[92314] = ax;        // mov dseg_D6F28, ax
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    *(word *)&g_memByte[92316] = ax;        // mov dseg_D6F2A, ax
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    *(word *)&g_memByte[92318] = ax;        // mov dseg_D6F2C, ax

cseg_580B3:;
    {
        word src = *(word *)&g_memByte[92320];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[92320] = src;
    }                                       // add dseg_D6F2E, 1
    cseg_584D7();                           // call cseg_584D7
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_580E0;                    // js short cseg_580E0

    if (flags.zero)
        goto cseg_580DB;                    // jz short cseg_580DB

    cseg_592D5();                           // call cseg_592D5
    *(word *)&g_memByte[511838] = 1;        // mov dseg_17A6DE, 1

cseg_580DB:;
    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

cseg_580E0:;
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void cseg_580EF()
{
    eax = *(word *)&g_memByte[511830];      // movzx eax, offerAmount
    D1 = eax;                               // mov D1, eax
    eax = *(dword *)&g_memByte[91354];      // mov eax, newBalance
    D2 = eax;                               // mov D2, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.sign)
        goto cseg_58113;                    // jns short cseg_58113

    D2 = 0;                                 // mov D2, 0

cseg_58113:;
    eax = D2;                               // mov eax, D2
    edx = (int32_t)eax < 0 ? -1 : 0;        // cdq
    ebx = 1000;                             // mov ebx, 3E8h
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D2 = eax;                               // mov D2, eax
    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 81h
    if (flags.zero)
        goto cseg_5827A;                    // jz cseg_5827A

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 257;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 101h
    if (flags.zero)
        goto cseg_5827A;                    // jz cseg_5827A

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 65;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 41h
    if (flags.zero)
        goto cseg_58159;                    // jz short cseg_58159

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 513;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 201h
    if (flags.zero)
        goto cseg_58159;                    // jz short cseg_58159

    return;                                 // retn

cseg_58159:;
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 64h
    if (flags.carry || flags.zero)
        goto cseg_581DD;                    // jbe short cseg_581DD

    *(word *)&D0 = 10;                      // mov word ptr D0, 0Ah
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 200;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0C8h
    if (flags.carry || flags.zero)
        goto cseg_581DD;                    // jbe short cseg_581DD

    *(word *)&D0 = 25;                      // mov word ptr D0, 19h
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 300;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 12Ch
    if (flags.carry || flags.zero)
        goto cseg_581DD;                    // jbe short cseg_581DD

    *(word *)&D0 = 50;                      // mov word ptr D0, 32h
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1000;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 3E8h
    if (flags.carry || flags.zero)
        goto cseg_581DD;                    // jbe short cseg_581DD

    *(word *)&D0 = 100;                     // mov word ptr D0, 64h
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2000;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 7D0h
    if (flags.carry || flags.zero)
        goto cseg_581DD;                    // jbe short cseg_581DD

    *(word *)&D0 = 250;                     // mov word ptr D0, 0FAh
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 3000;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0BB8h
    if (flags.carry || flags.zero)
        goto cseg_581DD;                    // jbe short cseg_581DD

    *(word *)&D0 = 500;                     // mov word ptr D0, 1F4h

cseg_581DD:;
    eax = D2;                               // mov eax, D2
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, eax
    if (!flags.zero)
        goto cseg_58259;                    // jnz short cseg_58259

    D3 = eax;                               // mov D3, eax
    {
        dword res = D3 & 65535;
        D3 = res;
    }                                       // and D3, 0FFFFh
    ax = D3;                                // mov ax, word ptr D3
    dx = *(word *)((byte *)&D3 + 2);        // mov dx, word ptr D3+2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D0);
        word rem = (word)(dividend % *(word *)&D0);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D0
    tmp = ax * *(word *)&D0;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D0
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    *(word *)((byte *)&D3 + 2) = dx;        // mov word ptr D3+2, dx
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (flags.zero)
        goto cseg_58259;                    // jz short cseg_58259

    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    goto cseg_58338;                        // jmp cseg_58338

cseg_58259:;
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    if (!flags.carry)
        goto cseg_58338;                    // jnb cseg_58338

    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    goto cseg_58338;                        // jmp cseg_58338

cseg_5827A:;
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 64h
    if (flags.carry)
        goto cseg_582FE;                    // jb short cseg_582FE

    *(word *)&D0 = 10;                      // mov word ptr D0, 0Ah
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 200;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0C8h
    if (flags.carry)
        goto cseg_582FE;                    // jb short cseg_582FE

    *(word *)&D0 = 25;                      // mov word ptr D0, 19h
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 300;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 12Ch
    if (flags.carry)
        goto cseg_582FE;                    // jb short cseg_582FE

    *(word *)&D0 = 50;                      // mov word ptr D0, 32h
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1000;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 3E8h
    if (flags.carry)
        goto cseg_582FE;                    // jb short cseg_582FE

    *(word *)&D0 = 100;                     // mov word ptr D0, 64h
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2000;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 7D0h
    if (flags.carry)
        goto cseg_582FE;                    // jb short cseg_582FE

    *(word *)&D0 = 250;                     // mov word ptr D0, 0FAh
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 3000;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0BB8h
    if (flags.carry)
        goto cseg_582FE;                    // jb short cseg_582FE

    *(word *)&D0 = 500;                     // mov word ptr D0, 1F4h

cseg_582FE:;
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 50000;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0C350h
    if (flags.carry || flags.zero)
        goto cseg_5831F;                    // jbe short cseg_5831F

    *(word *)&D1 = 50000;                   // mov word ptr D1, 0C350h

cseg_5831F:;
    eax = D2;                               // mov eax, D2
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, eax
    if (flags.carry || flags.zero)
        goto cseg_58338;                    // jbe short cseg_58338

    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_58338:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[511830] = ax;       // mov offerAmount, ax
    cseg_5834E();                           // call cseg_5834E
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5834E()
{
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    eax = *(word *)&g_memByte[511830];      // movzx eax, offerAmount
    ebx = 1000;                             // mov ebx, 3E8h
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
        flags.carry = edx != 0 != 0;
    }                                       // mul ebx
    D0 = eax;                               // mov D0, eax
    Int2Pounds();                           // jmp Int2Pounds
}

// =============== S U B R O U T I N E =======================================
//
void PlayerOffersOnSelect13()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void PlayerOffersAfterDrawCommon()
{
    push(D0);                               // push D0
    D0 = 14;                                // mov D0, 0Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 2
    if (flags.carry)
        goto cseg_583FC;                    // jb short cseg_583FC

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_583FC:;
    {
        word res = *(word *)&D7 << 1;
        *(word *)&D7 = res;
    }                                       // shl word ptr D7, 1
    A6 = 0;                                 // mov A6, 0
    A0 = 511822;                            // mov A0, offset dseg_17A6CE
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_58442;                    // js short cseg_58442

    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax

cseg_58442:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    A4 = 0;                                 // mov A4, 0
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 12h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D5 = 13;                      // mov word ptr D5, 0Dh
    *(word *)&D6 = 65535;                   // mov word ptr D6, 0FFFFh
    cseg_54116();                           // call cseg_54116
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 12h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 12;                      // mov word ptr D0, 0Ch
    SWOS::DrawMultipleItems();              // jmp DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void cseg_584D7()
{
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_584F3;                    // js short cseg_584F3

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1

cseg_584F3:;
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_58506;                    // js short cseg_58506

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_58506:;
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_58519;                    // js short cseg_58519

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_58519:;
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 30
    if (flags.carry || flags.zero)
        goto l_num_players_ok;              // jbe short @@num_players_ok

    *(word *)&g_memByte[337240] = 2;        // mov currentMessage, TOO_LARGE_SQUAD
    ShowChairmanMessage();                  // call ShowChairmanMessage
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

l_num_players_ok:;
    SaveRand2State();                       // call SaveRand2State
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    GetPlayerRandomNum();                   // call GetPlayerRandomNum
    Randomize2();                           // call Randomize2
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 16;                                // mov bx, 10h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    D1 = 96;                                // mov D1, 60h
    ax = D1;                                // mov ax, word ptr D1
    dx = *(word *)((byte *)&D1 + 2);        // mov dx, word ptr D1+2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D0);
        word rem = (word)(dividend % *(word *)&D0);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    al = g_memByte[129466];                 // mov al, dseg_E0048
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D1);
        word rem = (word)(dividend % *(word *)&D1);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 ^= ax;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // xor word ptr D0, ax
    Randomize2();                           // call Randomize2
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_58658;                    // js short cseg_58658

    cseg_53F13();                           // call cseg_53F13
    if (flags.zero)
        goto cseg_58E52;                    // jz cseg_58E52

    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_58658;                    // js short cseg_58658

    cseg_53F13();                           // call cseg_53F13
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 2
    if (flags.carry)
        goto cseg_58E52;                    // jb cseg_58E52

cseg_58658:;
    SWOS::Rand2();                          // call Rand2
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[511184] = ax;       // mov dseg_17A450, ax
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[511186] = ax;       // mov dseg_17A452, ax
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_8E23A();                           // call cseg_8E23A
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_586D7;                    // js short cseg_586D7

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_8E23A();                           // call cseg_8E23A
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, ax

cseg_586D7:;
    ax = *(word *)&g_memByte[511830];       // mov ax, offerAmount
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_58865;                    // js cseg_58865

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_8E23A();                           // call cseg_8E23A
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[511184];       // mov ax, dseg_17A450
    bx = 75;                                // mov bx, 4Bh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 50;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 32h
    ax = D1;                                // mov ax, word ptr D1
    tmp = ax * *(word *)&D0;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D0
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_59494();                           // call cseg_59494
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_58865;                    // js cseg_58865

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_8E23A();                           // call cseg_8E23A
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[511186];       // mov ax, dseg_17A452
    bx = 50;                                // mov bx, 32h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 50;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 32h
    ax = D1;                                // mov ax, word ptr D1
    tmp = ax * *(word *)&D0;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D0
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_59494();                           // call cseg_59494
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax

cseg_58865:;
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto cseg_58A69;                    // jz cseg_58A69

    A0 = 92798;                             // mov A0, offset careerTeam
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    ax = D0;                                // mov ax, word ptr D0
    bx = 140;                               // mov bx, 8Ch
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (flags.carry)
        goto cseg_589E9;                    // jb short cseg_589E9

    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_58A69;                    // js cseg_58A69

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayer();                            // call GetPlayer
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.carry)
        goto cseg_58A69;                    // jnb cseg_58A69

cseg_589E9:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 50;                                // mov bx, 32h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 100;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 64h
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D7;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D7
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    nullsub_20();                           // call nullsub_20
    goto cseg_58D21;                        // jmp cseg_58D21

cseg_58A69:;
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_54063();                           // call cseg_54063
    if (!flags.zero)
        goto cseg_58AB4;                    // jnz short cseg_58AB4

    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_58CA6;                    // js cseg_58CA6

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_54063();                           // call cseg_54063
    if (flags.zero)
        goto cseg_58CA6;                    // jz cseg_58CA6

cseg_58AB4:;
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 103, 1);
        byte res = src & 4;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+67h], 4
    if (!flags.zero)
        goto cseg_58BA8;                    // jnz cseg_58BA8

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_58B13;                    // js short cseg_58B13

    GetPlayer();                            // call GetPlayer
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 103, 1);
        byte res = src & 4;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+67h], 4
    if (!flags.zero)
        goto cseg_58BA8;                    // jnz cseg_58BA8

cseg_58B13:;
    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 153;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 99h
    if (!flags.carry)
        goto cseg_58C29;                    // jnb cseg_58C29

    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 100;                               // mov bx, 64h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 150;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 96h
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D7;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D7
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    nullsub_20();                           // call nullsub_20
    goto cseg_58D21;                        // jmp cseg_58D21

cseg_58BA8:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 150;                               // mov bx, 96h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 150;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 96h
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D7;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D7
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    nullsub_20();                           // call nullsub_20
    goto cseg_58D21;                        // jmp cseg_58D21

cseg_58C29:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 40;                                // mov bx, 28h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 95;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 5Fh
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D7;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D7
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    nullsub_20();                           // call nullsub_20
    goto cseg_58D21;                        // jmp short cseg_58D21

cseg_58CA6:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 87;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 57h
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D7;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D7
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    nullsub_20();                           // call nullsub_20

cseg_58D21:;
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (!flags.carry)
        goto cseg_58E44;                    // jnb cseg_58E44

    {
        word src = *(word *)&g_memByte[92320];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6F2E, 3
    if (!flags.carry && !flags.zero)
        goto cseg_58E52;                    // ja cseg_58E52

    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    bx = 100;                               // mov bx, 64h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D5);
        word rem = (word)(dividend % *(word *)&D5);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 14h
    if (!flags.carry)
        goto cseg_58E52;                    // jnb cseg_58E52

    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 10;                                // mov bx, 0Ah
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 100;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 64h
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D5;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D5
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    cseg_59296();                           // call cseg_59296
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, ax
    flags.carry = *(int16_t *)&D4 != 0;
    *(int16_t *)&D4 = -*(int16_t *)&D4;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // neg word ptr D4
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&g_memByte[511188] = ax;       // mov teamWillingToSellOrExchange, ax
    goto cseg_58EFD;                        // jmp cseg_58EFD

cseg_58E44:;
    *(word *)&g_memByte[511188] = 0;        // mov teamWillingToSellOrExchange, 0
    goto cseg_58EFD;                        // jmp cseg_58EFD

cseg_58E52:;
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_54063();                           // call cseg_54063
    if (flags.zero)
        goto cseg_58EA0;                    // jz short cseg_58EA0

    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_58EE4;                    // js short cseg_58EE4

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_54063();                           // call cseg_54063
    if (flags.zero)
        goto cseg_58EC4;                    // jz short cseg_58EC4

    *(word *)&g_memByte[511188] = 2;        // mov teamWillingToSellOrExchange, 2
    goto cseg_58EFD;                        // jmp short cseg_58EFD

cseg_58EA0:;
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_58ED4;                    // js short cseg_58ED4

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_54063();                           // call cseg_54063
    if (flags.zero)
        goto cseg_58EEF;                    // jz short cseg_58EEF

cseg_58EC4:;
    *(word *)&g_memByte[511188] = 4;        // mov teamWillingToSellOrExchange, 4
    cseg_58F21();                           // call cseg_58F21
    goto cseg_58EFD;                        // jmp short cseg_58EFD

cseg_58ED4:;
    *(word *)&g_memByte[511188] = 3;        // mov teamWillingToSellOrExchange, 3
    cseg_58F21();                           // call cseg_58F21
    goto cseg_58EFD;                        // jmp short cseg_58EFD

cseg_58EE4:;
    *(word *)&g_memByte[511188] = 1;        // mov teamWillingToSellOrExchange, 1
    goto cseg_58EFD;                        // jmp short cseg_58EFD

cseg_58EEF:;
    *(word *)&g_memByte[511188] = 4;        // mov teamWillingToSellOrExchange, 4
    cseg_58F21();                           // call cseg_58F21

cseg_58EFD:;
    RestoreRand2State();                    // call RestoreRand2State
    A6 = 514500;                            // mov A6, offset playerTransferMenu
    SWOS::ShowMenu();                       // call ShowMenu
    ax = *(word *)&g_memByte[511190];       // mov ax, dseg_17A456
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_58F21()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_59015();                           // call cseg_59015
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_58FBA;                    // js short cseg_58FBA

    cseg_59015();                           // call cseg_59015

cseg_58FBA:;
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_59015()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_8DF16();                           // call cseg_8DF16
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_8E09A();                           // call cseg_8E09A
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto cseg_5919D;                    // jz short cseg_5919D

    {
        word src = *(word *)&g_memByte[91774];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91774] = src;
    }                                       // add dseg_D6D0C, 1
    return;                                 // retn

cseg_5919D:;
    {
        word src = *(word *)&g_memByte[91772];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91772] = src;
    }                                       // add dseg_D6D0A, 1
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_20()
{
}

// =============== S U B R O U T I N E =======================================
//
void cseg_59296()
{
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_592D4

    A0 = 332160;                            // mov A0, offset avgTeamValueBases

cseg_592AB:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto cseg_592AB;                    // ja short cseg_592AB

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + -2, 2);     // mov ax, [esi-2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_592D5()
{
    cseg_5E2E0();                           // call cseg_5E2E0
    ax = *(word *)&g_memByte[511830];       // mov ax, offerAmount
    bx = 1000;                              // mov bx, 3E8h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        dword src = *(dword *)&g_memByte[91354];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        src = res;
        *(dword *)&g_memByte[91354] = src;
    }                                       // sub newBalance, eax
    {
        dword src = *(dword *)&g_memByte[91362];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(dword *)&g_memByte[91362] = src;
    }                                       // add playerPurchases, eax
    cseg_3B7F8();                           // call cseg_3B7F8
    cseg_3B842();                           // call cseg_3B842
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5938B;                    // js short cseg_5938B

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    cseg_56379();                           // call cseg_56379
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_56129();                           // call cseg_56129
    goto cseg_593A8;                        // jmp short cseg_593A8

cseg_5938B:;
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_56379();                           // call cseg_56379

cseg_593A8:;
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_593E4;                    // jns short cseg_593E4

    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5946C;                    // js cseg_5946C

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_56129();                           // call cseg_56129
    goto cseg_5946C;                        // jmp cseg_5946C

cseg_593E4:;
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5944F;                    // js short cseg_5944F

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    cseg_56379();                           // call cseg_56379
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_56129();                           // call cseg_56129
    goto cseg_5946C;                        // jmp short cseg_5946C

cseg_5944F:;
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_56379();                           // call cseg_56379

cseg_5946C:;
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 59, 1, 1);            // mov byte ptr [esi+3Bh], 1
    g_memByte[92857] = 1;                   // mov careerTeam+3Bh, 1
    cseg_547AC();                           // call cseg_547AC
}

// =============== S U B R O U T I N E =======================================
//
void cseg_59494()
{
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_5952F

    A0 = 332160;                            // mov A0, offset avgTeamValueBases

cseg_594AD:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto cseg_594AD;                    // ja short cseg_594AD

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + -2, 2);     // mov ax, [esi-2]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + -4, 2);     // mov ax, [esi-4]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1
    ax = (word)readMemory(esi + -4, 2);     // mov ax, [esi-4]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto cseg_5951F;                    // jb short cseg_5951F

    ax = (word)readMemory(esi + -2, 2);     // mov ax, [esi-2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    return;                                 // retn

cseg_5951F:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + -4, 2);     // mov ax, [esi-4]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
}

// =============== S U B R O U T I N E =======================================
//
void TransferPlayerInit()
{
    {
        word src = *(word *)&g_memByte[511188];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamWillingToSellOrExchange, 1
    if (flags.carry)
        goto cseg_59586;                    // jb short cseg_59586

    {
        word src = *(word *)&g_memByte[511188];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamWillingToSellOrExchange, 4
    if (!flags.carry && !flags.zero)
        goto cseg_59586;                    // ja short cseg_59586

    *(word *)&D0 = 10;                      // mov word ptr D0, 0Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 0Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 60;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub word ptr [esi+14h], 3Ch
    goto cseg_595ED;                        // jmp short cseg_595ED

cseg_59586:;
    ax = *(word *)&g_memByte[511188];       // mov ax, teamWillingToSellOrExchange
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_595ED;                    // jnz short cseg_595ED

    *(word *)&D0 = 10;                      // mov word ptr D0, 0Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 11;                      // mov word ptr D0, 0Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 12;                      // mov word ptr D0, 0Ch
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 12;                      // mov word ptr D0, 0Ch
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

cseg_595ED:;
    A2 = 91736;                             // mov A2, offset managerSexBuffer
    A3 = 91750;                             // mov A3, offset managerSurnameBuffer
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 11650;                             // mov A0, offset aDearAB
    PrintFormatted();                       // call PrintFormatted
    A4 = 515062;                            // mov A4, offset sellExchangeStrings
    ax = *(word *)&g_memByte[511188];       // mov ax, teamWillingToSellOrExchange
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_59655;                    // jz short cseg_59655

    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 8;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 8

cseg_59655:;
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_59667;                    // js short cseg_59667

    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // add A4, 4

cseg_59667:;
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 5
    A2 = eax;                               // mov A2, eax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    PrintFormatted();                       // call PrintFormatted
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 5
    A2 = eax;                               // mov A2, eax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    A0 = 12187;                             // mov A0, offset aInADealWithAFo
    PrintFormatted();                       // call PrintFormatted
    ax = *(word *)&g_memByte[511188];       // mov ax, teamWillingToSellOrExchange
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_597FC;                    // jns cseg_597FC

    *(int16_t *)&D0 = -*(int16_t *)&D0;     // neg word ptr D0
    A1 = 316574;                            // mov A1, offset fundsBuffer
    ax = D0;                                // mov ax, word ptr D0
    bx = 1000;                              // mov bx, 3E8h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    Int2Pounds();                           // call Int2Pounds
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    A2 = 316574;                            // mov A2, offset fundsBuffer
    A0 = 12644;                             // mov A0, offset aUnlessTheOffer
    PrintFormatted();                       // call PrintFormatted
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    A2 = 316574;                            // mov A2, offset fundsBuffer
    A0 = 12680;                             // mov A0, offset dseg_C3817
    PrintFormatted();                       // call PrintFormatted
    goto cseg_598C9;                        // jmp cseg_598C9

cseg_597FC:;
    A4 = 515078;                            // mov A4, offset dseg_17B386
    {
        word res = *(word *)&D0 << 3;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 3
    eax = A4;                               // mov eax, A4
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A4 = eax;                               // mov A4, eax
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi, 4);               // mov eax, [esi]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_59874;                    // jz short cseg_59874

    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    StringCopy();                           // call StringCopy

cseg_59874:;
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 4, 4);           // mov eax, [esi+4]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_598C9;                    // jz short cseg_598C9

    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 4, 4);           // mov eax, [esi+4]
    A0 = eax;                               // mov A0, eax
    StringCopy();                           // call StringCopy

cseg_598C9:;
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[511830];       // mov ax, offerAmount
    bx = 1000;                              // mov bx, 3E8h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    Int2Pounds();                           // call Int2Pounds
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5995C;                    // js short cseg_5995C

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_5995C:;
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5999B;                    // js short cseg_5999B

    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_5999B:;
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js short cseg_599DA

    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
}

// =============== S U B R O U T I N E =======================================
//
void TransferPlayerOnSelect10()
{
    *(word *)&g_memByte[511190] = 65535;    // mov dseg_17A456, 0FFFFh
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void TransferPlayerOnSelect11()
{
    *(word *)&g_memByte[511190] = 0;        // mov dseg_17A456, 0
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void TransferPlayerOnSelect12()
{
    *(word *)&g_memByte[511190] = 1;        // mov dseg_17A456, 1
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void TransferPlayerAfterDrawCommon()
{
    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 0Dh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 2
    if (flags.carry)
        goto cseg_59A66;                    // jb short cseg_59A66

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_59A66:;
    {
        word res = *(word *)&D7 << 1;
        *(word *)&D7 = res;
    }                                       // shl word ptr D7, 1
    A6 = 0;                                 // mov A6, 0
    A0 = 511822;                            // mov A0, offset dseg_17A6CE
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_59AAC;                    // js short cseg_59AAC

    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax

cseg_59AAC:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    A4 = 0;                                 // mov A4, 0
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 11h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D5 = 13;                      // mov word ptr D5, 0Dh
    *(word *)&D6 = 65535;                   // mov word ptr D6, 0FFFFh
    cseg_54116();                           // call cseg_54116
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 11h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 12;                      // mov word ptr D0, 0Ch
    SWOS::DrawMultipleItems();              // jmp DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void cseg_59B41()
{
    *(word *)&g_memByte[515942] = 65535;    // mov dseg_17B6E6, 0FFFFh
    *(word *)&g_memByte[515944] = 65535;    // mov dseg_17B6E8, 0FFFFh
    *(word *)&g_memByte[515946] = 65535;    // mov dseg_17B6EA, 0FFFFh
    *(word *)&g_memByte[515948] = 6;        // mov dseg_17B6EC, 6
    *(word *)&g_memByte[515954] = 0;        // mov dseg_17B6F2, 0
    *(word *)&g_memByte[515952] = 0;        // mov dseg_17B6F0, 0
    *(word *)&g_memByte[515950] = 0;        // mov dseg_17B6EE, 0

    ShowPlayerMarket();
}

// =============== S U B R O U T I N E =======================================
//
void ShowPlayerMarket()
{
    A1 = 20301;                             // mov A1, offset aPlayersOnForei
    ax = *(word *)&g_memByte[511836];       // mov ax, showDomesticPlayerMarket
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_59BA1;                    // jz short cseg_59BA1

    A1 = 20270;                             // mov A1, offset aPlayersOnDomes

cseg_59BA1:;
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A1;                               // mov eax, A1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    GetBankBalance();                       // call GetBankBalance
    cseg_59E7C();                           // call cseg_59E7C
}

// =============== S U B R O U T I N E =======================================
//
void cseg_59BFE()
{
    {
        word src = *(word *)&g_memByte[515942];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[515942] = src;
    }                                       // add dseg_17B6E6, 1
    {
        word src = *(word *)&g_memByte[515942];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_17B6E6, 4
    if (!flags.zero)
        goto cseg_59C19;                    // jnz short cseg_59C19

    *(word *)&g_memByte[515942] = 65535;    // mov dseg_17B6E6, 0FFFFh

cseg_59C19:;
    cseg_59E31();                           // call cseg_59E31
    cseg_59E62();                           // jmp cseg_59E62
}

// =============== S U B R O U T I N E =======================================
//
void cseg_59CA2()
{
    {
        word src = *(word *)&g_memByte[515946];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[515946] = src;
    }                                       // add dseg_17B6EA, 1
    {
        word src = *(word *)&g_memByte[515946];
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_17B6EA, 7
    if (!flags.zero)
        goto cseg_59CBD;                    // jnz short cseg_59CBD

    *(word *)&g_memByte[515946] = 65535;    // mov dseg_17B6EA, 0FFFFh

cseg_59CBD:;
    cseg_59E31();                           // call cseg_59E31
    cseg_59E62();                           // jmp cseg_59E62
}

// =============== S U B R O U T I N E =======================================
//
void cseg_59CC7()
{
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax = *(word *)&g_memByte[515954];       // mov ax, dseg_17B6F2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_59D0D;                    // jz short cseg_59D0D

    ax = *(word *)&g_memByte[515950];       // mov ax, dseg_17B6EE
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ah
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto cseg_59D0D;                    // jb short cseg_59D0D

    *(word *)&D0 = 0;                       // mov word ptr D0, 0

cseg_59D0D:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[515950] = ax;       // mov dseg_17B6EE, ax
    cseg_5A227();                           // call cseg_5A227
    cseg_59D28();                           // call cseg_59D28
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_59D28()
{
    ax = *(word *)&g_memByte[515954];       // mov ax, dseg_17B6F2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[515950];       // mov ax, dseg_17B6EE
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ah
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_59D80;                    // jnb short cseg_59D80

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 20384);        // mov dword ptr [esi+26h], offset aMore
    return;                                 // retn

cseg_59D80:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 20367);        // mov dword ptr [esi+26h], offset aList
}

// =============== S U B R O U T I N E =======================================
//
void cseg_59D8E()
{
    A0 = 92798;                             // mov A0, offset careerTeam
    A1 = 18798;                             // mov A1, offset aViewSquad
    D0 = 0;                                 // mov D0, 0
    A2 = 92302;                             // mov A2, offset playersOnTransferMarket
    ax = *(word *)&g_memByte[92300];        // mov ax, numPlayersOnTransferMarket
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_59E02;                    // jz short cseg_59E02

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_59DCF:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D0 |= eax;
    flags.carry = false;                    // or D0, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_59DCF;                    // jns short cseg_59DCF

cseg_59E02:;
    D1 = 0;                                 // mov D1, 0
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    *(word *)&D3 = 65535;                   // mov word ptr D3, 0FFFFh
    *(word *)&D4 = 65535;                   // mov word ptr D4, 0FFFFh
    ShowSquad();                            // jmp ShowSquad
}

// =============== S U B R O U T I N E =======================================
//
void jmp_SetExitMenuFlag_9()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void cseg_59E31()
{
    ax = *(word *)&g_memByte[515954];       // mov ax, dseg_17B6F2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_59E61

    *(word *)&g_memByte[515954] = 0;        // mov dseg_17B6F2, 0
    *(word *)&g_memByte[515952] = 0;        // mov dseg_17B6F0, 0
    *(word *)&g_memByte[515950] = 0;        // mov dseg_17B6EE, 0
    cseg_59D28();                           // call cseg_59D28
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_59E62()
{
    cseg_59E7C();                           // call cseg_59E7C
    A0 = 4149;                              // mov A0, offset cseg_59E76
    nullsub_17();                           // jmp nullsub_17
}

// =============== S U B R O U T I N E =======================================
//
void cseg_59E7C()
{
    ax = *(word *)&g_memByte[515942];       // mov ax, dseg_17B6E6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_59EF4;                    // jz short cseg_59EF4

    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 13;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Dh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 0);             // mov word ptr [esi+6], 0
    return;                                 // retn

cseg_59EF4:;
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_59F61()
{
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    A0 = 515958;                            // mov A0, offset dseg_17B6F6
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_54C1E();                           // call cseg_54C1E
    ax = *(word *)&g_memByte[511838];       // mov ax, dseg_17A6DE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5A003;                    // jz short cseg_5A003

    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

cseg_5A003:;
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    cseg_59E31();                           // call cseg_59E31
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5A017()
{
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 0);             // mov word ptr [esi+6], 0
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 0Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, ax
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    ax = *(word *)&g_memByte[515952];       // mov ax, dseg_17B6F0
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (flags.carry)
        goto cseg_5A092;                    // jb short cseg_5A092

    A6 = 0;                                 // mov A6, 0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1
    goto cseg_5A199;                        // jmp cseg_5A199

cseg_5A092:;
    A6 = 515958;                            // mov A6, offset dseg_17B6F6
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A6 = eax;                               // mov A6, eax
    ax = *(word *)&g_memByte[511836];       // mov ax, showDomesticPlayerMarket
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5A151;                    // jz cseg_5A151

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    A4 = eax;                               // mov A4, eax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    A6 = eax;                               // mov A6, eax
    goto cseg_5A199;                        // jmp short cseg_5A199

cseg_5A151:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    cseg_5A666();                           // call cseg_5A666
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 3;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 3
    A4 = eax;                               // mov A4, eax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = -56;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0FFFFFFC8h
    A6 = eax;                               // mov A6, eax

cseg_5A199:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    ax = *(word *)&g_memByte[515950];       // mov ax, dseg_17B6EE
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    push(D0);                               // push D0
    D0 = 20;                                // mov D0, 14h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    cseg_54116();                           // call cseg_54116
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 20;                                // mov D0, 14h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 12;                      // mov word ptr D0, 0Ch
    SWOS::DrawMultipleItems();              // jmp DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5A227()
{
    A6 = 0;                                 // mov A6, 0
    ax = *(word *)&g_memByte[515942];       // mov ax, dseg_17B6E6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5A269;                    // js short cseg_5A269

    A6 = 515914;                            // mov A6, offset dseg_17B6CA
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A6 = eax;                               // mov A6, eax

cseg_5A269:;
    ax = *(word *)&g_memByte[515946];       // mov ax, dseg_17B6EA
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5A2A0;                    // js short cseg_5A2A0

    *(word *)&D6 = 6;                       // mov word ptr D6, 6
    ax = *(word *)&g_memByte[515946];       // mov ax, dseg_17B6EA
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, ax
    {
        word res = *(word *)&D6 << 2;
        *(word *)&D6 = res;
    }                                       // shl word ptr D6, 2
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 3

cseg_5A2A0:;
    ax = *(word *)&g_memByte[515944];       // mov ax, dseg_17B6E8
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5A2D0;                    // js short cseg_5A2D0

    A0 = 332493;                            // mov A0, offset dseg_113C07
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al

cseg_5A2D0:;
    ax = *(word *)&g_memByte[511836];       // mov ax, showDomesticPlayerMarket
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_5A310;                    // jnz short cseg_5A310

    ax = *(word *)&g_memByte[515948];       // mov ax, dseg_17B6EC
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 6
    if (flags.zero)
        goto cseg_5A310;                    // jz short cseg_5A310

    A5 = 26324;                             // mov A5, (offset shortCountryNames+1CBh)
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    goto cseg_5A31A;                        // jmp short cseg_5A31A

cseg_5A310:;
    A5 = 0;                                 // mov A5, 0

cseg_5A31A:;
    *(word *)&g_memByte[515954] = 0;        // mov dseg_17B6F2, 0
    *(word *)&g_memByte[515952] = 0;        // mov dseg_17B6F0, 0
    A3 = 515958;                            // mov A3, offset dseg_17B6F6
    ax = *(word *)&g_memByte[511836];       // mov ax, showDomesticPlayerMarket
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5A42E;                    // jz cseg_5A42E

    A1 = 91848;                             // mov A1, offset homeMarketPlayers
    ax = *(word *)&g_memByte[91784];        // mov ax, numHomeMarketPlayers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_5A42D

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_5A36C:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, eax
    cseg_5A4FE();                           // call cseg_5A4FE
    if (!flags.zero)
        goto cseg_5A419;                    // jnz short cseg_5A419

    {
        word src = *(word *)&g_memByte[515954];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[515954] = src;
    }                                       // add dseg_17B6F2, 1
    ax = *(word *)&g_memByte[515950];       // mov ax, dseg_17B6EE
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[515954];       // mov ax, dseg_17B6F2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_5A419;                    // jnb short cseg_5A419

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ah
    ax = *(word *)&g_memByte[515954];       // mov ax, dseg_17B6F2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto cseg_5A419;                    // jb short cseg_5A419

    eax = A1;                               // mov eax, A1
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 4
    {
        word src = *(word *)&g_memByte[515952];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[515952] = src;
    }                                       // add dseg_17B6F0, 1

cseg_5A419:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 4
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_5A36C;                    // jns cseg_5A36C

cseg_5A42D:;
    return;                                 // retn

cseg_5A42E:;
    A1 = 91788;                             // mov A1, offset foreignMarketPlayers
    ax = *(word *)&g_memByte[91782];        // mov ax, numForeignMarketPlayers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_5A42D

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_5A451:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    push(D2);                               // push D2
    cseg_5A666();                           // call cseg_5A666
    pop(D2);                                // pop D2
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = -56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 0FFFFFFC8h
    A0 = eax;                               // mov A0, eax
    cseg_5A4FE();                           // call cseg_5A4FE
    if (!flags.zero)
        goto cseg_5A4E9;                    // jnz short cseg_5A4E9

    {
        word src = *(word *)&g_memByte[515954];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[515954] = src;
    }                                       // add dseg_17B6F2, 1
    ax = *(word *)&g_memByte[515950];       // mov ax, dseg_17B6EE
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[515954];       // mov ax, dseg_17B6F2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_5A4E9;                    // jnb short cseg_5A4E9

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ah
    ax = *(word *)&g_memByte[515954];       // mov ax, dseg_17B6F2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto cseg_5A4E9;                    // jb short cseg_5A4E9

    eax = A1;                               // mov eax, A1
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 4
    {
        word src = *(word *)&g_memByte[515952];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[515952] = src;
    }                                       // add dseg_17B6F0, 1

cseg_5A4E9:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 4
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_5A451;                    // jns cseg_5A451
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5A4FE()
{
    ax = D4;                                // mov ax, word ptr D4
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5A53C;                    // js short cseg_5A53C

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D4;                                // mov al, byte ptr D4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 6;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 6
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_5A655;                    // jg cseg_5A655

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 250;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 0FAh
    if (flags.sign != flags.overflow)
        goto cseg_5A655;                    // jl cseg_5A655

cseg_5A53C:;
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A5, 0
    if (flags.zero)
        goto cseg_5A57C;                    // jz short cseg_5A57C

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 76, 1);     // mov al, [esi+4Ch]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_5A655;                    // jb cseg_5A655

    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.carry)
        goto cseg_5A655;                    // jnb cseg_5A655

cseg_5A57C:;
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, 0
    if (flags.zero)
        goto cseg_5A5D4;                    // jz short cseg_5A5D4

    eax = A6;                               // mov eax, A6
    A2 = eax;                               // mov A2, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5

cseg_5A5AE:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_5A655;                    // js cseg_5A655

    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto cseg_5A5AE;                    // jnz short cseg_5A5AE

cseg_5A5D4:;
    ax = *(word *)&g_memByte[515942];       // mov ax, dseg_17B6E6
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5A648;                    // jz short cseg_5A648

    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5A648;                    // js short cseg_5A648

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 0
    if (flags.zero)
        goto cseg_5A655;                    // jz short cseg_5A655

    ax = (word)readMemory(esi + 104, 2);    // mov ax, [esi+68h]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)((byte *)&D0 + 2) = ax;        // mov word ptr D0+2, ax
    ax = (word)readMemory(esi + 106, 2);    // mov ax, [esi+6Ah]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ebx = D0;                               // mov ebx, D0
    cx = D6;                                // mov cx, word ptr D6
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        dword res = eax & ebx;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test eax, ebx
    if (flags.zero)
        goto cseg_5A655;                    // jz short cseg_5A655

cseg_5A648:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

cseg_5A655:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5A666()
{
    A0 = 200159;                            // mov A0, offset g_joy1Fire1

cseg_5A670:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 58;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 58
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_5A670;                    // jnz short cseg_5A670

    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_5A670;                    // jnz short cseg_5A670
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5A6A1()
{
    A0 = 92798;                             // mov A0, offset careerTeam
    A1 = 380186;                            // mov A1, offset dseg_11FB02
    *(word *)&D0 = 683;                     // mov word ptr D0, 683

cseg_5A6BE:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_5A6BE;                    // jns short cseg_5A6BE

    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 60
    A2 = eax;                               // mov A2, eax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

cseg_5A6F9:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    pop(D1);                                // pop D1
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 76
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 38
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A1 = 380262;                            // mov A1, offset dseg_11FB4E
    eax = A1;                               // mov eax, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    *(word *)&D0 = 37;                      // mov word ptr D0, 25h

cseg_5A783:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_5A783;                    // jns short cseg_5A783

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 10h
    if (!flags.zero)
        goto cseg_5A6F9;                    // jnz cseg_5A6F9

    A0 = 380186;                            // mov A0, offset dseg_11FB02
    A1 = 92798;                             // mov A1, offset careerTeam
    *(word *)&D0 = 683;                     // mov word ptr D0, 2ABh

cseg_5A7DB:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_5A7DB;                    // jns short cseg_5A7DB

    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 3Ch
    A0 = eax;                               // mov A0, eax
    A1 = 92766;                             // mov A1, offset currentMatchPlayers
    *(word *)&D0 = 15;                      // mov word ptr D0, 0Fh

cseg_5A820:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_5A820;                    // jns short cseg_5A820

    *(word *)&g_memByte[94090] = 16;        // mov careerNumPlayers, 10h
    *(word *)&D2 = 15;                      // mov word ptr D2, 0Fh

cseg_5A857:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 253;
        src = res;
        writeMemory(esi + 102, 1, src);
    }                                       // and byte ptr [esi+66h], 0FDh
    writeMemory(esi + 103, 1, 0);           // mov byte ptr [esi+67h], 0
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 254;
        src = res;
        writeMemory(esi + 102, 1, src);
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and byte ptr [esi+66h], 0FEh
    writeMemory(esi + 113, 1, 0);           // mov byte ptr [esi+71h], 0
    AddCareerPoolPlayer();                  // call AddCareerPoolPlayer
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_5A857;                    // jns short cseg_5A857

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SearchTeamInTmdFile();                  // call SearchTeamInTmdFile
    if (!flags.zero)
        return;                             // jnz short cseg_5A8DD

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_9423A();                           // call cseg_9423A
    A0 = 92798;                             // mov A0, offset careerTeam
    cseg_94193();                           // call cseg_94193
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5A8DE()
{
_l_start:;
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { nullsub_35(); return; }           // jnz nullsub_35

    ax = *(word *)&g_memByte[91780];        // mov ax, dseg_D6D12
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        { nullsub_35(); return; }           // jz nullsub_35

    {
        word src = *(word *)&g_memByte[91780];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91780] = src;
    }                                       // sub dseg_D6D12, 1
    cseg_5A90B();                           // call cseg_5A90B
    goto _l_start;                          // jmp short cseg_5A8DE
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5A90B()
{
    cseg_53F13();                           // call cseg_53F13
    if (flags.zero)
        { nullsub_35(); return; }           // jz nullsub_35

    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5A977;                    // jz short cseg_5A977

    A1 = 91948;                             // mov A1, offset dseg_D6DBA
    *(word *)&D2 = 0;                       // mov word ptr D2, 0

cseg_5A934:;
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 12, 1, src);
    }                                       // sub byte ptr [esi+0Ch], 1
    if (!flags.zero)
        goto cseg_5A953;                    // jnz short cseg_5A953

    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_53E64();                           // call cseg_53E64
    goto cseg_5A968;                        // jmp short cseg_5A968

cseg_5A953:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 14;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0Eh
    A1 = eax;                               // mov A1, eax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1

cseg_5A968:;
    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_5A934;                    // jnz short cseg_5A934

cseg_5A977:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[94090];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1

cseg_5A9C3:;
    {
        word src = *(word *)&g_memByte[91786];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numOffers, 5
    if (flags.zero)
        { nullsub_35(); return; }           // jz nullsub_35

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+66h], 2
    if (!flags.zero)
        goto cseg_5AB08;                    // jnz cseg_5AB08

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_5AB08;                    // jz cseg_5AB08

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_5AB08;                    // jz cseg_5AB08

    *(word *)&D3 = 1;                       // mov word ptr D3, 1
    cseg_53FAE();                           // call cseg_53FAE
    if (!flags.zero)
        goto cseg_5AA37;                    // jnz short cseg_5AA37

    *(word *)&D3 = 11;                      // mov word ptr D3, 0Bh

cseg_5AA37:;
    SWOS::Rand2();                          // call Rand2
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_5AB08;                    // jnb cseg_5AB08

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_5AB36();                           // call cseg_5AB36
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

cseg_5AB08:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.zero)
        goto cseg_5AB28;                    // jnz short cseg_5AB28

    *(word *)&D7 = 0;                       // mov word ptr D7, 0

cseg_5AB28:;
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto cseg_5A9C3;                    // jns cseg_5A9C3

    nullsub_35();
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_35()
{
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5AB36()
{
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[511822] = ax;       // mov dseg_17A6CE, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    cseg_8E23A();                           // call cseg_8E23A
    pop(D1);                                // pop D1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[492337] = ax;       // mov dseg_175032, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayer();                            // call GetPlayer
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    *(word *)&D0 = 65535;                   // mov word ptr D0, 0FFFFh
    IsPlayerInjured();                      // call IsPlayerInjured
    if (!flags.zero)
        return;                             // jnz cseg_5B3B4

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0E0h
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[492331] = ax;       // mov dseg_17502C, ax
    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 8
    if (flags.carry)
        goto cseg_5AC75;                    // jb cseg_5AC75

    {
        word src = *(word *)&g_memByte[337186];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[337186] = src;
    }                                       // add writeOnlyCareerVar001, 1
    A2 = 492341;                            // mov A2, offset dseg_175036
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A5 = eax;                               // mov A5, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    *(word *)&D4 = 0;                       // mov word ptr D4, 0

cseg_5AC0C:;
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.zero)
        goto cseg_5AC4A;                    // jnz short cseg_5AC4A

    cseg_5B3B5();                           // call cseg_5B3B5
    if (!flags.zero)
        goto cseg_5AC4A;                    // jnz short cseg_5AC4A

    al = D4;                                // mov al, byte ptr D4
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D5;                     // movzx ebx, word ptr D5
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 1

cseg_5AC4A:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2ACh
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 1
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (!flags.zero)
        goto cseg_5AC0C;                    // jnz short cseg_5AC0C

    goto cseg_5AD11;                        // jmp cseg_5AD11

cseg_5AC75:;
    {
        word src = *(word *)&g_memByte[337188];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[337188] = src;
    }                                       // add dseg_114EAE, 1
    A2 = 492341;                            // mov A2, offset dseg_175036
    A5 = 36608;                             // mov A5, offset tmdFileBuffer
    A0 = 36608;                             // mov A0, offset tmdFileBuffer
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    *(word *)&D4 = 0;                       // mov word ptr D4, 0

cseg_5ACAD:;
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (flags.zero)
        goto cseg_5ACEB;                    // jz short cseg_5ACEB

    cseg_5B3B5();                           // call cseg_5B3B5
    if (!flags.zero)
        goto cseg_5ACEB;                    // jnz short cseg_5ACEB

    al = D4;                                // mov al, byte ptr D4
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D5;                     // movzx ebx, word ptr D5
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 1

cseg_5ACEB:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2ACh
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 1
    ax = *(word *)&g_memByte[36606];        // mov ax, careerFileBuffer
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (!flags.zero)
        goto cseg_5ACAD;                    // jnz short cseg_5ACAD

cseg_5AD11:;
    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_5B3B4

    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D5;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    bx = 684;                               // mov bx, 2ACh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A5;                               // mov eax, A5
    A0 = eax;                               // mov A0, eax
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, eax
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_5B687();                           // call cseg_5B687
    if (flags.zero)
        return;                             // jz cseg_5B3B4

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[511820] = ax;       // mov teamOffering, ax
    *(word *)&g_memByte[492333] = 65535;    // mov dseg_17502E, 0FFFFh
    *(word *)&g_memByte[511824] = 65535;    // mov numExtraPlayersWanted, 0FFFFh
    cseg_53F13();                           // call cseg_53F13
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 2
    if (flags.carry)
        goto cseg_5AEC1;                    // jb cseg_5AEC1

    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 19h
    if (!flags.carry)
        goto cseg_5AEC1;                    // jnb cseg_5AEC1

    cseg_5B468();                           // call cseg_5B468
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[511824] = ax;       // mov numExtraPlayersWanted, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5AEC1;                    // js cseg_5AEC1

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    cseg_5B687();                           // call cseg_5B687
    if (!flags.zero)
        goto cseg_5AE4F;                    // jnz short cseg_5AE4F

    *(word *)&g_memByte[511824] = 65535;    // mov numExtraPlayersWanted, 0FFFFh
    goto cseg_5AEC1;                        // jmp short cseg_5AEC1

cseg_5AE4F:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    cseg_8E23A();                           // call cseg_8E23A
    pop(D1);                                // pop D1
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[492337];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[492337] = src;
    }                                       // add dseg_175032, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayer();                            // call GetPlayer
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0E0h
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[492333] = ax;       // mov dseg_17502E, ax
    *(word *)&D0 = 65535;                   // mov word ptr D0, 0FFFFh
    IsPlayerInjured();                      // call IsPlayerInjured
    if (!flags.zero)
        return;                             // jnz cseg_5B3B4

cseg_5AEC1:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 35;                                // mov bx, 23h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 85;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 55h
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[492337];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul dseg_175032
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[492335] = ax;       // mov dseg_175030, ax
    *(word *)&g_memByte[492339] = 0;        // mov dseg_175034, 0
    *(word *)&g_memByte[511826] = 65535;    // mov dseg_17A6D2, 0FFFFh
    *(word *)&g_memByte[511828] = 65535;    // mov dseg_17A6D4, 0FFFFh
    cseg_53EF9();                           // call cseg_53EF9
    if (flags.zero)
        goto cseg_5B090;                    // jz cseg_5B090

    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 19h
    if (!flags.carry)
        goto cseg_5B090;                    // jnb cseg_5B090

    *(word *)&D6 = 65535;                   // mov word ptr D6, 0FFFFh
    ax = *(word *)&g_memByte[492331];       // mov ax, dseg_17502C
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    cseg_5B518();                           // call cseg_5B518
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5B090;                    // js cseg_5B090

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    cseg_8E23A();                           // call cseg_8E23A
    pop(D1);                                // pop D1
    ax = *(word *)&g_memByte[492335];       // mov ax, dseg_175030
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto cseg_5B090;                    // ja cseg_5B090

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[492339] = ax;       // mov dseg_175034, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[511826] = ax;       // mov dseg_17A6D2, ax
    cseg_53EF9();                           // call cseg_53EF9
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 2
    if (flags.carry)
        goto cseg_5B090;                    // jb cseg_5B090

    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 19h
    if (!flags.carry)
        goto cseg_5B090;                    // jnb cseg_5B090

    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = *(word *)&g_memByte[492333];       // mov ax, dseg_17502E
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    cseg_5B518();                           // call cseg_5B518
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5B090;                    // js short cseg_5B090

    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    cseg_8E23A();                           // call cseg_8E23A
    pop(D1);                                // pop D1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[492339];       // mov ax, dseg_175034
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    ax = *(word *)&g_memByte[492335];       // mov ax, dseg_175030
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.carry && !flags.zero)
        goto cseg_5B090;                    // ja short cseg_5B090

    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[492339];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[492339] = src;
    }                                       // add dseg_175034, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[511828] = ax;       // mov dseg_17A6D4, ax

cseg_5B090:;
    ax = *(word *)&g_memByte[492335];       // mov ax, dseg_175030
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[492339];       // mov ax, dseg_175034
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = *(word *)&g_memByte[492335];       // mov ax, dseg_175030
    bx = 15;                                // mov bx, 0Fh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_5B108;                    // jnb short cseg_5B108

    *(word *)&D0 = 0;                       // mov word ptr D0, 0

cseg_5B108:;
    cseg_59494();                           // call cseg_59494
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[511830] = ax;       // mov offerAmount, ax
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D0, 1
    if (flags.zero)
        goto cseg_5B251;                    // jz cseg_5B251

    ax = D0;                                // mov ax, word ptr D0
    bx = 20;                                // mov bx, 14h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 105;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 69h
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[511830];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul offerAmount
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    cseg_59494();                           // call cseg_59494
    ax = *(word *)&g_memByte[511830];       // mov ax, offerAmount
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_5B251;                    // jz cseg_5B251

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[511832] = ax;       // mov dseg_17A6D8, ax
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D0, 1
    if (flags.zero)
        goto cseg_5B25A;                    // jz cseg_5B25A

    ax = D0;                                // mov ax, word ptr D0
    bx = 20;                                // mov bx, 14h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 105;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 69h
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[511832];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul dseg_17A6D8
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    cseg_59494();                           // call cseg_59494
    ax = *(word *)&g_memByte[511832];       // mov ax, dseg_17A6D8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_5B25A;                    // jz short cseg_5B25A

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[511834] = ax;       // mov dseg_17A6DA, ax
    goto cseg_5B263;                        // jmp short cseg_5B263

cseg_5B251:;
    *(word *)&g_memByte[511832] = 0;        // mov dseg_17A6D8, 0

cseg_5B25A:;
    *(word *)&g_memByte[511834] = 0;        // mov dseg_17A6DA, 0

cseg_5B263:;
    *(word *)&D0 = 65535;                   // mov word ptr D0, 0FFFFh
    ax = *(word *)&g_memByte[511824];       // mov ax, numExtraPlayersWanted
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5B27F;                    // js short cseg_5B27F

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_5B27F:;
    ax = *(word *)&g_memByte[511826];       // mov ax, dseg_17A6D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5B2A5;                    // js short cseg_5B2A5

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = *(word *)&g_memByte[511828];       // mov ax, dseg_17A6D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5B2A5;                    // js short cseg_5B2A5

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1

cseg_5B2A5:;
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1Eh
    if (!flags.carry && !flags.zero)
        return;                             // ja cseg_5B3B4

    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    bx = 14;                                // mov bx, 0Eh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A5 = 91948;                             // mov A5, offset dseg_D6DBA
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A5 = res;
    }                                       // add A5, eax
    ax = *(word *)&g_memByte[511830];       // mov ax, offerAmount
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, ax);            // mov [esi+6], ax
    ax = *(word *)&g_memByte[511832];       // mov ax, dseg_17A6D8
    writeMemory(esi + 8, 2, ax);            // mov [esi+8], ax
    ax = *(word *)&g_memByte[511834];       // mov ax, dseg_17A6DA
    writeMemory(esi + 10, 2, ax);           // mov [esi+0Ah], ax
    ax = *(word *)&g_memByte[511820];       // mov ax, teamOffering
    writeMemory(esi, 2, ax);                // mov [esi], ax
    al = g_memByte[511822];                 // mov al, byte ptr dseg_17A6CE
    writeMemory(esi + 2, 1, al);            // mov [esi+2], al
    al = g_memByte[511824];                 // mov al, byte ptr numExtraPlayersWanted
    writeMemory(esi + 3, 1, al);            // mov [esi+3], al
    al = g_memByte[511826];                 // mov al, byte ptr dseg_17A6D2
    writeMemory(esi + 4, 1, al);            // mov [esi+4], al
    al = g_memByte[511828];                 // mov al, byte ptr dseg_17A6D4
    writeMemory(esi + 5, 1, al);            // mov [esi+5], al
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0Fh
    A0 = 511038;                            // mov A0, offset dseg_17A3BE
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 12, 1, al);           // mov [esi+0Ch], al
    writeMemory(esi + 13, 1, 0);            // mov byte ptr [esi+0Dh], 0
    {
        word src = *(word *)&g_memByte[91786];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91786] = src;
    }                                       // add numOffers, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5B3B5()
{
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto cseg_5B457;                    // jz cseg_5B457

    {
        byte src = (byte)readMemory(esi + 25, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 4;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+19h], 4
    if (flags.zero)
        goto cseg_5B457;                    // jz short cseg_5B457

    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    *(word *)&D1 = 15;                      // mov word ptr D1, 0Fh

cseg_5B403:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, al
    if (flags.zero)
        return;                             // jz short cseg_5B467

    if (!flags.carry && !flags.zero)
        goto cseg_5B41E;                    // ja short cseg_5B41E

    *(word *)&D2 |= 1;                      // or word ptr D2, 1

cseg_5B41E:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, al
    if (flags.carry)
        goto cseg_5B437;                    // jb short cseg_5B437

    *(word *)&D2 |= 2;                      // or word ptr D2, 2

cseg_5B437:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 3
    if (flags.zero)
        return;                             // jz short cseg_5B467

    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 38;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 26h
    A1 = eax;                               // mov A1, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_5B403;                    // jns short cseg_5B403

cseg_5B457:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5B468()
{
    *(word *)&D2 = 15;                      // mov word ptr D2, 0Fh

cseg_5B471:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[94090];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        flags.carry = ((word)*(word *)&D0 >> 8) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    ax = *(word *)&g_memByte[511822];       // mov ax, dseg_17A6CE
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        goto cseg_5B4FA;                    // jz short cseg_5B4FA

    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+66h], 2
    if (!flags.zero)
        goto cseg_5B4FA;                    // jnz short cseg_5B4FA

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_5B4FA;                    // jz short cseg_5B4FA

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_5B4FA;                    // jz short cseg_5B4FA

    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, al
    if (flags.carry)
        goto cseg_5B4FA;                    // jb short cseg_5B4FA

    return;                                 // retn

cseg_5B4FA:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_5B471;                    // jns cseg_5B471

    *(word *)&D1 = 65535;                   // mov word ptr D1, 0FFFFh
    ax = 65535;                             // mov ax, 0FFFFh
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5B518()
{
    *(word *)&D3 = 255;                     // mov word ptr D3, 0FFh
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_5B53E:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D3;                                // mov al, byte ptr D3
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.carry)
        goto cseg_5B580;                    // jnb short cseg_5B580

    al = D0;                                // mov al, byte ptr D0
    *(byte *)&D3 = al;                      // mov byte ptr D3, al

cseg_5B580:;
    al = D4;                                // mov al, byte ptr D4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry || flags.zero)
        goto cseg_5B597;                    // jbe short cseg_5B597

    al = D0;                                // mov al, byte ptr D0
    *(byte *)&D4 = al;                      // mov byte ptr D4, al

cseg_5B597:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_5B53E;                    // jns short cseg_5B53E

    *(word *)&D2 = 15;                      // mov word ptr D2, 0Fh

cseg_5B5A9:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 16;                                // mov bx, 10h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_5B669;                    // jz cseg_5B669

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A6;                               // mov eax, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+66h], 2
    if (!flags.zero)
        goto cseg_5B669;                    // jnz short cseg_5B669

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_5B669;                    // jz short cseg_5B669

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_5B669;                    // jz short cseg_5B669

    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D3;                                // mov al, byte ptr D3
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_5B669;                    // jb short cseg_5B669

    al = D4;                                // mov al, byte ptr D4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.carry && !flags.zero)
        goto cseg_5B669;                    // ja short cseg_5B669

    return;                                 // retn

cseg_5B669:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_5B5A9;                    // jns cseg_5B5A9

    *(word *)&D1 = 65535;                   // mov word ptr D1, 0FFFFh
    ax = 65535;                             // mov ax, 0FFFFh
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5B687()
{
    ax = *(word *)&g_memByte[91786];        // mov ax, numOffers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5B6F4;                    // jz short cseg_5B6F4

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1
    A1 = 91948;                             // mov A1, offset dseg_D6DBA

cseg_5B6AA:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_5B6DE;                    // jnz short cseg_5B6DE

    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        return;                             // jz short cseg_5B704

    al = (byte)readMemory(esi + 3, 1);      // mov al, [esi+3]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        return;                             // jz short cseg_5B704

cseg_5B6DE:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 14;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 0Eh
    A1 = eax;                               // mov A1, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_5B6AA;                    // jns short cseg_5B6AA

cseg_5B6F4:;
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5B705()
{
    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, -1
    if (!flags.zero)
        return;                             // jnz @@out

    {
        word src = *(word *)&g_memByte[92018];
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6E00, 7
    if (flags.zero)
        return;                             // jz @@out

    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        return;                             // jz @@out

    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        return;                             // jz @@out

    {
        word src = *(word *)&g_memByte[91330];
        int16_t dstSigned = src;
        int16_t srcSigned = 19;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp currentSeasonShowing, 19
    if (flags.zero)
        return;                             // jz @@out

    {
        word src = *(word *)&g_memByte[511054];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_17A3CE, 1
    if (flags.zero)
        goto l_sacked;                      // jz @@sacked

    {
        word src = *(word *)&g_memByte[511054];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_17A3CE, 2
    if (flags.zero)
        goto cseg_5B7F7;                    // jz cseg_5B7F7

    *(word *)&D1 = 128;                     // mov word ptr D1, 128
    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_sacked;                      // jnz @@sacked

    al = g_memByte[129466];                 // mov al, dseg_E0048
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = g_memByte[109913];                 // mov al, dseg_DB3E6+1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    {
        word src = *(word *)&g_memByte[91668];
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / src);
        word rem = (word)(dividend % src);
        ax = quot;
        dx = rem;
    }                                       // div dseg_D6CA2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 3
    if (!flags.zero)
        return;                             // jnz @@out

cseg_5B7F7:;
    ax = *(word *)&g_memByte[91684];        // mov ax, dseg_D6CB2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_5B93B;                    // jnz cseg_5B93B

    ax = *(word *)&g_memByte[91680];        // mov ax, lastNationalityCall
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -1
    if (flags.zero)
        goto cseg_5B93B;                    // jz cseg_5B93B

    {
        word src = *(word *)&g_memByte[511054];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_17A3CE, 2
    if (flags.zero)
        goto cseg_5B839;                    // jz short cseg_5B839

    ax = *(word *)&g_memByte[91596];        // mov ax, dseg_D6C5A
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5B93B;                    // jz cseg_5B93B

cseg_5B839:;
    IsNewJobOffer();                        // call IsNewJobOffer
    if (flags.zero)
        goto cseg_5B93B;                    // jz cseg_5B93B

    IsOldJobOffer();                        // call IsOldJobOffer
    if (flags.zero)
        goto cseg_5B93B;                    // jz cseg_5B93B

    {
        word src = *(word *)&g_memByte[511054];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_17A3CE, 2
    if (flags.zero)
        goto cseg_5B915;                    // jz cseg_5B915

    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_3D5A7();                           // call cseg_3D5A7
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 200;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 200
    if (flags.sign != flags.overflow)
        goto cseg_5B93B;                    // jl short cseg_5B93B

cseg_5B915:;
    ax = *(word *)&g_memByte[91680];        // mov ax, lastNationalityCall
    ah ^= ah;
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ah & 0x80) != 0;
    flags.zero = ah == 0;                   // xor ah, ah
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_5C304();                           // call cseg_5C304
    if (flags.zero)
        goto cseg_5B93B;                    // jz short cseg_5B93B

    ax = *(word *)&g_memByte[91680];        // mov ax, lastNationalityCall
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    goto l_add_new_international_job_offer; // jmp @@add_new_international_job_offer

cseg_5B93B:;
    {
        word src = *(word *)&g_memByte[511054];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_17A3CE, 2
    if (flags.zero)
        return;                             // jz @@out

    SWOS::Rand();                           // call Rand

l_sacked:;
    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5B975;                    // jz short cseg_5B975

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5B975;                    // jz short cseg_5B975

    ax = *(word *)&g_memByte[91686];        // mov ax, dseg_D6CB4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    goto cseg_5BBD5;                        // jmp cseg_5BBD5

cseg_5B975:;
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5B991;                    // jz short cseg_5B991

    ax = *(word *)&g_memByte[91688];        // mov ax, dseg_D6CB6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    goto cseg_5BBD5;                        // jmp cseg_5BBD5

cseg_5B991:;
    al = g_memByte[126615];                 // mov al, dseg_DF525
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    bx = 75;                                // mov bx, 75
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)((byte *)&D6 + 2) = dx;        // mov word ptr D6+2, dx
    ax = D0;                                // mov ax, word ptr D0
    bx = 150;                               // mov bx, 150
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    A6 = 126568;                            // mov A6, offset competitionFileBuffer
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D0);                               // push D0
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    FindTeamInDIY();                        // call FindTeamInDIY
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    bx = 100;                               // mov bx, 100
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[126617];       // mov ax, numDiyTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = D1;                                // mov ax, word ptr D1
    {
        int32_t dividend = ((int16_t)dx << 16) | (int16_t)ax;
        int16_t quot = (int16_t)(dividend / *(int16_t *)&D0);
        int16_t rem = (int16_t)(dividend % *(int16_t *)&D0);
        ax = quot;
        dx = rem;
    }                                       // idiv word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    *(word *)&D2 = 100;                     // mov word ptr D2, 100
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D2;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_5BBD5;                    // jnz short cseg_5BBD5

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[91686] = ax;        // mov dseg_D6CB4, ax
    *(word *)&g_memByte[91688] = ax;        // mov dseg_D6CB6, ax

cseg_5BBD5:;
    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_5BC35;                    // jnz short cseg_5BC35

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    bx = 75;                                // mov bx, 75
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)((byte *)&D6 + 2) = dx;        // mov word ptr D6+2, dx
    goto cseg_5BC88;                        // jmp short cseg_5BC88

cseg_5BC35:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    bx = 0;                                 // mov bx, 0
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)((byte *)&D6 + 2) = dx;        // mov word ptr D6+2, dx

cseg_5BC88:;
    {
        word src = *(word *)&g_memByte[511054];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_17A3CE, 1
    if (flags.zero)
        goto l_national_selector_outer_loop; // jz @@national_selector_outer_loop

    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_decide_job_offer;            // jz short @@decide_job_offer

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_5C196;                    // jnz cseg_5C196

l_decide_job_offer:;
    SWOS::Rand();                           // call Rand
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 21;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 21
    if (!flags.carry)
        goto l_club_call;                   // jnb short @@club_call

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_national_selector_outer_loop; // jnz @@national_selector_outer_loop

    SWOS::Rand();                           // call Rand
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 85;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 85
    if (!flags.carry)
        goto l_club_job_offer;              // jnb @@club_job_offer

    IsPlayerOkForNationalSelector();        // call IsPlayerOkForNationalSelector
    if (!flags.zero)
        goto l_national_selector_outer_loop; // jnz @@national_selector_outer_loop

    goto l_club_job_offer;                  // jmp @@club_job_offer

l_club_call:;
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)&D5 = 99;                      // mov word ptr D5, 99

l_diy_job_offers_loop:;
    SWOS::Rand();                           // call Rand
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[131757];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax
    ax = D0;                                // mov ax, word ptr D0
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 25, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 4;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.league], 4
    if (flags.zero)
        goto l_diy_next_attempt;            // jz @@diy_next_attempt

    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi, 1);          // mov al, [esi+TeamFile.countryNumber]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto l_diy_next_attempt;            // jnz @@diy_next_attempt

    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (flags.zero)
        goto l_diy_next_attempt;            // jz @@diy_next_attempt

    push(A0);                               // push A0
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    pop(A0);                                // pop A0
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto l_diy_next_attempt;            // jb @@diy_next_attempt

    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto l_diy_next_attempt;            // ja @@diy_next_attempt

    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    push(A0);                               // push A0
    IsNewJobOffer();                        // call IsNewJobOffer
    pop(A0);                                // pop A0
    if (flags.zero)
        goto l_diy_next_attempt;            // jz @@diy_next_attempt

    push(A0);                               // push A0
    IsOldJobOffer();                        // call IsOldJobOffer
    pop(A0);                                // pop A0
    if (flags.zero)
        goto l_diy_next_attempt;            // jz @@diy_next_attempt

    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 25, 1);     // mov al, [esi+TeamFile.league]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto l_add_new_club_job_offer;      // jnz @@add_new_club_job_offer

    A6 = 126568;                            // mov A6, offset competitionFileBuffer
    push(D0);                               // push D0
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    FindTeamInDIY();                        // call FindTeamInDIY
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[126651];       // mov ax, dseg_DF549
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[126653];       // mov ax, dseg_DF54B
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.carry)
        goto l_diy_next_attempt;            // jb short @@diy_next_attempt

    goto l_add_new_club_job_offer;          // jmp @@add_new_club_job_offer

l_diy_next_attempt:;
    (*(int16_t *)&D5)--;
    flags.overflow = (int16_t)(*(int16_t *)&D5) == INT16_MIN;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto l_diy_job_offers_loop;         // jns @@diy_job_offers_loop

    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    goto l_club_job_offer;                  // jmp short @@club_job_offer

    return;                                 // retn

l_club_job_offer:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)&D5 = 99;                      // mov word ptr D5, 99

l_club_offers_loop:;
    SWOS::Rand();                           // call Rand
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[36606];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul careerFileBuffer
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    A0 = 36608;                             // mov A0, offset tmdFileBuffer
    ax = D0;                                // mov ax, word ptr D0
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 25, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 4;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.league], 4
    if (flags.zero)
        goto l_next_attempt;                // jz @@next_attempt

    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi, 1);          // mov al, [esi+TeamFile.countryNumber]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto l_next_attempt;                // jz short @@next_attempt

    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (flags.zero)
        goto l_next_attempt;                // jz short @@next_attempt

    push(A0);                               // push A0
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    pop(A0);                                // pop A0
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto l_next_attempt;                // jb short @@next_attempt

    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto l_next_attempt;                // ja short @@next_attempt

    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    IsNewJobOffer();                        // call IsNewJobOffer
    if (flags.zero)
        goto l_next_attempt;                // jz short @@next_attempt

    IsOldJobOffer();                        // call IsOldJobOffer
    if (flags.zero)
        goto l_next_attempt;                // jz short @@next_attempt

    goto l_add_new_club_job_offer;          // jmp @@add_new_club_job_offer

l_next_attempt:;
    (*(int16_t *)&D5)--;
    flags.overflow = (int16_t)(*(int16_t *)&D5) == INT16_MIN;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto l_club_offers_loop;            // jns @@club_offers_loop

    return;                                 // retn

l_national_selector_outer_loop:;
    *(word *)&D5 = 99;                      // mov word ptr D5, 99

l_new_rand_loop:;
    SWOS::Rand();                           // call Rand
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[456668];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul nat_teams_rand_limit1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        dword res = D0 >> 8;
        D0 = res;
    }                                       // shr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    bx = 6;                                 // mov bx, 6
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A0 = 456674;                            // mov A0, offset nationalTeams
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+4]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto l_dont_send_offer;             // jb short @@dont_send_offer

    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto l_dont_send_offer;             // ja short @@dont_send_offer

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (flags.zero)
        goto l_dont_send_offer;             // jz short @@dont_send_offer

    ax = *(word *)&g_memByte[91680];        // mov ax, lastNationalityCall
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (flags.zero)
        goto l_dont_send_offer;             // jz short @@dont_send_offer

    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_5C304();                           // call cseg_5C304
    if (flags.zero)
        goto l_dont_send_offer;             // jz short @@dont_send_offer

    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    IsNewJobOffer();                        // call IsNewJobOffer
    if (flags.zero)
        goto l_dont_send_offer;             // jz short @@dont_send_offer

    IsOldJobOffer();                        // call IsOldJobOffer
    if (flags.zero)
        goto l_dont_send_offer;             // jz short @@dont_send_offer

    goto l_add_new_international_job_offer; // jmp @@add_new_international_job_offer

l_dont_send_offer:;
    (*(int16_t *)&D5)--;
    flags.overflow = (int16_t)(*(int16_t *)&D5) == INT16_MIN;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto l_new_rand_loop;               // jns @@new_rand_loop

    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 8
    if (!flags.sign)
        goto l_national_selector_outer_loop; // jns @@national_selector_outer_loop

    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    goto l_national_selector_outer_loop;    // jmp @@national_selector_outer_loop

cseg_5C196:;
    al = g_memByte[91690];                  // mov al, dseg_D6CB8
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    LoadTeamFile();                         // call LoadTeamFile
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        word res = *(word *)&D6 >> 1;
        flags.carry = ((word)*(word *)&D6 >> 15) & 1;
        flags.overflow = (((*(word *)&D6 >> 15) & 1)) != 0;
        *(word *)&D6 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D6, 1

cseg_5C1B8:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)&D5 = 99;                      // mov word ptr D5, 99

cseg_5C1CD:;
    SWOS::Rand();                           // call Rand
    ax = D0;                                // mov ax, word ptr D0
    bx = *(word *)&g_memByte[252466];       // mov bx, word ptr teamFileBuffer
    {
        byte tmp = bl;
        bl = bh;
        bh = tmp;
    }                                       // xchg bh, bl
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    A0 = 252468;                            // mov A0, (offset teamFileBuffer+2)
    ax = D0;                                // mov ax, word ptr D0
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 25, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 4;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.league], 4
    if (flags.zero)
        goto cseg_5C2AA;                    // jz short cseg_5C2AA

    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    push(A0);                               // push A0
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    pop(A0);                                // pop A0
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto cseg_5C2AA;                    // jb short cseg_5C2AA

    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto cseg_5C2AA;                    // ja short cseg_5C2AA

    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(A0);                               // push A0
    IsNewJobOffer();                        // call IsNewJobOffer
    pop(A0);                                // pop A0
    if (flags.zero)
        goto cseg_5C2AA;                    // jz short cseg_5C2AA

    push(A0);                               // push A0
    IsOldJobOffer();                        // call IsOldJobOffer
    pop(A0);                                // pop A0
    if (flags.zero)
        goto cseg_5C2AA;                    // jz short cseg_5C2AA

    goto l_add_new_club_job_offer;          // jmp short @@add_new_club_job_offer

cseg_5C2AA:;
    (*(int16_t *)&D5)--;
    flags.overflow = (int16_t)(*(int16_t *)&D5) == INT16_MIN;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto cseg_5C1CD;                    // jns cseg_5C1CD

    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 8
    if (!flags.sign)
        goto cseg_5C1B8;                    // jns cseg_5C1B8

    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    goto cseg_5C1B8;                        // jmp cseg_5C1B8

l_add_new_international_job_offer:;
    D1 = -1;                                // mov D1, -1
    { AddJobOffer(); return; }              // jmp AddJobOffer

l_add_new_club_job_offer:;
    push(D0);                               // push D0
    CalculateStartingBalance();             // call CalculateStartingBalance
    pop(D0);                                // pop D0
    AddJobOffer();                          // call AddJobOffer
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5C304()
{
    ax = *(word *)&g_memByte[511054];       // mov ax, dseg_17A3CE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_5C31D;                    // jnz short cseg_5C31D

    {
        word src = *(word *)&g_memByte[91330];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp currentSeasonShowing, 3
    if (flags.carry)
        { NotOkForNationalSelector(); return; } // jb NotOkForNationalSelector

cseg_5C31D:;
    eax = *(dword *)&g_memByte[33925];      // mov eax, dseg_C8B14
    D1 = eax;                               // mov D1, eax
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 80
    if (flags.zero)
        goto cseg_5C33A;                    // jz short cseg_5C33A

    eax = *(dword *)&g_memByte[33929];      // mov eax, dseg_C8B18
    D1 = eax;                               // mov D1, eax

cseg_5C33A:;
    ax = *(word *)&g_memByte[91330];        // mov ax, currentSeasonShowing
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cx = D0;                                // mov cx, word ptr D0
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        word res = *(word *)&D1 & ax;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D1, ax
}

// =============== S U B R O U T I N E =======================================

// out:
//      zero flag: clear = ok, set = not ok
//
void IsPlayerOkForNationalSelector()
{
    ax = *(word *)&g_memByte[511054];       // mov ax, dseg_17A3CE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_5C371;                    // jnz short cseg_5C371

    {
        word src = *(word *)&g_memByte[91330];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp currentSeasonShowing, 3
    if (flags.carry)
        { NotOkForNationalSelector(); return; } // jb short NotOkForNationalSelector

cseg_5C371:;
    ax = *(word *)&g_memByte[91330];        // mov ax, currentSeasonShowing
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(dword *)&g_memByte[33925];      // mov eax, dseg_C8B14
    D1 = eax;                               // mov D1, eax
    cx = D0;                                // mov cx, word ptr D0
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        word res = *(word *)&D1 & ax;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D1, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    eax = *(dword *)&g_memByte[33929];      // mov eax, dseg_C8B18
    D1 = eax;                               // mov D1, eax
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        word res = *(word *)&D1 & ax;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D1, ax
}

// =============== S U B R O U T I N E =======================================
//
void NotOkForNationalSelector()
{
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5C3CB()
{
    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_5C41A

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_5C3E4:;
    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 20h
    if (!flags.carry)
        goto cseg_5C411;                    // jnb short cseg_5C411

    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetNewJobOfferPtr();                    // call GetNewJobOfferPtr
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 4, 0);            // mov dword ptr [esi+14h], 0

cseg_5C411:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_5C3E4;                    // jns short cseg_5C3E4
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team file number and ordinal
// out:
//      D1 - nationality
//      D2 - team file index
//
// Ends program if team is not in nationalities array.
//
void GetNationalityAndTeamFile()
{
    GetNationalityRecordPtr();              // call GetNationalityRecordPtr
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        goto l_fatal_error;                 // jz short @@fatal_error

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 3, 1);      // mov al, [esi+3]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    return;                                 // retn

l_fatal_error:;
    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0 -
// out:
//     D0 -
//
void cseg_5C46D()
{
    A0 = 456674;                            // mov A0, offset nationalTeams
    ax = *(word *)&g_memByte[456670];       // mov ax, numNationalTeams
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

l_next_team:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 3, 1);      // mov al, [esi+3]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto l_got_a_match;                 // jz short @@got_a_match

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 6;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 6
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_next_team;                   // jns short @@next_team

    *(word *)&D0 = -1;                      // mov word ptr D0, -1
    return;                                 // retn

l_got_a_match:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - player nationality
// out:
//      D0 - team file number that contains national team and number
//           of team in file (all in one word), or -1 if not found in national teams
//
void GetNationalTeamNumber()
{
    A0 = 456674;                            // mov A0, offset nationalTeams
    ax = *(word *)&g_memByte[456670];       // mov ax, numNationalTeams
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

l_next_nationality:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto l_found_a_match;               // jz short @@found_a_match

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 6;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 6
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_next_nationality;            // jns short @@next_nationality

    *(word *)&D0 = -1;                      // mov word ptr D0, -1
    return;                                 // retn

l_found_a_match:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team file number and ordinal
// out:
//      A0 -> nationality record in nationalities array, or null if not found
//
void GetNationalityRecordPtr()
{
    A0 = 456674;                            // mov A0, offset nationalTeams
    ax = *(word *)&g_memByte[456670];       // mov ax, numNationalTeams
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

l_next_record:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        return;                             // jz short @@out

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 6;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 6
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_next_record;                 // jns short @@next_record

    A0 = 0;                                 // mov A0, 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5C57C()
{
    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

l_next_offer:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetNewJobOfferPtr();                    // call GetNewJobOfferPtr
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 2, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = -1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+2], -1
    if (!flags.zero)
        goto l_skip_offer;                  // jnz short @@skip_offer

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 2
    A1 = eax;                               // mov A1, eax
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A0 = eax;                               // mov A0, eax
    StringCopy();                           // call StringCopy

l_skip_offer:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto l_next_offer;                  // jns short @@next_offer
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5C5EF()
{
    push(A0);                               // push A0
    push(A1);                               // push A1
    ax = D3;                                // mov ax, word ptr D3
    bx = 17;                                // mov bx, 11h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A1 = 92426;                             // mov A1, offset dseg_D6F98
    eax = A1;                               // mov eax, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    StringCopy();                           // call StringCopy
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    A2 = 92346;                             // mov A2, offset dseg_D6F48
    {
        word res = *(word *)&D3 << 2;
        *(word *)&D3 = res;
    }                                       // shl word ptr D3, 2
    ax = D2;                                // mov ax, word ptr D2
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    writeMemory(esi + ebx, 2, ax);          // mov [esi+ebx], ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + ebx + 2, 2, ax);      // mov [esi+ebx+2], ax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+4Eh]
    push(ax);                               // push ax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4Ch
    A0 = eax;                               // mov A0, eax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4Ch
    A1 = eax;                               // mov A1, eax
    *(word *)&D0 = 18;                      // mov word ptr D0, 12h

cseg_5C6C8:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_5C6C8;                    // jns short cseg_5C6C8

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = -114;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 0FFFFFF8Eh
    {
        int32_t val = stack[stackTop++];
        ax = val;
    }                                       // pop ax
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al
    writeMemory(esi + 109, 1, 0);           // mov byte ptr [esi+6Dh], 0
    writeMemory(esi + 110, 1, 0);           // mov byte ptr [esi+6Eh], 0
    writeMemory(esi + 111, 1, 0);           // mov byte ptr [esi+6Fh], 0
    writeMemory(esi + 112, 1, 0);           // mov byte ptr [esi+70h], 0
    A0 = 92798;                             // mov A0, offset careerTeam
    push(D1);                               // push D1
    SetBenchPlayersNumbers();               // call SetBenchPlayersNumbers
    pop(D1);                                // pop D1
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0
//
void cseg_5C72F()
{
    *(word *)&g_memByte[511028] = 65535;    // mov dseg_17A3B4, 0FFFFh
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_5C783;                    // jnz short cseg_5C783

    A0 = 6354;                              // mov A0, offset aAddInternation
    al = g_memByte[91683];                  // mov al, dseg_D6CB1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    A1 = -7;                                // mov A1, offset AddInternationalPlayerHome
    cseg_4C83A();                           // call cseg_4C83A
    goto cseg_5C79C;                        // jmp short cseg_5C79C

cseg_5C783:;
    A0 = 6386;                              // mov A0, offset aAddInternati_0
    A1 = -6;                                // mov A1, offset AddInternationalPlayerAbroad
    ChooseTeamsDialog();                    // call ChooseTeamsDialog

cseg_5C79C:;
    ax = *(word *)&g_memByte[511028];       // mov ax, dseg_17A3B4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(dword *)&g_memByte[511030];     // mov eax, dseg_17A3B6
    A5 = eax;                               // mov A5, eax
    eax = *(dword *)&g_memByte[511034];     // mov eax, dseg_17A3BA
    A2 = eax;                               // mov A2, eax
}

// =============== S U B R O U T I N E =======================================
//
void AddInternationalPlayerHome()
{
    A1 = 6354;                              // mov A1, offset aAddInternation
    cseg_5C7D3();                           // jmp short cseg_5C7D3
}

// =============== S U B R O U T I N E =======================================
//
void AddInternationalPlayerAbroad()
{
    A1 = 6386;                              // mov A1, offset aAddInternati_0

    cseg_5C7D3();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5C7D3()
{
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&g_memByte[511024] = ax;       // mov dseg_17A3B0, ax
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    GetTeamPointer();                       // call GetTeamPointer
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    A2 = eax;                               // mov A2, eax
    al = g_memByte[91682];                  // mov al, dseg_D6CB0
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D2 = 0;                       // mov word ptr D2, 0

cseg_5C8C4:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 76, 1);     // mov al, [esi+4Ch]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_5C94F;                    // jnz short cseg_5C94F

    A3 = 92330;                             // mov A3, offset dseg_D6F38
    *(word *)&D4 = 3;                       // mov word ptr D4, 3

cseg_5C8EC:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_5C93F;                    // jnz short cseg_5C93F

    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_5C93F;                    // jnz short cseg_5C93F

    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    {
        word res = *(word *)&D4 & 65532;
        *(word *)&D4 = res;
    }                                       // and word ptr D4, 0FFFCh
    *(word *)&D4 |= 8;
    flags.carry = false;
    flags.sign = (*(word *)&D4 & 0x8000) != 0;
    flags.zero = *(word *)&D4 == 0;         // or word ptr D4, 8
    al = D4;                                // mov al, byte ptr D4
    writeMemory(esi + 103, 1, al);          // mov [esi+67h], al
    goto cseg_5C94F;                        // jmp short cseg_5C94F

cseg_5C93F:;
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A3 = res;
    }                                       // add A3, 4
    (*(int16_t *)&D4)--;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto cseg_5C8EC;                    // jns short cseg_5C8EC

cseg_5C94F:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 38;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 26h
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 10h
    if (!flags.zero)
        goto cseg_5C8C4;                    // jnz cseg_5C8C4

    eax = A0;                               // mov eax, A0
    A2 = eax;                               // mov A2, eax
    D0 = 0;                                 // mov D0, 0
    al = g_memByte[91682];                  // mov al, dseg_D6CB0
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    *(word *)&D2 = 0;                       // mov word ptr D2, 0

cseg_5C993:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 76, 1);     // mov al, [esi+4Ch]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto cseg_5C9B8;                    // jz short cseg_5C9B8

    cx = D2;                                // mov cx, word ptr D2
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D0 |= eax;                              // or D0, eax

cseg_5C9B8:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 38;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 26h
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 10h
    if (!flags.zero)
        goto cseg_5C993;                    // jnz short cseg_5C993

    D4 = 0;                                 // mov D4, 0
    A2 = 92346;                             // mov A2, offset dseg_D6F48
    ax = *(word *)&g_memByte[511024];       // mov ax, dseg_17A3B0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D2 = 19;                      // mov word ptr D2, 13h

cseg_5C9FA:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto cseg_5CA44;                    // jnz short cseg_5CA44

    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    cx = D3;                                // mov cx, word ptr D3
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D0 |= eax;                              // or D0, eax
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D4 |= eax;                              // or D4, eax

cseg_5CA44:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A2 = res;
    }                                       // add A2, 4
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_5C9FA;                    // jns short cseg_5C9FA

    *(word *)&g_memByte[511028] = 65535;    // mov dseg_17A3B4, 0FFFFh
    *(word *)&g_memByte[330670] = 0;        // mov dseg_113491, 0
    D1 = 0;                                 // mov D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    *(word *)&D3 = 65535;                   // mov word ptr D3, 0FFFFh
    push(A0);                               // push A0
    cseg_53F2D();                           // call cseg_53F2D
    pop(A0);                                // pop A0
    if (flags.sign)
        return;                             // js cseg_5CC6E

    *(word *)&g_memByte[330670] = 1;        // mov dseg_113491, 1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[511026] = ax;       // mov dseg_17A3B2, ax
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    A2 = eax;                               // mov A2, eax
    eax = A5;                               // mov eax, A5
    *(dword *)&g_memByte[511030] = eax;     // mov dseg_17A3B6, eax
    eax = A2;                               // mov eax, A2
    *(dword *)&g_memByte[511034] = eax;     // mov dseg_17A3BA, eax
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    {
        word res = *(word *)&D6 & 224;
        *(word *)&D6 = res;
    }                                       // and word ptr D6, 0E0h
    {
        word res = *(word *)&D6 >> 5;
        *(word *)&D6 = res;
    }                                       // shr word ptr D6, 5
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 14h
    if (flags.zero)
        goto cseg_5CC65;                    // jz cseg_5CC65

    *(word *)&D7 = 65535;                   // mov word ptr D7, 0FFFFh

cseg_5CB32:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 14h
    if (flags.zero)
        goto cseg_5CC65;                    // jz cseg_5CC65

    A0 = 92798;                             // mov A0, offset careerTeam
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 79, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 255;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4Fh], 0FFh
    if (!flags.zero)
        goto cseg_5CB32;                    // jnz short cseg_5CB32

    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        word res = *(word *)&D2 & 224;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 0E0h
    {
        word res = *(word *)&D2 >> 5;
        *(word *)&D2 = res;
    }                                       // shr word ptr D2, 5
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 0
    if (!flags.zero)
        goto cseg_5CBA4;                    // jnz short cseg_5CBA4

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 0
    if (flags.zero)
        goto cseg_5CBAE;                    // jz short cseg_5CBAE

    goto cseg_5CB32;                        // jmp short cseg_5CB32

cseg_5CBA4:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 0
    if (flags.zero)
        goto cseg_5CB32;                    // jz short cseg_5CB32

cseg_5CBAE:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 10h
    if (flags.carry || flags.zero)
        goto cseg_5CC16;                    // jbe short cseg_5CC16

    A1 = 92766;                             // mov A1, offset currentMatchPlayers
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al

cseg_5CBD7:;
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx + -1, 1); // mov al, [esi+ebx-1]
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 16;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 10h
    if (!flags.zero)
        goto cseg_5CBD7;                    // jnz short cseg_5CBD7

    al = D2;                                // mov al, byte ptr D2
    writeMemory(esi + 16, 1, al);           // mov [esi+10h], al

cseg_5CC16:;
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    eax = A5;                               // mov eax, A5
    A0 = eax;                               // mov A0, eax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = *(word *)&g_memByte[511026];       // mov ax, dseg_17A3B2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[511024];       // mov ax, dseg_17A3B0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    cseg_5C5EF();                           // call cseg_5C5EF
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[94090] = src;
    }                                       // add careerNumPlayers, 1
    *(word *)&g_memByte[511028] = 0;        // mov dseg_17A3B4, 0
    return;                                 // retn

cseg_5CC65:;
    *(word *)&g_memByte[511028] = 1;        // mov dseg_17A3B4, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5CC6F()
{
    eax = D0;                               // mov eax, D0
    D3 = eax;                               // mov D3, eax
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    A2 = 92346;                             // mov A2, offset dseg_D6F48
    A0 = 92798;                             // mov A0, offset careerTeam

cseg_5CC96:;
    eax = 1;                                // mov eax, 1
    cx = D2;                                // mov cx, word ptr D2
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        dword res = D3 & eax;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D3, eax
    if (flags.zero)
        goto cseg_5CD81;                    // jz cseg_5CD81

    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    writeMemory(esi + ebx, 2, -1);          // mov word ptr [esi+ebx], -1
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerPositionFromCurrent();         // call GetPlayerPositionFromCurrent
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 16
    if (flags.carry)
        goto cseg_5CD6F;                    // jb short cseg_5CD6F

    A1 = 92766;                             // mov A1, offset currentMatchPlayers
    eax = A1;                               // mov eax, A1
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    *(word *)&D0 = 20;                      // mov word ptr D0, 14h
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 2
    if (flags.sign)
        goto cseg_5CD6F;                    // js short cseg_5CD6F

    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    push(ax);                               // push ax

cseg_5CD45:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_5CD45;                    // jns short cseg_5CD45

    esi = A1;                               // mov esi, A1
    {
        int32_t val = stack[stackTop++];
        ax = val;
    }                                       // pop ax
    writeMemory(esi, 1, al);                // mov [esi], al

cseg_5CD6F:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 79, 1, 255);          // mov byte ptr [esi+4Fh], 0FFh
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[94090] = src;
    }                                       // sub careerNumPlayers, 1

cseg_5CD81:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 38;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 26h
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 14h
    if (!flags.zero)
        goto cseg_5CC96;                    // jnz cseg_5CC96
}

// =============== S U B R O U T I N E =======================================

// in:
//     D1 - player index
//
void GetPlayerPositionFromCurrent()
{
    A1 = 92766;                             // mov A1, offset currentMatchPlayers
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

l_next_player_loop:;
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        return;                             // jz short @@out

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 20
    if (!flags.zero)
        goto l_next_player_loop;            // jnz short @@next_player_loop

    debugBreak();                           // int 3

cseg_5CDEF:;
    goto cseg_5CDEF;                        // jmp short cseg_5CDEF
}

// =============== S U B R O U T I N E =======================================

// in:
//     A0 -> team
//
void cseg_5CDF2()
{
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+78]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    A3 = 511012;                            // mov A3, offset dseg_17A3A4
    A1 = 92346;                             // mov A1, offset dseg_D6F48
    A2 = 92766;                             // mov A2, offset currentMatchPlayers
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

cseg_5CE27:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, -1);                // mov word ptr [esi], -1
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 4
    A1 = eax;                               // mov A1, eax
    al = D1;                                // mov al, byte ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A2)++;
    flags.sign = (*(int32_t *)&A2 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A2 == 0;      // inc A2
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayer();                            // call GetPlayer
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 79, 1, -1);           // mov [esi+(PlayerFile.playerName+4Ch)], -1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 11
    if (!flags.carry)
        goto cseg_5CE8E;                    // jnb short cseg_5CE8E

    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A3)++;                    // inc A3
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al

cseg_5CE8E:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 65311;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FF1Fh
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5CEC3;                    // jz short cseg_5CEC3

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0Bh
    if (flags.zero)
        goto cseg_5CEC3;                    // jz short cseg_5CEC3

    *(byte *)&D0 |= 96;
    flags.carry = false;
    flags.sign = (*(byte *)&D0 & 0x80) != 0;
    flags.zero = *(byte *)&D0 == 0;         // or byte ptr D0, 60h
    goto cseg_5CECA;                        // jmp short cseg_5CECA

cseg_5CEC3:;
    *(byte *)&D0 |= 0;                      // or byte ptr D0, 0

cseg_5CECA:;
    al = D0;                                // mov al, byte ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 102, 1, al);          // mov [esi+66h], al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 14h
    if (!flags.zero)
        goto cseg_5CE27;                    // jnz cseg_5CE27

    *(word *)&g_memByte[94090] = 0;         // mov careerNumPlayers, 0
}

// =============== S U B R O U T I N E =======================================
//
void ShowSelectRepresentationMenu()
{
    A6 = 515998;                            // mov A6, offset selectNationalTeamMenu
    SWOS::ShowMenu();                       // call ShowMenu
    ax = *(word *)&g_memByte[516806];       // mov ax, dseg_17BA46
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
}

// =============== S U B R O U T I N E =======================================
//
void SelectNationalTeamInit()
{
    *(dword *)&g_memByte[516794] = 0;       // mov dseg_17BA3A, 0
    *(word *)&g_memByte[516808] = 0;        // mov dseg_17BA48, 0
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 14h
    if (flags.zero)
        goto cseg_5CF3F;                    // jz short cseg_5CF3F

    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

cseg_5CF3F:;

    SelectNationalTeamFinish();
}

// =============== S U B R O U T I N E =======================================
//
void SelectNationalTeamFinish()
{
    push(D0);                               // push D0
    D0 = 38;                                // mov D0, 26h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub word ptr [esi+14h], 19h
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+24h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D0 |= 8192;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // or word ptr D0, 2000h
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+24h], ax
    cseg_5CFE2();                           // call cseg_5CFE2
    cseg_5D281();                           // call cseg_5D281
    cseg_5D380();                           // call cseg_5D380
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5CFE2()
{
    *(word *)&D0 = 24;                      // mov word ptr D0, 18h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 25;                      // mov word ptr D0, 19h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 10h
    if (flags.carry || flags.zero)
        goto cseg_5D05E;                    // jbe short cseg_5D05E

    *(word *)&D0 = 24;                      // mov word ptr D0, 18h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 17;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 11h
    if (flags.carry || flags.zero)
        goto cseg_5D05E;                    // jbe short cseg_5D05E

    *(word *)&D0 = 25;                      // mov word ptr D0, 19h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_5D05E:;
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    A0 = 6555;                              // mov A0, offset aASquad
    A2 = 92803;                             // mov A2, (offset careerTeam+5)
    PrintFormatted();                       // call PrintFormatted
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, 0);            // mov word ptr [esi+16h], 0
    ax = *(word *)&g_memByte[516808];       // mov ax, dseg_17BA48
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5D1CD;                    // jz cseg_5D1CD

    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, 0);            // mov word ptr [esi+16h], 0

cseg_5D1CD:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[516808];       // mov ax, dseg_17BA48
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_5D280

    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 14h
    if (flags.zero)
        return;                             // jz cseg_5D280

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    A0 = 6471;                              // mov A0, offset aSelect1MoreInt
    *(word *)&D0 = 20;                      // mov word ptr D0, 14h
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto cseg_5D27B;                    // jz short cseg_5D27B

    A0 = 6512;                              // mov A0, offset aSelect0MoreInt

cseg_5D27B:;
    PrintFormatted();                       // call PrintFormatted
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5D281()
{
    A0 = 516734;                            // mov A0, offset dseg_17B9FE
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    {
        word res = *(word *)&D3 & 224;
        *(word *)&D3 = res;
    }                                       // and word ptr D3, 0E0h
    {
        word res = *(word *)&D3 >> 5;
        flags.carry = ((word)*(word *)&D3 >> 11) & 1;
        *(word *)&D3 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D3, 5
    D5 = 0;                                 // mov D5, 0
    D2 = -1;                                // mov D2, 0FFFFFFFFh
    *(word *)&D1 = 19;                      // mov word ptr D1, 13h

cseg_5D2C7:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayer();                            // call GetPlayer
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 79, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 255;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4Fh], 0FFh
    if (flags.zero)
        goto cseg_5D35E;                    // jz short cseg_5D35E

    ax = *(word *)&g_memByte[516808];       // mov ax, dseg_17BA48
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5D348;                    // jz short cseg_5D348

    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    {
        word res = *(word *)&D4 & 224;
        *(word *)&D4 = res;
    }                                       // and word ptr D4, 0E0h
    {
        word res = *(word *)&D4 >> 5;
        *(word *)&D4 = res;
    }                                       // shr word ptr D4, 5
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 0
    if (!flags.zero)
        goto cseg_5D328;                    // jnz short cseg_5D328

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 0
    if (flags.zero)
        goto cseg_5D348;                    // jz short cseg_5D348

    goto cseg_5D332;                        // jmp short cseg_5D332

cseg_5D328:;
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 0
    if (!flags.zero)
        goto cseg_5D348;                    // jnz short cseg_5D348

cseg_5D332:;
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D5 |= eax;
    flags.carry = false;
    flags.sign = (D5 & 0x80000000) != 0;
    flags.zero = D5 == 0;                   // or D5, eax
    goto cseg_5D35E;                        // jmp short cseg_5D35E

cseg_5D348:;
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    eax = ~(eax);                           // not eax
    {
        dword res = D2 & eax;
        D2 = res;
        flags.carry = false;
    }                                       // and D2, eax

cseg_5D35E:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_5D2C7;                    // jns cseg_5D2C7

    eax = D2;                               // mov eax, D2
    *(dword *)&g_memByte[516802] = eax;     // mov dseg_17BA42, eax
    eax = D5;                               // mov eax, D5
    *(dword *)&g_memByte[516798] = eax;     // mov dseg_17BA3E, eax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5D380()
{
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[516808];       // mov ax, dseg_17BA48
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_5D457

    eax = *(dword *)&g_memByte[516794];     // mov eax, dseg_17BA3A
    D0 = eax;                               // mov D0, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        return;                             // jz cseg_5D457

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = *(dword *)&g_memByte[516794];     // mov eax, dseg_17BA3A
    D0 = eax;                               // mov D0, eax
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    *(word *)&D1 = 31;                      // mov word ptr D1, 1Fh

cseg_5D3F1:;
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        dword res = D0 & eax;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D0, eax
    if (flags.zero)
        goto cseg_5D40F;                    // jz short cseg_5D40F

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1

cseg_5D40F:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_5D3F1;                    // jns short cseg_5D3F1

    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 6431);         // mov dword ptr [esi+26h], offset aRemovePlayer
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 1
    if (flags.zero)
        return;                             // jz short cseg_5D457

    writeMemory(esi + 38, 4, 6445);         // mov dword ptr [esi+26h], offset aRemovePlayers
}

// =============== S U B R O U T I N E =======================================
//
void NationalTeamAddPlayer()
{
    *(dword *)&g_memByte[516794] = 0;       // mov dseg_17BA3A, 0
    A6 = 516866;                            // mov A6, offset nationalTeamAddPlayerMenu
    SWOS::ShowMenu();                       // call ShowMenu
    ax = *(word *)&g_memByte[517008];       // mov ax, nationalTeamAddPlayerType
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5D50F;                    // js cseg_5D50F

    cseg_5C72F();                           // call cseg_5C72F
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_5D50F;                    // jnz short cseg_5D50F

    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    A1 = 516848;                            // mov A1, offset dseg_17BA70
    StringCopy();                           // call StringCopy
    A0 = 516810;                            // mov A0, offset dseg_17BA4A
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 4Ch
    A5 = eax;                               // mov A5, eax
    *(word *)&D0 = 37;                      // mov word ptr D0, 25h

cseg_5D4CE:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_5D4CE;                    // jns short cseg_5D4CE

    *(word *)&g_memByte[516808] = 1;        // mov dseg_17BA48, 1
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    cseg_5D380();                           // call cseg_5D380

cseg_5D50F:;
    cseg_5CFE2();                           // call cseg_5CFE2
    cseg_5D281();                           // call cseg_5D281
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void NationalTeamRemovePlayers()
{
    eax = *(dword *)&g_memByte[516794];     // mov eax, dseg_17BA3A
    D0 = eax;                               // mov D0, eax
    cseg_5CC6F();                           // call cseg_5CC6F
    *(dword *)&g_memByte[516794] = 0;       // mov dseg_17BA3A, 0
    cseg_5CFE2();                           // call cseg_5CFE2
    cseg_5D281();                           // call cseg_5D281
    cseg_5D380();                           // call cseg_5D380
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 14h
    if (flags.zero)
        goto cseg_5D56C;                    // jz short cseg_5D56C

    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

cseg_5D56C:;
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void SelectNationalTeamExit()
{
    *(word *)&g_memByte[516806] = -1;       // mov dseg_17BA46, -1
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void SelectNationalTeamAbort()
{
    *(word *)&g_memByte[516808] = 0;        // mov dseg_17BA48, 0
    cseg_5CFE2();                           // call cseg_5CFE2
    cseg_5D281();                           // call cseg_5D281
    cseg_5D380();                           // call cseg_5D380
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void SelectNationalTeamOnSelect25()
{
    A0 = 92798;                             // mov A0, offset careerTeam
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    RotatePlayersLeft();                    // call RotatePlayersLeft
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 24;                                // mov D0, 18h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void SelectNationalTeam25AfterDraw()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 24;                                // mov D0, 18h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    SWOS::DrawMenuItem();                   // jmp DrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void SelectNationalTeamCommon()
{
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    A0 = 92798;                             // mov A0, offset careerTeam
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    ax = *(word *)&g_memByte[516808];       // mov ax, dseg_17BA48
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5D70B;                    // jz short cseg_5D70B

    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    A0 = 516734;                            // mov A0, offset dseg_17B9FE
    A2 = 516848;                            // mov A2, offset dseg_17BA70
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = *(word *)&g_memByte[511026];       // mov ax, dseg_17A3B2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[511024];       // mov ax, dseg_17A3B0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    cseg_5C5EF();                           // call cseg_5C5EF
    *(word *)&g_memByte[516808] = 0;        // mov dseg_17BA48, 0
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    cseg_5CFE2();                           // call cseg_5CFE2
    cseg_5D380();                           // call cseg_5D380
    cseg_5D281();                           // call cseg_5D281
    { SWOS::DrawMenu(); return; }           // jmp DrawMenu

cseg_5D70B:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[516806] = ax;       // mov dseg_17BA46, ax
    eax = *(dword *)&g_memByte[516794];     // mov eax, dseg_17BA3A
    D0 = eax;                               // mov D0, eax
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D0 ^= eax;
    flags.carry = false;
    flags.sign = (D0 & 0x80000000) != 0;
    flags.zero = D0 == 0;                   // xor D0, eax
    eax = D0;                               // mov eax, D0
    *(dword *)&g_memByte[516794] = eax;     // mov dseg_17BA3A, eax
    cseg_5D380();                           // call cseg_5D380
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void SelectNationalTeamAfterDrawCommon()
{
    esi = A5;                               // mov esi, A5
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2], 7
    if (!flags.zero)
        goto cseg_5D790;                    // jnz short cseg_5D790

    ax = *(word *)&g_memByte[516808];       // mov ax, dseg_17BA48
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_5D9C8

    A6 = 516734;                            // mov A6, offset dseg_17B9FE
    *(word *)&D6 = 65535;                   // mov word ptr D6, 0FFFFh
    *(word *)&D5 = 13;                      // mov word ptr D5, 0Dh
    A4 = 516848;                            // mov A4, offset dseg_17BA70
    goto cseg_5D935;                        // jmp cseg_5D935

cseg_5D790:;
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 10h
    if (!flags.zero)
        goto cseg_5D7FF;                    // jnz short cseg_5D7FF

    *(word *)&D6 = 65535;                   // mov word ptr D6, 0FFFFh

cseg_5D7FF:;
    A0 = 92798;                             // mov A0, offset careerTeam
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (!flags.zero)
        goto cseg_5D853;                    // jnz short cseg_5D853

    *(word *)&D5 = 14;                      // mov word ptr D5, 0Eh

cseg_5D853:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 0);             // mov word ptr [esi+6], 0
    eax = *(dword *)&g_memByte[516798];     // mov eax, dseg_17BA3E
    D0 = eax;                               // mov D0, eax
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        dword res = D0 & eax;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D0, eax
    if (flags.zero)
        goto cseg_5D894;                    // jz short cseg_5D894

    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1
    *(word *)&D5 = 9;                       // mov word ptr D5, 9

cseg_5D894:;
    eax = *(dword *)&g_memByte[516802];     // mov eax, dseg_17BA42
    D0 = eax;                               // mov D0, eax
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        dword res = D0 & eax;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D0, eax
    if (flags.zero)
        goto cseg_5D8C0;                    // jz short cseg_5D8C0

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1

cseg_5D8C0:;
    ax = *(word *)&g_memByte[516808];       // mov ax, dseg_17BA48
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_5D8F4;                    // jnz short cseg_5D8F4

    eax = *(dword *)&g_memByte[516794];     // mov eax, dseg_17BA3A
    D0 = eax;                               // mov D0, eax
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        dword res = D0 & eax;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D0, eax
    if (flags.zero)
        goto cseg_5D8F4;                    // jz short cseg_5D8F4

    *(word *)&D5 = 13;                      // mov word ptr D5, 0Dh

cseg_5D8F4:;
    A4 = 92426;                             // mov A4, offset dseg_D6F98
    ax = D1;                                // mov ax, word ptr D1
    bx = 17;                                // mov bx, 11h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    eax = A4;                               // mov eax, A4
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A4 = eax;                               // mov A4, eax

cseg_5D935:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    push(D0);                               // push D0
    D0 = 27;                                // mov D0, 1Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    cseg_54116();                           // call cseg_54116
    *(word *)&D0 = 37;                      // mov word ptr D0, 25h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 27;                                // mov D0, 1Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 12;                      // mov word ptr D0, 0Ch
    SWOS::DrawMultipleItems();              // jmp DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_21()
{
}

// =============== S U B R O U T I N E =======================================
//
void NationalTeamAddPlayerHomeOnSelect()
{
    *(word *)&g_memByte[517008] = 0;        // mov nationalTeamAddPlayerType, 0
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void NationalTeamAddPlayerAbroadOnSelect()
{
    *(word *)&g_memByte[517008] = 1;        // mov nationalTeamAddPlayerType, 1
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void NationalTeamAddPlayerExit()
{
    *(word *)&g_memByte[517008] = -1;       // mov nationalTeamAddPlayerType, -1
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================

// in:
//      D1 -  player index
//      A0 -> team
// out:
//      D1 - player position
//
void GetPlayerPosition()
{
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (flags.zero)
        goto l_career_team;                 // jz short @@career_team

    ax = *(word *)&g_memByte[99542];        // mov ax, numPlayers
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset currentTeam
    if (flags.zero)
        goto l_career_team;                 // jz short @@career_team

    *(word *)&D3 = 16;                      // mov word ptr D3, 16

l_career_team:;
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D3 = res;
    }                                       // sub word ptr D3, 1

cseg_5DA4B:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto l_out;                         // jz short @@out

    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_5DA4B;                    // jns short cseg_5DA4B

    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop

    return;                                 // retn

l_out:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team number
// out:
//      D1 - starting balance
//
void CalculateStartingBalance()
{
    GetTeamPointer();                       // call GetTeamPointer
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    GetTeamValueBase();                     // call GetTeamValueBase
    ax = D0;                                // mov ax, word ptr D0
    bx = 3;                                 // mov bx, 3
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 40;                                // mov bx, 40
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 80;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 80
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D1;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D1
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    bx = 1000;                              // mov bx, 1000
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    D1 = eax;                               // mov D1, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - selected team number
//      D1 - starting balance
//
void cseg_5DB56()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    eax = D1;                               // mov eax, D1
    *(dword *)&g_memByte[91382] = eax;      // mov startingBalance, eax
    *(word *)&g_memByte[91670] = -1;        // mov teamNoOfferAccepted, -1
    *(word *)&g_memByte[91332] = -1;        // mov stayingInOldClub, -1
    *(word *)&g_memByte[131757] = 0;        // mov g_numSelectedTeams, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ax = D7;                                // mov ax, word ptr D7
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    GetTeamLeague();                        // call GetTeamLeague
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[91724] = ax;        // mov careerTeamLeague, ax
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&g_memByte[91720] = ax;        // mov selTeamNumber, ax
    A1 = 92798;                             // mov A1, offset careerTeam
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A2 = eax;                               // mov A2, eax
    *(word *)&D0 = 341;                     // mov word ptr D0, 341

cseg_5DD3A:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A2 = res;
    }                                       // add A2, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_5DD3A;                    // jns short cseg_5DD3A

    *(word *)&g_memByte[131757] = 1;        // mov g_numSelectedTeams, 1
    *(byte *)&D0 = 2;                       // mov byte ptr D0, 2
    ax = *(word *)&g_memByte[91722];        // mov ax, coachOrPlayer
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_5DD9E;                    // jnz short cseg_5DD9E

    *(byte *)&D0 = 3;                       // mov byte ptr D0, 3

cseg_5DD9E:;
    al = D0;                                // mov al, byte ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + -680, 1, al);         // mov [esi-680], al
    esi = A2;                               // mov esi, A2
    writeMemory(esi + -680, 1, al);         // mov [esi-680], al
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 60
    A1 = 92766;                             // mov A1, offset currentMatchPlayers
    *(word *)&D0 = 15;                      // mov word ptr D0, 15

l_set_current_match_players:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_set_current_match_players;   // jns short @@set_current_match_players

    *(word *)&g_memByte[94090] = 16;        // mov careerNumPlayers, 16
    *(word *)&g_memByte[323894] = 0;        // mov teamsLoaded, 0
    *(dword *)&g_memByte[91354] = 0;        // mov newBalance, 0
    *(word *)&g_memByte[91576] = 0;         // mov dseg_D6C46, 0
    *(word *)&g_memByte[91578] = 0;         // mov additionalInvestments, 0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team (file)
// out:
//      D0 - average player price in team
//
void GetAveragePlayerPrice()
{
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D2 = 15;                      // mov word ptr D2, 15
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

l_player_prices_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 38;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 38
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto l_player_prices_loop;          // jns short @@player_prices_loop

    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 16;                                // mov bx, 16
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5DEB9()
{
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_5DECD:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    push(D2);                               // push D2
    cseg_5E345();                           // call cseg_5E345
    pop(D2);                                // pop D2
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_5DECD;                    // jns short cseg_5DECD

    eax = *(dword *)&g_memByte[91354];      // mov eax, newBalance
    *(dword *)&g_memByte[91358] = eax;      // mov old_balance, eax
    *(dword *)&g_memByte[91362] = 0;        // mov playerPurchases, 0
    *(dword *)&g_memByte[91366] = 0;        // mov playerSales, 0
    *(dword *)&g_memByte[91374] = 0;        // mov playerWagesBill, 0
    *(dword *)&g_memByte[91370] = 0;        // mov generalRunningCosts, 0
    *(dword *)&g_memByte[91378] = 0;        // mov gateReceipts, 0
    *(dword *)&g_memByte[91394] = 0;        // mov sensisoftPlcSponsorship, 0
    ax = *(word *)&g_memByte[91332];        // mov ax, stayingInOldClub
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5E0A3;                    // jz cseg_5E0A3

    *(word *)&g_memByte[91578] = 0;         // mov additionalInvestments, 0
    ax = *(word *)&g_memByte[91576];        // mov ax, dseg_D6C46
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_5DF98;                    // jnz short cseg_5DF98

    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 20h
    if (!flags.carry)
        goto cseg_5E0A3;                    // jnb cseg_5E0A3

    *(word *)&D7 = 16;                      // mov word ptr D7, 10h
    *(word *)&g_memByte[91578] = 1;         // mov additionalInvestments, 1

cseg_5DF98:;
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 31;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1Fh
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    *(word *)&g_memByte[91576] = 0;         // mov dseg_D6C46, 0
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto cseg_5E0A3;                    // ja cseg_5E0A3

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[91576] = ax;        // mov dseg_D6C46, ax
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    GetTeamValueBase();                     // call GetTeamValueBase
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D7;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 10000;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 2710h
    if (flags.carry || flags.zero)
        goto cseg_5E074;                    // jbe short cseg_5E074

    *(word *)&D0 = 10000;                   // mov word ptr D0, 2710h
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0Fh
    ax = D0;                                // mov ax, word ptr D0
    bx = 100;                               // mov bx, 64h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D0 = 10000;                   // mov word ptr D0, 2710h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax

cseg_5E074:;
    ax = D0;                                // mov ax, word ptr D0
    bx = 1000;                              // mov bx, 3E8h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    *(dword *)&g_memByte[91394] = eax;      // mov sensisoftPlcSponsorship, eax
    {
        dword src = *(dword *)&g_memByte[91354];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91354] = src;
    }                                       // add newBalance, eax

cseg_5E0A3:;
    *(dword *)&g_memByte[91390] = 0;        // mov competitionBonuses, 0
    ax = *(word *)&g_memByte[91332];        // mov ax, stayingInOldClub
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5E199;                    // jz cseg_5E199

    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_5E199;                    // jz cseg_5E199

    al = g_memByte[105091];                 // mov al, dseg_DA111
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word src = *(word *)&g_memByte[99888];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CBE, 1
    if (flags.zero)
        goto cseg_5E117;                    // jz short cseg_5E117

    {
        word src = *(word *)&g_memByte[99888];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CBE, 2
    if (flags.zero)
        goto cseg_5E133;                    // jz short cseg_5E133

    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    bx = 50011;                             // mov bx, 50011
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    goto cseg_5E153;                        // jmp short cseg_5E153

cseg_5E117:;
    ax = D0;                                // mov ax, word ptr D0
    bx = 62644;                             // mov bx, 62644
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    goto cseg_5E153;                        // jmp short cseg_5E153

cseg_5E133:;
    ax = D0;                                // mov ax, word ptr D0
    bx = 41668;                             // mov bx, 41668
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        dword res = D0 << 1;
        D0 = res;
    }                                       // shl D0, 1

cseg_5E153:;
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 1000;                              // mov bx, 1000
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    bx = 1000;                              // mov bx, 1000
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        dword src = *(dword *)&g_memByte[91390];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91390] = src;
    }                                       // add competitionBonuses, eax

cseg_5E199:;
    ax = *(word *)&g_memByte[91332];        // mov ax, stayingInOldClub
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5E299;                    // jz cseg_5E299

    al = g_memByte[126615];                 // mov al, dseg_DF525
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5E232;                    // jz short cseg_5E232

    {
        word src = *(word *)&g_memByte[91726];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6CDC, 1
    if (flags.zero)
        goto cseg_5E216;                    // jz short cseg_5E216

    {
        word src = *(word *)&g_memByte[91726];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6CDC, 2
    if (flags.zero)
        goto cseg_5E1FA;                    // jz short cseg_5E1FA

    ax = D0;                                // mov ax, word ptr D0
    bx = 11112;                             // mov bx, 11112
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    goto cseg_5E253;                        // jmp short cseg_5E253

cseg_5E1FA:;
    ax = D0;                                // mov ax, word ptr D0
    bx = 16667;                             // mov bx, 16667
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    goto cseg_5E253;                        // jmp short cseg_5E253

cseg_5E216:;
    ax = D0;                                // mov ax, word ptr D0
    bx = 32353;                             // mov bx, 7E61h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    goto cseg_5E253;                        // jmp short cseg_5E253

cseg_5E232:;
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    bx = 34000;                             // mov bx, 84D0h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx

cseg_5E253:;
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 1000;                              // mov bx, 3E8h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    bx = 1000;                              // mov bx, 3E8h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        dword src = *(dword *)&g_memByte[91390];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91390] = src;
    }                                       // add competitionBonuses, eax

cseg_5E299:;
    eax = *(dword *)&g_memByte[91390];      // mov eax, competitionBonuses
    {
        dword src = *(dword *)&g_memByte[91354];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91354] = src;
    }                                       // add newBalance, eax
    eax = *(dword *)&g_memByte[91382];      // mov eax, startingBalance
    *(dword *)&g_memByte[91386] = eax;      // mov dseg_D6B88, eax
    eax = *(dword *)&g_memByte[91386];      // mov eax, dseg_D6B88
    D0 = eax;                               // mov D0, eax
    {
        dword src = *(dword *)&g_memByte[91354];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(dword *)&g_memByte[91354] = src;
    }                                       // add newBalance, eax
    *(word *)&g_memByte[91398] = 1;         // mov dseg_D6B94, 1
    *(word *)&g_memByte[91352] = 0;         // mov clubBusinessActive, 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5E2E0()
{
    ax = *(word *)&g_memByte[91398];        // mov ax, dseg_D6B94
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_5E344

    *(word *)&g_memByte[91398] = 0;         // mov dseg_D6B94, 0
    eax = *(dword *)&g_memByte[91354];      // mov eax, newBalance
    *(dword *)&g_memByte[91358] = eax;      // mov old_balance, eax
    *(dword *)&g_memByte[91362] = 0;        // mov playerPurchases, 0
    *(dword *)&g_memByte[91366] = 0;        // mov playerSales, 0
    *(dword *)&g_memByte[91374] = 0;        // mov playerWagesBill, 0
    *(dword *)&g_memByte[91370] = 0;        // mov generalRunningCosts, 0
    *(dword *)&g_memByte[91378] = 0;        // mov gateReceipts, 0
    *(dword *)&g_memByte[91386] = 0;        // mov dseg_D6B88, 0
    *(dword *)&g_memByte[91390] = 0;        // mov competitionBonuses, 0
}

// =============== S U B R O U T I N E =======================================

// in:
//     D1 - player index
//
void cseg_5E345()
{
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    cseg_8E23A();                           // call cseg_8E23A
    pop(D1);                                // pop D1
    push(D0);                               // push small [word ptr D0]
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayer();                            // call GetPlayer
    {
        int32_t val = stack[stackTop++];
        *(word *)&D0 = val;
    }                                       // pop small [word ptr D0]
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+(PlayerFile.someFlag+4Ch)], 9Bh
    if (!flags.zero)
        goto cseg_5E3CA;                    // jnz short cseg_5E3CA

    ax = D0;                                // mov ax, word ptr D0
    bx = 33;                                // mov bx, 33
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    goto cseg_5E411;                        // jmp short cseg_5E411

cseg_5E3CA:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+(PlayerFile.someFlag+4Ch)], 9Ah
    if (!flags.zero)
        goto cseg_5E411;                    // jnz short cseg_5E411

    ax = D0;                                // mov ax, word ptr D0
    bx = 66;                                // mov bx, 66
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx

cseg_5E411:;
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ebx = 1000;                             // mov ebx, 1000
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    ebx = 768;                              // mov ebx, 768
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    ebx = 96;                               // mov ebx, 96
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    ebx = *(word *)&g_memByte[91668];       // movzx ebx, dseg_D6CA2
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D0 = eax;                               // mov D0, eax
    {
        dword res = D0 & 65535;
        D0 = res;
    }                                       // and D0, 0FFFFh
    A0 = 91416;                             // mov A0, offset dseg_D6BA6
    {
        word res = *(word *)&D1 << 2;
        flags.carry = ((word)*(word *)&D1 >> 14) & 1;
        *(word *)&D1 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D1, 2
    eax = D0;                               // mov eax, D0
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    writeMemory(esi + ebx, 4, eax);         // mov [esi+ebx], eax
    cseg_5E4B4();                           // jmp short cseg_5E4B4
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5E48C()
{
    A0 = 91416;                             // mov A0, offset dseg_D6BA6
    {
        word res = *(word *)&D1 << 2;
        flags.carry = ((word)*(word *)&D1 >> 14) & 1;
        *(word *)&D1 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D1, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    writeMemory(esi + ebx, 4, 0);           // mov dword ptr [esi+ebx], 0

    cseg_5E4B4();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5E4B4()
{
    A1 = 91416;                             // mov A1, offset dseg_D6BA6
    D3 = 0;                                 // mov D3, 0
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_5E4DC:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    {
        word res = *(word *)&D1 << 2;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 2
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    D0 = eax;                               // mov D0, eax
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        D3 = res;
    }                                       // add D3, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_5E4DC;                    // jns short cseg_5E4DC

    eax = D3;                               // mov eax, D3
    *(dword *)&g_memByte[91408] = eax;      // mov dseg_D6B9E, eax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_5E535()
{
    GetTeamValueBase();                     // call GetTeamValueBase
    ax = D0;                                // mov ax, word ptr D0
    bx = 1000;                              // mov bx, 1000
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 768;                               // mov bx, 768
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    bx = 1536;                              // mov bx, 1536
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
}

// =============== S U B R O U T I N E =======================================
//
void ShowChairmanMessage()
{
    PlayChairmanScene();                    // call PlayChairmanScene
    A6 = 517544;                            // mov A6, offset chairmanMemosMenu
    SWOS::ShowMenu();                       // jmp ShowMenu
}

// =============== S U B R O U T I N E =======================================
//
void ChairmanMemosInit()
{
    *(word *)&g_memByte[252398] = 1;        // mov fireResetFlag, 1
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        { ChairmanMemosOnReturn(); return; } // jz short ChairmanMemosOnReturn

    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 4918);         // mov [esi+MenuEntry.fg.string], offset aMemoFromThePre
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 4942);         // mov [esi+MenuEntry.fg.string], offset aThePresident

    ChairmanMemosOnReturn();
}

// =============== S U B R O U T I N E =======================================
//
void ChairmanMemosOnReturn()
{
    A2 = 91736;                             // mov A2, offset managerSexBuffer
    A3 = 91750;                             // mov A3, offset managerSurnameBuffer
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 13256;                             // mov A0, offset aDearAB_0
    PrintFormatted();                       // call PrintFormatted
    ax = *(word *)&g_memByte[337240];       // mov ax, currentMessage
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        word res = *(word *)&D0 << 3;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 3
    A5 = 517704;                            // mov A5, offset clubMessagesTable
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A5 = res;
    }                                       // add A5, 4
    A0 = eax;                               // mov A0, eax
    A2 = 91741;                             // mov A2, offset managerNameBuffer
    eax = *(dword *)&g_memByte[456664];     // mov eax, plNameForMessage
    A3 = eax;                               // mov A3, eax
    PrintFormatted();                       // call PrintFormatted
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    A2 = 91741;                             // mov A2, offset managerNameBuffer
    eax = *(dword *)&g_memByte[456664];     // mov eax, plNameForMessage
    A3 = eax;                               // mov A3, eax
    PrintFormatted();                       // call PrintFormatted
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    SWOS::DrawMenu();                       // call DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void ChairmanMemosContinue()
{
    *(word *)&g_memByte[337240] = 0;        // mov currentMessage, 0
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ShowClubBussinesMenu()
{
    *(word *)&g_memByte[91352] = 0;         // mov clubBusinessActive, 0
    A6 = 518008;                            // mov A6, offset clubBusinessMenu
    SWOS::ShowMenu();                       // jmp ShowMenu
}

// =============== S U B R O U T I N E =======================================
//
void ClubBusinessInit()
{
    ax = *(word *)&g_memByte[91666];        // mov ax, dseg_D6CA0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_5E797;                    // jnz short cseg_5E797

    ax = *(word *)&g_memByte[91332];        // mov ax, stayingInOldClub
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5EA3D;                    // jz cseg_5EA3D

    goto cseg_5ED53;                        // jmp cseg_5ED53

cseg_5E797:;
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91358];      // mov eax, old_balance
    D0 = eax;                               // mov D0, eax
    Int2PoundsSigned();                     // call Int2PoundsSigned
    push(D0);                               // push D0
    D0 = 14;                                // mov D0, 14
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91378];      // mov eax, gateReceipts
    D0 = eax;                               // mov D0, eax
    WriteAccountBalance();                  // call WriteAccountBalance
    push(D0);                               // push D0
    D0 = 15;                                // mov D0, 15
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91370];      // mov eax, generalRunningCosts
    D0 = eax;                               // mov D0, eax
    flags.carry = *(int32_t *)&D0 != 0;
    *(int32_t *)&D0 = -*(int32_t *)&D0;
    flags.sign = (*(int32_t *)&D0 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&D0 == 0;      // neg D0
    WriteAccountBalance();                  // call WriteAccountBalance
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91366];      // mov eax, playerSales
    D0 = eax;                               // mov D0, eax
    WriteAccountBalance();                  // call WriteAccountBalance
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91362];      // mov eax, playerPurchases
    D0 = eax;                               // mov D0, eax
    flags.carry = *(int32_t *)&D0 != 0;
    *(int32_t *)&D0 = -*(int32_t *)&D0;
    flags.sign = (*(int32_t *)&D0 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&D0 == 0;      // neg D0
    WriteAccountBalance();                  // call WriteAccountBalance
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91374];      // mov eax, playerWagesBill
    D0 = eax;                               // mov D0, eax
    flags.carry = *(int32_t *)&D0 != 0;
    *(int32_t *)&D0 = -*(int32_t *)&D0;
    flags.sign = (*(int32_t *)&D0 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&D0 == 0;      // neg D0
    WriteAccountBalance();                  // call WriteAccountBalance
    eax = *(dword *)&g_memByte[91386];      // mov eax, dseg_D6B88
    D1 = eax;                               // mov D1, eax
    eax = *(dword *)&g_memByte[91390];      // mov eax, competitionBonuses
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = *(dword *)&g_memByte[91378];      // mov eax, gateReceipts
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = *(dword *)&g_memByte[91366];      // mov eax, playerSales
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = *(dword *)&g_memByte[91362];      // mov eax, playerPurchases
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = *(dword *)&g_memByte[91374];      // mov eax, playerWagesBill
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = *(dword *)&g_memByte[91370];      // mov eax, generalRunningCosts
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // sub D1, eax
    if (!flags.sign)
        goto cseg_5E96F;                    // jns short cseg_5E96F

    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 14205);        // mov dword ptr [esi+38], offset aTotalLoss

cseg_5E96F:;
    push(D0);                               // push D0
    D0 = 20;                                // mov D0, 20
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = D1;                               // mov eax, D1
    D0 = eax;                               // mov D0, eax
    WriteAccountBalance();                  // call WriteAccountBalance
    push(D0);                               // push D0
    D0 = 21;                                // mov D0, 21
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = *(dword *)&g_memByte[91354];      // mov eax, newBalance
    D0 = eax;                               // mov D0, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.sign)
        goto cseg_5EA29;                    // jns short cseg_5EA29

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+36]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D1 |= 8192;                   // or word ptr D1, 2000h
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 36, 2, ax);           // mov [esi+36], ax
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+30]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 65520;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFF0h
    *(word *)&D1 |= 12;
    flags.carry = false;
    flags.sign = (*(word *)&D1 & 0x8000) != 0;
    flags.zero = *(word *)&D1 == 0;         // or word ptr D1, 0Ch
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 30, 2, ax);           // mov [esi+30], ax

cseg_5EA29:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    Int2PoundsSigned();                     // call Int2PoundsSigned
    return;                                 // retn

cseg_5EA3D:;
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 30;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+22], 30
    writeMemory(esi + 38, 4, 14102);        // mov dword ptr [esi+38], offset aBalanceAtStart
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 30;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+22], 30
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91358];      // mov eax, old_balance
    D0 = eax;                               // mov D0, eax
    Int2PoundsSigned();                     // call Int2PoundsSigned
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 14;                      // mov word ptr D0, 14
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 15;                      // mov word ptr D0, 15
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91366];      // mov eax, playerSales
    D0 = eax;                               // mov D0, eax
    WriteAccountBalance();                  // call WriteAccountBalance
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91362];      // mov eax, playerPurchases
    D0 = eax;                               // mov D0, eax
    flags.carry = *(int32_t *)&D0 != 0;
    *(int32_t *)&D0 = -*(int32_t *)&D0;
    flags.sign = (*(int32_t *)&D0 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&D0 == 0;      // neg D0
    WriteAccountBalance();                  // call WriteAccountBalance
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 19;                      // mov word ptr D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub word ptr [esi+22], 15
    eax = *(dword *)&g_memByte[91386];      // mov eax, dseg_D6B88
    D1 = eax;                               // mov D1, eax
    eax = *(dword *)&g_memByte[91390];      // mov eax, competitionBonuses
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = *(dword *)&g_memByte[91378];      // mov eax, gateReceipts
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = *(dword *)&g_memByte[91366];      // mov eax, playerSales
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = *(dword *)&g_memByte[91362];      // mov eax, playerPurchases
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = *(dword *)&g_memByte[91374];      // mov eax, playerWagesBill
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = *(dword *)&g_memByte[91370];      // mov eax, generalRunningCosts
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // sub D1, eax
    if (!flags.sign)
        goto cseg_5EC46;                    // jns short cseg_5EC46

    writeMemory(esi + 38, 4, 14205);        // mov dword ptr [esi+38], offset aTotalLoss

cseg_5EC46:;
    push(D0);                               // push D0
    D0 = 20;                                // mov D0, 20
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub word ptr [esi+22], 15
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = D1;                               // mov eax, D1
    D0 = eax;                               // mov D0, eax
    WriteAccountBalance();                  // call WriteAccountBalance
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub word ptr [esi+22], 15
    push(D0);                               // push D0
    D0 = 21;                                // mov D0, 21
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub word ptr [esi+22], 15
    eax = *(dword *)&g_memByte[91354];      // mov eax, newBalance
    D0 = eax;                               // mov D0, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.sign)
        goto cseg_5ED3F;                    // jns short cseg_5ED3F

    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+36]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D1 |= 8192;                   // or word ptr D1, 2000h
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 36, 2, ax);           // mov [esi+36], ax
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+30]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 65520;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFF0h
    *(word *)&D1 |= 12;
    flags.carry = false;
    flags.sign = (*(word *)&D1 & 0x8000) != 0;
    flags.zero = *(word *)&D1 == 0;         // or word ptr D1, 0Ch
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 30, 2, ax);           // mov [esi+30], ax

cseg_5ED3F:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    Int2PoundsSigned();                     // call Int2PoundsSigned
    return;                                 // retn

cseg_5ED53:;
    ax = *(word *)&g_memByte[91576];        // mov ax, dseg_D6C46
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5EDE0;                    // jz cseg_5EDE0

    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D1 = 9;                       // mov word ptr D1, 9

cseg_5ED86:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub word ptr [esi+22], 13
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_5ED86;                    // jns short cseg_5ED86

    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D1 = 9;                       // mov word ptr D1, 9

cseg_5EDC5:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub word ptr [esi+22], 13
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_5EDC5;                    // jns short cseg_5EDC5

cseg_5EDE0:;
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 14139);        // mov dword ptr [esi+38], offset aBalanceAtEndOf
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+22], 5
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+22], 5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91358];      // mov eax, old_balance
    D0 = eax;                               // mov D0, eax
    Int2PoundsSigned();                     // call Int2PoundsSigned
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 13;                      // mov word ptr D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91390];      // mov eax, competitionBonuses
    D0 = eax;                               // mov D0, eax
    WriteAccountBalance();                  // call WriteAccountBalance
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D1 = 7;                       // mov word ptr D1, 7

cseg_5EEE6:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+22], 15
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_5EEE6;                    // jns short cseg_5EEE6

    push(D0);                               // push D0
    D0 = 14;                                // mov D0, 14
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D1 = 7;                       // mov word ptr D1, 7

cseg_5EF25:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+22], 15
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_5EF25;                    // jns short cseg_5EF25

    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 14479);        // mov dword ptr [esi+38], offset aSponsorshipFor
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+22], 5
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 14517);        // mov dword ptr [esi+38], offset aSeasonFromSens
    push(D0);                               // push D0
    D0 = 14;                                // mov D0, 14
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+22], 10
    *(word *)&D0 = 15;                      // mov word ptr D0, 15
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 14;                                // mov D0, 14
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91386];      // mov eax, dseg_D6B88
    D0 = eax;                               // mov D0, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    WriteAccountBalance();                  // call WriteAccountBalance
    ax = *(word *)&g_memByte[91576];        // mov ax, dseg_D6C46
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5F141;                    // jz cseg_5F141

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 16;                      // mov word ptr D0, 16
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    push(D0);                               // push D0
    D0 = 16;                                // mov D0, 16
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91394];      // mov eax, sensisoftPlcSponsorship
    D0 = eax;                               // mov D0, eax
    WriteAccountBalance();                  // call WriteAccountBalance
    ax = *(word *)&g_memByte[91578];        // mov ax, additionalInvestments
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_adittional_investments;   // jz short @@no_adittional_investments

    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 14351);        // mov dword ptr [esi+38], offset aAdditionalInve

l_no_adittional_investments:;
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D1 = 4;                       // mov word ptr D1, 4

cseg_5F0E7:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+22], 15
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_5F0E7;                    // jns short cseg_5F0E7

    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D1 = 4;                       // mov word ptr D1, 4

cseg_5F126:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+22], 15
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_5F126;                    // jns short cseg_5F126

cseg_5F141:;
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91366];      // mov eax, playerSales
    D0 = eax;                               // mov D0, eax
    WriteAccountBalance();                  // call WriteAccountBalance
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[91362];      // mov eax, playerPurchases
    D0 = eax;                               // mov D0, eax
    flags.carry = *(int32_t *)&D0 != 0;
    *(int32_t *)&D0 = -*(int32_t *)&D0;
    flags.sign = (*(int32_t *)&D0 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&D0 == 0;      // neg D0
    WriteAccountBalance();                  // call WriteAccountBalance
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 19;                      // mov word ptr D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub word ptr [esi+22], 15
    eax = *(dword *)&g_memByte[91386];      // mov eax, dseg_D6B88
    D1 = eax;                               // mov D1, eax
    eax = *(dword *)&g_memByte[91390];      // mov eax, competitionBonuses
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = *(dword *)&g_memByte[91378];      // mov eax, gateReceipts
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = *(dword *)&g_memByte[91366];      // mov eax, playerSales
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = *(dword *)&g_memByte[91394];      // mov eax, sensisoftPlcSponsorship
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = *(dword *)&g_memByte[91362];      // mov eax, playerPurchases
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = *(dword *)&g_memByte[91374];      // mov eax, playerWagesBill
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = *(dword *)&g_memByte[91370];      // mov eax, generalRunningCosts
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // sub D1, eax
    if (!flags.sign)
        goto cseg_5F277;                    // jns short cseg_5F277

    writeMemory(esi + 38, 4, 14205);        // mov dword ptr [esi+38], offset aTotalLoss

cseg_5F277:;
    push(D0);                               // push D0
    D0 = 20;                                // mov D0, 20
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub word ptr [esi+22], 15
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = D1;                               // mov eax, D1
    D0 = eax;                               // mov D0, eax
    WriteAccountBalance();                  // call WriteAccountBalance
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub word ptr [esi+22], 15
    push(D0);                               // push D0
    D0 = 21;                                // mov D0, 21
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub word ptr [esi+22], 15
    eax = *(dword *)&g_memByte[91354];      // mov eax, newBalance
    D0 = eax;                               // mov D0, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.sign)
        goto cseg_5F36D;                    // jns short cseg_5F36D

    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+36]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D1 |= 8192;                   // or word ptr D1, 2000h
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 36, 2, ax);           // mov [esi+36], ax
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+30]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 65520;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFF0h
    *(word *)&D1 |= 12;
    flags.carry = false;
    flags.sign = (*(word *)&D1 & 0x8000) != 0;
    flags.zero = *(word *)&D1 == 0;         // or word ptr D1, 0Ch
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 30, 2, ax);           // mov [esi+30], ax

cseg_5F36D:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    Int2PoundsSigned();                     // call Int2PoundsSigned
}

// =============== S U B R O U T I N E =======================================
//
void j_SetExitMenuFlag13()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void GotJobOfferInit()
{
    ax = *(word *)&g_memByte[91670];        // mov ax, teamNoOfferAccepted
    *(word *)&g_memByte[518830] = ax;       // mov team_num_offering_job, ax
    eax = *(dword *)&g_memByte[91672];      // mov eax, teamFundsAccepted
    *(dword *)&g_memByte[518836] = eax;     // mov job_offer_funds, eax
    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, -1
    if (!flags.zero)
        goto l_new_job_accepted;            // jnz short @@new_job_accepted

    ax = *(word *)&g_memByte[518826];       // mov ax, jobOfferOrdinal
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_got_job_offer;               // jns short @@got_job_offer

    ax = *(word *)&g_memByte[518828];       // mov ax, oldJobOfferOrdinal
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetJobOfferPtr();                       // call GetJobOfferPtr
    goto cseg_5F3CF;                        // jmp short cseg_5F3CF

l_got_job_offer:;
    GetNewJobOfferPtr();                    // call GetNewJobOfferPtr

cseg_5F3CF:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+JobOffer.teamNo]
    *(word *)&g_memByte[518830] = ax;       // mov team_num_offering_job, ax
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+JobOffer.amountOffered]
    *(dword *)&g_memByte[518836] = eax;     // mov job_offer_funds, eax
    ax = *(word *)&g_memByte[518826];       // mov ax, jobOfferOrdinal
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_5F405;                    // jns short cseg_5F405

l_new_job_accepted:;
    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

cseg_5F405:;

    GotJobOfferFinish();
}

// =============== S U B R O U T I N E =======================================
//
void GotJobOfferFinish()
{
    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_5F4A6;                    // jz cseg_5F4A6

    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_5F4A6;                    // jnz short cseg_5F4A6

    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 9063);         // mov [esi+MenuEntry.fg.string], offset aRetire
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 10
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

cseg_5F4A6:;
    {
        dword src = *(dword *)&g_memByte[518836];
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp job_offer_funds, -1
    if (!flags.zero)
        goto cseg_5F571;                    // jnz cseg_5F571

    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 6251);         // mov [esi+MenuEntry.fg.string], offset aInternationalJ
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+MenuEntry.x], 30
    {
        word src = (word)readMemory(esi + 24, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 60;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 24, 2, src);
    }                                       // add [esi+MenuEntry.dwWidth], 60
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 65;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add [esi+MenuEntry.x], 65
    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 65;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+MenuEntry.x], 65
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 12;                      // mov word ptr D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

cseg_5F571:;
    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, -1
    if (!flags.zero)
        goto cseg_5FA34;                    // jnz cseg_5FA34

cseg_5F581:;
    ax = *(word *)&g_memByte[518826];       // mov ax, jobOfferOrdinal
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_5F5A8;                    // jns short cseg_5F5A8

    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    goto cseg_5F5C2;                        // jmp short cseg_5F5C2

cseg_5F5A8:;
    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

cseg_5F5C2:;
    ax = *(word *)&g_memByte[518824];       // mov ax, dseg_17C228
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_5F639;                    // jnz short cseg_5F639

    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

cseg_5F639:;
    ax = *(word *)&g_memByte[518830];       // mov ax, team_num_offering_job
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[518832] = eax;     // mov team_offering_job_ptr, eax
    A2 = 91736;                             // mov A2, offset managerSexBuffer
    A3 = 91750;                             // mov A3, offset managerSurnameBuffer
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 11650;                             // mov A0, offset aDearAB
    PrintFormatted();                       // call PrintFormatted
    {
        dword src = *(dword *)&g_memByte[518836];
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp job_offer_funds, -1
    if (flags.zero)
        goto cseg_5F862;                    // jz cseg_5F862

    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = *(dword *)&g_memByte[518832];     // mov eax, team_offering_job_ptr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A2 = eax;                               // mov A2, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 12722;                             // mov A0, offset aWeHereAtAWould
    push(A2);                               // push A2
    PrintFormatted();                       // call PrintFormatted
    pop(A2);                                // pop A2
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 12767;                             // mov A0, offset aCoachingJobAtO
    PrintFormatted();                       // call PrintFormatted
    eax = *(dword *)&g_memByte[518836];     // mov eax, job_offer_funds
    D0 = eax;                               // mov D0, eax
    A1 = 316574;                            // mov A1, offset fundsBuffer
    Int2Pounds();                           // call Int2Pounds
    A2 = 316574;                            // mov A2, offset fundsBuffer
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 12808;                             // mov A0, offset aWeCanOfferYouA
    PrintFormatted();                       // call PrintFormatted
    A2 = 316574;                            // mov A2, offset fundsBuffer
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 12859;                             // mov A0, offset aWeHopeToBeAble
    PrintFormatted();                       // call PrintFormatted
    A2 = 316574;                            // mov A2, offset fundsBuffer
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 12904;                             // mov A0, offset aInTheRegionOfA
    PrintFormatted();                       // call PrintFormatted
    A2 = 316574;                            // mov A2, offset fundsBuffer
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 12951;                             // mov A0, offset aWeLookForwardT
    PrintFormatted();                       // call PrintFormatted
    return;                                 // retn

cseg_5F862:;
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 10
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = *(dword *)&g_memByte[518832];     // mov eax, team_offering_job_ptr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A2 = eax;                               // mov A2, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 5834;                              // mov A0, offset aTheMembersOfTh
    push(A2);                               // push A2
    PrintFormatted();                       // call PrintFormatted
    pop(A2);                                // pop A2
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 5874;                              // mov A0, offset aOfAWouldLikeTo
    PrintFormatted();                       // call PrintFormatted
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 5912;                              // mov A0, offset aAsCoachOfTheNa
    PrintFormatted();                       // call PrintFormatted
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 5942;                              // mov A0, offset aWeCanPromiseYo
    PrintFormatted();                       // call PrintFormatted
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 5985;                              // mov A0, offset aAnAnnuallyRevi
    PrintFormatted();                       // call PrintFormatted
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 6017;                              // mov A0, offset aWeLookForwar_0
    PrintFormatted();                       // call PrintFormatted
    return;                                 // retn

cseg_5FA34:;
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17248);        // mov [esi+MenuEntry.fg.string], offset aNewJob
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 10
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 13;                      // mov word ptr D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = *(word *)&g_memByte[91670];        // mov ax, teamNoOfferAccepted
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetTeamPointer();                       // call GetTeamPointer
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[518832] = eax;     // mov team_offering_job_ptr, eax
    A2 = 91736;                             // mov A2, offset managerSexBuffer
    A3 = 91750;                             // mov A3, offset managerSurnameBuffer
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 11650;                             // mov A0, offset aDearAB
    PrintFormatted();                       // call PrintFormatted
    {
        dword src = *(dword *)&g_memByte[518836];
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp job_offer_funds, -1
    if (flags.zero)
        goto cseg_5FD31;                    // jz cseg_5FD31

    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = *(dword *)&g_memByte[518832];     // mov eax, team_offering_job_ptr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A2 = eax;                               // mov A2, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 12998;                             // mov A0, offset aWeHereAtAAreDe
    push(A2);                               // push A2
    PrintFormatted();                       // call PrintFormatted
    pop(A2);                                // pop A2
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 13037;                             // mov A0, offset aHaveAcceptedTh
    PrintFormatted();                       // call PrintFormatted
    eax = *(dword *)&g_memByte[91672];      // mov eax, teamFundsAccepted
    D0 = eax;                               // mov D0, eax
    A1 = 316574;                            // mov A1, offset fundsBuffer
    Int2Pounds();                           // call Int2Pounds
    A2 = 316574;                            // mov A2, offset fundsBuffer
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 13089;                             // mov A0, offset aFromTheStartOf
    PrintFormatted();                       // call PrintFormatted
    A2 = 316574;                            // mov A2, offset fundsBuffer
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 13130;                             // mov A0, offset aWeHopeToBeAb_0
    PrintFormatted();                       // call PrintFormatted
    A2 = 316574;                            // mov A2, offset fundsBuffer
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 13175;                             // mov A0, offset aInTheRegionO_0
    PrintFormatted();                       // call PrintFormatted
    A2 = 316574;                            // mov A2, offset fundsBuffer
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 4879;                              // mov A0, offset aAndWeLookForwa
    PrintFormatted();                       // call PrintFormatted
    return;                                 // retn

cseg_5FD31:;
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 10
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub [esi+MenuEntry.y], 15
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = *(dword *)&g_memByte[518832];     // mov eax, team_offering_job_ptr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A2 = eax;                               // mov A2, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 6053;                              // mov A0, offset aTheMembersOf_0
    push(A2);                               // push A2
    PrintFormatted();                       // call PrintFormatted
    pop(A2);                                // pop A2
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 6093;                              // mov A0, offset aOfAAreDelighte
    PrintFormatted();                       // call PrintFormatted
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 6127;                              // mov A0, offset aAcceptedThePos
    PrintFormatted();                       // call PrintFormatted
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.func2]
    A1 = eax;                               // mov A1, eax
    A0 = 6179;                              // mov A0, offset aFromTheStart_0
    PrintFormatted();                       // call PrintFormatted
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 6209;                              // mov A0, offset nullString2
    PrintFormatted();                       // call PrintFormatted
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 6210;                              // mov A0, offset aWeLookForwar_1
    PrintFormatted();                       // call PrintFormatted
}

// =============== S U B R O U T I N E =======================================
//
void AcceptJobOffer()
{
    ax = *(word *)&g_memByte[518826];       // mov ax, jobOfferOrdinal
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_5FF41;                    // js short cseg_5FF41

    GetNewJobOfferPtr();                    // call GetNewJobOfferPtr
    goto cseg_5FF52;                        // jmp short cseg_5FF52

cseg_5FF41:;
    ax = *(word *)&g_memByte[518828];       // mov ax, oldJobOfferOrdinal
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetJobOfferPtr();                       // call GetJobOfferPtr

cseg_5FF52:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+JobOffer.teamNo]
    *(word *)&g_memByte[91670] = ax;        // mov teamNoOfferAccepted, ax
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+JobOffer.amountOffered]
    *(dword *)&g_memByte[91672] = eax;      // mov teamFundsAccepted, eax
    *(word *)&g_memByte[92034] = 0;         // mov numNewJobOffers, 0
    *(word *)&g_memByte[92166] = 0;         // mov numJobOffers, 0
    GetCurrentSeasonPointer();              // call GetCurrentSeasonPointer
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 105, 1);    // mov al, [esi+SeasonInformations.managerStatus]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto l_out;                         // js short @@out

    writeMemory(esi + 105, 1, 1);           // mov [esi+SeasonInformations.managerStatus], 1

l_out:;
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void j_SetExitMenuFlag_14()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void RejectJobOffer()
{
    ax = *(word *)&g_memByte[518830];       // mov ax, team_num_offering_job
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[518826];       // mov ax, jobOfferOrdinal
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_5FFC8;                    // jns short cseg_5FFC8

    cseg_601FA();                           // call cseg_601FA
    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

cseg_5FFC8:;
    RemoveJobOffer();                       // call RemoveJobOffer
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ViewFutureTeam()
{
    eax = *(dword *)&g_memByte[518832];     // mov eax, team_offering_job_ptr
    A0 = eax;                               // mov A0, eax
    A1 = 20937;                             // mov A1, offset aViewTeam
    D0 = 0;                                 // mov D0, 0
    D1 = 0;                                 // mov D1, 0
    *(word *)&D2 = 1;                       // mov word ptr D2, 1

    cseg_60003();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_60003()
{
    *(word *)&D3 = 65535;                   // mov word ptr D3, 0FFFFh
    *(word *)&D4 = 65535;                   // mov word ptr D4, 0FFFFh
    *(word *)&g_memByte[456650] = 1;        // mov dseg_168A6F, 1
    ShowSquad();                            // call ShowSquad
    *(word *)&g_memByte[456650] = 0;        // mov dseg_168A6F, 0
    GotJobOfferFinish();                    // jmp GotJobOfferFinish
}

// =============== S U B R O U T I N E =======================================
//
void ViewFutureTeamLeague()
{
    eax = *(dword *)&g_memByte[518832];     // mov eax, team_offering_job_ptr
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 25, 1);     // mov al, [esi+19h]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    A0 = 33933;                             // mov A0, offset competitionsTable
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&g_memByte[378420] = ax;       // mov dseg_11F41C, ax
    cseg_3AA17();                           // call cseg_3AA17
    *(word *)&g_memByte[378420] = 65535;    // mov dseg_11F41C, 0FFFFh
    GotJobOfferFinish();                    // jmp GotJobOfferFinish
}

// =============== S U B R O U T I N E =======================================
//
void ConsiderJobOffer()
{
    ax = *(word *)&g_memByte[518826];       // mov ax, jobOfferOrdinal
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_60106;                    // js short cseg_60106

    GetNewJobOfferPtr();                    // call GetNewJobOfferPtr
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+JobOffer.teamNo]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+JobOffer.amountOffered]
    D1 = eax;                               // mov D1, eax
    cseg_6010B();                           // call cseg_6010B

cseg_60106:;
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void cseg_6010B()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    IsNewJobOffer();                        // call IsNewJobOffer
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 2
    A0 = eax;                               // mov A0, eax
    A1 = 316574;                            // mov A1, offset fundsBuffer
    StringCopy();                           // call StringCopy
    push(D0);                               // push D0
    push(D1);                               // push D1
    RemoveJobOffer();                       // call RemoveJobOffer
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    {
        word src = *(word *)&g_memByte[92166];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numJobOffers, 5
    if (flags.zero)
        return;                             // jz cseg_601F9

    A0 = 92168;                             // mov A0, offset jobOffers
    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    bx = 26;                                // mov bx, 1Ah
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    writeMemory(esi + ebx, 2, ax);          // mov [esi+ebx], ax
    eax = D1;                               // mov eax, D1
    writeMemory(esi + ebx + 20, 4, eax);    // mov [esi+ebx+14h], eax
    {
        word src = *(word *)&g_memByte[92166];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[92166] = src;
    }                                       // add numJobOffers, 1
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    A0 = 316574;                            // mov A0, offset fundsBuffer
    StringCopy();                           // call StringCopy
}

// =============== S U B R O U T I N E =======================================
//
void cseg_601FA()
{
    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_60296

    A0 = 92168;                             // mov A0, offset jobOffers
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_60221:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_60286;                    // jnz short cseg_60286

    {
        word src = *(word *)&g_memByte[92166];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[92166] = src;
    }                                       // sub numJobOffers, 1
    ax = D1;                                // mov ax, word ptr D1
    bx = 13;                                // mov bx, 0Dh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_60296

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_60262:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+1Ah]
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 2
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_60262;                    // jns short cseg_60262

    return;                                 // retn

cseg_60286:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 26;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 1Ah
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_60221;                    // jns short cseg_60221
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team number offering job
// out:
//      zero flag: clear = new offer, set = already have this offer
//
// Check do we already have this job offer in job offers queue.
//
void IsOldJobOffer()
{
    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_dont_have_this_job_offer;    // jz short @@dont_have_this_job_offer

    A0 = 92168;                             // mov A0, offset jobOffers
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

l_next_job_offer:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+JobOffer.teamNo]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        return;                             // jz short @@out

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 26;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 26
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_next_job_offer;              // jns short @@next_job_offer

l_dont_have_this_job_offer:;
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - job offer index
// out:
//      A0 -> pointer to that job offer in job_offers
//
void GetJobOfferPtr()
{
    ax = D0;                                // mov ax, word ptr D0
    bx = 26;                                // mov bx, 26
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A0 = 92168;                             // mov A0, offset jobOffers
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - number of team offering job
//      D1 - initial funds offered
//
// Add new job offer to queue as first, shift others one place right.
//
void AddJobOffer()
{
    {
        word src = *(word *)&g_memByte[92034];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numNewJobOffers, 5
    if (flags.zero)
        return;                             // jz @@out

    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_first_job_offer;             // jz short @@first_job_offer

    A0 = 92036;                             // mov A0, offset newJobOffers
    bx = 26;                                // mov bx, 26
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 26;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 26
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    {
        word res = *(word *)&D2 >> 1;
        *(word *)&D2 = res;
    }                                       // shr word ptr D2, 1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

l_shift_offers_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + -28, 2);    // mov ax, [esi-28]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned - srcSigned;
        A0 = res;
    }                                       // sub A0, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    flags.carry = false;                    // or ax, ax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto l_shift_offers_loop;           // jns short @@shift_offers_loop

l_first_job_offer:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[92036] = ax;        // mov newJobOffers.teamNo, ax
    eax = D1;                               // mov eax, D1
    *(dword *)&g_memByte[92056] = eax;      // mov newJobOffers.amountOffered, eax
    g_memByte[92038] = -1;                  // mov newJobOffers.teamName, -1
    {
        word src = *(word *)&g_memByte[92034];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[92034] = src;
    }                                       // add numNewJobOffers, 1
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - number of team offering job to remove
//
// Removes job offer from queue, shift following offers one place left.
//
void RemoveJobOffer()
{
    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    A0 = 92036;                             // mov A0, offset newJobOffers
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

l_next_offer:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+JobOffer.teamNo]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_not_this_offer;              // jnz short @@not_this_offer

    {
        word src = *(word *)&g_memByte[92034];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[92034] = src;
    }                                       // sub numNewJobOffers, 1
    ax = D1;                                // mov ax, word ptr D1
    bx = 13;                                // mov bx, 13
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

l_shift_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+26]
    writeMemory(esi, 2, ax);                // mov [esi+JobOffer.teamNo], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 2
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_shift_loop;                  // jns short @@shift_loop

    return;                                 // retn

l_not_this_offer:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 26;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 26
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_next_offer;                  // jns short @@next_offer
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team number offering job
// out:
//      zero flag: clear = new offer, set = already have this offer
//
// Check do we already have this job offer in new job offers queue.
//
void IsNewJobOffer()
{
    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_new_job_offer;               // jz short @@new_job_offer

    A0 = 92036;                             // mov A0, offset newJobOffers
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

l_job_offers_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+JobOffer.teamNo]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        return;                             // jz short @@out

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 26;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 26
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_job_offers_loop;             // jns short @@job_offers_loop

l_new_job_offer:;
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - new job offer index
// out:
//      A0 -> pointer to that job offer in new_job_offers
//
void GetNewJobOfferPtr()
{
    ax = D0;                                // mov ax, word ptr D0
    bx = 26;                                // mov bx, 26
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A0 = 92036;                             // mov A0, offset newJobOffers
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
}

// =============== S U B R O U T I N E =======================================
//
void JobOffersInit()
{
    cseg_5C57C();                           // call cseg_5C57C
    *(word *)&g_memByte[517542] = -1;       // mov dseg_17BD26, -1

    JobOffersFinish();
}

// =============== S U B R O U T I N E =======================================
//
void JobOffersFinish()
{
    cseg_6065E();                           // call cseg_6065E
}

// =============== S U B R O U T I N E =======================================
//
void JobOffersCommon()
{
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&g_memByte[518826] = ax;       // mov jobOfferOrdinal, ax
    *(word *)&g_memByte[518828] = -1;       // mov oldJobOfferOrdinal, -1
    A6 = 518454;                            // mov A6, offset gotJobOfferMenu
    SWOS::ShowMenu();                       // call ShowMenu
    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, -1
    if (!flags.zero)
        goto cseg_605AC;                    // jnz short cseg_605AC

    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_605B1;                    // jnz short cseg_605B1

    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_605B1;                    // jnz short cseg_605B1

cseg_605AC:;
    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

cseg_605B1:;
    *(word *)&D0 = 12;                      // mov word ptr D0, 12
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void cseg_605C0()
{
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    *(word *)&g_memByte[518826] = -1;       // mov jobOfferOrdinal, -1
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&g_memByte[518828] = ax;       // mov oldJobOfferOrdinal, ax
    A6 = 518454;                            // mov A6, offset gotJobOfferMenu
    SWOS::ShowMenu();                       // call ShowMenu
    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, 0FFFFh
    if (!flags.zero)
        goto cseg_60640;                    // jnz short cseg_60640

    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_60645;                    // jnz short cseg_60645

    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_60645;                    // jnz short cseg_60645

cseg_60640:;
    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

cseg_60645:;
    *(word *)&D0 = 12;                      // mov word ptr D0, 0Ch
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void JobOffersExit()
{
    cseg_60E1C();                           // call cseg_60E1C
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void cseg_6065E()
{
    *(word *)&D0 = 13;                      // mov word ptr D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 60, 2, 1);            // mov [esi+(MenuEntry.isInvisible+38h)], 1
    *(word *)&D0 = 15;                      // mov word ptr D0, 15
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 60, 2, 1);            // mov [esi+(MenuEntry.isInvisible+38h)], 1
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    bx = 15;                                // mov bx, 15
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 30;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 30
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    ax = D1;                                // mov ax, word ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 20
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    ax = D1;                                // mov ax, word ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 15;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 15
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 56
    ax = D1;                                // mov ax, word ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 15;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 15
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 56
    ax = D1;                                // mov ax, word ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 15;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 15
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 56
    ax = D1;                                // mov ax, word ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 15;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 15
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 56
    ax = D1;                                // mov ax, word ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 15;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 15
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 56
}

// =============== S U B R O U T I N E =======================================
//
void cseg_6087D()
{
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.carry)
        return;                             // jnb cseg_60BA2

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 0);             // mov word ptr [esi+6], 0
    *(word *)&D0 = 15;                      // mov word ptr D0, 0Fh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    writeMemory(esi + 60, 2, 0);            // mov word ptr [esi+3Ch], 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    ax = *(word *)&g_memByte[517542];       // mov ax, dseg_17BD26
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.zero)
        goto cseg_6092B;                    // jnz short cseg_6092B

    *(word *)&D5 = 13;                      // mov word ptr D5, 0Dh

cseg_6092B:;
    push(D0);                               // push D0
    D0 = 15;                                // mov D0, 0Fh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D0 |= ax;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // or word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 15;                                // mov D0, 0Fh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+24h]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        word res = *(word *)&D3 & 65520;
        *(word *)&D3 = res;
    }                                       // and word ptr D3, 0FFF0h
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 16;                                // mov D0, 10h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+24h]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    {
        word res = *(word *)&D4 & 65520;
        *(word *)&D4 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D4, 0FFF0h
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetJobOfferPtr();                       // call GetJobOfferPtr
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2
    A2 = eax;                               // mov A2, eax
    esi = A6;                               // mov esi, A6
    {
        dword src = readMemory(esi + 20, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi+14h], 0FFFFFFFFh
    if (!flags.zero)
        goto cseg_60AF7;                    // jnz short cseg_60AF7

    A0 = 6275;                              // mov A0, offset aInternationa_0
    goto cseg_60B01;                        // jmp short cseg_60B01

cseg_60AF7:;
    A0 = 11582;                             // mov A0, offset aJobOfferFromA

cseg_60B01:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+14h]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto cseg_60B34;                    // jnz short cseg_60B34

    A0 = 11600;                             // mov A0, offset aJobOfferFromAW
    *(word *)&D3 |= 6;                      // or word ptr D3, 6
    *(word *)&D4 |= 6;
    flags.carry = false;
    flags.sign = (*(word *)&D4 & 0x8000) != 0;
    flags.zero = *(word *)&D4 == 0;         // or word ptr D4, 6
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1

cseg_60B34:;
    PrintFormatted();                       // call PrintFormatted
    ax = D3;                                // mov ax, word ptr D3
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 36, 2, ax);           // mov [esi+24h], ax
    ax = D4;                                // mov ax, word ptr D4
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 36, 2, ax);           // mov [esi+24h], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 15;                                // mov D0, 0Fh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    SWOS::DrawMultipleItems();              // call DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void JobOffersAfterDrawCommon()
{
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.carry)
        return;                             // jnb @@out

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 0);             // mov [esi+MenuEntry.isDisabled], 0
    *(word *)&D0 = 13;                      // mov word ptr D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    writeMemory(esi + 60, 2, 0);            // mov [esi+(MenuEntry.isInvisible+38h)], 0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        word res = *(word *)&D3 & 65520;
        *(word *)&D3 = res;
    }                                       // and word ptr D3, 0FFF0h
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 14;                                // mov D0, 14
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    {
        word res = *(word *)&D4 & 65520;
        *(word *)&D4 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D4, 0FFF0h
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetNewJobOfferPtr();                    // call GetNewJobOfferPtr
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2
    A2 = eax;                               // mov A2, eax
    esi = A6;                               // mov esi, A6
    {
        dword src = readMemory(esi + 20, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi+20], -1
    if (!flags.zero)
        goto l_not_an_international_offer;  // jnz short @@not_an_international_offer

    A0 = 6275;                              // mov A0, offset aInternationa_0
    goto cseg_60D7A;                        // jmp short cseg_60D7A

l_not_an_international_offer:;
    A0 = 11582;                             // mov A0, offset aJobOfferFromA

cseg_60D7A:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+20]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto l_print_offer_string;          // jnz short @@print_offer_string

    A0 = 11600;                             // mov A0, offset aJobOfferFromAW
    *(word *)&D3 |= 6;                      // or word ptr D3, 6
    *(word *)&D4 |= 6;
    flags.carry = false;
    flags.sign = (*(word *)&D4 & 0x8000) != 0;
    flags.zero = *(word *)&D4 == 0;         // or word ptr D4, 6
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1

l_print_offer_string:;
    PrintFormatted();                       // call PrintFormatted
    ax = D3;                                // mov ax, word ptr D3
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    ax = D4;                                // mov ax, word ptr D4
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    SWOS::DrawMultipleItems();              // call DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void cseg_60E1C()
{
    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_60E70;                    // jz short cseg_60E70

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_60E35:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetJobOfferPtr();                       // call GetJobOfferPtr
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+14h]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto cseg_60E67;                    // jnz short cseg_60E67

    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_601FA();                           // call cseg_601FA

cseg_60E67:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_60E35;                    // jns short cseg_60E35

cseg_60E70:;
    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_60EC4

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_60E89:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetNewJobOfferPtr();                    // call GetNewJobOfferPtr
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+14h]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto cseg_60EBB;                    // jnz short cseg_60EBB

    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    RemoveJobOffer();                       // call RemoveJobOffer

cseg_60EBB:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_60E89;                    // jns short cseg_60E89
}

// =============== S U B R O U T I N E =======================================
//
void PlayChairmanScene()
{
}

// =============== S U B R O U T I N E =======================================
//
void EditCustomTeam()
{
    A0 = 18871;                             // mov A0, offset aEditCustomTeam
    CheckContinueAbortPrompt();             // call CheckContinueAbortPrompt
    if (!flags.zero)
        { nullsub_36(); return; }           // jnz nullsub_36

    *(word *)&g_memByte[131757] = 0;        // mov g_numSelectedTeams, 0
    *(word *)&g_memByte[521024] = 0;        // mov saveCustomTeams, 0
    A0 = 16522;                             // mov A0, offset aSelectTeamToEd
    A1 = -161;                              // mov A1, offset EditTeamsCallback
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    *(word *)&D4 = 1;                       // mov word ptr D4, 1
    ChooseTeamsDialog();                    // call ChooseTeamsDialog
    ax = *(word *)&g_memByte[521024];       // mov ax, saveCustomTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_dont_save_custom_teams;      // jz @@dont_save_custom_teams

l_prompt_save_custom_teams:;
    A0 = 18871;                             // mov A0, offset aEditCustomTeam
    A1 = 14693;                             // mov A1, offset customTeamsChanged
    A2 = 19661;                             // mov A2, offset aSave
    A3 = 17196;                             // mov A3, offset aAbort
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    SWOS::DoContinueAbortMenu();            // call DoContinueAbortMenu
    if (flags.zero)
        goto l_save_custom_teams;           // jz short @@save_custom_teams

    goto l_dont_save_custom_teams;          // jmp short @@dont_save_custom_teams

l_save_custom_teams:;
    A0 = 18871;                             // mov A0, offset aEditCustomTeam
    SetZeroFlag();                          // call SetZeroFlag
    if (!flags.zero)
        goto l_prompt_save_custom_teams;    // jnz short @@prompt_save_custom_teams

    A0 = 252426;                            // mov A0, offset aCustoms_edt
    A1 = 252466;                            // mov A1, offset teamFileBuffer
    ax = *(word *)&g_memByte[252466];       // mov ax, word ptr teamFileBuffer
    {
        byte tmp = al;
        al = ah;
        ah = tmp;
    }                                       // xchg ah, al
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // add D1, 2
    SWOS::WriteFile();                      // call WriteFile
    if (flags.zero)
        goto l_dont_save_custom_teams;      // jz short @@dont_save_custom_teams

    nullsub_9();                            // call nullsub_9
    goto l_prompt_save_custom_teams;        // jmp @@prompt_save_custom_teams

l_dont_save_custom_teams:;
    g_memByte[316572] = 255;                // mov lastLoadedExtNumber, 255
    A0 = 18871;                             // mov A0, offset aEditCustomTeam
    SetZeroFlag();                          // jmp SetZeroFlag
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsCallback()
{
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    *(dword *)&g_memByte[521020] = eax;     // mov editTeamsSelectedTeam, eax
    A6 = 518840;                            // mov A6, offset editTeamsMenu
    push(A5);                               // push A5
    SWOS::ShowMenu();                       // call ShowMenu
    pop(A5);                                // pop A5

    nullsub_36();
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_36()
{
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsInit()
{
    eax = *(dword *)&g_memByte[521020];     // mov eax, editTeamsSelectedTeam
    A0 = eax;                               // mov A0, eax
    A1 = 380870;                            // mov A1, offset editTeamsTeam
    *(word *)&D0 = 341;                     // mov word ptr D0, 341

l_copy_team:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_team;                   // jns short @@copy_team

    *(word *)&g_memByte[521026] = 0;        // mov teamIsImported, 0

    EditTeamsFinish();
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsFinish()
{
    InitEditTeamsMenu();                    // call InitEditTeamsMenu
    nullsub_22();                           // call nullsub_22
}

// =============== S U B R O U T I N E =======================================
//
void ImportTeamsMenu()
{
    A0 = 252466;                            // mov A0, offset teamFileBuffer
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, 2
    {
        dword res = D1 >> 1;
        D1 = res;
    }                                       // shr D1, 1
    A1 = 382238;                            // mov A1, offset editTeamsBuffer

l_copy_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // sub D1, 1
    if (!flags.zero)
        goto l_copy_loop;                   // jnz short @@copy_loop

    A0 = 330184;                            // mov A0, offset lastSelectedTeam
    A1 = 426016;                            // mov A1, offset editTeamsSaveVarsArea
    *(word *)&D0 = 245;                     // mov word ptr D0, 245

l_save_vars:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_save_vars;                   // jns short @@save_vars

    A0 = 16726;                             // mov A0, offset aSelectTeamToIm
    SetZeroFlag();                          // call SetZeroFlag
    A0 = 16726;                             // mov A0, offset aSelectTeamToIm
    A1 = 0;                                 // mov A1, 0
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    *(word *)&D3 = 1;                       // mov word ptr D3, 1
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    ChooseTeamsDialog();                    // call ChooseTeamsDialog
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -1
    if (flags.zero)
        goto l_selection_aborted;           // jz @@selection_aborted

    ax = *(word *)&g_memByte[380870];       // mov ax, word ptr editTeamsTeam
    push(ax);                               // push ax
    al = g_memByte[380895];                 // mov al, editTeamsTeam+19h
    push(ax);                               // push ax
    A1 = 380870;                            // mov A1, offset editTeamsTeam
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    *(word *)&D0 = 340;                     // mov word ptr D0, 340

l_copy_selected_team:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_selected_team;          // jns short @@copy_selected_team

    {
        int32_t val = stack[stackTop++];
        ax = val;
    }                                       // pop ax
    g_memByte[380895] = al;                 // mov editTeamsTeam+19h, al
    {
        int32_t val = stack[stackTop++];
        ax = val;
    }                                       // pop ax
    *(word *)&g_memByte[380870] = ax;       // mov word ptr editTeamsTeam, ax
    *(word *)&g_memByte[521026] = 1;        // mov teamIsImported, 1
    *(word *)&D0 = 21;                      // mov word ptr D0, 21
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

l_selection_aborted:;
    A0 = 330184;                            // mov A0, offset lastSelectedTeam
    A1 = 426016;                            // mov A1, offset editTeamsSaveVarsArea
    *(word *)&D0 = 245;                     // mov word ptr D0, 245

l_restore_vars:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_restore_vars;                // jns short @@restore_vars

    g_memByte[316572] = -1;                 // mov lastLoadedExtNumber, -1
    A0 = 382238;                            // mov A0, offset editTeamsBuffer
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, 2
    {
        dword res = D1 >> 1;
        D1 = res;
    }                                       // shr D1, 1
    A1 = 252466;                            // mov A1, offset teamFileBuffer

l_copy_to_team_file_buffer:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // sub D1, 1
    if (!flags.zero)
        goto l_copy_to_team_file_buffer;    // jnz short @@copy_to_team_file_buffer

    InitEditTeamsMenu();                    // jmp InitEditTeamsMenu
}

// =============== S U B R O U T I N E =======================================

// Restore team currently editing.
//
void EditTeamsUndo()
{
    *(word *)&g_memByte[521026] = 0;        // mov teamIsImported, 0
    eax = *(dword *)&g_memByte[521020];     // mov eax, editTeamsSelectedTeam
    A0 = eax;                               // mov A0, eax
    A1 = 380870;                            // mov A1, offset editTeamsTeam
    *(word *)&D0 = 341;                     // mov word ptr D0, 341

l_copy_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_loop;                   // jns short @@copy_loop

    InitEditTeamsMenu();                    // call InitEditTeamsMenu
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsOK()
{
    eax = *(dword *)&g_memByte[521020];     // mov eax, editTeamsSelectedTeam
    A0 = eax;                               // mov A0, eax
    A1 = 380870;                            // mov A1, offset editTeamsTeam
    *(word *)&D1 = 341;                     // mov word ptr D1, 341

l_compare_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_difference_found;            // jnz short @@difference_found

    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_compare_loop;                // jns short @@compare_loop

    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

l_difference_found:;
    *(word *)&g_memByte[521024] = 1;        // mov saveCustomTeams, 1
    eax = *(dword *)&g_memByte[521020];     // mov eax, editTeamsSelectedTeam
    A1 = eax;                               // mov A1, eax
    A0 = 380870;                            // mov A0, offset editTeamsTeam
    *(word *)&D0 = 341;                     // mov word ptr D0, 341

l_copy_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_loop;                   // jns short @@copy_loop

    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================

// [edit teams menu procedure]
// Called when shirt is selected in edit teams menu.
// Changes color of shirts.
//
void EditTeamsChangeShirtsPrimary()
{
    A6 = 380870;                            // mov A6, offset editTeamsTeam
    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 81h
    if (flags.zero)
        goto l_stripes_color_up;            // jz short @@stripes_color_up

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 513;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 201h
    if (flags.zero)
        goto l_shirt_color_up;              // jz @@shirt_color_up

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 257;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 101h
    if (flags.zero)
        goto l_shirt_color_down;            // jz short @@shirt_color_down

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 65;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 41h
    if (flags.zero)
        goto l_stripes_color_down;          // jz short @@stripes_color_down

    return;                                 // jmp @@out

l_stripes_color_down:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 1
    if (!flags.sign)
        goto l_set_stripes_color;           // jns @@set_stripes_color

    *(byte *)&D0 = 9;                       // mov byte ptr D0, 9
    goto l_set_stripes_color;               // jmp @@set_stripes_color

l_stripes_color_up:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 10;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 10
    if (!flags.zero)
        goto l_set_stripes_color;           // jnz short @@set_stripes_color

    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0
    goto l_set_stripes_color;               // jmp short @@set_stripes_color

l_shirt_color_down:;
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 26, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.prShirtType], SHIRT_ORDINARY
    if (flags.zero)
        goto l_stripes_color_down;          // jz short @@stripes_color_down

    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 1
    if (!flags.sign)
        goto l_set_basic_color;             // jns short @@set_basic_color

    *(byte *)&D0 = 9;                       // mov byte ptr D0, 9
    goto l_set_basic_color;                 // jmp short @@set_basic_color

l_shirt_color_up:;
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 26, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.prShirtType], SHIRT_ORDINARY
    if (flags.zero)
        goto l_stripes_color_up;            // jz short @@stripes_color_up

    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 10;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 10
    if (!flags.zero)
        goto l_set_basic_color;             // jnz short @@set_basic_color

    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0
    goto l_set_basic_color;                 // jmp short @@set_basic_color

l_set_stripes_color:;
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 27, 1, al);           // mov [esi+TeamFile.prStripesColor], al
    goto cseg_61653;                        // jmp short cseg_61653

l_set_basic_color:;
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 28, 1, al);           // mov [esi+TeamFile.prBasicColor], al

cseg_61653:;
    PrimaryKitColorConversion();            // call PrimaryKitColorConversion
    nullsub_22();                           // call nullsub_22
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CallDrawMultipleItems();                // jmp CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsChangeShirtsSecondary()
{
    A6 = 380870;                            // mov A6, offset editTeamsTeam
    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 81h
    if (flags.zero)
        goto l_stripes_color_up;            // jz short @@stripes_color_up

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 513;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 201h
    if (flags.zero)
        goto l_stripes_color_down;          // jz @@stripes_color_down

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 257;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 101h
    if (flags.zero)
        goto l_shirt_type_down;             // jz short @@shirt_type_down

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 65;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 41h
    if (flags.zero)
        goto l_shirt_type_up;               // jz short @@shirt_type_up

    return;                                 // jmp @@out

l_shirt_type_up:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 32, 1);     // mov al, [esi+TeamFile.secStripesColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 1
    if (!flags.sign)
        goto l_set_stripes_color;           // jns @@set_stripes_color

    *(byte *)&D0 = 9;                       // mov byte ptr D0, 9
    goto l_set_stripes_color;               // jmp @@set_stripes_color

l_stripes_color_up:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 32, 1);     // mov al, [esi+TeamFile.secStripesColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 10;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 10
    if (!flags.zero)
        goto l_set_stripes_color;           // jnz short @@set_stripes_color

    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0
    goto l_set_stripes_color;               // jmp short @@set_stripes_color

l_shirt_type_down:;
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 31, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.secShirtTpe], 0
    if (flags.zero)
        goto l_shirt_type_up;               // jz short @@shirt_type_up

    al = (byte)readMemory(esi + 33, 1);     // mov al, [esi+TeamFile.secBasicColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 1
    if (!flags.sign)
        goto l_set_basic_color;             // jns short @@set_basic_color

    *(byte *)&D0 = 9;                       // mov byte ptr D0, 9
    goto l_set_basic_color;                 // jmp short @@set_basic_color

l_stripes_color_down:;
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 31, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.secShirtTpe], 0
    if (flags.zero)
        goto l_stripes_color_up;            // jz short @@stripes_color_up

    al = (byte)readMemory(esi + 33, 1);     // mov al, [esi+TeamFile.secBasicColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 10;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 10
    if (!flags.zero)
        goto l_set_basic_color;             // jnz short @@set_basic_color

    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0
    goto l_set_basic_color;                 // jmp short @@set_basic_color

l_set_stripes_color:;
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 32, 1, al);           // mov [esi+TeamFile.secStripesColor], al
    goto l_do_conversion;                   // jmp short @@do_conversion

l_set_basic_color:;
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 33, 1, al);           // mov [esi+TeamFile.secBasicColor], al

l_do_conversion:;
    SecondaryKitColorConversion();          // call SecondaryKitColorConversion
    nullsub_22();                           // call nullsub_22
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CallDrawMultipleItems();                // jmp CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsChangeShortsPrimary()
{
    A6 = 380870;                            // mov A6, offset editTeamsTeam
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 29, 1);     // mov al, [esi+TeamFile.prShortsColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 65;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 41h
    if (flags.zero)
        goto l_shorts_color_down;           // jz short @@shorts_color_down

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 257;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 101h
    if (flags.zero)
        goto l_shorts_color_down;           // jz short @@shorts_color_down

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 81h
    if (flags.zero)
        goto l_shorts_color_up;             // jz short @@shorts_color_up

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 513;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 201h
    if (flags.zero)
        goto l_shorts_color_up;             // jz short @@shorts_color_up

    return;                                 // jmp @@out

l_shorts_color_down:;
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 1
    if (!flags.sign)
        goto l_change_shorts_color;         // jns short @@change_shorts_color

    *(byte *)&D0 = 9;                       // mov byte ptr D0, 9
    goto l_change_shorts_color;             // jmp short @@change_shorts_color

l_shorts_color_up:;
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 10;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 10
    if (!flags.zero)
        goto l_change_shorts_color;         // jnz short @@change_shorts_color

    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0

l_change_shorts_color:;
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 29, 1, al);           // mov [esi+TeamFile.prShortsColor], al
    PrimaryKitColorConversion();            // call PrimaryKitColorConversion
    nullsub_22();                           // call nullsub_22
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CallDrawMultipleItems();                // jmp CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsChangeShortsSecondary()
{
    A6 = 380870;                            // mov A6, offset editTeamsTeam
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 34, 1);     // mov al, [esi+TeamFile.secShortsColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 65;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 41h
    if (flags.zero)
        goto l_short_color_down;            // jz short @@short_color_down

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 257;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 101h
    if (flags.zero)
        goto l_short_color_down;            // jz short @@short_color_down

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 81h
    if (flags.zero)
        goto l_shorts_color_up;             // jz short @@shorts_color_up

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 513;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 201h
    if (flags.zero)
        goto l_shorts_color_up;             // jz short @@shorts_color_up

    return;                                 // jmp @@out

l_short_color_down:;
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 1
    if (!flags.sign)
        goto l_change_shorts_color;         // jns short @@change_shorts_color

    *(byte *)&D0 = 9;                       // mov byte ptr D0, 9
    goto l_change_shorts_color;             // jmp short @@change_shorts_color

l_shorts_color_up:;
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 10;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 10
    if (!flags.zero)
        goto l_change_shorts_color;         // jnz short @@change_shorts_color

    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0

l_change_shorts_color:;
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 34, 1, al);           // mov [esi+TeamFile.secShortsColor], al
    SecondaryKitColorConversion();          // call SecondaryKitColorConversion
    nullsub_22();                           // call nullsub_22
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CallDrawMultipleItems();                // jmp CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsChangeSocksPrimary()
{
    A6 = 380870;                            // mov A6, offset editTeamsTeam
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 30, 1);     // mov al, [esi+TeamFile.prSocksColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 65;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 41h
    if (flags.zero)
        goto l_socks_color_down;            // jz short @@socks_color_down

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 257;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 101h
    if (flags.zero)
        goto l_socks_color_down;            // jz short @@socks_color_down

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 81h
    if (flags.zero)
        goto l_socks_color_up;              // jz short @@socks_color_up

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 513;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 201h
    if (flags.zero)
        goto l_socks_color_up;              // jz short @@socks_color_up

    return;                                 // jmp @@out

l_socks_color_down:;
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 1
    if (!flags.sign)
        goto l_change_socks_color;          // jns short @@change_socks_color

    *(byte *)&D0 = 9;                       // mov byte ptr D0, 9
    goto l_change_socks_color;              // jmp short @@change_socks_color

l_socks_color_up:;
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 10;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 10
    if (!flags.zero)
        goto l_change_socks_color;          // jnz short @@change_socks_color

    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0

l_change_socks_color:;
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 30, 1, al);           // mov [esi+TeamFile.prSocksColor], al
    PrimaryKitColorConversion();            // call PrimaryKitColorConversion
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CallDrawMultipleItems();                // jmp CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsChangeSocksSecondary()
{
    A6 = 380870;                            // mov A6, offset editTeamsTeam
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 35, 1);     // mov al, [esi+TeamFile.secSocksColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 65;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 41h
    if (flags.zero)
        goto l_socks_color_up;              // jz short @@socks_color_up

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 257;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 101h
    if (flags.zero)
        goto l_socks_color_up;              // jz short @@socks_color_up

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 81h
    if (flags.zero)
        goto l_socks_color_down;            // jz short @@socks_color_down

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 513;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 201h
    if (flags.zero)
        goto l_socks_color_down;            // jz short @@socks_color_down

    return;                                 // jmp @@out

l_socks_color_up:;
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 1
    if (!flags.sign)
        goto cseg_61AE9;                    // jns short cseg_61AE9

    *(byte *)&D0 = 9;                       // mov byte ptr D0, 9
    goto cseg_61AE9;                        // jmp short cseg_61AE9

l_socks_color_down:;
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 10;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 10
    if (!flags.zero)
        goto cseg_61AE9;                    // jnz short cseg_61AE9

    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0

cseg_61AE9:;
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 35, 1, al);           // mov [esi+TeamFile.secSocksColor], al
    SecondaryKitColorConversion();          // call SecondaryKitColorConversion
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CallDrawMultipleItems();                // jmp CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsSelectPrimaryShirtType()
{
    A6 = 380870;                            // mov A6, offset editTeamsTeam
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 12;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 12
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 26, 1, al);           // mov [esi+TeamFile.prShirtType], al
    MarkFirstKitShirt();                    // call MarkFirstKitShirt
    PrimaryKitColorConversion();            // call PrimaryKitColorConversion
    nullsub_22();                           // call nullsub_22
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CallDrawMultipleItems();                // call CallDrawMultipleItems
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CallDrawMultipleItems();                // jmp CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsSelectSecondaryShirtType()
{
    A6 = 380870;                            // mov A6, offset editTeamsTeam
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 16
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 31, 1, al);           // mov [esi+TeamFile.secShirtTpe], al
    MarkSecondKitShirt();                   // call MarkSecondKitShirt
    SecondaryKitColorConversion();          // call SecondaryKitColorConversion
    nullsub_22();                           // call nullsub_22
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 16;                                // mov D0, 16
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CallDrawMultipleItems();                // call CallDrawMultipleItems
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CallDrawMultipleItems();                // jmp CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsChangePlayerName()
{
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 23;                      // mov word ptr D0, 23
    SWOS::InputText();                      // jmp InputText
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsSelectTeamName()
{
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 17;                      // mov word ptr D0, 17
    SWOS::InputText();                      // jmp InputText
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsSelectCoachName()
{
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 23;                      // mov word ptr D0, 23
    SWOS::InputText();                      // jmp InputText
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsChangePlayerFace()
{
    EditTeamsGetPlayerPointer();            // call EditTeamsGetPlayerPointer
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 24;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 18h
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 3
    if (!flags.zero)
        goto l_not_overflown;               // jnz short @@not_overflown

    *(word *)&D0 = 0;                       // mov word ptr D0, 0

l_not_overflown:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 231;
        src = res;
        writeMemory(esi + 102, 1, src);
    }                                       // and [esi+(PlayerFile.positionAndFace+4Ch)], 0E7h
    {
        byte res = *(byte *)&D0 << 3;
        *(byte *)&D0 = res;
    }                                       // shl byte ptr D0, 3
    al = D0;                                // mov al, byte ptr D0
    {
        byte src = (byte)readMemory(esi + 102, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 102, 1, src);
    }                                       // add [esi+(PlayerFile.positionAndFace+4Ch)], al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 186;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, SPR_PL_FACE_WHITE_GUY
    ax = D1;                                // mov ax, word ptr D1
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.sprite2], ax
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================

// [edit teams menu function]
// Sets small faces and player names menu entries.
// Set coach name. Mark in red shirt corresponding
// to team settings, for both kits.
// Also do some kind of color conversion.
// Reads all from edit teams selected team.
//
void InitEditTeamsMenu()
{
    *(word *)&D0 = 20;                      // mov word ptr D0, 20
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    ax = *(word *)&g_memByte[521026];       // mov ax, teamIsImported
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_team_not_imported;           // jz short @@team_not_imported

    *(word *)&D0 = 20;                      // mov word ptr D0, 20
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

l_team_not_imported:;
    A6 = 380870;                            // mov A6, offset editTeamsTeam
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 5
    A2 = eax;                               // mov A2, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 36;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 36
    A2 = eax;                               // mov A2, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    PrimaryKitColorConversion();            // call PrimaryKitColorConversion
    SecondaryKitColorConversion();          // call SecondaryKitColorConversion
    MarkFirstKitShirt();                    // call MarkFirstKitShirt
    MarkSecondKitShirt();                   // call MarkSecondKitShirt
    push(D0);                               // push D0
    D0 = 23;                                // mov D0, 23
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 39;                                // mov D0, 39
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    *(word *)&D7 = 15;                      // mov word ptr D7, 15

l_faces_and_names_loop:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 24;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 18h
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 186;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, SPR_PL_FACE_WHITE_GUY
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+38], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, PlayerFile.playerName+4Ch
    A2 = eax;                               // mov A2, eax
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 56
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 38;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A6 = res;
    }                                       // add A6, 38
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_faces_and_names_loop;        // jns short @@faces_and_names_loop
}

// =============== S U B R O U T I N E =======================================
//
void EditTeamsPlayersBeforeDraw()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 23;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 23
    ax = D0;                                // mov ax, word ptr D0
    bx = 38;                                // mov bx, 38
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A6 = 380870;                            // mov A6, offset editTeamsTeam
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A6 = res;
    }                                       // add A6, eax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    push(D0);                               // push D0
    D0 = 55;                                // mov D0, 55
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+(PlayerFile.shirtNumber+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    A2 = 332080;                            // mov A2, offset playerPositionsStringTable
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 56
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 55;                                // mov D0, 55
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    SWOS::DrawMultipleItems();              // jmp DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================

// [edit teams menu function]
//
void PrimaryKitColorConversion()
{
    A6 = 380870;                            // mov A6, offset editTeamsTeam
    A2 = 520728;                            // mov A2, offset editTeamsPrimaryShirtColTable
    A3 = 323927;                            // mov A3, offset kTeamColorsTable
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 << 1;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 1
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        word res = *(word *)&D2 << 1;
        *(word *)&D2 = res;
    }                                       // shl word ptr D2, 1
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    A3 = 520940;                            // mov A3, offset shirtTypesTable
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 26, 1);     // mov al, [esi+TeamFile.prShirtType]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 << 4;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 4
    eax = A3;                               // mov eax, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A3 = eax;                               // mov A3, eax
    A4 = 521004;                            // mov A4, offset shirtsIndexTable
    *(word *)&D3 = 7;                       // mov word ptr D3, 7

cseg_6221F:;
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A3;                               // mov esi, A3
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 2
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 2
    if (flags.zero)
        goto cseg_62261;                    // jz short cseg_62261

    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    writeMemory(esi + ebx, 2, ax);          // mov [esi+ebx], ax
    goto cseg_62278;                        // jmp short cseg_62278

cseg_62261:;
    ax = D2;                                // mov ax, word ptr D2
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    writeMemory(esi + ebx, 2, ax);          // mov [esi+ebx], ax

cseg_62278:;
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_6221F;                    // jns short cseg_6221F

    A3 = 323927;                            // mov A3, offset kTeamColorsTable
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 29, 1);     // mov al, [esi+TeamFile.prShortsColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&g_memByte[520786] = ax;       // mov word ptr editTeamsShortsColTable+16h, ax
    A2 = 520800;                            // mov A2, offset editTeamsSocksColTable
    A3 = 323927;                            // mov A3, offset kTeamColorsTable
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 30, 1);     // mov al, [esi+TeamFile.prSocksColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[520822] = ax;       // mov word ptr editTeamsSocksColTable+16h, ax
}

// =============== S U B R O U T I N E =======================================

// [edit teams menu function]
//
void SecondaryKitColorConversion()
{
    A6 = 380870;                            // mov A6, offset editTeamsTeam
    A2 = 520836;                            // mov A2, offset editTeamsSecondaryShirtColTable
    A3 = 323927;                            // mov A3, offset kTeamColorsTable
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 32, 1);     // mov al, [esi+TeamFile.secStripesColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 << 1;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 1
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 33, 1);     // mov al, [esi+TeamFile.secBasicColor]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        word res = *(word *)&D2 << 1;
        *(word *)&D2 = res;
    }                                       // shl word ptr D2, 1
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    A3 = 520940;                            // mov A3, offset shirtTypesTable
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 31, 1);     // mov al, [esi+TeamFile.secShirtTpe]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 << 4;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 4
    eax = A3;                               // mov eax, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A3 = eax;                               // mov A3, eax
    A4 = 521004;                            // mov A4, offset shirtsIndexTable
    *(word *)&D3 = 7;                       // mov word ptr D3, 7

cseg_62403:;
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A3;                               // mov esi, A3
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 2
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 2
    if (flags.zero)
        goto cseg_62445;                    // jz short cseg_62445

    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    writeMemory(esi + ebx, 2, ax);          // mov [esi+ebx], ax
    goto cseg_6245C;                        // jmp short cseg_6245C

cseg_62445:;
    ax = D2;                                // mov ax, word ptr D2
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    writeMemory(esi + ebx, 2, ax);          // mov [esi+ebx], ax

cseg_6245C:;
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_62403;                    // jns short cseg_62403

    A3 = 323927;                            // mov A3, offset kTeamColorsTable
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 34, 1);     // mov al, [esi+TeamFile.secShortsColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&g_memByte[520894] = ax;       // mov word ptr editTeamsSecondaryShortsColTable+16h, ax
    A2 = 520908;                            // mov A2, offset editTeamsSecondarySocksColTable
    A3 = 323927;                            // mov A3, offset kTeamColorsTable
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 35, 1);     // mov al, [esi+TeamFile.secSocksColor]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[520930] = ax;       // mov word ptr editTeamsSecondarySocksColTable+16h, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================

// [edit teams menu procedure]
// In edit menu team colors in red shirt corresponding
// to selected team settings, for the first (upper) kit.
//
void MarkFirstKitShirt()
{
    A6 = 380870;                            // mov A6, offset editTeamsTeam
    push(D0);                               // push D0
    D0 = 15;                                // mov D0, 15
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 26, 1);     // mov al, [esi+TeamFile.prShirtType]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    *(word *)&D1 = 3;                       // mov word ptr D1, 3

l_shirts_loop:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 30, 2, 9);            // mov [esi+MenuEntry.bg.backAndFrameColor], 9
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto l_not_this_type;               // jnz short @@not_this_type

    writeMemory(esi + 30, 2, 10);           // mov word ptr [esi+30], 10

l_not_this_type:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        A0 = res;
    }                                       // sub A0, 56
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_shirts_loop;                 // jns short @@shirts_loop
}

// =============== S U B R O U T I N E =======================================

// [edit teams menu procedure]
// In edit menu team colors in red shirt corresponding
// to selected team settings, for the second (lower) kit.
//
void MarkSecondKitShirt()
{
    A6 = 380870;                            // mov A6, offset editTeamsTeam
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 31, 1);     // mov al, [esi+TeamFile.secShirtTpe]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    *(word *)&D1 = 3;                       // mov word ptr D1, 3

l_shirts_loop:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 30, 2, 9);            // mov [esi+MenuEntry.bg.backAndFrameColor], 9
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto l_not_this_type;               // jnz short @@not_this_type

    writeMemory(esi + 30, 2, 10);           // mov [esi+MenuEntry.bg.backAndFrameColor], 10

l_not_this_type:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        A0 = res;
    }                                       // sub A0, 56
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_shirts_loop;                 // jns short @@shirts_loop
}

// =============== S U B R O U T I N E =======================================

// [edit teams function]
// out:
//     A0 -> currently selected player
//
void EditTeamsGetPlayerPointer()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 23;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 23
    ax = D0;                                // mov ax, word ptr D0
    bx = 38;                                // mov bx, 38
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A0 = 380870;                            // mov A0, offset editTeamsTeam
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, eax
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_22()
{
}

// =============== S U B R O U T I N E =======================================
//
void ResetAnimatedPatternsForBothTeams()
{
}

// =============== S U B R O U T I N E =======================================
//
void cseg_63919()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    A0 = 99550;                             // mov A0, offset trainingMatchSavedPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_639F9()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ax = *(word *)&g_memByte[99548];        // mov ax, dseg_D8B6A
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto cseg_63A6B;                    // jnz short cseg_63A6B

    *(word *)&g_memByte[99548] = 65535;     // mov dseg_D8B6A, 0FFFFh

cseg_63A6B:;
    A6 = 99550;                             // mov A6, offset trainingMatchSavedPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1

cseg_63A89:;
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto cseg_63AAD;                    // jz short cseg_63AAD

    (*(int16_t *)&D6)--;
    flags.overflow = (int16_t)(*(int16_t *)&D6) == INT16_MIN;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto cseg_63A89;                    // jns short cseg_63A89

    debugBreak();                           // int 3

cseg_63AAB:;
    goto cseg_63AAB;                        // jmp short cseg_63AAB

cseg_63AAD:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 0Bh
    if (!flags.carry)
        goto cseg_63C62;                    // jnb cseg_63C62

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayer();                            // call GetPlayer
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    {
        word res = *(word *)&D7 & 224;
        *(word *)&D7 = res;
    }                                       // and word ptr D7, 0E0h
    {
        word res = *(word *)&D7 >> 5;
        *(word *)&D7 = res;
    }                                       // shr word ptr D7, 5
    *(byte *)&D3 = 255;                     // mov byte ptr D3, 0FFh
    A6 = 99550;                             // mov A6, offset trainingMatchSavedPlayers
    *(word *)&D4 = 11;                      // mov word ptr D4, 0Bh

cseg_63B05:;
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A0 = 92798;                             // mov A0, offset careerTeam
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    al = D0;                                // mov al, byte ptr D0
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, al
    if (!flags.zero)
        goto cseg_63BB5;                    // jnz short cseg_63BB5

    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D3, al
    if (flags.sign == flags.overflow)
        goto cseg_63BB5;                    // jge short cseg_63BB5

    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D2 = ax;                      // mov word ptr D2, ax

cseg_63BB5:;
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 1
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (!flags.zero)
        goto cseg_63B05;                    // jnz cseg_63B05

    al = D3;                                // mov al, byte ptr D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.sign)
        goto cseg_63BE2;                    // jns short cseg_63BE2

    *(word *)&D2 = 11;                      // mov word ptr D2, 0Bh

cseg_63BE2:;
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    A0 = 99582;                             // mov A0, offset dseg_D8B8C
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D6 = ax;                      // mov word ptr D6, ax

cseg_63C62:;
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 2
    if (flags.sign)
        goto cseg_63CBC;                    // js short cseg_63CBC

cseg_63C85:;
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx + 1, 1); // mov al, [esi+ebx+1]
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 1
    A6 = eax;                               // mov A6, eax
    (*(int16_t *)&D0)--;
    flags.overflow = (int16_t)(*(int16_t *)&D0) == INT16_MIN;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_63C85;                    // jns short cseg_63C85

cseg_63CBC:;
    A0 = 99550;                             // mov A0, offset trainingMatchSavedPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    writeMemory(esi + ebx, 1, 170);         // mov byte ptr [esi+ebx], 0AAh
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_63D46()
{
    A1 = 99652;                             // mov A1, offset dseg_D8BD2
    *(word *)&D1 = 31;                      // mov word ptr D1, 31

l_copy_positions_loop:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    GetPlayer();                            // call GetPlayer
    pop(D1);                                // pop D1
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+(PlayerFile.shirtNumber+4Ch)]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_copy_positions_loop;         // jns short @@copy_positions_loop

    A1 = 99620;                             // mov A1, offset lastMatchPlayers
    A0 = 92766;                             // mov A0, offset currentMatchPlayers
    *(word *)&D1 = 31;                      // mov word ptr D1, 31

cseg_63DB3:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_63DB3;                    // jns short cseg_63DB3

    al = g_memByte[92822];                  // mov al, careerTeam+18h
    g_memByte[99684] = al;                  // mov currentTactics, al
    ax = *(word *)&g_memByte[94092];        // mov ax, dseg_D761A
    *(word *)&g_memByte[99616] = ax;        // mov dseg_D8BAE, ax
    al = g_memByte[92802];                  // mov al, careerTeam+4
    g_memByte[99685] = al;                  // mov dseg_D8BF3, al
    ax = *(word *)&g_memByte[91722];        // mov ax, coachOrPlayer
    *(word *)&g_memByte[99618] = ax;        // mov dseg_D8BB0, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_63E05()
{
    ax = *(word *)&g_memByte[99618];        // mov ax, dseg_D8BB0
    *(word *)&g_memByte[91722] = ax;        // mov coachOrPlayer, ax
    al = g_memByte[99685];                  // mov al, dseg_D8BF3
    g_memByte[92802] = al;                  // mov careerTeam+4, al
    ax = *(word *)&g_memByte[99616];        // mov ax, dseg_D8BAE
    *(word *)&g_memByte[94092] = ax;        // mov dseg_D761A, ax
    al = g_memByte[99684];                  // mov al, currentTactics
    g_memByte[92822] = al;                  // mov careerTeam+18h, al
    A1 = 99620;                             // mov A1, offset lastMatchPlayers
    A0 = 92766;                             // mov A0, offset currentMatchPlayers
    *(word *)&D1 = 31;                      // mov word ptr D1, 31

cseg_63E4E:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_63E4E;                    // jns short cseg_63E4E

    A1 = 99652;                             // mov A1, offset dseg_D8BD2
    *(word *)&D1 = 31;                      // mov word ptr D1, 1Fh

cseg_63E86:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    GetPlayer();                            // call GetPlayer
    pop(D1);                                // pop D1
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_63E86;                    // jns short cseg_63E86
}

// =============== S U B R O U T I N E =======================================
//
void cseg_63EC4()
{
    A0 = 99550;                             // mov A0, offset trainingMatchSavedPlayers
    A1 = 92766;                             // mov A1, offset currentMatchPlayers
    *(word *)&D0 = 31;                      // mov word ptr D0, 31

cseg_63EE1:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_63EE1;                    // jns short cseg_63EE1

    al = g_memByte[99614];                  // mov al, dseg_D8BAC
    g_memByte[92822] = al;                  // mov careerTeam+18h, al
    ax = *(word *)&g_memByte[99548];        // mov ax, dseg_D8B6A
    *(word *)&g_memByte[94092] = ax;        // mov dseg_D761A, ax
    A1 = 99582;                             // mov A1, offset dseg_D8B8C
    *(word *)&D1 = 31;                      // mov word ptr D1, 1Fh

cseg_63F2F:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    GetPlayer();                            // call GetPlayer
    pop(D1);                                // pop D1
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_63F2F;                    // jns short cseg_63F2F
}

// =============== S U B R O U T I N E =======================================
//
void cseg_63F6F()
{
    A0 = 92766;                             // mov A0, offset currentMatchPlayers
    A1 = 99550;                             // mov A1, offset trainingMatchSavedPlayers
    *(word *)&D0 = 31;                      // mov word ptr D0, 31

cseg_63F8C:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_63F8C;                    // jns short cseg_63F8C

    al = g_memByte[92822];                  // mov al, careerTeam+18h
    g_memByte[99614] = al;                  // mov dseg_D8BAC, al
    ax = *(word *)&g_memByte[94092];        // mov ax, dseg_D761A
    *(word *)&g_memByte[99548] = ax;        // mov dseg_D8B6A, ax
    A1 = 99582;                             // mov A1, offset dseg_D8B8C
    *(word *)&D1 = 31;                      // mov word ptr D1, 31

cseg_63FDA:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    GetPlayer();                            // call GetPlayer
    pop(D1);                                // pop D1
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+4Eh]
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_63FDA;                    // jns short cseg_63FDA
}

// =============== S U B R O U T I N E =======================================

// Check if this is the same team that played the last game.
//
// out:
//      zero flag - set = equal, clear = different
//
void CheckIfTeamIsChanged()
{
    A0 = 99620;                             // mov A0, offset lastMatchPlayers
    A1 = 92766;                             // mov A1, offset currentMatchPlayers
    *(word *)&D1 = 10;                      // mov word ptr D1, 10

l_compare_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto l_different;                   // jnz short @@different

    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_compare_loop;                // jns short @@compare_loop

    al = g_memByte[99684];                  // mov al, currentTactics
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = g_memByte[92822];                  // mov al, careerTeam+18h
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto l_different;                   // jnz short @@different

    ax = *(word *)&g_memByte[99616];        // mov ax, dseg_D8BAE
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[94092];        // mov ax, dseg_D761A
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_different;                   // jnz short @@different

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

l_different:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void PlayTrainingGame()
{
    *(word *)&g_memByte[465960] = 1;        // mov g_trainingGame, 1
    A0 = 92798;                             // mov A0, offset careerTeam
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 2;                       // mov word ptr D1, 2
    cseg_52588();                           // call cseg_52588
    cseg_63D46();                           // call cseg_63D46
    cseg_63EC4();                           // call cseg_63EC4
    cseg_64161();                           // call cseg_64161
    *(word *)&g_memByte[486724] = 0;        // mov pitchTypeOrSeason, 0
    *(word *)&g_memByte[486726] = 65535;    // mov friendlyPitchType, RANDOM
    *(word *)&g_memByte[486728] = 8;        // mov friendlySeason, 8
    *(word *)&g_memByte[486730] = 2;        // mov minSubstitutes, 2
    *(word *)&g_memByte[486732] = 2;        // mov maxSubstitutes, 2
    A1 = 92798;                             // mov A1, offset careerTeam
    A2 = 98218;                             // mov A2, offset currentTeam
    push(A6);                               // push A6
    InitAndPlayGame();                      // call InitAndPlayGame
    pop(A6);                                // pop A6
    *(word *)&g_memByte[99544] = -1;        // mov currentTeamNumber, -1
    *(word *)&g_memByte[465960] = 0;        // mov g_trainingGame, 0
    cseg_63F6F();                           // call cseg_63F6F
    cseg_63E05();                           // call cseg_63E05
}

// =============== S U B R O U T I N E =======================================
//
void cseg_64161()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    *(word *)&g_memByte[99546] = -1;        // mov dseg_D8B68, -1
    A5 = 92798;                             // mov A5, offset careerTeam
    A6 = 98218;                             // mov A6, offset currentTeam
    al = g_memByte[98242];                  // mov al, currentTeam+18h
    push(ax);                               // push ax
    eax = A5;                               // mov eax, A5
    A0 = eax;                               // mov A0, eax
    eax = A6;                               // mov eax, A6
    A1 = eax;                               // mov A1, eax
    *(word *)&D0 = 75;                      // mov word ptr D0, 75

l_copy_header_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.overflow = (int16_t)(*(int16_t *)&D0) == INT16_MIN;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_header_loop;            // jns short @@copy_header_loop

    {
        int32_t val = stack[stackTop++];
        ax = val;
    }                                       // pop ax
    g_memByte[98242] = al;                  // mov currentTeam+18h, al
    A4 = 99510;                             // mov A4, offset playerPositions
    *(word *)&g_memByte[99542] = 0;         // mov numPlayers, 0
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 76
    A1 = eax;                               // mov A1, eax
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_64265:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    push(D1);                               // push D1
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    pop(D1);                                // pop D1
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    IsPlayerInjured();                      // call IsPlayerInjured
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    if (!flags.zero)
        goto cseg_643AA;                    // jnz short cseg_643AA

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 76
    *(word *)&D0 = 37;                      // mov word ptr D0, 37

l_copy_player_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.overflow = (int16_t)(*(int16_t *)&D0) == INT16_MIN;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_player_loop;            // jns short @@copy_player_loop

    al = D6;                                // mov al, byte ptr D6
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A4)++;                    // inc A4
    {
        word src = *(word *)&g_memByte[99542];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[99542] = src;
    }                                       // add numPlayers, 1
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1

cseg_643AA:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 13
    if (!flags.carry)
        goto cseg_64265;                    // jnb cseg_64265

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 1, 1, 153);           // mov byte ptr [esi+1], 153
    writeMemory(esi + 4, 1, 1);             // mov byte ptr [esi+4], 1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&g_memByte[99544] = ax;        // mov currentTeamNumber, ax
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+18h]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 372768;                            // mov A0, offset g_tacticsTable
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 369, 1);    // mov al, [esi+171h]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A3 = 483940;                            // mov A3, offset dseg_16F50A
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A3 = eax;                               // mov A3, eax
    A4 = 99510;                             // mov A4, offset playerPositions
    D7 = 0;                                 // mov D7, 0
    *(word *)&D4 = 0;                       // mov word ptr D4, 0

cseg_6447B:;
    *(word *)&D6 = 0;                       // mov word ptr D6, 0

cseg_64484:;
    cx = D6;                                // mov cx, word ptr D6
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        dword res = D7 & eax;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D7, eax
    if (!flags.zero)
        goto cseg_646A3;                    // jnz cseg_646A3

    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A2 = 521034;                            // mov A2, offset dseg_17D06C
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A2 = eax;                               // mov A2, eax
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_64819;                    // js cseg_64819

    ax = *(word *)&g_memByte[99542];        // mov ax, numPlayers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    *(byte *)&D2 = 255;                     // mov byte ptr D2, 0FFh
    A5 = 0;                                 // mov A5, 0

cseg_64529:;
    cx = D1;                                // mov cx, word ptr D1
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        dword res = D7 & eax;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D7, eax
    if (!flags.zero)
        goto cseg_64616;                    // jnz cseg_64616

    ax = *(word *)&g_memByte[99544];        // mov ax, currentTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    pop(D1);                                // pop D1
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    al = D0;                                // mov al, byte ptr D0
    {
        int8_t dstSigned = *(byte *)&D5;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D5, al
    if (!flags.zero)
        goto cseg_64616;                    // jnz cseg_64616

    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A5, 0
    if (flags.zero)
        goto cseg_645E3;                    // jz short cseg_645E3

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_645B1;                    // jz short cseg_645B1

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (!flags.zero)
        goto cseg_645CB;                    // jnz short cseg_645CB

cseg_645B1:;
    esi = A5;                               // mov esi, A5
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_645E3;                    // jz short cseg_645E3

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_645E3;                    // jz short cseg_645E3

    goto cseg_64616;                        // jmp short cseg_64616

cseg_645CB:;
    esi = A5;                               // mov esi, A5
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_645F4;                    // jz short cseg_645F4

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_645F4;                    // jz short cseg_645F4

cseg_645E3:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_64616;                    // jg short cseg_64616

cseg_645F4:;
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax

cseg_64616:;
    (*(int16_t *)&D1)--;
    flags.overflow = (int16_t)(*(int16_t *)&D1) == INT16_MIN;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_64529;                    // jns cseg_64529

    al = D2;                                // mov al, byte ptr D2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_646A3;                    // js short cseg_646A3

    al = D3;                                // mov al, byte ptr D3
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    esi = A4;                               // mov esi, A4
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    al = D0;                                // mov al, byte ptr D0
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    cx = D6;                                // mov cx, word ptr D6
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D7 |= eax;                              // or D7, eax
    {
        int32_t dstSigned = D7;
        int32_t srcSigned = 2047;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D7, 7FFh
    if (flags.zero)
        goto cseg_646C6;                    // jz short cseg_646C6

cseg_646A3:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 0Bh
    if (!flags.zero)
        goto cseg_64484;                    // jnz cseg_64484

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 1
    goto cseg_6447B;                        // jmp cseg_6447B

cseg_646C6:;
    *(word *)&D1 = 12;                      // mov word ptr D1, 0Ch

cseg_646CF:;
    ax = *(word *)&g_memByte[99544];        // mov ax, currentTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    pop(D1);                                // pop D1
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al
    {
        byte src = (byte)readMemory(esi + 78, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        src = res;
        writeMemory(esi + 78, 1, src);
    }                                       // add byte ptr [esi+4Eh], 1
    (*(int16_t *)&D1)--;
    flags.overflow = (int16_t)(*(int16_t *)&D1) == INT16_MIN;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_646CF;                    // jns short cseg_646CF

    A0 = 92803;                             // mov A0, (offset careerTeam+5)
    A1 = 456352;                            // mov A1, offset team_A_name
    StringCopy();                           // call StringCopy
    A0 = 456352;                            // mov A0, offset team_A_name
    GetStringLength();                      // call GetStringLength
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 14
    if (flags.carry || flags.zero)
        goto cseg_64774;                    // jbe short cseg_64774

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 16
    if (flags.zero)
        goto cseg_64758;                    // jz short cseg_64758

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = -2;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, -2
    A0 = eax;                               // mov A0, eax
    goto cseg_64765;                        // jmp short cseg_64765

cseg_64758:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = -3;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, -3
    A0 = eax;                               // mov A0, eax

cseg_64765:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, '.');               // mov byte ptr [esi], '.'
    (*(int32_t *)&A0)++;                    // inc A0

cseg_64774:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 'A');               // mov byte ptr [esi], 'A'
    (*(int32_t *)&A0)++;
    flags.overflow = (int32_t)(*(int32_t *)&A0) == INT32_MAX;
    flags.sign = (*(int32_t *)&A0 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A0 == 0;      // inc A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    A0 = 456352;                            // mov A0, offset team_A_name
    A1 = 456369;                            // mov A1, offset team_B_name
    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi + -1, 1, 'B');          // mov byte ptr [esi-1], 'B'
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    return;                                 // retn

cseg_64819:;
    debugBreak();                           // int 3

cseg_6481A:;
    goto cseg_6481A;                        // jmp short cseg_6481A
}

// =============== S U B R O U T I N E =======================================
//
void cseg_6481C()
{
    cseg_63F6F();                           // call cseg_63F6F
    al = g_memByte[92822];                  // mov al, careerTeam+18h
    g_memByte[98242] = al;                  // mov currentTeam+18h, al
    cseg_648C7();                           // call cseg_648C7
    A0 = 99550;                             // mov A0, offset trainingMatchSavedPlayers
    al = D4;                                // mov al, byte ptr D4
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_64881;                    // js short cseg_64881

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 11, 1);     // mov al, [esi+0Bh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    writeMemory(esi + 11, 1, al);           // mov [esi+0Bh], al
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al

cseg_64881:;
    al = D5;                                // mov al, byte ptr D5
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        return;                             // js short cseg_648C6

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 12, 1);     // mov al, [esi+0Ch]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    writeMemory(esi + 12, 1, al);           // mov [esi+0Ch], al
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
}

// =============== S U B R O U T I N E =======================================
//
void cseg_648C7()
{
    *(byte *)&D4 = 255;                     // mov byte ptr D4, 0FFh
    *(byte *)&D5 = 255;                     // mov byte ptr D5, 0FFh
    *(word *)&D1 = 11;                      // mov word ptr D1, 11

cseg_648DE:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    pop(D1);                                // pop D1
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 0
    if (flags.zero)
        goto cseg_649C7;                    // jz cseg_649C7

    eax = A4;                               // mov eax, A4
    A1 = eax;                               // mov A1, eax
    al = D4;                                // mov al, byte ptr D4
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_649E3();                           // call cseg_649E3
    if (!flags.zero)
        goto cseg_64988;                    // jnz short cseg_64988

    eax = A4;                               // mov eax, A4
    A5 = eax;                               // mov A5, eax
    al = D4;                                // mov al, byte ptr D4
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    eax = A0;                               // mov eax, A0
    A4 = eax;                               // mov A4, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    goto cseg_649C7;                        // jmp short cseg_649C7

cseg_64988:;
    eax = A5;                               // mov eax, A5
    A1 = eax;                               // mov A1, eax
    al = D5;                                // mov al, byte ptr D5
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_649E3();                           // call cseg_649E3
    if (!flags.zero)
        goto cseg_649C7;                    // jnz short cseg_649C7

    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D3 = ax;                      // mov word ptr D3, ax

cseg_649C7:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto cseg_648DE;                    // jnz cseg_648DE
}

// =============== S U B R O U T I N E =======================================
//
void cseg_649E3()
{
    al = D0;                                // mov al, byte ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_64A36;                    // js short cseg_64A36

    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_64A04;                    // jz short cseg_64A04

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (!flags.zero)
        goto cseg_64A1E;                    // jnz short cseg_64A1E

cseg_64A04:;
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_64A36;                    // jz short cseg_64A36

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_64A36;                    // jz short cseg_64A36

    goto cseg_64A54;                        // jmp short cseg_64A54

cseg_64A1E:;
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_64A47;                    // jz short cseg_64A47

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_64A47;                    // jz short cseg_64A47

cseg_64A36:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.sign == flags.overflow)
        goto cseg_64A54;                    // jge short cseg_64A54

cseg_64A47:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

cseg_64A54:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_64A65()
{
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { nullsub_37(); return; }           // jnz nullsub_37

    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    cseg_64B06();                           // call cseg_64B06
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    cseg_64B06();                           // call cseg_64B06
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    cseg_64B06();                           // call cseg_64B06
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    cseg_64B06();                           // call cseg_64B06
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    cseg_64B06();                           // call cseg_64B06
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    cseg_64B06();                           // call cseg_64B06
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    cseg_64B06();                           // call cseg_64B06
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    cseg_64B06();                           // call cseg_64B06
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    cseg_64B06();                           // call cseg_64B06
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    cseg_64B06();                           // call cseg_64B06
    cseg_6481C();                           // call cseg_6481C
}

// =============== S U B R O U T I N E =======================================
//
void cseg_64B06()
{
    cseg_64B80();                           // call cseg_64B80
    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 153;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 99h
    if (flags.carry)
        { nullsub_37(); return; }           // jb short nullsub_37

    esi = A3;                               // mov esi, A3
    writeMemory(esi + 113, 1, 154);         // mov byte ptr [esi+71h], 9Ah
    cseg_5E345();                           // call cseg_5E345

    nullsub_37();
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_37()
{
}

// =============== S U B R O U T I N E =======================================
//
void AddTrialPlayer()
{
    SWOS::Rand();                           // call Rand
    ax = D0;                                // mov ax, word ptr D0
    bx = 11;                                // mov bx, 11
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        flags.carry = ((word)*(word *)&D0 >> 8) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 8
    A0 = 521138;                            // mov A0, offset dseg_17D0D4
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

    cseg_64B80();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_64B80()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    A0 = 92766;                             // mov A0, offset currentMatchPlayers
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

cseg_64B9F:;
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_64BB3:;
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_64BD5;                    // jnz short cseg_64BD5

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    goto cseg_64B9F;                        // jmp short cseg_64B9F

cseg_64BD5:;
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_64BB3;                    // jns short cseg_64BB3

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayer();                            // call GetPlayer
    cseg_63919();                           // call cseg_63919
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 78, 1, 16);           // mov byte ptr [esi+4Eh], 10h
    {
        word res = *(word *)&D7 << 5;
        flags.carry = ((word)*(word *)&D7 >> 11) & 1;
        *(word *)&D7 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D7, 5
    al = D7;                                // mov al, byte ptr D7
    writeMemory(esi + 102, 1, al);          // mov [esi+66h], al
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    cseg_56615();                           // call cseg_56615
    pop(D1);                                // pop D1
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 2
    if (flags.zero)
        goto cseg_64C59;                    // jz short cseg_64C59

    ax = (word)readMemory(esi + 101, 2);    // mov ax, [esi+65h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    goto cseg_64C69;                        // jmp short cseg_64C69

cseg_64C59:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 77, 2);     // mov ax, [esi+4Dh]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax

cseg_64C69:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 0Bh
    A0 = 92766;                             // mov A0, offset currentMatchPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        goto cseg_64CD2;                    // jz short cseg_64CD2

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_64CB1:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        A0 = res;
    }                                       // sub A0, 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_64CB1;                    // jns short cseg_64CB1

cseg_64CD2:;
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    A0 = 91544;                             // mov A0, offset dseg_D6C26
    SWOS::Rand();                           // call Rand
    ax = D0;                                // mov ax, word ptr D0
    bx = 50;                                // mov bx, 32h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 40;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 28h
    *(int16_t *)&D0 = -*(int16_t *)&D0;     // neg word ptr D0
    al = D0;                                // mov al, byte ptr D0
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[94090] = src;
    }                                       // add careerNumPlayers, 1
    push(D1);                               // push D1
    push(A3);                               // push A3
    cseg_5E345();                           // call cseg_5E345
    pop(A3);                                // pop A3
    pop(D1);                                // pop D1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_64D5A()
{
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_64E3D

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        return;                             // jnz cseg_64E3D

    A5 = 92766;                             // mov A5, offset currentMatchPlayers
    *(word *)&D7 = 10;                      // mov word ptr D7, 0Ah

cseg_64D8C:;
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_64DE6;                    // js short cseg_64DE6

    SWOS::Rand();                           // call Rand
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 20h
    if (!flags.carry)
        goto cseg_64DE6;                    // jnb short cseg_64DE6

    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al

cseg_64DE6:;
    ax = D6;                                // mov ax, word ptr D6
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A6 = eax;                               // mov A6, eax
    push(A0);                               // push A0
    cseg_64E3E();                           // call cseg_64E3E
    pop(A0);                                // pop A0
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_64D8C;                    // jns cseg_64D8C
}

// =============== S U B R O U T I N E =======================================
//
void cseg_64E3E()
{
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_650B9

    eax = A6;                               // mov eax, A6
    D6 = eax;                               // mov D6, eax
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        D6 = res;
    }                                       // sub D6, offset careerTeam
    ax = D6;                                // mov ax, word ptr D6
    dx = *(word *)((byte *)&D6 + 2);        // mov dx, word ptr D6+2
    bx = 38;                                // mov bx, 26h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)((byte *)&D6 + 2) = dx;        // mov word ptr D6+2, dx
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 1;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+66h], 1
    if (!flags.zero)
        goto cseg_6508D;                    // jnz cseg_6508D

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_64FBC;                    // jz cseg_64FBC

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (!flags.zero)
        return;                             // jnz cseg_650B9

    SWOS::Rand();                           // call Rand
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 51;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 33h
    if (!flags.carry)
        return;                             // jnb cseg_650B9

    A0 = 91544;                             // mov A0, offset dseg_D6C26
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 113, 1, al);          // mov [esi+71h], al
    {
        byte src = (byte)readMemory(esi + 102, 1);
        src |= 1;
        writeMemory(esi + 102, 1, src);
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (src & 0x80) != 0;
        flags.zero = src == 0;
    }                                       // or byte ptr [esi+66h], 1
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_5E345();                           // call cseg_5E345
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    return;                                 // jmp cseg_650B9

cseg_64FBC:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 113, 1, 154);         // mov byte ptr [esi+71h], 9Ah
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_5E345();                           // call cseg_5E345
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    return;                                 // jmp short cseg_650B9

cseg_6508D:;
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 113, 1, src);
    }                                       // add byte ptr [esi+71h], 2
    if (flags.sign)
        goto cseg_650A3;                    // js short cseg_650A3

    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 254;
        src = res;
        writeMemory(esi + 102, 1, src);
    }                                       // and byte ptr [esi+66h], 0FEh

cseg_650A3:;
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 100;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 64h
    if (flags.zero || flags.sign != flags.overflow)
        return;                             // jle short cseg_650B9

    writeMemory(esi + 113, 1, 100);         // mov byte ptr [esi+71h], 64h
}

// =============== S U B R O U T I N E =======================================
//
void CheckPlayersLeavingComing()
{
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 30
    if (!flags.carry)
        goto l_no_trial_player;             // jnb short @@no_trial_player

    SWOS::Rand();                           // call Rand
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 25
    if (!flags.carry)
        goto l_no_trial_player;             // jnb short @@no_trial_player

    AddTrialPlayer();                       // call AddTrialPlayer
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 79
    A1 = eax;                               // mov A1, eax
    PlayerJoinedClubOnTrial();              // call PlayerJoinedClubOnTrial
    return;                                 // retn

l_no_trial_player:;
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

l_players_loop:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+113], 155
    if (flags.zero)
        goto l_trial;                       // jz short @@trial

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+113], 154
    if (!flags.zero)
        goto l_next_player;                 // jnz short @@next_player

    SWOS::Rand();                           // call Rand
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (!flags.carry)
        goto l_next_player;                 // jnb short @@next_player

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 79
    A1 = eax;                               // mov A1, eax
    ReservePlayerLeftClubMessage();         // call ReservePlayerLeftClubMessage
    goto l_remove_player;                   // jmp short @@remove_player

l_trial:;
    SWOS::Rand();                           // call Rand
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 5
    if (!flags.carry)
        goto l_next_player;                 // jnb short @@next_player

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 79
    A1 = eax;                               // mov A1, eax
    TrialPlayerLeftClubMessage();           // call TrialPlayerLeftClubMessage

l_remove_player:;
    push(D2);                               // push D2
    RemovePlayerFromTeam();                 // call RemovePlayerFromTeam
    pop(D2);                                // pop D2
    return;                                 // jmp short @@out

l_next_player:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto l_players_loop;                // jns @@players_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player name
//
void PlayerJoinedClubOnTrial()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    eax = A1;                               // mov eax, A1
    *(dword *)&g_memByte[456664] = eax;     // mov plNameForMessage, eax
    *(word *)&g_memByte[337240] = 26;       // mov currentMessage, PLAYER_JOINED_CLUB_ON_TRIAL
    ShowChairmanMessage();                  // call ShowChairmanMessage
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player name
//
void TrialPlayerLeftClubMessage()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    eax = A1;                               // mov eax, A1
    *(dword *)&g_memByte[456664] = eax;     // mov plNameForMessage, eax
    *(word *)&g_memByte[337240] = 24;       // mov currentMessage, TRIAL_PLAYER_LEFT_CLUB
    ShowChairmanMessage();                  // call ShowChairmanMessage
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player name
//
void ReservePlayerLeftClubMessage()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    eax = A1;                               // mov eax, A1
    *(dword *)&g_memByte[456664] = eax;     // mov plNameForMessage, eax
    *(word *)&g_memByte[337240] = 25;       // mov currentMessage, RESERVE_PLAYER_LEFT_CLUB
    ShowChairmanMessage();                  // call ShowChairmanMessage
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_65608()
{
    A0 = 521190;                            // mov A0, offset dseg_17D108
    {
        byte src = g_memByte[91678];
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 80h
    if (flags.zero)
        goto cseg_65639;                    // jz short cseg_65639

    ax = *(word *)&g_memByte[91618];        // mov ax, dseg_D6C70
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_656AC;                    // jnz cseg_656AC

    A0 = 521210;                            // mov A0, offset dseg_17D11C
    goto cseg_656AC;                        // jmp short cseg_656AC

cseg_65639:;
    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto cseg_65682;                    // jz short cseg_65682

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 521250;                            // mov A0, offset dseg_17D144
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_656AC;                    // jz short cseg_656AC

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_656AC;                    // jz short cseg_656AC

    A0 = 521230;                            // mov A0, offset dseg_17D130
    goto cseg_656AC;                        // jmp short cseg_656AC

cseg_65682:;
    A0 = 521170;                            // mov A0, offset dseg_17D0F4
    {
        byte src = g_memByte[91678];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 2
    if (!flags.zero)
        goto cseg_656AC;                    // jnz short cseg_656AC

    al = g_memByte[91678];                  // mov al, someTeamFlags
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_65757;                    // jnz cseg_65757

    A0 = 521150;                            // mov A0, offset dseg_17D0E0

cseg_656AC:;
    A1 = 91694;                             // mov A1, offset dseg_D6CBC
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 4
    cseg_65FE6();                           // call cseg_65FE6
    cseg_6604A();                           // call cseg_6604A
    return;                                 // retn

cseg_65757:;
    debugBreak();                           // int 3

cseg_65758:;
    goto cseg_65758;                        // jmp short cseg_65758
}

// =============== S U B R O U T I N E =======================================
//
void cseg_6575A()
{
    A0 = 521310;                            // mov A0, offset dseg_17D180
    {
        byte src = g_memByte[91678];
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 80h
    if (flags.zero)
        goto cseg_6578B;                    // jz short cseg_6578B

    ax = *(word *)&g_memByte[91618];        // mov ax, dseg_D6C70
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_657FE;                    // jnz cseg_657FE

    A0 = 521330;                            // mov A0, offset dseg_17D194
    goto cseg_657FE;                        // jmp short cseg_657FE

cseg_6578B:;
    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto cseg_657D4;                    // jz short cseg_657D4

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 521370;                            // mov A0, offset dseg_17D1BC
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_657FE;                    // jz short cseg_657FE

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_657FE;                    // jz short cseg_657FE

    A0 = 521350;                            // mov A0, offset dseg_17D1A8
    goto cseg_657FE;                        // jmp short cseg_657FE

cseg_657D4:;
    A0 = 521290;                            // mov A0, offset dseg_17D16C
    {
        byte src = g_memByte[91678];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 2
    if (!flags.zero)
        goto cseg_657FE;                    // jnz short cseg_657FE

    al = g_memByte[91678];                  // mov al, someTeamFlags
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_658A9;                    // jnz cseg_658A9

    A0 = 521270;                            // mov A0, offset dseg_17D158

cseg_657FE:;
    A1 = 91694;                             // mov A1, offset dseg_D6CBC
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 4
    cseg_65FE6();                           // call cseg_65FE6
    cseg_6604A();                           // call cseg_6604A
    return;                                 // retn

cseg_658A9:;
    debugBreak();                           // int 3

cseg_658AA:;
    goto cseg_658AA;                        // jmp short cseg_658AA
}

// =============== S U B R O U T I N E =======================================
//
void cseg_658AC()
{
    A0 = 521430;                            // mov A0, offset dseg_17D1F8
    {
        byte src = g_memByte[91678];
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 80h
    if (flags.zero)
        goto cseg_658DD;                    // jz short cseg_658DD

    ax = *(word *)&g_memByte[91618];        // mov ax, dseg_D6C70
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_65950;                    // jnz cseg_65950

    A0 = 521450;                            // mov A0, offset dseg_17D20C
    goto cseg_65950;                        // jmp short cseg_65950

cseg_658DD:;
    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto cseg_65926;                    // jz short cseg_65926

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 521490;                            // mov A0, offset dseg_17D234
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_65950;                    // jz short cseg_65950

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_65950;                    // jz short cseg_65950

    A0 = 521470;                            // mov A0, offset dseg_17D220
    goto cseg_65950;                        // jmp short cseg_65950

cseg_65926:;
    A0 = 521410;                            // mov A0, offset dseg_17D1E4
    {
        byte src = g_memByte[91678];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 2
    if (!flags.zero)
        goto cseg_65950;                    // jnz short cseg_65950

    al = g_memByte[91678];                  // mov al, someTeamFlags
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_659FB;                    // jnz cseg_659FB

    A0 = 521390;                            // mov A0, offset dseg_17D1D0

cseg_65950:;
    A1 = 91694;                             // mov A1, offset dseg_D6CBC
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 4
    cseg_65FE6();                           // call cseg_65FE6
    cseg_6604A();                           // call cseg_6604A
    return;                                 // retn

cseg_659FB:;
    debugBreak();                           // int 3

cseg_659FC:;
    goto cseg_659FC;                        // jmp short cseg_659FC
}

// =============== S U B R O U T I N E =======================================
//
void cseg_659FE()
{
    A0 = 521550;                            // mov A0, offset dseg_17D270
    {
        byte src = g_memByte[91678];
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 80h
    if (flags.zero)
        goto cseg_65A2F;                    // jz short cseg_65A2F

    ax = *(word *)&g_memByte[91618];        // mov ax, dseg_D6C70
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_65AA2;                    // jnz cseg_65AA2

    A0 = 521570;                            // mov A0, offset dseg_17D284
    goto cseg_65AA2;                        // jmp short cseg_65AA2

cseg_65A2F:;
    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto cseg_65A78;                    // jz short cseg_65A78

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 521610;                            // mov A0, offset dseg_17D2AC
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_65AA2;                    // jz short cseg_65AA2

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_65AA2;                    // jz short cseg_65AA2

    A0 = 521590;                            // mov A0, offset dseg_17D298
    goto cseg_65AA2;                        // jmp short cseg_65AA2

cseg_65A78:;
    A0 = 521530;                            // mov A0, offset dseg_17D25C
    {
        byte src = g_memByte[91678];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 2
    if (!flags.zero)
        goto cseg_65AA2;                    // jnz short cseg_65AA2

    al = g_memByte[91678];                  // mov al, someTeamFlags
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_65B4D;                    // jnz cseg_65B4D

    A0 = 521510;                            // mov A0, offset dseg_17D248

cseg_65AA2:;
    A1 = 91694;                             // mov A1, offset dseg_D6CBC
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 4
    cseg_65FE6();                           // call cseg_65FE6
    cseg_6604A();                           // call cseg_6604A
    return;                                 // retn

cseg_65B4D:;
    debugBreak();                           // int 3

cseg_65B4E:;
    goto cseg_65B4E;                        // jmp short cseg_65B4E
}

// =============== S U B R O U T I N E =======================================
//
void cseg_65B50()
{
    A0 = 521670;                            // mov A0, offset dseg_17D2E8
    {
        byte src = g_memByte[91678];
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 80h
    if (flags.zero)
        goto cseg_65B81;                    // jz short cseg_65B81

    ax = *(word *)&g_memByte[91618];        // mov ax, dseg_D6C70
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_65BF4;                    // jnz cseg_65BF4

    A0 = 521690;                            // mov A0, offset dseg_17D2FC
    goto cseg_65BF4;                        // jmp short cseg_65BF4

cseg_65B81:;
    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto cseg_65BCA;                    // jz short cseg_65BCA

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 521730;                            // mov A0, offset dseg_17D324
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_65BF4;                    // jz short cseg_65BF4

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_65BF4;                    // jz short cseg_65BF4

    A0 = 521710;                            // mov A0, offset dseg_17D310
    goto cseg_65BF4;                        // jmp short cseg_65BF4

cseg_65BCA:;
    A0 = 521650;                            // mov A0, offset dseg_17D2D4
    {
        byte src = g_memByte[91678];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 2
    if (!flags.zero)
        goto cseg_65BF4;                    // jnz short cseg_65BF4

    al = g_memByte[91678];                  // mov al, someTeamFlags
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_65C9F;                    // jnz cseg_65C9F

    A0 = 521630;                            // mov A0, offset dseg_17D2C0

cseg_65BF4:;
    A1 = 91694;                             // mov A1, offset dseg_D6CBC
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 4
    cseg_65FE6();                           // call cseg_65FE6
    cseg_6604A();                           // call cseg_6604A
    return;                                 // retn

cseg_65C9F:;
    debugBreak();                           // int 3

cseg_65CA0:;
    goto cseg_65CA0;                        // jmp short cseg_65CA0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_65CA2()
{
    A0 = 521862;                            // mov A0, offset dseg_17D3A8
    {
        byte src = g_memByte[91678];
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 80h
    if (flags.zero)
        goto cseg_65CD3;                    // jz short cseg_65CD3

    ax = *(word *)&g_memByte[91618];        // mov ax, dseg_D6C70
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_65D89;                    // jnz cseg_65D89

    A0 = 521882;                            // mov A0, offset dseg_17D3BC
    goto cseg_65D89;                        // jmp cseg_65D89

cseg_65CD3:;
    A0 = 521822;                            // mov A0, offset dseg_17D380
    {
        byte src = g_memByte[91678];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 2
    if (flags.zero)
        goto cseg_65D04;                    // jz short cseg_65D04

    ax = *(word *)&g_memByte[91620];        // mov ax, dseg_D6C72
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_65D89;                    // jnz cseg_65D89

    A0 = 521842;                            // mov A0, offset dseg_17D394
    goto cseg_65D89;                        // jmp cseg_65D89

cseg_65D04:;
    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto cseg_65D4D;                    // jz short cseg_65D4D

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 521922;                            // mov A0, offset dseg_17D3E4
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_65D89;                    // jz short cseg_65D89

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_65D89;                    // jz short cseg_65D89

    A0 = 521902;                            // mov A0, offset dseg_17D3D0
    goto cseg_65D89;                        // jmp short cseg_65D89

cseg_65D4D:;
    {
        byte src = g_memByte[91678];
        byte res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 1
    if (flags.zero)
        goto cseg_65FE3;                    // jz cseg_65FE3

    A0 = 521802;                            // mov A0, offset dseg_17D36C
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91718];        // mov ax, dseg_D6CD4
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_65D89;                    // jz short cseg_65D89

    A0 = 521782;                            // mov A0, offset dseg_17D358

cseg_65D89:;
    A1 = 91694;                             // mov A1, offset dseg_D6CBC
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 4
    cseg_65FE6();                           // call cseg_65FE6
    cseg_6604A();                           // call cseg_6604A
    {
        byte src = g_memByte[91678];
        byte res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 1
    if (flags.zero)
        return;                             // jz cseg_65FE2

    *(byte *)&D0 = 80;                      // mov byte ptr D0, 50h
    cseg_33A1A();                           // call cseg_33A1A
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 7;                                 // mov bx, 7
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A2 = 521750;                            // mov A2, offset dseg_17D338
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[131747] = ax;       // mov dseg_E0931, ax
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A2 = eax;                               // mov A2, eax
    *(word *)&D2 = 46;                      // mov word ptr D2, 2Eh
    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_65EB8:;
    A4 = 521750;                            // mov A4, offset dseg_17D338
    *(word *)&D4 = 7;                       // mov word ptr D4, 7

cseg_65ECB:;
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 4
    A3 = eax;                               // mov A3, eax
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_65F5E;                    // jnz short cseg_65F5E

    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A3, eax
    if (!flags.zero)
        goto cseg_65F5E;                    // jnz short cseg_65F5E

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91718];        // mov ax, dseg_D6CD4
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_65F5E;                    // jz short cseg_65F5E

    eax = A3;                               // mov eax, A3
    *(dword *)&g_memByte[91694] = eax;      // mov dseg_D6CBC, eax
    goto cseg_65F99;                        // jmp short cseg_65F99

cseg_65F5E:;
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 108803;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A3, offset e_c_qualifying_group_8_copy
    if (!flags.zero)
        goto cseg_65F74;                    // jnz short cseg_65F74

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 8
    if (!flags.carry)
        goto cseg_65FC8;                    // jnb short cseg_65FC8

cseg_65F74:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_65F74;                    // jz short cseg_65F74

cseg_65F99:;
    ax = *(word *)&g_memByte[91718];        // mov ax, dseg_D6CD4
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_65F74;                    // jz short cseg_65F74

    ax = D0;                                // mov ax, word ptr D0
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 2
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1
    if (flags.zero)
        return;                             // jz short cseg_65FE2

cseg_65FC8:;
    (*(int16_t *)&D4)--;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto cseg_65ECB;                    // jns cseg_65ECB

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 2
    goto cseg_65EB8;                        // jmp cseg_65EB8

cseg_65FE2:;
    return;                                 // retn

cseg_65FE3:;
    debugBreak();                           // int 3

cseg_65FE4:;
    goto cseg_65FE4;                        // jmp short cseg_65FE4
}

// =============== S U B R O U T I N E =======================================
//
void cseg_65FE6()
{
    *(word *)&g_memByte[131751] = 65535;    // mov dseg_E0935, 0FFFFh
    A0 = 91694;                             // mov A0, offset dseg_D6CBC
    *(word *)&D1 = 4;                       // mov word ptr D1, 4

cseg_66002:;
    esi = A0;                               // mov esi, A0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    {
        dword src = readMemory(esi, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 108333;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi], offset invitationTournamentCopy
    if (!flags.zero)
        goto cseg_66040;                    // jnz short cseg_66040

    SWOS::Rand();                           // call Rand
    {
        word res = *(word *)&D0 & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D0, 1
    if (flags.zero)
        goto cseg_66040;                    // jz short cseg_66040

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[131751] = ax;       // mov dseg_E0935, ax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + -4, 4, 108369);       // mov dword ptr [esi-4], offset tourCopy

cseg_66040:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_66002;                    // jns short cseg_66002
}

// =============== S U B R O U T I N E =======================================
//
void cseg_6604A()
{
    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        return;                             // jz cseg_66353

    *(word *)&D5 = 6;                       // mov word ptr D5, 6
    {
        byte src = g_memByte[91714];
        int8_t dstSigned = src;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr dseg_D6CD0, 50h
    if (!flags.zero)
        goto cseg_6608C;                    // jnz short cseg_6608C

    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, 1
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        goto cseg_6609D;                    // jz short cseg_6609D

cseg_6608C:;
    {
        byte src = g_memByte[91716];
        int8_t dstSigned = src;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr dseg_D6CD2, 50h
    if (!flags.zero)
        goto cseg_6609D;                    // jnz short cseg_6609D

    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, 1

cseg_6609D:;
    {
        word res = *(word *)&D5 & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D5, 1
    if (flags.zero)
        goto cseg_660B0;                    // jz short cseg_660B0

    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, 1

cseg_660B0:;
    al = D5;                                // mov al, byte ptr D5
    g_memByte[109484] = al;                 // mov world_cup_qualifying_group_8_copy+0Dh, al
    *(byte *)&D0 = 80;                      // mov byte ptr D0, 50h
    cseg_33A1A();                           // call cseg_33A1A
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 28;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1Ch
    A2 = 521942;                            // mov A2, offset dseg_17D3F8
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[131749] = ax;       // mov dseg_E0933, ax
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A2 = eax;                               // mov A2, eax
    *(word *)&D2 = 48;                      // mov word ptr D2, 30h
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 6
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    {
        word res = *(word *)&D5 << 1;
        *(word *)&D5 = res;
    }                                       // shl word ptr D5, 1
    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_6612C:;
    A4 = 521942;                            // mov A4, offset dseg_17D3F8
    *(word *)&D4 = 7;                       // mov word ptr D4, 7

cseg_6613F:;
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 4
    A3 = eax;                               // mov A3, eax
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_661EA;                    // jnz short cseg_661EA

    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A3, eax
    if (!flags.zero)
        goto cseg_661EA;                    // jnz short cseg_661EA

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_661EA;                    // jz short cseg_661EA

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_661EA;                    // jz short cseg_661EA

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, 50h
    if (!flags.zero)
        goto cseg_661EA;                    // jnz short cseg_661EA

    eax = A3;                               // mov eax, A3
    *(dword *)&g_memByte[91694] = eax;      // mov dseg_D6CBC, eax
    goto cseg_6622A;                        // jmp short cseg_6622A

cseg_661EA:;
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 109471;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A3, offset world_cup_qualifying_group_8_copy
    if (!flags.zero)
        goto cseg_66205;                    // jnz short cseg_66205

    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (!flags.carry)
        goto cseg_66268;                    // jnb short cseg_66268

cseg_66205:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66205;                    // jz short cseg_66205

cseg_6622A:;
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66205;                    // jz short cseg_66205

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66205;                    // jz short cseg_66205

    ax = D0;                                // mov ax, word ptr D0
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 2
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1
    if (flags.zero)
        goto cseg_66282;                    // jz short cseg_66282

cseg_66268:;
    (*(int16_t *)&D4)--;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto cseg_6613F;                    // jns cseg_6613F

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 2
    goto cseg_6612C;                        // jmp cseg_6612C

cseg_66282:;
    A5 = 109511;                            // mov A5, offset north_america_world_cup_qualification_copy
    *(byte *)&D0 = 83;                      // mov byte ptr D0, 53h
    cseg_66354();                           // call cseg_66354
    A5 = 109583;                            // mov A5, offset south_america_world_cup_qualification_copy
    *(byte *)&D0 = 82;                      // mov byte ptr D0, 52h
    cseg_66354();                           // call cseg_66354
    A5 = 109647;                            // mov A5, offset africa_world_cup_qualification_copy
    *(byte *)&D0 = 81;                      // mov byte ptr D0, 51h
    cseg_66354();                           // call cseg_66354
    A5 = 109759;                            // mov A5, offset asiaWorldCupQualificationCopy
    *(byte *)&D0 = 84;                      // mov byte ptr D0, 54h
    cseg_66354();                           // call cseg_66354
    A5 = 109867;                            // mov A5, offset oceaniaWorldCupQualificationCopy
    *(byte *)&D0 = 4;                       // mov byte ptr D0, 4
    {
        byte src = g_memByte[91714];
        int8_t dstSigned = src;
        int8_t srcSigned = 85;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr dseg_D6CD0, 55h
    if (!flags.zero)
        goto cseg_66316;                    // jnz short cseg_66316

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 1
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        goto cseg_66326;                    // jz short cseg_66326

cseg_66316:;
    {
        byte src = g_memByte[91716];
        int8_t dstSigned = src;
        int8_t srcSigned = 85;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr dseg_D6CD2, 55h
    if (!flags.zero)
        goto cseg_66326;                    // jnz short cseg_66326

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 1

cseg_66326:;
    {
        word res = *(word *)&D0 & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D0, 1
    if (flags.zero)
        goto cseg_66339;                    // jz short cseg_66339

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_66339:;
    al = D0;                                // mov al, byte ptr D0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 13, 1, al);           // mov [esi+0Dh], al
    *(byte *)&D0 = 85;                      // mov byte ptr D0, 55h
    cseg_66354();                           // call cseg_66354
}

// =============== S U B R O U T I N E =======================================
//
void cseg_66354()
{
    al = D0;                                // mov al, byte ptr D0
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    cseg_33A1A();                           // call cseg_33A1A
    eax = A5;                               // mov eax, A5
    A3 = eax;                               // mov A3, eax
    esi = A5;                               // mov esi, A5
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 0
    if (flags.zero)
        goto cseg_66388;                    // jz short cseg_66388

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 2
    if (flags.zero)
        goto cseg_663C5;                    // jz short cseg_663C5

    debugBreak();                           // int 3

cseg_66386:;
    goto cseg_66386;                        // jmp short cseg_66386

cseg_66388:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 13, 1);     // mov al, [esi+0Dh]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    goto cseg_66400;                        // jmp short cseg_66400

cseg_663C5:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 15, 1);     // mov al, [esi+0Fh]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax

cseg_66400:;
    al = D1;                                // mov al, byte ptr D1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66458;                    // jz short cseg_66458

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66458;                    // jz short cseg_66458

    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D6, al
    if (!flags.zero)
        goto cseg_66458;                    // jnz short cseg_66458

    eax = A3;                               // mov eax, A3
    *(dword *)&g_memByte[91694] = eax;      // mov dseg_D6CBC, eax
    goto cseg_6649B;                        // jmp short cseg_6649B

cseg_66458:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66458;                    // jz short cseg_66458

    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66458;                    // jz short cseg_66458

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66458;                    // jz short cseg_66458

cseg_6649B:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A5 = res;
    }                                       // add A5, 2
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_66458;                    // jns short cseg_66458
}

// =============== S U B R O U T I N E =======================================
//
void cseg_664BB()
{
    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, CN_EUROPE
    if (flags.zero)
        goto l_europe;                      // jz short @@europe

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 82;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, CN_SOUTH_AMERICA
    if (flags.zero)
        goto l_south_america;               // jz short @@south_america

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 81;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, CN_AFRICA
    if (flags.zero)
        goto l_africa;                      // jz short @@africa

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 84;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, CN_ASIA
    if (flags.zero)
        goto l_asia;                        // jz short @@asia

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 83;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, CN_NORTH_AMERICA
    if (flags.zero)
        goto l_north_america;               // jz short @@north_america

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 85;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, CN_OCEANIA
    if (flags.zero)
        goto l_oceania;                     // jz short @@oceania

    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop

l_europe:;
    cseg_65CA2();                           // call cseg_65CA2
    goto cseg_6651C;                        // jmp short cseg_6651C

l_south_america:;
    cseg_65B50();                           // call cseg_65B50
    goto cseg_6651C;                        // jmp short cseg_6651C

l_africa:;
    cseg_659FE();                           // call cseg_659FE
    goto cseg_6651C;                        // jmp short cseg_6651C

l_asia:;
    cseg_658AC();                           // call cseg_658AC
    goto cseg_6651C;                        // jmp short cseg_6651C

l_north_america:;
    cseg_6575A();                           // call cseg_6575A
    goto cseg_6651C;                        // jmp short cseg_6651C

l_oceania:;
    cseg_65608();                           // call cseg_65608

cseg_6651C:;
    cseg_6652C();                           // call cseg_6652C
    cseg_66682();                           // call cseg_66682
    cseg_667D8();                           // call cseg_667D8
}

// =============== S U B R O U T I N E =======================================
//
void cseg_6652C()
{
    A0 = 92798;                             // mov A0, offset careerTeam
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    ax = D0;                                // mov ax, word ptr D0
    bx = 75;                                // mov bx, 75
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)((byte *)&D6 + 2) = dx;        // mov word ptr D6+2, dx
    ax = D0;                                // mov ax, word ptr D0
    bx = 125;                               // mov bx, 125
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    A1 = 108405;                            // mov A1, offset friendlyCopy
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 13, 1);     // mov al, [esi+13]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    A2 = eax;                               // mov A2, eax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    *(word *)&D5 = 1;                       // mov word ptr D5, 1
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 2
    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_66655:;
    cseg_66947();                           // call cseg_66947
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 1
    (*(int16_t *)&D4)--;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto cseg_66655;                    // jns short cseg_66655
}

// =============== S U B R O U T I N E =======================================
//
void cseg_66682()
{
    A0 = 92798;                             // mov A0, offset careerTeam
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    ax = D0;                                // mov ax, word ptr D0
    bx = 75;                                // mov bx, 75
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)((byte *)&D6 + 2) = dx;        // mov word ptr D6+2, dx
    ax = D0;                                // mov ax, word ptr D0
    bx = 125;                               // mov bx, 125
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    A1 = 108333;                            // mov A1, offset invitationTournamentCopy
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 13, 1);     // mov al, [esi+13]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    A2 = eax;                               // mov A2, eax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    *(word *)&D5 = 1;                       // mov word ptr D5, 1
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 2
    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_667AB:;
    cseg_66947();                           // call cseg_66947
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 1
    (*(int16_t *)&D4)--;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto cseg_667AB;                    // jns short cseg_667AB
}

// =============== S U B R O U T I N E =======================================
//
void cseg_667D8()
{
    SWOS::Rand();                           // call Rand
    ax = D0;                                // mov ax, word ptr D0
    bx = 6;                                 // mov bx, 6
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    A2 = 521974;                            // mov A2, offset toursTable
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned - srcSigned;
        eax = res;
    }                                       // sub eax, offset aChairmanScenes
    A2 = eax;                               // mov A2, eax
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 80;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 80
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    *(word *)&D7 = 49;                      // mov word ptr D7, 49
    A1 = 108369;                            // mov A1, offset tourCopy
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    eax = A2;                               // mov eax, A2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 13, 1);     // mov al, [esi+13]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    A2 = eax;                               // mov A2, eax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    *(word *)&D5 = 1;                       // mov word ptr D5, 1
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 2

cseg_6691A:;
    cseg_66947();                           // call cseg_66947
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 1
    (*(int16_t *)&D4)--;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto cseg_6691A;                    // jns short cseg_6691A
}

// =============== S U B R O U T I N E =======================================
//
void cseg_66947()
{
    *(word *)&D2 = 99;                      // mov word ptr D2, 99

cseg_66950:;
    SWOS::Rand();                           // call Rand
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[456672];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul dseg_168A85
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        dword res = D0 >> 8;
        D0 = res;
    }                                       // shr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    bx = 6;                                 // mov bx, 6
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A0 = 456674;                            // mov A0, offset nationalTeams
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_669E4;                    // jz short cseg_669E4

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D3, al
    if (!flags.zero)
        goto cseg_66950;                    // jnz cseg_66950

cseg_669E4:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66950;                    // jz cseg_66950

    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_66A30;                    // js short cseg_66A30

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+4]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.carry)
        goto cseg_66A76;                    // jb short cseg_66A76

    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry && !flags.zero)
        goto cseg_66A76;                    // ja short cseg_66A76

cseg_66A30:;
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_66A97

    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_66A53:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66A76;                    // jz short cseg_66A76

    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_66A53;                    // jns short cseg_66A53

    return;                                 // retn

cseg_66A76:;
    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_66950;                    // js cseg_66950

    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_66950;                    // jns cseg_66950

    goto cseg_66950;                        // jmp cseg_66950
}

// =============== S U B R O U T I N E =======================================
//
void cseg_66A98()
{
    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, 80
    if (flags.zero)
        goto l_P;                           // jz short @@P

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 82;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, 82
    if (flags.zero)
        goto l_R;                           // jz short @@R

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 81;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, 81
    if (flags.zero)
        goto l_Q;                           // jz short @@Q

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 84;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, 84
    if (flags.zero)
        goto l_T;                           // jz short @@T

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 83;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, 83
    if (flags.zero)
        goto l_S;                           // jz short @@S

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 'U';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, 'U'
    if (flags.zero)
        goto l_U;                           // jz short @@U

    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop

l_P:;
    cseg_66B23();                           // call cseg_66B23
    goto cseg_66AF9;                        // jmp short cseg_66AF9

l_R:;
    cseg_672CB();                           // call cseg_672CB
    goto cseg_66AF9;                        // jmp short cseg_66AF9

l_Q:;
    cseg_67156();                           // call cseg_67156
    goto cseg_66AF9;                        // jmp short cseg_66AF9

l_T:;
    cseg_66FE1();                           // call cseg_66FE1
    goto cseg_66AF9;                        // jmp short cseg_66AF9

l_S:;
    cseg_66E6C();                           // call cseg_66E6C
    goto cseg_66AF9;                        // jmp short cseg_66AF9

l_U:;
    cseg_66CF8();                           // call cseg_66CF8

cseg_66AF9:;
    {
        word src = *(word *)&g_memByte[131751];
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_E0935, 0FFFFh
    if (flags.zero)
        return;                             // jz short @@out

    esi = 91694;                            // mov esi, offset dseg_D6CBC
    eax ^= 4;                               // xor eax, 4
    {
        int16_t dstSigned = ax;
        int16_t srcSigned = *(word *)&g_memByte[131751];
        word res = dstSigned - srcSigned;
        ax = res;
    }                                       // sub ax, dseg_E0935
    {
        dword src = readMemory(esi + eax, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 108333;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi+eax], offset invitationTournamentCopy
    if (!flags.zero)
        return;                             // jnz short @@out

    writeMemory(esi + eax, 4, 108369);      // mov dword ptr [esi+eax], offset tourCopy
}

// =============== S U B R O U T I N E =======================================
//
void cseg_66B23()
{
    A0 = 522078;                            // mov A0, offset dseg_17D480
    {
        byte src = g_memByte[91678];
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 80h
    if (flags.zero)
        goto cseg_66B63;                    // jz short cseg_66B63

    ax = *(word *)&g_memByte[91618];        // mov ax, dseg_D6C70
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_66C54;                    // jnz cseg_66C54

    ax = *(word *)&g_memByte[91612];        // mov ax, dseg_D6C6A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_66C54;                    // jnz cseg_66C54

    A0 = 522098;                            // mov A0, offset dseg_17D494
    goto cseg_66C54;                        // jmp cseg_66C54

cseg_66B63:;
    A0 = 522038;                            // mov A0, offset dseg_17D458
    {
        byte src = g_memByte[91678];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 2
    if (flags.zero)
        goto cseg_66BA3;                    // jz short cseg_66BA3

    ax = *(word *)&g_memByte[91620];        // mov ax, dseg_D6C72
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_66C54;                    // jnz cseg_66C54

    ax = *(word *)&g_memByte[91614];        // mov ax, dseg_D6C6C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_66C54;                    // jnz cseg_66C54

    A0 = 522058;                            // mov A0, offset dseg_17D46C
    goto cseg_66C54;                        // jmp cseg_66C54

cseg_66BA3:;
    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto cseg_66C04;                    // jz short cseg_66C04

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 522138;                            // mov A0, offset dseg_17D4BC
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66C54;                    // jz cseg_66C54

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66C54;                    // jz short cseg_66C54

    esi = 521942;                           // mov esi, offset dseg_17D3F8
    ebx = *(word *)&g_memByte[131749];      // movzx ebx, dseg_E0933
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    *(dword *)&g_memByte[522118] = eax;     // mov dseg_17D4A8, eax
    A0 = 522118;                            // mov A0, offset dseg_17D4A8
    goto cseg_66C54;                        // jmp short cseg_66C54

cseg_66C04:;
    {
        byte src = g_memByte[91678];
        byte res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 1
    if (flags.zero)
        goto cseg_66CF5;                    // jz cseg_66CF5

    A0 = 522018;                            // mov A0, offset dseg_17D444
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91718];        // mov ax, dseg_D6CD4
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66C54;                    // jz short cseg_66C54

    A0 = 521998;                            // mov A0, offset dseg_17D430
    esi = 521750;                           // mov esi, offset dseg_17D338
    ebx = *(word *)&g_memByte[131747];      // movzx ebx, dseg_E0931
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    *(dword *)&g_memByte[521998] = eax;     // mov dseg_17D430, eax

cseg_66C54:;
    A1 = 91694;                             // mov A1, offset dseg_D6CBC
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 4
    return;                                 // retn

cseg_66CF5:;
    debugBreak();                           // int 3

cseg_66CF6:;
    goto cseg_66CF6;                        // jmp short cseg_66CF6
}

// =============== S U B R O U T I N E =======================================
//
void cseg_66CF8()
{
    A0 = 522198;                            // mov A0, offset dseg_17D4F8
    {
        byte src = g_memByte[91678];
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 80h
    if (flags.zero)
        goto cseg_66D38;                    // jz short cseg_66D38

    ax = *(word *)&g_memByte[91618];        // mov ax, dseg_D6C70
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_66DC9;                    // jnz cseg_66DC9

    ax = *(word *)&g_memByte[91612];        // mov ax, dseg_D6C6A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_66DC9;                    // jnz cseg_66DC9

    A0 = 522218;                            // mov A0, offset dseg_17D50C
    goto cseg_66DC9;                        // jmp cseg_66DC9

cseg_66D38:;
    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto cseg_66D9F;                    // jz short cseg_66D9F

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 522258;                            // mov A0, offset dseg_17D534
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66DC9;                    // jz short cseg_66DC9

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66DC9;                    // jz short cseg_66DC9

    esi = 521942;                           // mov esi, offset dseg_17D3F8
    ebx = *(word *)&g_memByte[131749];      // movzx ebx, dseg_E0933
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    *(dword *)&g_memByte[522238] = 109867;  // mov dseg_17D520, offset oceaniaWorldCupQualificationCopy
    A0 = 522238;                            // mov A0, offset dseg_17D520
    goto cseg_66DC9;                        // jmp short cseg_66DC9

cseg_66D9F:;
    A0 = 522178;                            // mov A0, offset dseg_17D4E4
    {
        byte src = g_memByte[91678];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 2
    if (!flags.zero)
        goto cseg_66DC9;                    // jnz short cseg_66DC9

    al = g_memByte[91678];                  // mov al, someTeamFlags
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_66E69;                    // jnz cseg_66E69

    A0 = 522158;                            // mov A0, offset dseg_17D4D0

cseg_66DC9:;
    A1 = 91694;                             // mov A1, offset dseg_D6CBC
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4

cseg_66E69:;
    debugBreak();                           // int 3

cseg_66E6A:;
    goto cseg_66E6A;                        // jmp short cseg_66E6A
}

// =============== S U B R O U T I N E =======================================
//
void cseg_66E6C()
{
    A0 = 522318;                            // mov A0, offset dseg_17D570
    {
        byte src = g_memByte[91678];
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 80h
    if (flags.zero)
        goto cseg_66EAC;                    // jz short cseg_66EAC

    ax = *(word *)&g_memByte[91618];        // mov ax, dseg_D6C70
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_66F3D;                    // jnz cseg_66F3D

    ax = *(word *)&g_memByte[91612];        // mov ax, dseg_D6C6A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_66F3D;                    // jnz cseg_66F3D

    A0 = 522338;                            // mov A0, offset dseg_17D584
    goto cseg_66F3D;                        // jmp cseg_66F3D

cseg_66EAC:;
    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto cseg_66F13;                    // jz short cseg_66F13

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 522378;                            // mov A0, offset dseg_17D5AC
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66F3D;                    // jz short cseg_66F3D

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_66F3D;                    // jz short cseg_66F3D

    esi = 521942;                           // mov esi, offset dseg_17D3F8
    ebx = *(word *)&g_memByte[131749];      // movzx ebx, dseg_E0933
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    *(dword *)&g_memByte[522358] = 109511;  // mov dseg_17D598, offset north_america_world_cup_qualification_copy
    A0 = 522358;                            // mov A0, offset dseg_17D598
    goto cseg_66F3D;                        // jmp short cseg_66F3D

cseg_66F13:;
    A0 = 522298;                            // mov A0, offset dseg_17D55C
    {
        byte src = g_memByte[91678];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 2
    if (!flags.zero)
        goto cseg_66F3D;                    // jnz short cseg_66F3D

    al = g_memByte[91678];                  // mov al, someTeamFlags
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_66FDE;                    // jnz cseg_66FDE

    A0 = 522278;                            // mov A0, offset dseg_17D548

cseg_66F3D:;
    A1 = 91694;                             // mov A1, offset dseg_D6CBC
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 4
    return;                                 // retn

cseg_66FDE:;
    debugBreak();                           // int 3

cseg_66FDF:;
    goto cseg_66FDF;                        // jmp short cseg_66FDF
}

// =============== S U B R O U T I N E =======================================
//
void cseg_66FE1()
{
    A0 = 522438;                            // mov A0, offset dseg_17D5E8
    {
        byte src = g_memByte[91678];
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 80h
    if (flags.zero)
        goto cseg_67021;                    // jz short cseg_67021

    ax = *(word *)&g_memByte[91618];        // mov ax, dseg_D6C70
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_670B2;                    // jnz cseg_670B2

    ax = *(word *)&g_memByte[91612];        // mov ax, dseg_D6C6A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_670B2;                    // jnz cseg_670B2

    A0 = 522458;                            // mov A0, offset dseg_17D5FC
    goto cseg_670B2;                        // jmp cseg_670B2

cseg_67021:;
    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto cseg_67088;                    // jz short cseg_67088

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 522498;                            // mov A0, offset dseg_17D624
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_670B2;                    // jz short cseg_670B2

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_670B2;                    // jz short cseg_670B2

    esi = 521942;                           // mov esi, offset dseg_17D3F8
    ebx = *(word *)&g_memByte[131749];      // movzx ebx, dseg_E0933
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    *(dword *)&g_memByte[522478] = 109759;  // mov dseg_17D610, offset asiaWorldCupQualificationCopy
    A0 = 522478;                            // mov A0, offset dseg_17D610
    goto cseg_670B2;                        // jmp short cseg_670B2

cseg_67088:;
    A0 = 522418;                            // mov A0, offset dseg_17D5D4
    {
        byte src = g_memByte[91678];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 2
    if (!flags.zero)
        goto cseg_670B2;                    // jnz short cseg_670B2

    al = g_memByte[91678];                  // mov al, someTeamFlags
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_67153;                    // jnz cseg_67153

    A0 = 522398;                            // mov A0, offset dseg_17D5C0

cseg_670B2:;
    A1 = 91694;                             // mov A1, offset dseg_D6CBC
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 4
    return;                                 // retn

cseg_67153:;
    debugBreak();                           // int 3

cseg_67154:;
    goto cseg_67154;                        // jmp short cseg_67154
}

// =============== S U B R O U T I N E =======================================
//
void cseg_67156()
{
    A0 = 522558;                            // mov A0, offset dseg_17D660
    {
        byte src = g_memByte[91678];
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 80h
    if (flags.zero)
        goto cseg_67196;                    // jz short cseg_67196

    ax = *(word *)&g_memByte[91618];        // mov ax, dseg_D6C70
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_67227;                    // jnz cseg_67227

    ax = *(word *)&g_memByte[91612];        // mov ax, dseg_D6C6A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_67227;                    // jnz cseg_67227

    A0 = 522578;                            // mov A0, offset dseg_17D674
    goto cseg_67227;                        // jmp cseg_67227

cseg_67196:;
    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto cseg_671FD;                    // jz short cseg_671FD

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 522618;                            // mov A0, offset dseg_17D69C
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_67227;                    // jz short cseg_67227

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_67227;                    // jz short cseg_67227

    esi = 521942;                           // mov esi, offset dseg_17D3F8
    ebx = *(word *)&g_memByte[131749];      // movzx ebx, dseg_E0933
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    *(dword *)&g_memByte[522598] = 109647;  // mov dseg_17D688, offset africa_world_cup_qualification_copy
    A0 = 522598;                            // mov A0, offset dseg_17D688
    goto cseg_67227;                        // jmp short cseg_67227

cseg_671FD:;
    A0 = 522538;                            // mov A0, offset dseg_17D64C
    {
        byte src = g_memByte[91678];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 2
    if (!flags.zero)
        goto cseg_67227;                    // jnz short cseg_67227

    al = g_memByte[91678];                  // mov al, someTeamFlags
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_672C8;                    // jnz cseg_672C8

    A0 = 522518;                            // mov A0, offset dseg_17D638

cseg_67227:;
    A1 = 91694;                             // mov A1, offset dseg_D6CBC
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 4
    return;                                 // retn

cseg_672C8:;
    debugBreak();                           // int 3

cseg_672C9:;
    goto cseg_672C9;                        // jmp short cseg_672C9
}

// =============== S U B R O U T I N E =======================================
//
void cseg_672CB()
{
    A0 = 522678;                            // mov A0, offset dseg_17D6D8
    {
        byte src = g_memByte[91678];
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 80h
    if (flags.zero)
        goto cseg_6730B;                    // jz short cseg_6730B

    ax = *(word *)&g_memByte[91618];        // mov ax, dseg_D6C70
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_6739C;                    // jnz cseg_6739C

    ax = *(word *)&g_memByte[91612];        // mov ax, dseg_D6C6A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_6739C;                    // jnz cseg_6739C

    A0 = 522698;                            // mov A0, offset dseg_17D6EC
    goto cseg_6739C;                        // jmp cseg_6739C

cseg_6730B:;
    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto cseg_67372;                    // jz short cseg_67372

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 522738;                            // mov A0, offset dseg_17D714
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_6739C;                    // jz short cseg_6739C

    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_6739C;                    // jz short cseg_6739C

    esi = 521942;                           // mov esi, offset dseg_17D3F8
    ebx = *(word *)&g_memByte[131749];      // movzx ebx, dseg_E0933
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    *(dword *)&g_memByte[522718] = 109583;  // mov dseg_17D700, offset south_america_world_cup_qualification_copy
    A0 = 522718;                            // mov A0, offset dseg_17D700
    goto cseg_6739C;                        // jmp short cseg_6739C

cseg_67372:;
    A0 = 522658;                            // mov A0, offset dseg_17D6C4
    {
        byte src = g_memByte[91678];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 2
    if (!flags.zero)
        goto cseg_6739C;                    // jnz short cseg_6739C

    al = g_memByte[91678];                  // mov al, someTeamFlags
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_6743D;                    // jnz cseg_6743D

    A0 = 522638;                            // mov A0, offset dseg_17D6B0

cseg_6739C:;
    A1 = 91694;                             // mov A1, offset dseg_D6CBC
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 4
    return;                                 // retn

cseg_6743D:;
    debugBreak();                           // int 3

cseg_6743E:;
    goto cseg_6743E;                        // jmp short cseg_6743E
}

