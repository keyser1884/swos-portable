// automatically generated by ida2asm, do not edit!

#include "vm.h"
#include "defs.h"

#ifdef _MSC_VER
# pragma warning(disable: 4309 4146 4333 4805 4102)
#endif

using namespace SwosVM;

extern void Player1StatusProc();
extern void Player2StatusProc();
extern void FirstHalfJustEnded();
extern void GoToHalftime();
extern void GameOver();
extern void PrepareForInitialKick();
extern void EnqueueCrowdChantsReload();
extern void ResetAnimatedPatternsForBothTeams();
extern void CheckIfGoalkeeperClaimedTheBall();
extern void SetBallPosition();
extern void InitPlayersBeforeEnteringPitch();
extern void PlayersLeavingPitch();
extern void StopAllPlayers();
extern void PlayGoodTackleComment();
extern void PlayKickSample();
extern void PlayDangerousPlayComment();
extern void ActivateReferee();
extern void PlayFoulWhistleSample();
extern void PlayPenaltyComment();
extern void PlayFoulComment();
extern void PlayInjuryComment();
extern void Rand();
extern void PlayHeaderComment();
extern void PlayBallBounceSample();
extern void PlayBarHitComment();
extern void PlayPostHitComment();
extern void PlayMissGoalSample();
extern void GoalScored();
extern void PlayGoalComment();
extern void PlayOwnGoalComment();
extern void PlayHomeGoalSample();
extern void PlayAwayGoalSample();
extern void PlayNearMissComment();
extern void FixPenaltyBug();
extern void EnqueueCornerSample();
extern void EnqueueThrowInSample();
extern void PlayRefereeWhistleSample();
extern void EnqueueDeletedSample();
extern void StopGoodPassSample();
extern void EnqueuPlayingGoodPassSample();
extern void CalculateDeltaXAndY();
extern void WriteAmigaModeDirectionFlip();
extern void CheckForAmigaModeDirectionFlipBan();
extern void InitDIYCup();
extern void cseg_95C18();
extern void StringCopy();
extern void cseg_268C6();
extern void cseg_28139();
extern void Int2Ascii();
extern void cseg_8F1F2();
extern void cseg_24DFA();
extern void cseg_2B7D8();
extern void cseg_908B4();
extern void cseg_2D553();
extern void cseg_89758();

// first pass forward declarations
void UpdateControlledPlayerNumbers();
void MarkPlayer();
void InitTeamsData();
void StartPenalties();
void UpdateControlledPlayer();
void UpdatePlayerBeingPassedTo();
void UpdateCameraBreakMode();
void SetNextPlayerFrame();
void MovePlayer();
void FadeAndPlayWinCupAnimation();
void FadeAndPlayWinMatchAnimation();
void FadeAndPlayLoseMatchAnimation();
void FadeAndPlayLoseCupAnimation();
void PlayNewSeasonAnimations();
void StartingMatch();
void SetCameraMovingToShowerState();
void StartFirstExtraTime();
void EndFirstExtraTime();
void StopPlayers();
void SetPlayerAnimationTable();
void nullsub_8();
void NextPenalty();
void GoalkeeperClaimedTheBall();
void UpdatePlayerWithBall();
void ResetBothTeamSpinTimers();
void ApplyBallAfterTouch();
void SetPlayerDowntimeAfterTackle();
void UpdatePlayerSpeed();
void UpdateTeamShotChanceTable();
void GetPlayerPointerFromShirtNumber();
void UpdateBallVariables();
void CalculateBallNextGroundXYPositions();
void GoalkeeperJumping();
void PlayerBeginTackling();
void PlayersTackledTheBallStrong();
void ShouldGoalkeeperDive();
void GetFramesNeededToCoverDistance();
void GoalkeeperCaughtTheBall();
void cseg_78D9A();
void PlayerTacklingTestFoul();
void nullsub_28();
void TryBookingThePlayer();
void TrySendingOffThePlayer();
void TestFoulForPenaltyAndFreeKick();
void PlayerTackled();
void UpdateBallWithControllingGoalkeeper();
void CalculateIfPlayerWinsBall();
void DoPass();
void PlayerKickingBall();
void GetClosestNonControlledPlayerInDirection();
void GetBallDestCoordinatesTable();
void PlayerAttemptingJumpHeader();
void PlayerHittingJumpHeader();
void DoFlyingHeader();
void DoLobHeader();
void SetPlayerJumpHeaderHitAnimationTable();
void SetAnimationTableAndPictureIndex();
void UpdateControllingPlayer();
void SetThrowInPlayerDestinationCoordinates();
void PlayerTackledTheBallWeak();
void UpdateBall();
void ReverseDestXDirection();
void ReverseDestYDirection();
void DoGoalkeeperSprites();
void CheckIfBallOutOfPlay();
void CalculateNextBallPosition();
void PlayStopGoodPassSampleIfNeeded();
void EndFirstHalf();
void EndOfGame();
void ResetBothTeamsPlayerPassingKicking();
void ResetPlayerPassingKicking();
void SetJumpHeaderHitAnimTable();
void SetStaticHeaderDirection();
void PlayerHittingStaticHeader();
void AttemptStaticHeader();
void AI_SetControlsDirection();
void AI_SetDirectionTowardOpponentsGoal();
void AI_DecideWhetherToTriggerFire();
void AI_ResumeGameDelay();
void FindClosestPlayerToBallFacing();
void AI_Kick();
void cseg_87D60();
void cseg_87DA0();
void cseg_88183();
void cseg_88373();
void cseg_883A5();
void cseg_883B8();
void cseg_883DD();
void cseg_88688();
void cseg_88961();

// =============== S U B R O U T I N E =======================================
//
void UpdateControlledPlayerNumbers()
{
    *(word *)&D7 = 1;                       // mov word ptr D7, 1
    A0 = 326192;                            // mov A0, offset team1CurPlayerNumSprite
    A1 = 522804;                            // mov A1, offset topTeamData
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 10, 4);          // mov eax, [esi+TeamGeneralInfo.inGameTeamPtr]
    A2 = eax;                               // mov A2, eax

l_teams_loop:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 8, 2);      // mov ax, [esi+TeamGeneralInfo.isPlCoach]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_check_player;                // jnz short @@check_player

    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+TeamGeneralInfo.playerNumber]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_check_player;                // jnz short @@check_player

    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_player;                   // jz @@no_player

l_check_player:;
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    A1 = eax;                               // mov A1, eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, 0
    if (flags.zero)
        goto l_no_player;                   // jz @@no_player

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+Sprite.playerOrdinal]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+TeamGame.markedPlayer]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto l_this_player_not_marked;      // jnz short @@this_player_not_marked

    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_second_team;                 // jz short @@second_team

    {
        byte src = g_memByte[323904];
        byte res = src & 16;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr currentGameTick, 10h
    if (flags.zero)
        goto l_no_player;                   // jz @@no_player

    goto l_this_player_not_marked;          // jmp short @@this_player_not_marked

l_second_team:;
    {
        byte src = g_memByte[323904];
        byte res = src & 16;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr currentGameTick, 10h
    if (!flags.zero)
        goto l_no_player;                   // jnz @@no_player

l_this_player_not_marked:;
    ax = D1;                                // mov ax, word ptr D1
    bx = 61;                                // mov bx, size PlayerGame
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx + 45, 1); // mov al, [esi+ebx+PlayerGameHeader.shirtNumber]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    goto l_draw_number;                     // jmp short @@draw_number

    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 46, 4);          // mov eax, [esi+Sprite.deltaX]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto l_player_moving;               // jnz short @@player_moving

    eax = readMemory(esi + 50, 4);          // mov eax, [esi+Sprite.deltaY]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto l_player_moving;               // jnz short @@player_moving

    goto l_draw_number;                     // jmp short @@draw_number

l_player_moving:;
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    {
        word res = *(word *)&D0 & 14;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0Eh
    A2 = 449780;                            // mov A2, offset playerNumberZOffset
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t res = *(int16_t *)&D2 >> 1;
        *(int16_t *)&D2 = res;
    }                                       // sar word ptr D2, 1

l_draw_number:;
    *(word *)&D0 = 1187;                    // mov word ptr D0, SPR_CORNER_FLAG_FRAME_3
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 70, 2, ax);           // mov [esi+Sprite.imageIndex], ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 40, 2);     // mov ax, word ptr [esi+(Sprite.z+2)]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 20
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 32, 2, ax);           // mov word ptr [esi+(Sprite.x+2)], ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 40, 2, ax);           // mov word ptr [esi+(Sprite.z+2)], ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 36, 2, ax);           // mov word ptr [esi+(Sprite.y+2)], ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    goto l_try_second_team_player;          // jmp short @@try_second_team_player

l_no_player:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 70, 2, -1);           // mov [esi+Sprite.imageIndex], -1

l_try_second_team_player:;
    A0 = 326304;                            // mov A0, offset team2CurPlayerNumSprite
    A1 = 522952;                            // mov A1, offset bottomTeamData
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 10, 4);          // mov eax, [esi+TeamGeneralInfo.inGameTeamPtr]
    A2 = eax;                               // mov A2, eax
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_teams_loop;                  // jns @@teams_loop
}

// =============== S U B R O U T I N E =======================================
//
void MarkPlayer()
{
    A1 = 522804;                            // mov A1, offset topTeamData
    {
        byte src = g_memByte[323904];
        byte res = src & 16;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr currentGameTick, 10h
    if (flags.zero)
        goto l_do_mark;                     // jz short @@do_mark

    A1 = 522952;                            // mov A1, offset bottomTeamData

l_do_mark:;
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 10, 4);          // mov eax, [esi+TeamGeneralInfo.inGameTeamPtr]
    A2 = eax;                               // mov A2, eax
    A0 = 325968;                            // mov A0, offset playerMarkSprite
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 70, 2, -1);           // mov [esi+Sprite.imageIndex], -1
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+TeamGame.markedPlayer]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js @@out

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 11
    if (!flags.carry)
        return;                             // jnb @@out

    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+TeamGeneralInfo.spritesTable]
    A1 = eax;                               // mov A1, eax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_NORMAL
    if (!flags.zero)
        return;                             // jnz short @@out

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 70, 2, 1204);         // mov [esi+Sprite.imageIndex], SPR_PLAYER_MARK
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 40, 2);     // mov ax, word ptr [esi+(Sprite.z+2)]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 20
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 32, 2, ax);           // mov word ptr [esi+(Sprite.x+2)], ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 40, 2, ax);           // mov word ptr [esi+(Sprite.z+2)], ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 36, 2, ax);           // mov word ptr [esi+(Sprite.y+2)], ax
}

// =============== S U B R O U T I N E =======================================
//
void InitTeamsData()
{
    *(dword *)&g_memByte[522760] = 0;       // mov currentScorer, 0
    *(dword *)&g_memByte[522768] = 0;       // mov lastPlayerBeforeGoalkeeper, 0
    *(word *)&g_memByte[457532] = 0;        // mov goalScored, 0
    *(word *)&g_memByte[457534] = 0;        // mov runSlower, 0
    *(word *)&g_memByte[523650] = 0;        // mov whichCard, 0
    *(dword *)&g_memByte[523652] = 0;       // mov bookedPlayer, 0
    *(word *)&g_memByte[523097] = 0;        // mov playerHadBall, 0
    *(dword *)&g_memByte[523099] = 0;       // mov lastKeeperPlayed, 0
    *(dword *)&g_memByte[523104] = 0;       // mov lastTeamPlayed, 0
    *(dword *)&g_memByte[523108] = 0;       // mov lastPlayerPlayed, 0
    *(word *)&g_memByte[523112] = 0;        // mov penalty, 0
    *(word *)&g_memByte[455992] = 0;        // mov goalCameraMode, 0
    *(word *)&g_memByte[523114] = 0;        // mov goalOut, 0
    *(word *)&g_memByte[523116] = 0;        // mov gameNotInProgressCounterWriteOnly, 0
    *(word *)&g_memByte[523118] = 0;        // mov fireBlocked, 0
    *(dword *)&g_memByte[523120] = 0;       // mov lastTeamPlayedBeforeBreak, 0
    *(word *)&g_memByte[523124] = 0;        // mov stoppageTimerTotal, 0
    *(word *)&g_memByte[523126] = 0;        // mov stoppageTimerActive, 0
    *(word *)&g_memByte[523134] = 0;        // mov stoppageEventTimer, 0
    *(word *)&g_memByte[523144] = 0;        // mov inGameCounter, 0
    *(word *)&g_memByte[523128] = 100;      // mov gameStatePl, 100
    *(word *)&g_memByte[523130] = 100;      // mov gameState, ST_GAME_IN_PROGRESS
    *(word *)&g_memByte[523146] = 0;        // mov breakState, 0
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    *(word *)&D7 = 1;                       // mov word ptr D7, 1
    ax = *(word *)&g_memByte[449278];       // mov ax, topTeamPlayerNo
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = *(word *)&g_memByte[449274];       // mov ax, topTeamCoachNo
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[449270];       // mov ax, pl1Coach
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    A0 = 522804;                            // mov A0, offset topTeamData
    A1 = 522952;                            // mov A1, offset bottomTeamData
    A2 = 330096;                            // mov A2, offset team1SpritesTable
    eax = *(dword *)&g_memByte[449724];     // mov eax, topTeamPtr
    A3 = eax;                               // mov A3, eax
    A4 = 522772;                            // mov A4, offset team1StatsData
    A5 = 449298;                            // mov A5, offset pl1Tactics
    *(word *)&D5 = 1;                       // mov word ptr D5, 1
    {
        word src = *(word *)&g_memByte[523158];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamPlayingUp, 1
    if (flags.zero)
        goto l_init_teams;                  // jz short @@init_teams

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax

l_init_teams:;
    eax = A1;                               // mov eax, A1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi+TeamGeneralInfo.opponentsTeam], eax
    eax = A3;                               // mov eax, A3
    writeMemory(esi + 10, 4, eax);          // mov [esi+TeamGeneralInfo.inGameTeamPtr], eax
    eax = A4;                               // mov eax, A4
    writeMemory(esi + 14, 4, eax);          // mov [esi+TeamGeneralInfo.teamStatsPtr], eax
    ax = D6;                                // mov ax, word ptr D6
    writeMemory(esi + 4, 2, ax);            // mov [esi+TeamGeneralInfo.playerNumber], ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 6, 2, ax);            // mov [esi+TeamGeneralInfo.playerCoachNumber], ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 8, 2, ax);            // mov [esi+TeamGeneralInfo.isPlCoach], ax
    eax = A2;                               // mov eax, A2
    writeMemory(esi + 20, 4, eax);          // mov [esi+TeamGeneralInfo.spritesTable], eax
    ax = D5;                                // mov ax, word ptr D5
    writeMemory(esi + 18, 2, ax);           // mov [esi+TeamGeneralInfo.teamNumber], ax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 28, 2, ax);           // mov [esi+TeamGeneralInfo.tactics], ax
    writeMemory(esi + 140, 2, 0);           // mov [esi+TeamGeneralInfo.goalkeeperPlaying], 0
    writeMemory(esi + 142, 2, 0);           // mov [esi+TeamGeneralInfo.resetControls], 0
    writeMemory(esi + 30, 2, 10);           // mov [esi+TeamGeneralInfo.updatePlayerIndex], 10
    writeMemory(esi + 32, 4, 0);            // mov [esi+TeamGeneralInfo.controlledPlayerSprite], 0
    writeMemory(esi + 36, 4, 0);            // mov [esi+TeamGeneralInfo.passToPlayerPtr], 0
    writeMemory(esi + 104, 4, 0);           // mov [esi+TeamGeneralInfo.passingKickingPlayer], 0
    writeMemory(esi + 40, 2, 0);            // mov [esi+TeamGeneralInfo.playerHasBall], 0
    writeMemory(esi + 80, 2, 0);            // mov [esi+TeamGeneralInfo.goalkeeperDivingRight], 0
    writeMemory(esi + 82, 2, 0);            // mov [esi+TeamGeneralInfo.goalkeeperDivingLeft], 0
    writeMemory(esi + 84, 2, 0);            // mov [esi+TeamGeneralInfo.ballOutOfPlayOrKeeper], 0
    writeMemory(esi + 86, 2, 0);            // mov [esi+TeamGeneralInfo.goaliePlayingOrOut], 0
    writeMemory(esi + 88, 2, 0);            // mov [esi+TeamGeneralInfo.passingBall], 0
    writeMemory(esi + 90, 2, 0);            // mov [esi+TeamGeneralInfo.passingToPlayer], 0
    writeMemory(esi + 92, 2, 0);            // mov [esi+TeamGeneralInfo.playerSwitchTimer], 0
    writeMemory(esi + 94, 2, 0);            // mov [esi+TeamGeneralInfo.ballInPlay], 0
    writeMemory(esi + 96, 2, 0);            // mov [esi+TeamGeneralInfo.ballOutOfPlay], 0
    writeMemory(esi + 102, 2, 0);           // mov [esi+TeamGeneralInfo.passKickTimer], 0
    writeMemory(esi + 110, 2, 0);           // mov [esi+TeamGeneralInfo.ballCanBeControlled], 0
    writeMemory(esi + 114, 2, 0);           // mov [esi+TeamGeneralInfo.field_72], 0
    writeMemory(esi + 112, 2, -1);          // mov [esi+TeamGeneralInfo.ballControllingPlayerDirection], -1
    writeMemory(esi + 116, 2, 0);           // mov [esi+TeamGeneralInfo.field_74], 0
    writeMemory(esi + 138, 2, 0);           // mov [esi+TeamGeneralInfo.wonTheBallTimer], 0
    writeMemory(esi + 118, 2, -1);          // mov [esi+TeamGeneralInfo.spinTimer], -1
    writeMemory(esi + 60, 1, 0);            // mov [esi+TeamGeneralInfo.field_3C], 0
    writeMemory(esi + 76, 2, 0);            // mov [esi+TeamGeneralInfo.goalkeeperSavedCommentTimer], 0
    writeMemory(esi + 72, 4, 0);            // mov [esi+TeamGeneralInfo.lastHeadingTacklingPlayer], 0
    writeMemory(esi + 78, 2, 0);            // mov [esi+TeamGeneralInfo.field_4E], 0
    writeMemory(esi + 52, 2, 0);            // mov [esi+TeamGeneralInfo.headerOrTackle], 0
    writeMemory(esi + 58, 2, 0);            // mov [esi+TeamGeneralInfo.shooting], 0
    writeMemory(esi + 128, 2, 0);           // mov [esi+TeamGeneralInfo.passInProgress], 0
    ax = *(word *)&g_memByte[449280];       // mov ax, bottomTeamPlayerNo
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = *(word *)&g_memByte[449276];       // mov ax, bottomTeamCoachNo
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[449272];       // mov ax, pl2Coach
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    A0 = 522952;                            // mov A0, offset bottomTeamData
    A1 = 522804;                            // mov A1, offset topTeamData
    A2 = 330140;                            // mov A2, offset team2SpritesTable
    eax = *(dword *)&g_memByte[449728];     // mov eax, bottomTeamPtr
    A3 = eax;                               // mov A3, eax
    A4 = 522788;                            // mov A4, offset team2StatsData
    A5 = 449300;                            // mov A5, offset pl2Tactics
    *(word *)&D5 = 2;                       // mov word ptr D5, 2
    {
        word src = *(word *)&g_memByte[523158];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamPlayingUp, 1
    if (flags.zero)
        goto l_next_team;                   // jz short @@next_team

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax

l_next_team:;
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_init_teams;                  // jns @@init_teams
}

// =============== S U B R O U T I N E =======================================
//
void StartPenalties()
{
    *(word *)&g_memByte[449310] = -1;       // mov penaltiesState, -1
    ax = *(word *)&g_memByte[336636];       // mov ax, statsTeam1Goals
    *(word *)&g_memByte[336628] = ax;       // mov savedTeam1Goals, ax
    ax = *(word *)&g_memByte[336638];       // mov ax, statsTeam2Goals
    *(word *)&g_memByte[336630] = ax;       // mov savedTeam2Goals, ax
    *(word *)&g_memByte[336636] = 0;        // mov statsTeam1Goals, 0
    *(word *)&g_memByte[336648] = 0;        // mov team1GoalsDigit1, 0
    *(word *)&g_memByte[336644] = 0;        // mov team1GoalsDigit2, 0
    *(word *)&g_memByte[336638] = 0;        // mov statsTeam2Goals, 0
    *(word *)&g_memByte[336650] = 0;        // mov team2GoalsDigit1, 0
    *(word *)&g_memByte[336646] = 0;        // mov team2GoalsDigit2, 0
    *(word *)&g_memByte[449316] = 0;        // mov team1PenaltyGoals, 0
    *(word *)&g_memByte[449318] = 0;        // mov team2PenaltyGoals, 0
    SWOS::Rand();                           // call Rand
    {
        word res = *(word *)&D0 & 1;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[523158] = ax;       // mov teamPlayingUp, ax
    SWOS::Rand();                           // call Rand
    {
        word res = *(word *)&D0 & 1;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[523156] = ax;       // mov teamStarting, ax
    *(word *)&g_memByte[523170] = 11;       // mov team1PenaltyShooterIndex, 11
    *(word *)&g_memByte[523172] = 11;       // mov team2PenaltyShooterIndex, 11
    *(word *)&g_memByte[523164] = 0;        // mov team1PenaltyAttempts, 0
    *(word *)&g_memByte[523166] = 0;        // mov team2PenaltyAttempts, 0
    *(word *)&g_memByte[523160] = 1;        // mov playingPenalties, 1
    *(word *)&g_memByte[523162] = 1;        // mov dontShowScorers, 1
    A0 = 330096;                            // mov A0, offset team1SpritesTable
    *(word *)&D0 = 10;                      // mov word ptr D0, 10

l_team2_sprites_loop:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 4
    A5 = eax;                               // mov A5, eax
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 102, 2, 0);           // mov [esi+Sprite.cards], 0
    writeMemory(esi + 108, 2, 0);           // mov [esi+Sprite.sentAway], 0
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_team2_sprites_loop;          // jns short @@team2_sprites_loop

    A0 = 330140;                            // mov A0, offset team2SpritesTable
    *(word *)&D0 = 10;                      // mov word ptr D0, 10

l_team1_sprites_loop:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 4
    A5 = eax;                               // mov A5, eax
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 102, 2, 0);           // mov [esi+Sprite.cards], 0
    writeMemory(esi + 108, 2, 0);           // mov [esi+Sprite.sentAway], 0
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_team1_sprites_loop;          // jns short @@team1_sprites_loop

    NextPenalty();                          // call NextPenalty
}

// =============== S U B R O U T I N E =======================================

// in:
//      A6 -> current team data
//
// Update players distance from the ball. Update controlling player if
// he's closest to the ball. Stop him if he was getting passed to.
//
void UpdateControlledPlayer()
{
    A2 = 328988;                            // mov A2, offset ballSprite
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+TeamGeneralInfo.spritesTable]
    A1 = eax;                               // mov A1, eax
    A3 = 0;                                 // mov A3, 0
    A4 = 0;                                 // mov A4, 0
    D5 = -1;                                // mov D5, -1
    D7 = -1;                                // mov D7, -1
    *(word *)&D6 = 10;                      // mov word ptr D6, 10

l_players_loop:;
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    A2 = eax;                               // mov A2, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
    ax = D1;                                // mov ax, word ptr D1
    bx = D1;                                // mov bx, word ptr D1
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    ax = D2;                                // mov ax, word ptr D2
    bx = D2;                                // mov bx, word ptr D2
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    eax = D2;                               // mov eax, D2
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = D1;                               // mov eax, D1
    writeMemory(esi + 74, 4, eax);          // mov [esi+Sprite.ballDistance], eax
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (!flags.zero)
        goto l_check_is_player_sent_away;   // jnz short @@check_is_player_sent_away

    ax = (word)readMemory(esi + 84, 2);     // mov ax, [esi+Sprite.onScreen]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_next;                        // jz @@next

l_check_is_player_sent_away:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 108, 2);    // mov ax, [esi+Sprite.sentAway]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_next;                        // jnz @@next

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 86, 2);     // mov ax, [esi+TeamGeneralInfo.goaliePlayingOrOut]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_check_is_player_getting_pass; // jnz short @@check_is_player_getting_pass

    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerOrdinal], 1
    if (flags.zero)
        goto l_next;                        // jz @@next

l_check_is_player_getting_pass:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 104, 4);         // mov eax, [esi+TeamGeneralInfo.passingKickingPlayer]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, eax
    if (flags.zero)
        goto l_next;                        // jz short @@next

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_TACKLING
    if (flags.zero)
        goto l_next;                        // jz short @@next

    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_TACKLED
    if (flags.zero)
        goto l_next;                        // jz short @@next

    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 9;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_JUMP_HEADING
    if (flags.zero)
        goto l_next;                        // jz short @@next

    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 8;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_STATIC_HEADING
    if (flags.zero)
        goto l_next;                        // jz short @@next

    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 13;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_ROLLING_INJURED
    if (flags.zero)
        goto l_next;                        // jz short @@next

    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 36, 4);          // mov eax, [esi+TeamGeneralInfo.passToPlayerPtr]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, eax
    if (flags.zero)
        goto l_next;                        // jz short @@next

    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, eax
    if (!flags.carry)
        goto l_next;                        // jnb short @@next

    eax = D1;                               // mov eax, D1
    D5 = eax;                               // mov D5, eax
    eax = A2;                               // mov eax, A2
    A3 = eax;                               // mov A3, eax

l_next:;
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto l_players_loop;                // jns @@players_loop

    ax = *(word *)&g_memByte[523160];       // mov ax, playingPenalties
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_check_closest_active_player; // jz short @@check_closest_active_player

    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (flags.zero)
        return;                             // jz @@out

l_check_closest_active_player:;
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A3, 0
    if (flags.zero)
        return;                             // jz @@out

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 96, 2);     // mov ax, [esi+TeamGeneralInfo.ballOutOfPlay]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A3, eax
    if (flags.zero)
        goto l_its_controlled_player;       // jz short @@its_controlled_player

    push(A3);                               // push A3
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    A3 = eax;                               // mov A3, eax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A3, 0
    if (flags.zero)
        goto l_no_old_controlling_player;   // jz short @@no_old_controlling_player

    esi = A3;                               // mov esi, A3
    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_NORMAL
    if (!flags.zero)
        goto l_no_old_controlling_player;   // jnz short @@no_old_controlling_player

    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax

l_no_old_controlling_player:;
    pop(A3);                                // pop A3

l_its_controlled_player:;
    eax = A3;                               // mov eax, A3
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 32, 4, eax);          // mov [esi+TeamGeneralInfo.controlledPlayerSprite], eax
    eax = readMemory(esi + 36, 4);          // mov eax, [esi+TeamGeneralInfo.passToPlayerPtr]
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A3, eax
    if (!flags.zero)
        return;                             // jnz short @@out

    push(A3);                               // push A3
    eax = readMemory(esi + 36, 4);          // mov eax, [esi+TeamGeneralInfo.passToPlayerPtr]
    A3 = eax;                               // mov A3, eax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A3, 0
    if (flags.zero)
        goto l_noone_getting_that_pass;     // jz short @@noone_getting_that_pass

    esi = A3;                               // mov esi, A3
    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_NORMAL
    if (!flags.zero)
        goto l_noone_getting_that_pass;     // jnz short @@noone_getting_that_pass

    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax

l_noone_getting_that_pass:;
    pop(A3);                                // pop A3
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 36, 4, 0);            // mov [esi+TeamGeneralInfo.passToPlayerPtr], 0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A6 -> team data
//
// Find closest player being passed to and update passToPlayerPtr.
// Stop him so he can get the pass if game is running, do not if game is stopped.
//
void UpdatePlayerBeingPassedTo()
{
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (!flags.zero)
        goto l_game_stopped;                // jnz @@game_stopped

    A2 = 328988;                            // mov A2, offset ballSprite
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 98, 2, ax);           // mov [esi+TeamGeneralInfo.ballX], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 100, 2, ax);          // mov [esi+TeamGeneralInfo.ballY], ax
    ax = (word)readMemory(esi + 94, 2);     // mov ax, [esi+TeamGeneralInfo.ballInPlay]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    ax = (word)readMemory(esi + 92, 2);     // mov ax, [esi+TeamGeneralInfo.playerSwitchTimer]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    ax = (word)readMemory(esi + 90, 2);     // mov ax, [esi+TeamGeneralInfo.passingToPlayer]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_ball_in_pass;                // jz short @@ball_in_pass

    eax = readMemory(esi + 36, 4);          // mov eax, [esi+TeamGeneralInfo.passToPlayerPtr]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        return;                             // jnz @@out

l_ball_in_pass:;
    ax = *(word *)&g_memByte[523160];       // mov ax, playingPenalties
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_playing_penalties;       // jz short @@not_playing_penalties

    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_PENALTIES
    if (!flags.zero)
        return;                             // jnz @@out

    eax = *(dword *)&g_memByte[523174];     // mov eax, penaltyShooterSprite
    A3 = eax;                               // mov A3, eax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 94, 2, 0);            // mov [esi+TeamGeneralInfo.ballInPlay], 0
    goto l_skip_searching_for_closest_player; // jmp @@skip_searching_for_closest_player

l_not_playing_penalties:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+TeamGeneralInfo.spritesTable]
    A1 = eax;                               // mov A1, eax
    A2 = 328988;                            // mov A2, offset ballSprite
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    A3 = 0;                                 // mov A3, 0
    A4 = 0;                                 // mov A4, 0
    D5 = -1;                                // mov D5, 0FFFFFFFFh
    D7 = -1;                                // mov D7, -1
    *(word *)&D6 = 10;                      // mov word ptr D6, 10

l_find_closest_player_loop:;
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    A2 = eax;                               // mov A2, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 84, 2);     // mov ax, [esi+Sprite.onScreen]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_next;                        // jz @@next

    ax = (word)readMemory(esi + 108, 2);    // mov ax, [esi+Sprite.sentAway]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_next;                        // jnz short @@next

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 84, 2);     // mov ax, [esi+TeamGeneralInfo.ballOutOfPlayOrKeeper]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_ball_with_keeper;            // jnz short @@ball_with_keeper

    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerOrdinal], 1
    if (flags.zero)
        goto l_next;                        // jz short @@next

l_ball_with_keeper:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, eax
    if (flags.zero)
        goto l_next;                        // jz short @@next

    eax = readMemory(esi + 104, 4);         // mov eax, [esi+TeamGeneralInfo.passingKickingPlayer]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, eax
    if (flags.zero)
        goto l_next;                        // jz short @@next

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_NORMAL
    if (!flags.zero)
        goto l_next;                        // jnz short @@next

    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    D1 = eax;                               // mov D1, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, eax
    if (!flags.carry)
        goto l_next;                        // jnb short @@next

    eax = D1;                               // mov eax, D1
    D5 = eax;                               // mov D5, eax
    eax = A2;                               // mov eax, A2
    A3 = eax;                               // mov A3, eax

l_next:;
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto l_find_closest_player_loop;    // jns @@find_closest_player_loop

    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A3, 0
    if (flags.zero)
        return;                             // jz short @@out

l_skip_searching_for_closest_player:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 36, 4);          // mov eax, [esi+TeamGeneralInfo.passToPlayerPtr]
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A3, eax
    if (flags.zero)
        goto l_set_pass_to_player;          // jz short @@set_pass_to_player

    push(A3);                               // push A3
    eax = readMemory(esi + 36, 4);          // mov eax, [esi+TeamGeneralInfo.passToPlayerPtr]
    A3 = eax;                               // mov A3, eax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A3, 0
    if (flags.zero)
        goto l_pop_then_set_pass_to_player; // jz short @@pop_then_set_pass_to_player

    esi = A3;                               // mov esi, A3
    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_NORMAL
    if (!flags.zero)
        goto l_pop_then_set_pass_to_player; // jnz short @@pop_then_set_pass_to_player

    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax

l_pop_then_set_pass_to_player:;
    pop(A3);                                // pop A3

l_set_pass_to_player:;
    eax = A3;                               // mov eax, A3
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 36, 4, eax);          // mov [esi+TeamGeneralInfo.passToPlayerPtr], eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax

l_out:;
    return;                                 // retn

l_game_stopped:;
    A2 = 328988;                            // mov A2, offset ballSprite
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 98, 2, ax);           // mov [esi+TeamGeneralInfo.ballX], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 100, 2, ax);          // mov [esi+TeamGeneralInfo.ballY], ax
    ax = (word)readMemory(esi + 94, 2);     // mov ax, [esi+TeamGeneralInfo.ballInPlay]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out2

    ax = (word)readMemory(esi + 92, 2);     // mov ax, [esi+TeamGeneralInfo.playerSwitchTimer]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out2

    ax = (word)readMemory(esi + 90, 2);     // mov ax, [esi+TeamGeneralInfo.passingToPlayer]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_check_if_penalties;          // jz short @@check_if_penalties

    eax = readMemory(esi + 36, 4);          // mov eax, [esi+TeamGeneralInfo.passToPlayerPtr]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        return;                             // jnz @@out2

l_check_if_penalties:;
    ax = *(word *)&g_memByte[523160];       // mov ax, playingPenalties
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_penalties;                // jz short @@no_penalties

    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_PENALTIES
    if (!flags.zero)
        return;                             // jnz @@out2

    eax = *(dword *)&g_memByte[523174];     // mov eax, penaltyShooterSprite
    A3 = eax;                               // mov A3, eax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 94, 2, 0);            // mov [esi+TeamGeneralInfo.ballInPlay], 0
    goto cseg_735CE;                        // jmp cseg_735CE

l_no_penalties:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+TeamGeneralInfo.spritesTable]
    A1 = eax;                               // mov A1, eax
    A2 = 328988;                            // mov A2, offset ballSprite
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    A3 = 0;                                 // mov A3, 0
    A4 = 0;                                 // mov A4, 0
    D5 = -1;                                // mov D5, 0FFFFFFFFh
    D7 = -1;                                // mov D7, -1
    *(word *)&D6 = 10;                      // mov word ptr D6, 10

l_find_closest_player_loop2:;
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    A2 = eax;                               // mov A2, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 108, 2);    // mov ax, [esi+Sprite.sentAway]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_next_player;                 // jnz short @@next_player

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 84, 2);     // mov ax, [esi+TeamGeneralInfo.ballOutOfPlayOrKeeper]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_ball_with_keeper2;           // jnz short @@ball_with_keeper2

    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerOrdinal], 1
    if (flags.zero)
        goto l_next_player;                 // jz short @@next_player

l_ball_with_keeper2:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, eax
    if (flags.zero)
        goto l_next_player;                 // jz short @@next_player

    eax = readMemory(esi + 104, 4);         // mov eax, [esi+TeamGeneralInfo.passingKickingPlayer]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, eax
    if (flags.zero)
        goto l_next_player;                 // jz short @@next_player

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_NORMAL
    if (!flags.zero)
        goto l_next_player;                 // jnz short @@next_player

    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    D1 = eax;                               // mov D1, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, eax
    if (!flags.carry)
        goto l_next_player;                 // jnb short @@next_player

    eax = D1;                               // mov eax, D1
    D5 = eax;                               // mov D5, eax
    eax = A2;                               // mov eax, A2
    A3 = eax;                               // mov A3, eax

l_next_player:;
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto l_find_closest_player_loop2;   // jns @@find_closest_player_loop2

    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A3, 0
    if (flags.zero)
        return;                             // jz short @@out2

cseg_735CE:;
    eax = A3;                               // mov eax, A3
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 36, 4, eax);          // mov [esi+TeamGeneralInfo.passToPlayerPtr], eax
}

// =============== S U B R O U T I N E =======================================
//
void UpdateCameraBreakMode()
{
    ax = *(word *)&g_memByte[523160];       // mov ax, playingPenalties
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_penalties;                // jz short @@no_penalties

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PENALTIES
    if (flags.zero)
        goto l_no_penalties;                // jz short @@no_penalties

    {
        word src = *(word *)&g_memByte[523168];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[523168] = src;
    }                                       // add penaltiesTimer, 1
    {
        word src = *(word *)&g_memByte[523168];
        int16_t dstSigned = src;
        int16_t srcSigned = *(word *)&g_memByte[540852];
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp penaltiesTimer, penaltiesInterval
    if (!flags.zero)
        goto l_no_penalties;                // jnz short @@no_penalties

    NextPenalty();                          // call NextPenalty

l_no_penalties:;
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (!flags.zero)
        goto l_game_not_in_progress;        // jnz short @@game_not_in_progress

    ax = *(word *)&g_memByte[323900];       // mov ax, lastFrameTicks
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word src = *(word *)&g_memByte[523144];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[523144] = src;
    }                                       // add inGameCounter, ax
    return;                                 // jmp @@out

l_game_not_in_progress:;
    {
        word src = *(word *)&g_memByte[523116];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[523116] = src;
    }                                       // add gameNotInProgressCounterWriteOnly, 1
    ax = *(word *)&g_memByte[323900];       // mov ax, lastFrameTicks
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word src = *(word *)&g_memByte[523124];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[523124] = src;
    }                                       // add stoppageTimerTotal, ax
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 102;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_WAITING_ON_PLAYER
    if (!flags.zero)
        goto l_not_waiting_on_player;       // jnz short @@not_waiting_on_player

    {
        word src = *(word *)&g_memByte[523126];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[523126] = src;
    }                                       // add stoppageTimerActive, ax
    eax = *(dword *)&g_memByte[523120];     // mov eax, lastTeamPlayedBeforeBreak
    A6 = eax;                               // mov A6, eax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+TeamGeneralInfo.playerNumber]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_jmp_out;                     // jnz short @@jmp_out

    {
        word src = *(word *)&g_memByte[523126];
        int16_t dstSigned = src;
        int16_t srcSigned = *(word *)&g_memByte[540856];
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp stoppageTimerActive, initalKickInterval
    if (flags.carry)
        goto l_jmp_out;                     // jb short @@jmp_out

    SWOS::PrepareForInitialKick();          // call PrepareForInitialKick
    {
        word src = *(word *)&g_memByte[455948];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[455948] = src;
    }                                       // add initialKickWriteOnlyTicks, 1
    return;                                 // jmp @@out

l_jmp_out:;
    return;                                 // jmp @@out

l_not_waiting_on_player:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 21;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_STARTING_GAME
    if (flags.carry)
        goto l_game_started;                // jb @@game_started

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_GAME_ENDED
    if (!flags.carry && !flags.zero)
        goto l_game_started;                // ja @@game_started

    al = g_memByte[522854];                 // mov al, topTeamData.firePressed
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_end_game_transmission;       // jnz @@end_game_transmission

    al = g_memByte[523002];                 // mov al, bottomTeamData.firePressed
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_end_game_transmission;       // jnz short @@end_game_transmission

    {
        word src = *(word *)&g_memByte[522810];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp topTeamData.playerCoachNumber, 1
    if (flags.zero)
        goto l_check_pl1_fire;              // jz short @@check_pl1_fire

    {
        word src = *(word *)&g_memByte[522958];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp bottomTeamData.playerCoachNumber, 1
    if (!flags.zero)
        goto l_check_for_pl2_coach;         // jnz short @@check_for_pl2_coach

l_check_pl1_fire:;
    SWOS::Player1StatusProc();              // call Player1StatusProc
    al = g_memByte[323920];                 // mov al, pl1Fire
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_end_game_transmission;       // jnz short @@end_game_transmission

l_check_for_pl2_coach:;
    {
        word src = *(word *)&g_memByte[522810];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp topTeamData.playerCoachNumber, 2
    if (flags.zero)
        goto l_check_pl2_fire;              // jz short @@check_pl2_fire

    {
        word src = *(word *)&g_memByte[522958];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp bottomTeamData.playerCoachNumber, 2
    if (!flags.zero)
        goto l_check_control_states_again;  // jnz short @@check_control_states_again

l_check_pl2_fire:;
    SWOS::Player2StatusProc();              // call Player2StatusProc
    al = g_memByte[323921];                 // mov al, pl2Fire
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_end_game_transmission;       // jnz short @@end_game_transmission

l_check_control_states_again:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 26;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_RESULT_AFTER_THE_GAME
    if (!flags.zero)
        goto l_game_started;                // jnz @@game_started

    SWOS::Player1StatusProc();              // call Player1StatusProc
    al = g_memByte[323920];                 // mov al, pl1Fire
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_end_game_transmission;       // jnz short @@end_game_transmission

    SWOS::Player2StatusProc();              // call Player2StatusProc
    al = g_memByte[323921];                 // mov al, pl2Fire
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_game_started;                // jz @@game_started

l_end_game_transmission:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_RESULT_ON_HALFTIME
    if (!flags.zero)
        goto l_not_half_time_result;        // jnz short @@not_half_time_result

    {
        int16_t src = *(word *)&g_memByte[449742];
        src = -src;
        *(word *)&g_memByte[449742] = src;
    }                                       // neg resultTimer
    {
        int16_t src = *(word *)&g_memByte[449744];
        src = -src;
        *(word *)&g_memByte[449744] = src;
    }                                       // neg timeVar
    {
        int16_t src = *(word *)&g_memByte[449740];
        flags.carry = src != 0;
        src = -src;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
        *(word *)&g_memByte[449740] = src;
    }                                       // neg statsTimer
    SetCameraMovingToShowerState();         // call SetCameraMovingToShowerState
    SWOS::PrepareForInitialKick();          // call PrepareForInitialKick
    *(word *)&g_memByte[523134] = 0;        // mov stoppageEventTimer, 0
    return;                                 // jmp @@out

l_not_half_time_result:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 26;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_RESULT_AFTER_THE_GAME
    if (!flags.zero)
        goto l_not_result_after_the_game;   // jnz short @@not_result_after_the_game

    {
        int16_t src = *(word *)&g_memByte[449742];
        src = -src;
        *(word *)&g_memByte[449742] = src;
    }                                       // neg resultTimer
    {
        int16_t src = *(word *)&g_memByte[449744];
        src = -src;
        *(word *)&g_memByte[449744] = src;
    }                                       // neg timeVar
    {
        int16_t src = *(word *)&g_memByte[449740];
        flags.carry = src != 0;
        src = -src;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
        *(word *)&g_memByte[449740] = src;
    }                                       // neg statsTimer
    *(word *)&g_memByte[252376] = 0;        // mov playGame, 0
    *(word *)&g_memByte[523134] = 0;        // mov stoppageEventTimer, 0
    return;                                 // jmp @@out

l_not_result_after_the_game:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 21;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_STARTING_GAME
    if (!flags.zero)
        goto l_game_not_starting;           // jnz short @@game_not_starting

    *(word *)&g_memByte[521030] = 0;        // mov showFansCounter, 0
    SWOS::PrepareForInitialKick();          // call PrepareForInitialKick
    *(word *)&g_memByte[523134] = 0;        // mov stoppageEventTimer, 0
    return;                                 // jmp @@out

l_game_not_starting:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 22;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_CAMERA_GOING_TO_SHOWERS
    if (!flags.zero)
        goto l_game_started;                // jnz short @@game_started

    SWOS::PrepareForInitialKick();          // call PrepareForInitialKick
    *(word *)&g_memByte[523134] = 0;        // mov stoppageEventTimer, 0
    return;                                 // jmp @@out

l_game_started:;
    ax = *(word *)&g_memByte[523134];       // mov ax, stoppageEventTimer
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_stoppage_event_triggered;    // jz short @@stoppage_event_triggered

    ax = *(word *)&g_memByte[323900];       // mov ax, lastFrameTicks
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word src = *(word *)&g_memByte[523134];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[523134] = src;
    }                                       // sub stoppageEventTimer, ax
    if (flags.sign)
        goto l_stoppage_event_triggered;    // js short @@stoppage_event_triggered

    if (!flags.zero)
        return;                             // jnz @@out

l_stoppage_event_triggered:;
    *(word *)&g_memByte[523134] = 0;        // mov stoppageEventTimer, 0
    eax = *(dword *)&g_memByte[523120];     // mov eax, lastTeamPlayedBeforeBreak
    A6 = eax;                               // mov A6, eax
    A5 = 328988;                            // mov A5, offset ballSprite
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 101;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_STOPPED
    if (!flags.zero)
        goto l_game_running;                // jnz @@game_running

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_RESULT_ON_HALFTIME
    if (!flags.zero)
        goto l_not_result_on_halftime;      // jnz short @@not_result_on_halftime

    {
        int16_t src = *(word *)&g_memByte[449742];
        src = -src;
        *(word *)&g_memByte[449742] = src;
    }                                       // neg resultTimer
    {
        int16_t src = *(word *)&g_memByte[449744];
        src = -src;
        *(word *)&g_memByte[449744] = src;
    }                                       // neg timeVar
    {
        int16_t src = *(word *)&g_memByte[449740];
        flags.carry = src != 0;
        src = -src;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
        *(word *)&g_memByte[449740] = src;
    }                                       // neg statsTimer
    SetCameraMovingToShowerState();         // call SetCameraMovingToShowerState
    return;                                 // jmp @@out

l_not_result_on_halftime:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 26;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_RESULT_AFTER_THE_GAME
    if (!flags.zero)
        goto l_not_showing_end_game_result; // jnz short @@not_showing_end_game_result

    {
        int16_t src = *(word *)&g_memByte[449742];
        src = -src;
        *(word *)&g_memByte[449742] = src;
    }                                       // neg resultTimer
    {
        int16_t src = *(word *)&g_memByte[449744];
        src = -src;
        *(word *)&g_memByte[449744] = src;
    }                                       // neg timeVar
    {
        int16_t src = *(word *)&g_memByte[449740];
        flags.carry = src != 0;
        src = -src;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
        *(word *)&g_memByte[449740] = src;
    }                                       // neg statsTimer
    *(word *)&g_memByte[252376] = 0;        // mov playGame, 0
    return;                                 // jmp @@out

l_not_showing_end_game_result:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 21;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_STARTING_GAME
    if (!flags.zero)
        goto l_not_starting_the_game;       // jnz short @@not_starting_the_game

    SWOS::PrepareForInitialKick();          // call PrepareForInitialKick
    return;                                 // jmp @@out

l_not_starting_the_game:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 22;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_CAMERA_GOING_TO_SHOWERS
    if (!flags.zero)
        goto l_not_going_to_showers;        // jnz short @@not_going_to_showers

    SWOS::PrepareForInitialKick();          // call PrepareForInitialKick
    return;                                 // jmp @@out

l_not_going_to_showers:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 29;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FIRST_HALF_ENDED
    if (!flags.zero)
        goto l_not_1st_half_ended;          // jnz short @@not_1st_half_ended

    SWOS::FirstHalfJustEnded();             // call FirstHalfJustEnded
    return;                                 // jmp @@out

l_not_1st_half_ended:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 23;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_GOING_TO_HALFTIME
    if (!flags.zero)
        goto l_not_going_to_halftime;       // jnz short @@not_going_to_halftime

    {
        int16_t src = *(word *)&g_memByte[449742];
        src = -src;
        *(word *)&g_memByte[449742] = src;
    }                                       // neg resultTimer
    {
        int16_t src = *(word *)&g_memByte[449744];
        src = -src;
        *(word *)&g_memByte[449744] = src;
    }                                       // neg timeVar
    {
        int16_t src = *(word *)&g_memByte[449740];
        flags.carry = src != 0;
        src = -src;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
        *(word *)&g_memByte[449740] = src;
    }                                       // neg statsTimer
    SWOS::GoToHalftime();                   // call GoToHalftime
    return;                                 // jmp @@out

l_not_going_to_halftime:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_GAME_ENDED
    if (!flags.zero)
        goto l_game_not_ended;              // jnz short @@game_not_ended

    SWOS::PlayersLeavingPitch();            // call PlayersLeavingPitch
    return;                                 // jmp @@out

l_game_not_ended:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 24;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PLAYERS_GOING_TO_SHOWER
    if (!flags.zero)
        goto l_players_not_going_to_showers; // jnz short @@players_not_going_to_showers

    SWOS::GameOver();                       // call GameOver
    return;                                 // jmp @@out

l_players_not_going_to_showers:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 27;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FIRST_EXTRA_STARTING
    if (!flags.zero)
        goto l_first_extra_not_starting;    // jnz short @@first_extra_not_starting

    SWOS::PrepareForInitialKick();          // call PrepareForInitialKick
    return;                                 // jmp @@out

l_first_extra_not_starting:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 28;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FIRST_EXTRA_ENDED
    if (!flags.zero)
        goto l_first_extra_not_ended;       // jnz short @@first_extra_not_ended

    SWOS::PrepareForInitialKick();          // call PrepareForInitialKick
    return;                                 // jmp @@out

l_first_extra_not_ended:;
    ax = *(word *)&g_memByte[523130];       // mov ax, gameState
    *(word *)&g_memByte[523128] = ax;       // mov gameStatePl, ax
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (!flags.zero)
        goto cseg_73993;                    // jnz short cseg_73993

    ax = *(word *)&g_memByte[486154];       // mov ax, g_inSubstitutesMenu
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_73993;                    // jnz short cseg_73993

    ax = *(word *)&g_memByte[486156];       // mov ax, g_cameraLeavingSubsTimer
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_73993;                    // jnz short cseg_73993

    *(word *)&g_memByte[449744] = 31000;    // mov timeVar, 31000

cseg_73993:;
    *(word *)&g_memByte[523132] = 0;        // mov breakCameraMode, 0
    return;                                 // jmp @@out

l_game_running:;
    ax = *(word *)&g_memByte[523132];       // mov ax, breakCameraMode
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    ax = *(word *)&g_memByte[486154];       // mov ax, g_inSubstitutesMenu
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[486158];       // mov ax, g_waitForPlayerToGoInTimer
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 0
    if (!flags.zero)
        goto cseg_73A30;                    // jnz short cseg_73A30

    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 46, 4);          // mov eax, [esi+Sprite.deltaX]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        return;                             // jnz @@out

    eax = readMemory(esi + 50, 4);          // mov eax, [esi+Sprite.deltaY]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        return;                             // jnz @@out

    *(word *)&g_memByte[523132] = 1;        // mov breakCameraMode, 1
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (flags.zero)
        return;                             // jz @@out

    *(word *)&g_memByte[523134] = *(word *)&g_memByte[540860]; // mov stoppageEventTimer, goalCameraInterval
    ax = *(word *)&g_memByte[455992];       // mov ax, goalCameraMode
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    *(word *)&g_memByte[523134] = 75;       // mov stoppageEventTimer, 75
    return;                                 // retn

cseg_73A30:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 1
    if (!flags.zero)
        goto cseg_73B28;                    // jnz cseg_73B28

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 14;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PENALTY
    if (flags.zero)
        goto l_game_stopped;                // jz short @@game_stopped

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PENALTIES
    if (flags.zero)
        goto l_game_stopped;                // jz short @@game_stopped

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (flags.zero)
        goto l_game_stopped;                // jz short @@game_stopped

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FOUL
    if (flags.zero)
        goto l_game_stopped;                // jz short @@game_stopped

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FREE_KICK_LEFT1
    if (flags.carry)
        goto l_game_stopped;                // jb short @@game_stopped

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 12;
        word res = dstSigned - srcSigned;
    }                                       // cmp gameState, ST_FREE_KICK_RIGHT3

l_game_stopped:;
    ax = *(word *)&g_memByte[523160];       // mov ax, playingPenalties
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_no_auto_replay;              // jnz short @@no_auto_replay

    ax = *(word *)&g_memByte[486154];       // mov ax, g_inSubstitutesMenu
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_no_auto_replay;              // jnz short @@no_auto_replay

    ax = *(word *)&g_memByte[455992];       // mov ax, goalCameraMode
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_auto_replay;              // jz short @@no_auto_replay

    ax = *(word *)&g_memByte[131704];       // mov ax, g_autoSaveHighlights
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_auto_save_highlights;     // jz short @@no_auto_save_highlights

    *(word *)&g_memByte[486146] = 1;        // mov saveHighlightScene, 1

l_no_auto_save_highlights:;
    SWOS::EnqueueCrowdChantsReload();       // call EnqueueCrowdChantsReload
    ax = *(word *)&g_memByte[131700];       // mov ax, g_autoReplays
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_auto_replay;              // jz short @@no_auto_replay

    *(word *)&g_memByte[455924] = 0;        // mov userRequestedReplay, 0
    *(word *)&g_memByte[486144] = 1;        // mov instantReplayFlag, 1
    *(word *)&g_memByte[456264] = 1;        // mov loadCrowdChantSampleFlag, 1

l_no_auto_replay:;
    *(dword *)&g_memByte[522760] = 0;       // mov currentScorer, 0
    ax = *(word *)&g_memByte[523160];       // mov ax, playingPenalties
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_73AF7;                    // jz short cseg_73AF7

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PENALTIES
    if (flags.zero)
        goto cseg_73AF7;                    // jz short cseg_73AF7

    return;                                 // jmp @@out

cseg_73AF7:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (flags.zero)
        goto l_keeper_holds_the_ball;       // jz short @@keeper_holds_the_ball

    ax = *(word *)&g_memByte[523136];       // mov ax, foulXCoordinate
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[523138];       // mov ax, foulYCoordinate
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    SWOS::SetBallPosition();                // call SetBallPosition

l_keeper_holds_the_ball:;
    *(word *)&g_memByte[523132] = 2;        // mov breakCameraMode, 2
    return;                                 // retn

cseg_73B28:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 2
    if (!flags.zero)
        goto cseg_73C3D;                    // jnz cseg_73C3D

    ax = *(word *)&g_memByte[523650];       // mov ax, whichCard
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[455926];       // mov ax, cameraCoordinatesValid
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    *(word *)&g_memByte[457532] = 0;        // mov goalScored, 0
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (!flags.zero)
        goto cseg_73B85;                    // jnz short cseg_73B85

    *(word *)&g_memByte[523128] = 102;      // mov gameStatePl, ST_WAITING_ON_PLAYER
    *(word *)&g_memByte[523144] = 0;        // mov inGameCounter, 0
    ax = *(word *)&g_memByte[523130];       // mov ax, gameState
    *(word *)&g_memByte[523146] = ax;       // mov breakState, ax

cseg_73B85:;
    ax = *(word *)&g_memByte[522946];       // mov ax, topTeamData.resetControls
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_73BCE;                    // jnz short cseg_73BCE

    eax = *(dword *)&g_memByte[522824];     // mov eax, topTeamData.spritesTable
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 10;                      // mov word ptr D0, 10

l_next_player_sprite:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    A1 = eax;                               // mov A1, eax
    flags.carry = false;                    // or eax, eax
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 100, 2, 1);           // mov [esi+Sprite.destReachedState], 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_next_player_sprite;          // jns short @@next_player_sprite

cseg_73BCE:;
    ax = *(word *)&g_memByte[523094];       // mov ax, bottomTeamData.resetControls
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_73C17;                    // jnz short cseg_73C17

    eax = *(dword *)&g_memByte[522972];     // mov eax, bottomTeamData.spritesTable
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 10;                      // mov word ptr D0, 10

l_players_loop:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 4
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 100, 2, 1);           // mov [esi+Sprite.destReachedState], 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_players_loop;                // jns short @@players_loop

cseg_73C17:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (!flags.zero)
        goto cseg_73C33;                    // jnz short cseg_73C33

    *(word *)&g_memByte[326624] = 3;        // mov goalie1Sprite.destReachedState, 3
    *(word *)&g_memByte[327856] = 3;        // mov goalie2Sprite.destReachedState, 3

cseg_73C33:;
    *(word *)&g_memByte[523132] = 4;        // mov breakCameraMode, 4
    return;                                 // retn

cseg_73C3D:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 4
    if (!flags.zero)
        goto cseg_73C60;                    // jnz short cseg_73C60

    ax = *(word *)&g_memByte[486154];       // mov ax, g_inSubstitutesMenu
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    *(word *)&g_memByte[523132] = 3;        // mov breakCameraMode, 3
    return;                                 // retn

cseg_73C60:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 3
    if (!flags.zero)
        goto cseg_73DD5;                    // jnz cseg_73DD5

    ax = *(word *)&g_memByte[523632];       // mov ax, refState
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[523634];       // mov ax, injuriesForever
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    A0 = 330096;                            // mov A0, offset team1SpritesTable
    *(word *)&D0 = 21;                      // mov word ptr D0, 21

l_check_if_players_arrived_loop:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    A1 = eax;                               // mov A1, eax
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PLAYERS_TO_INITIAL_POSITIONS
    if (flags.zero)
        goto l_check_if_player_arrived;     // jz short @@check_if_player_arrived

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 14;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PENALTY
    if (flags.zero)
        goto l_check_if_player_arrived;     // jz short @@check_if_player_arrived

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PENALTIES
    if (flags.zero)
        goto l_check_if_player_arrived;     // jz short @@check_if_player_arrived

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 84, 2);     // mov ax, [esi+Sprite.onScreen]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_check_if_next_player_arrived; // jz short @@check_if_next_player_arrived

l_check_if_player_arrived:;
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 100, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.destReachedState], 3
    if (!flags.zero)
        return;                             // jnz @@out

l_check_if_next_player_arrived:;
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_check_if_players_arrived_loop; // jns short @@check_if_players_arrived_loop

    *(word *)&g_memByte[457534] = 0;        // mov runSlower, 0
    ax = *(word *)&g_memByte[455992];       // mov ax, goalCameraMode
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_73DCB;                    // jz cseg_73DCB

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ResetAnimatedPatternsForBothTeams();    // call ResetAnimatedPatternsForBothTeams
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

cseg_73DCB:;
    *(word *)&g_memByte[523132] = 5;        // mov breakCameraMode, 5
    return;                                 // retn

cseg_73DD5:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 5
    if (!flags.zero)
        goto cseg_73DFC;                    // jnz short cseg_73DFC

    *(word *)&g_memByte[523650] = 0;        // mov whichCard, 0
    *(dword *)&g_memByte[523652] = 0;       // mov bookedPlayer, 0
    *(word *)&g_memByte[523132] = 6;        // mov breakCameraMode, 6
    return;                                 // retn

cseg_73DFC:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 6
    if (!flags.zero)
        goto cseg_73E2C;                    // jnz short cseg_73E2C

    *(word *)&g_memByte[523664] = 0;        // mov ballOutOfGameTimer, 0
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (flags.zero)
        goto cseg_73E22;                    // jz short cseg_73E22

    *(word *)&g_memByte[449744] = 31000;    // mov timeVar, 31000

cseg_73E22:;
    *(word *)&g_memByte[523132] = 7;        // mov breakCameraMode, 7
    return;                                 // retn

cseg_73E2C:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 7
    if (!flags.zero)
        goto cseg_73F0A;                    // jnz cseg_73F0A

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 94, 2, 1);            // mov [esi+TeamGeneralInfo.ballInPlay], 1
    {
        word src = *(word *)&g_memByte[523664];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[523664] = src;
    }                                       // add ballOutOfGameTimer, 1
    {
        word src = *(word *)&g_memByte[523664];
        int16_t dstSigned = src;
        int16_t srcSigned = *(word *)&g_memByte[540864];
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp ballOutOfGameTimer, letPlayerControlCameraInterval
    if (flags.carry)
        goto cseg_73E8B;                    // jb short cseg_73E8B

    {
        word src = *(word *)&g_memByte[455962];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[455962] = src;
    }                                       // add deadCameraBreakVar01, 1
    ax = *(word *)&g_memByte[523128];       // mov ax, gameStatePl
    *(word *)&g_memByte[455964] = ax;       // mov deadCameraBreakVar02, ax
    ax = *(word *)&g_memByte[523130];       // mov ax, gameState
    *(word *)&g_memByte[455966] = ax;       // mov deadCameraBreakVar03, ax
    SWOS::CheckIfGoalkeeperClaimedTheBall(); // call CheckIfGoalkeeperClaimedTheBall
    {
        word src = *(word *)&g_memByte[455942];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[455942] = src;
    }                                       // add deadCameraBreakVar04, 1
    return;                                 // jmp @@out

cseg_73E8B:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        return;                             // jz @@out

    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 5;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_THROW_IN
    if (flags.zero)
        goto l_set_throw_in_anim_table;     // jz short @@set_throw_in_anim_table

    A0 = 453234;                            // mov A0, offset playerNormalStandingAnimTable
    SetPlayerAnimationTable();              // call SetPlayerAnimationTable
    goto cseg_73ED6;                        // jmp short cseg_73ED6

l_set_throw_in_anim_table:;
    A0 = 453788;                            // mov A0, offset aboutToThrowInAnimTable
    SetPlayerAnimationTable();              // call SetPlayerAnimationTable

cseg_73ED6:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 96, 2, 1);            // mov [esi+TeamGeneralInfo.ballOutOfPlay], 1
    *(word *)&g_memByte[523132] = 8;        // mov breakCameraMode, 8
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (flags.zero)
        return;                             // jz short @@out

    ax = *(word *)&g_memByte[486154];       // mov ax, g_inSubstitutesMenu
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&g_memByte[449742] = 31000;    // mov resultTimer, 31000
    return;                                 // retn

cseg_73F0A:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 8
    if (!flags.zero)
        goto l_assert_failed;               // jnz short @@assert_failed

    *(word *)&g_memByte[523666] = 0;        // mov writeOnlyVar03, 0
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (flags.zero)
        goto cseg_73F2C;                    // jz short cseg_73F2C

    SWOS::PlayRefereeWhistleSample();       // call PlayRefereeWhistleSample

cseg_73F2C:;
    *(word *)&g_memByte[455992] = 0;        // mov goalCameraMode, 0
    *(word *)&g_memByte[523128] = 102;      // mov gameStatePl, 102
    *(word *)&g_memByte[523144] = 0;        // mov inGameCounter, 0
    ax = *(word *)&g_memByte[523130];       // mov ax, gameState
    *(word *)&g_memByte[523146] = ax;       // mov breakState, ax

l_out:;
    return;                                 // retn

l_assert_failed:;
    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> player
//
// globals:
//   read:
//     goalScored
//     lastTeamScoredPtr
//     playerScoredPtr
//     currentGameTick
//
// Sets next picture frame for players. Also takes care of cheering after
// scored goal.
//
void SetNextPlayerFrame()
{
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 84, 2);     // mov ax, [esi+Sprite.onScreen]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    {
        word src = (word)readMemory(esi + 26, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 26, 2, src);
    }                                       // sub [esi+Sprite.cycleFramesTimer], 1
    if (!flags.zero)
        return;                             // jnz @@out

    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+Sprite.frameIndex], 1
    ax = (word)readMemory(esi + 24, 2);     // mov ax, [esi+Sprite.frameDelay]
    writeMemory(esi + 26, 2, ax);           // mov [esi+Sprite.cycleFramesTimer], ax
    eax = readMemory(esi + 18, 4);          // mov eax, [esi+Sprite.frameIndicesTable]
    A1 = eax;                               // mov A1, eax

l_next_frame_index:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+Sprite.frameIndex]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_index_positive;              // jns @@index_positive

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -999;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -999
    if (flags.zero)
        goto l_reset_index;                 // jz short @@reset_index

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -101;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -101
    if (flags.zero)
        goto l_pause_frame;                 // jz short @@pause_frame

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -100
    if (flags.zero || flags.sign != flags.overflow)
        goto l_add_negative_offset;         // jle short @@add_negative_offset

    *(int16_t *)&D0 = -*(int16_t *)&D0;     // neg word ptr D0
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 24, 2, ax);           // mov [esi+Sprite.frameDelay], ax
    writeMemory(esi + 26, 2, ax);           // mov [esi+Sprite.cycleFramesTimer], ax
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+Sprite.frameIndex], 1
    goto l_next_frame_index;                // jmp @@next_frame_index

l_reset_index:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, 0);            // mov [esi+Sprite.frameIndex], 0
    goto l_next_frame_index;                // jmp @@next_frame_index

l_add_negative_offset:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 100;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 100
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+Sprite.frameIndex], ax
    goto l_next_frame_index;                // jmp @@next_frame_index

l_pause_frame:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub [esi+Sprite.frameIndex], 1
    return;                                 // jmp @@out

l_index_positive:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 28, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 28, 2, src);
    }                                       // add [esi+Sprite.frameSwitchCounter], 1
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+Sprite.frameOffset]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = *(word *)&g_memByte[457532];       // mov ax, goalScored
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_set_picture_index;           // jz @@set_picture_index

    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_NORMAL
    if (!flags.zero)
        goto l_set_picture_index;           // jnz @@set_picture_index

    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_player_facing_up_or_down;    // jz short @@player_facing_up_or_down

    {
        word src = (word)readMemory(esi + 42, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.direction], 4
    if (!flags.zero)
        goto l_set_picture_index;           // jnz @@set_picture_index

l_player_facing_up_or_down:;
    ax = *(word *)&g_memByte[457540];       // mov ax, lastTeamScoredNumber
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+Sprite.teamNumber]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto l_set_picture_index;           // jnz @@set_picture_index

    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerOrdinal], 1
    if (flags.zero)
        goto l_set_picture_index;           // jz short @@set_picture_index

    eax = *(dword *)&g_memByte[457536];     // mov eax, lastPlayerScored
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, eax
    if (!flags.zero)
        goto l_not_the_player_that_scored;  // jnz short @@not_the_player_that_scored

    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 127;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 7Fh
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 100
    if (!flags.carry && !flags.zero)
        goto l_set_picture_index;           // ja short @@set_picture_index

    goto l_make_player_cheer;               // jmp short @@make_player_cheer

l_not_the_player_that_scored:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+Sprite.playerOrdinal]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 << 2;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 2
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    {
        word res = *(word *)&D1 & 63;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 3Fh
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 31
    if (!flags.carry && !flags.zero)
        goto l_set_picture_index;           // ja short @@set_picture_index

l_make_player_cheer:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 365;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 365
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 341;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 341

l_set_picture_index:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 70, 2, ax);           // mov [esi+Sprite.imageIndex], ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> player
//
// globals:
//   read:
//      gameStatePl
//      breakCameraMode
//
// Update x and y coordinates based on deltas. If sprite has reached its
// destination stop it, and set standing animation table.
//
void MovePlayer()
{
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 84, 2);     // mov ax, [esi+Sprite.onScreen]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_havent_been_drawn;           // jz @@havent_been_drawn

l_check_delta_x:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 46, 4);          // mov eax, [esi+Sprite.deltaX]
    D0 = eax;                               // mov D0, eax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto l_check_delta_y;               // jz @@check_delta_y

    if (!flags.sign)
        goto l_moving_right;                // jns short @@moving_right

    ax = (word)readMemory(esi + 58, 2);     // mov ax, [esi+Sprite.destX]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = D0;                               // mov eax, D0
    {
        dword src = readMemory(esi + 30, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 30, 4, src);
    }                                       // add [esi+Sprite.x], eax
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.sign != flags.overflow)
        goto l_check_delta_y;               // jl short @@check_delta_y

l_x_axis_on_destination:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 32, 2, ax);           // mov word ptr [esi+(Sprite.x+2)], ax
    writeMemory(esi + 46, 4, 0);            // mov [esi+Sprite.deltaX], 0
    goto l_check_delta_y;                   // jmp short @@check_delta_y

l_moving_right:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 58, 2);     // mov ax, [esi+Sprite.destX]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = D0;                               // mov eax, D0
    {
        dword src = readMemory(esi + 30, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 30, 4, src);
    }                                       // add [esi+Sprite.x], eax
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero || flags.sign != flags.overflow)
        goto l_x_axis_on_destination;       // jle short @@x_axis_on_destination

l_check_delta_y:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 50, 4);          // mov eax, [esi+Sprite.deltaY]
    D0 = eax;                               // mov D0, eax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto l_check_player_state;          // jz @@check_player_state

    if (!flags.sign)
        goto l_moving_down;                 // jns short @@moving_down

    ax = (word)readMemory(esi + 60, 2);     // mov ax, [esi+Sprite.destY]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = D0;                               // mov eax, D0
    {
        dword src = readMemory(esi + 34, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 34, 4, src);
    }                                       // add [esi+Sprite.y], eax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.sign != flags.overflow)
        return;                             // jl @@out2

l_reached_y_dest:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 36, 2, ax);           // mov word ptr [esi+(Sprite.y+2)], ax
    writeMemory(esi + 50, 4, 0);            // mov [esi+Sprite.deltaY], 0
    goto l_check_player_state;              // jmp short @@check_player_state

l_moving_down:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 60, 2);     // mov ax, [esi+Sprite.destY]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = D0;                               // mov eax, D0
    {
        dword src = readMemory(esi + 34, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 34, 4, src);
    }                                       // add [esi+Sprite.y], eax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero || flags.sign != flags.overflow)
        goto l_reached_y_dest;              // jle short @@reached_y_dest

l_check_player_state:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_NORMAL
    if (!flags.zero)
        return;                             // jnz @@out2

    eax = readMemory(esi + 46, 4);          // mov eax, [esi+Sprite.deltaX]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        return;                             // jnz short @@out2

    eax = readMemory(esi + 50, 4);          // mov eax, [esi+Sprite.deltaY]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        return;                             // jnz short @@out2

    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (flags.zero)
        goto l_update_animation_table;      // jz short @@update_animation_table

    {
        word src = *(word *)&g_memByte[523132];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp breakCameraMode, 3
    if (!flags.zero)
        goto l_update_animation_table;      // jnz short @@update_animation_table

    {
        word src = (word)readMemory(esi + 100, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.destReachedState], 2
    if (!flags.zero)
        goto l_update_animation_table;      // jnz short @@update_animation_table

    writeMemory(esi + 100, 2, 3);           // mov [esi+Sprite.destReachedState], 3

l_update_animation_table:;
    esi = A0;                               // mov esi, A0
    {
        dword src = readMemory(esi + 6, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 453234;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.animationTable], offset playerNormalStandingAnimTable
    if (flags.zero)
        return;                             // jz short @@out2

    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    A4 = eax;                               // mov A4, eax
    A0 = 453234;                            // mov A0, offset playerNormalStandingAnimTable
    SetPlayerAnimationTable();              // call SetPlayerAnimationTable
    eax = A4;                               // mov eax, A4
    A0 = eax;                               // mov A0, eax

l_out2:;
    return;                                 // retn

l_havent_been_drawn:;
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (!flags.zero)
        goto l_check_delta_x;               // jnz @@check_delta_x

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 58, 2);     // mov ax, [esi+Sprite.destX]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = readMemory(esi + 46, 4);          // mov eax, [esi+Sprite.deltaX]
    D0 = eax;                               // mov D0, eax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto l_check_dest_y;                // jz short @@check_dest_y

    if (!flags.sign)
        goto l_moving_right2;               // jns short @@moving_right2

    {
        dword src = readMemory(esi + 30, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 30, 4, src);
    }                                       // add [esi+Sprite.x], eax
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.sign != flags.overflow)
        goto l_check_dest_y;                // jl short @@check_dest_y

l_not_moving_on_x_axis:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 32, 2, ax);           // mov word ptr [esi+(Sprite.x+2)], ax
    writeMemory(esi + 46, 4, 0);            // mov [esi+Sprite.deltaX], 0
    goto l_check_dest_y;                    // jmp short @@check_dest_y

l_moving_right2:;
    eax = D0;                               // mov eax, D0
    esi = A0;                               // mov esi, A0
    {
        dword src = readMemory(esi + 30, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 30, 4, src);
    }                                       // add [esi+Sprite.x], eax
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero || flags.sign != flags.overflow)
        goto l_not_moving_on_x_axis;        // jle short @@not_moving_on_x_axis

l_check_dest_y:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 60, 2);     // mov ax, [esi+Sprite.destY]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = readMemory(esi + 50, 4);          // mov eax, [esi+Sprite.deltaY]
    D0 = eax;                               // mov D0, eax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        return;                             // jz short @@out

    if (!flags.sign)
        goto l_moving_down2;                // jns short @@moving_down2

    {
        dword src = readMemory(esi + 34, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 34, 4, src);
    }                                       // add [esi+Sprite.y], eax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.sign != flags.overflow)
        return;                             // jl short @@out

l_reached_y_dest2:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 36, 2, ax);           // mov word ptr [esi+(Sprite.y+2)], ax
    writeMemory(esi + 50, 4, 0);            // mov [esi+Sprite.deltaY], 0
    return;                                 // jmp short @@out

l_moving_down2:;
    eax = D0;                               // mov eax, D0
    esi = A0;                               // mov esi, A0
    {
        dword src = readMemory(esi + 34, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 34, 4, src);
    }                                       // add [esi+Sprite.y], eax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero || flags.sign != flags.overflow)
        goto l_reached_y_dest2;             // jle short @@reached_y_dest2
}

// =============== S U B R O U T I N E =======================================
//
void FadeAndPlayWinCupAnimation()
{
}

// =============== S U B R O U T I N E =======================================
//
void FadeAndPlayWinMatchAnimation()
{
}

// =============== S U B R O U T I N E =======================================
//
void FadeAndPlayLoseMatchAnimation()
{
}

// =============== S U B R O U T I N E =======================================
//
void FadeAndPlayLoseCupAnimation()
{
}

// =============== S U B R O U T I N E =======================================
//
void PlayNewSeasonAnimations()
{
}

// =============== S U B R O U T I N E =======================================
//
void StartingMatch()
{
    *(word *)&g_memByte[523154] = 1;        // mov halfNumber, 1
    *(word *)&D1 = 1672;                    // mov word ptr D1, 1672
    *(word *)&D2 = 449;                     // mov word ptr D2, 449
    SWOS::SetBallPosition();                // call SetBallPosition
    *(word *)&g_memByte[449800] = 0;        // mov hideBall, 0
    InitTeamsData();                        // call InitTeamsData
    *(word *)&g_memByte[523134] = 100;      // mov stoppageEventTimer, 100
    *(word *)&g_memByte[523130] = 21;       // mov gameState, ST_STARTING_GAME
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    *(word *)&g_memByte[523128] = 101;      // mov gameStatePl, 101
    *(word *)&g_memByte[523116] = 0;        // mov gameNotInProgressCounterWriteOnly, 0
    *(word *)&g_memByte[523140] = -1;       // mov cameraDirection, -1
    *(dword *)&g_memByte[523120] = 522804;  // mov lastTeamPlayedBeforeBreak, offset topTeamData
    *(word *)&g_memByte[523124] = 0;        // mov stoppageTimerTotal, 0
    *(word *)&g_memByte[523126] = 0;        // mov stoppageTimerActive, 0
    SWOS::StopAllPlayers();                 // call StopAllPlayers
    *(word *)&g_memByte[449796] = 0;        // mov cameraXVelocity, 0
    *(word *)&g_memByte[449798] = 0;        // mov cameraYVelocity, 0
    *(word *)&g_memByte[455928] = 1;        // mov writeOnlyVar02, 1
    SWOS::InitPlayersBeforeEnteringPitch(); // jmp InitPlayersBeforeEnteringPitch
}

// =============== S U B R O U T I N E =======================================

// Called when first half is over.
//
void SetCameraMovingToShowerState()
{
    *(word *)&g_memByte[523154] = 2;        // mov halfNumber, 2
    {
        int16_t src = *(word *)&g_memByte[523158];
        src = -src;
        *(word *)&g_memByte[523158] = src;
    }                                       // neg teamPlayingUp
    {
        word src = *(word *)&g_memByte[523158];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[523158] = src;
    }                                       // add teamPlayingUp, 3
    {
        int16_t src = *(word *)&g_memByte[523156];
        src = -src;
        *(word *)&g_memByte[523156] = src;
    }                                       // neg teamStarting
    {
        word src = *(word *)&g_memByte[523156];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[523156] = src;
    }                                       // add teamStarting, 3
    *(word *)&D1 = 1672;                    // mov word ptr D1, 1672
    *(word *)&D2 = 449;                     // mov word ptr D2, 449
    SWOS::SetBallPosition();                // call SetBallPosition
    *(word *)&g_memByte[449800] = 0;        // mov hideBall, 0
    InitTeamsData();                        // call InitTeamsData
    *(word *)&g_memByte[523134] = 110;      // mov stoppageEventTimer, 110
    *(word *)&g_memByte[523130] = 22;       // mov gameState, ST_CAMERA_GOING_TO_SHOWERS
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    *(word *)&g_memByte[523128] = 101;      // mov gameStatePl, 101
    *(word *)&g_memByte[523116] = 0;        // mov gameNotInProgressCounterWriteOnly, 0
    *(word *)&g_memByte[523140] = -1;       // mov cameraDirection, -1
    *(dword *)&g_memByte[523120] = 522804;  // mov lastTeamPlayedBeforeBreak, offset topTeamData
    *(word *)&g_memByte[523124] = 0;        // mov stoppageTimerTotal, 0
    *(word *)&g_memByte[523126] = 0;        // mov stoppageTimerActive, 0
    SWOS::StopAllPlayers();                 // call StopAllPlayers
    *(word *)&g_memByte[449796] = 0;        // mov cameraXVelocity, 0
    *(word *)&g_memByte[449798] = 0;        // mov cameraYVelocity, 0
    *(word *)&g_memByte[455928] = 1;        // mov writeOnlyVar02, 1
    ax = *(word *)&g_memByte[252376];       // mov ax, playGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_75B53;                    // jz short cseg_75B53

    *(word *)&g_memByte[449746] = 385;      // mov nullSampleTimer, 385

cseg_75B53:;
    SWOS::InitPlayersBeforeEnteringPitch(); // jmp InitPlayersBeforeEnteringPitch
}

// =============== S U B R O U T I N E =======================================
//
void StartFirstExtraTime()
{
    *(word *)&g_memByte[523154] = 1;        // mov halfNumber, 1
    SWOS::Rand();                           // call Rand
    {
        word res = *(word *)&D0 & 1;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[523158] = ax;       // mov teamPlayingUp, ax
    SWOS::Rand();                           // call Rand
    {
        word res = *(word *)&D0 & 1;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[523156] = ax;       // mov teamStarting, ax
    *(word *)&g_memByte[449800] = 0;        // mov hideBall, 0
    InitTeamsData();                        // call InitTeamsData
    *(word *)&g_memByte[523134] = 110;      // mov stoppageEventTimer, 110
    *(word *)&g_memByte[523130] = 27;       // mov gameState, ST_FIRST_EXTRA_STARTING
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    *(word *)&g_memByte[523128] = 101;      // mov gameStatePl, ST_STOPPED
    *(word *)&g_memByte[523116] = 0;        // mov gameNotInProgressCounterWriteOnly, 0
    *(word *)&g_memByte[523140] = -1;       // mov cameraDirection, -1
    A0 = 522804;                            // mov A0, offset topTeamData
    ax = *(word *)&g_memByte[523156];       // mov ax, teamStarting
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[523158];       // mov ax, teamPlayingUp
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_75E77;                    // jz short cseg_75E77

    A0 = 522952;                            // mov A0, offset bottomTeamData

cseg_75E77:;
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[523120] = eax;     // mov lastTeamPlayedBeforeBreak, eax
    *(word *)&g_memByte[523124] = 0;        // mov stoppageTimerTotal, 0
    *(word *)&g_memByte[523126] = 0;        // mov stoppageTimerActive, 0
    SWOS::StopAllPlayers();                 // call StopAllPlayers
    *(word *)&g_memByte[449796] = 0;        // mov cameraXVelocity, 0
    *(word *)&g_memByte[449798] = 0;        // mov cameraYVelocity, 0
}

// =============== S U B R O U T I N E =======================================
//
void EndFirstExtraTime()
{
    *(word *)&g_memByte[523154] = 2;        // mov halfNumber, 2
    {
        int16_t src = *(word *)&g_memByte[523158];
        src = -src;
        *(word *)&g_memByte[523158] = src;
    }                                       // neg teamPlayingUp
    {
        word src = *(word *)&g_memByte[523158];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[523158] = src;
    }                                       // add teamPlayingUp, 3
    {
        int16_t src = *(word *)&g_memByte[523156];
        src = -src;
        *(word *)&g_memByte[523156] = src;
    }                                       // neg teamStarting
    {
        word src = *(word *)&g_memByte[523156];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[523156] = src;
    }                                       // add teamStarting, 3
    *(word *)&g_memByte[449800] = 0;        // mov hideBall, 0
    InitTeamsData();                        // call InitTeamsData
    *(word *)&g_memByte[523134] = 110;      // mov stoppageEventTimer, 110
    *(word *)&g_memByte[523130] = 28;       // mov gameState, ST_FIRST_EXTRA_ENDED
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    *(word *)&g_memByte[523128] = 101;      // mov gameStatePl, ST_STOPPED
    *(word *)&g_memByte[523116] = 0;        // mov gameNotInProgressCounterWriteOnly, 0
    *(word *)&g_memByte[523140] = -1;       // mov cameraDirection, -1
    A0 = 522804;                            // mov A0, offset topTeamData
    ax = *(word *)&g_memByte[523156];       // mov ax, teamStarting
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[523158];       // mov ax, teamPlayingUp
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_75F45;                    // jz short cseg_75F45

    A0 = 522952;                            // mov A0, offset bottomTeamData

cseg_75F45:;
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[523120] = eax;     // mov lastTeamPlayedBeforeBreak, eax
    *(word *)&g_memByte[523124] = 0;        // mov stoppageTimerTotal, 0
    *(word *)&g_memByte[523126] = 0;        // mov stoppageTimerActive, 0
    SWOS::StopAllPlayers();                 // call StopAllPlayers
    *(word *)&g_memByte[449796] = 0;        // mov cameraXVelocity, 0
    *(word *)&g_memByte[449798] = 0;        // mov cameraYVelocity, 0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team (general info)
//
void StopPlayers()
{
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+TeamGeneralInfo.spritesTable]
    A1 = eax;                               // mov A1, eax
    *(word *)&D0 = 10;                      // mov word ptr D0, 10

l_players_loop:;
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    A2 = eax;                               // mov A2, eax
    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_NORMAL
    if (!flags.zero)
        goto l_next;                        // jnz short @@next

    ax = (word)readMemory(esi + 108, 2);    // mov ax, [esi+Sprite.sentAway]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_next;                        // jnz short @@next

    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax

l_next:;
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_players_loop;                // jns short @@players_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> animation table
//      A1 -> player
//
// Set player's animation table and frame indices table and sets up starting state.
//
void SetPlayerAnimationTable()
{
    eax = A0;                               // mov eax, A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 6, 4, eax);           // mov [esi+Sprite.animationTable], eax
    push(D0);                               // push small [word ptr D0]
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+Sprite.teamNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerOrdinal], 1
    if (!flags.zero)
        goto l_not_goalkeeper;              // jnz short @@not_goalkeeper

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 2

l_not_goalkeeper:;
    {
        word res = *(word *)&D0 << 3;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 3
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 24, 2, ax);           // mov [esi+Sprite.frameDelay], ax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx + 2, 4);     // mov eax, [esi+ebx+2]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 18, 4, eax);          // mov [esi+Sprite.frameIndicesTable], eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto l_fatal_error;                 // jz short @@fatal_error

    writeMemory(esi + 28, 2, -1);           // mov [esi+Sprite.frameSwitchCounter], -1
    writeMemory(esi + 22, 2, -1);           // mov [esi+Sprite.frameIndex], -1
    writeMemory(esi + 26, 2, 1);            // mov [esi+Sprite.cycleFramesTimer], 1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    writeMemory(esi + 10, 2, ax);           // mov [esi+Sprite.startingDirection], ax
    {
        int32_t val = stack[stackTop++];
        *(word *)&D0 = val;
    }                                       // pop small [word ptr D0]
    return;                                 // retn

l_fatal_error:;
    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_8()
{
}

// =============== S U B R O U T I N E =======================================

// Next penalty is about to be shot. Check if penalties are over. If not,
// initialize globals for penalty, set penaltyShooterSprite.
// (penalties after the game)
//
void NextPenalty()
{
    ax = *(word *)&g_memByte[523164];       // mov ax, team1PenaltyAttempts
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[523166];       // mov ax, team2PenaltyAttempts
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 10
    if (flags.carry)
        goto l_still_under_five_attempts;   // jb short @@still_under_five_attempts

    ax = *(word *)&g_memByte[523164];       // mov ax, team1PenaltyAttempts
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[523166];       // mov ax, team2PenaltyAttempts
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_next_penalty;                // jnz @@next_penalty

    ax = *(word *)&g_memByte[449316];       // mov ax, team1PenaltyGoals
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[449318];       // mov ax, team2PenaltyGoals
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_next_penalty;                // jz @@next_penalty

l_finish_penalties:;
    *(word *)&g_memByte[523160] = 0;        // mov playingPenalties, 0
    ax = *(word *)&g_memByte[336628];       // mov ax, savedTeam1Goals
    *(word *)&g_memByte[336636] = ax;       // mov statsTeam1Goals, ax
    ax = *(word *)&g_memByte[336630];       // mov ax, savedTeam2Goals
    *(word *)&g_memByte[336638] = ax;       // mov statsTeam2Goals, ax
    SWOS::PlayersLeavingPitch();            // call PlayersLeavingPitch
    return;                                 // retn

l_still_under_five_attempts:;
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    ax = *(word *)&g_memByte[523164];       // mov ax, team1PenaltyAttempts
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = *(word *)&g_memByte[449316];       // mov ax, team1PenaltyGoals
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = *(word *)&g_memByte[449318];       // mov ax, team2PenaltyGoals
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto l_finish_penalties;            // jb short @@finish_penalties

    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    ax = *(word *)&g_memByte[523166];       // mov ax, team2PenaltyAttempts
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = *(word *)&g_memByte[449318];       // mov ax, team2PenaltyGoals
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = *(word *)&g_memByte[449316];       // mov ax, team1PenaltyGoals
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto l_finish_penalties;            // jb @@finish_penalties

l_next_penalty:;
    *(word *)&g_memByte[329028] = 0;        // mov word ptr ballSprite.z+2, 0
    {
        int16_t src = *(word *)&g_memByte[523158];
        src = -src;
        *(word *)&g_memByte[523158] = src;
    }                                       // neg teamPlayingUp
    {
        word src = *(word *)&g_memByte[523158];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[523158] = src;
    }                                       // add teamPlayingUp, 3
    {
        int16_t src = *(word *)&g_memByte[523156];
        src = -src;
        *(word *)&g_memByte[523156] = src;
    }                                       // neg teamStarting
    {
        word src = *(word *)&g_memByte[523156];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[523156] = src;
    }                                       // add teamStarting, 3
    *(word *)&g_memByte[449800] = 0;        // mov hideBall, 0
    InitTeamsData();                        // call InitTeamsData
    *(word *)&g_memByte[523130] = 31;       // mov gameState, ST_PENALTIES
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    *(word *)&g_memByte[523140] = 0;        // mov cameraDirection, 0
    g_memByte[523142] = 131;                // mov byte ptr playerTurnFlags, 83h
    *(word *)&g_memByte[523136] = 336;      // mov foulXCoordinate, 336
    *(word *)&g_memByte[523138] = 187;      // mov foulYCoordinate, 187
    *(word *)&g_memByte[523128] = 101;      // mov gameStatePl, 101
    *(word *)&g_memByte[523116] = 0;        // mov gameNotInProgressCounterWriteOnly, 0
    A6 = 522952;                            // mov A6, offset bottomTeamData
    eax = A6;                               // mov eax, A6
    *(dword *)&g_memByte[523120] = eax;     // mov lastTeamPlayedBeforeBreak, eax
    *(word *)&g_memByte[523124] = 0;        // mov stoppageTimerTotal, 0
    *(word *)&g_memByte[523126] = 0;        // mov stoppageTimerActive, 0
    SWOS::StopAllPlayers();                 // call StopAllPlayers
    *(word *)&g_memByte[449796] = 0;        // mov cameraXVelocity, 0
    *(word *)&g_memByte[449798] = 0;        // mov cameraYVelocity, 0
    *(word *)&g_memByte[523168] = 0;        // mov penaltiesTimer, 0
    A0 = 523170;                            // mov A0, offset team1PenaltyShooterIndex
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 18, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.teamNumber], 1
    if (flags.zero)
        goto l_team1;                       // jz short @@team1

    A0 = 523172;                            // mov A0, offset team2PenaltyShooterIndex

l_team1:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi, 2, src);
    }                                       // sub word ptr [esi], 1
    if (!flags.zero)
        goto l_not_goalkeeper;              // jnz short @@not_goalkeeper

    writeMemory(esi, 2, 10);                // mov word ptr [esi], 10

l_not_goalkeeper:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+TeamGeneralInfo.spritesTable]
    A0 = eax;                               // mov A0, eax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    *(dword *)&g_memByte[523174] = eax;     // mov penaltyShooterSprite, eax
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 18, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.teamNumber], 1
    if (!flags.zero)
        goto l_second_team_shoots;          // jnz short @@second_team_shoots

    {
        word src = *(word *)&g_memByte[523164];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[523164] = src;
    }                                       // add team1PenaltyAttempts, 1
    return;                                 // retn

l_second_team_shoots:;
    {
        word src = *(word *)&g_memByte[523166];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[523166] = src;
    }                                       // add team2PenaltyAttempts, 1
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> goalkeeper sprite
//      A2 -> ball sprite
//      A6 -> player team (general)
//
void GoalkeeperClaimedTheBall()
{
    eax = *(dword *)&g_memByte[523108];     // mov eax, lastPlayerPlayed
    *(dword *)&g_memByte[522768] = eax;     // mov lastPlayerBeforeGoalkeeper, eax
    eax = *(dword *)&g_memByte[523104];     // mov eax, lastTeamPlayed
    *(dword *)&g_memByte[522764] = eax;     // mov lastTeamScored, eax
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 44, 2, 0);            // mov [esi+Sprite.speed], 0
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522952;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset bottomTeamData
    if (flags.zero)
        goto l_right_team;                  // jz short @@right_team

    *(word *)&g_memByte[523140] = 4;        // mov cameraDirection, 4
    g_memByte[523142] = 124;                // mov byte ptr playerTurnFlags, 7Ch
    goto l_camera_direction_set;            // jmp short @@camera_direction_set

l_right_team:;
    *(word *)&g_memByte[523140] = 0;        // mov cameraDirection, 0
    g_memByte[523142] = 199;                // mov byte ptr playerTurnFlags, 0C7h

l_camera_direction_set:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+TeamGeneralInfo.playerNumber]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_player_controlled_team;      // jnz short @@player_controlled_team

    {
        byte src = g_memByte[523142];
        byte res = src & 187;
        src = res;
        g_memByte[523142] = src;
    }                                       // and byte ptr playerTurnFlags, 10111011b

l_player_controlled_team:;
    {
        word src = *(word *)&g_memByte[455970];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp forceLeftTeam, 1
    if (!flags.zero)
        goto l_keeper_holds_the_ball;       // jnz short @@keeper_holds_the_ball

    A6 = 522804;                            // mov A6, offset topTeamData

l_keeper_holds_the_ball:;
    *(word *)&g_memByte[523130] = 3;        // mov gameState, ST_KEEPER_HOLDS_BALL
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    ax = *(word *)&g_memByte[329020];       // mov ax, word ptr ballSprite.x+2
    *(word *)&g_memByte[523136] = ax;       // mov foulXCoordinate, ax
    ax = *(word *)&g_memByte[329024];       // mov ax, word ptr ballSprite.y+2
    *(word *)&g_memByte[523138] = ax;       // mov foulYCoordinate, ax
    *(word *)&g_memByte[523128] = 101;      // mov gameStatePl, ST_STOPPED
    *(word *)&g_memByte[523116] = 0;        // mov gameNotInProgressCounterWriteOnly, 0
    eax = A6;                               // mov eax, A6
    *(dword *)&g_memByte[523120] = eax;     // mov lastTeamPlayedBeforeBreak, eax
    *(word *)&g_memByte[523124] = 0;        // mov stoppageTimerTotal, 0
    *(word *)&g_memByte[523126] = 0;        // mov stoppageTimerActive, 0
    SWOS::StopAllPlayers();                 // call StopAllPlayers
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 80, 2);     // mov ax, [esi+TeamGeneralInfo.goalkeeperDivingRight]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    ax = (word)readMemory(esi + 82, 2);     // mov ax, [esi+TeamGeneralInfo.goalkeeperDivingLeft]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    eax = A1;                               // mov eax, A1
    writeMemory(esi + 32, 4, eax);          // mov [esi+TeamGeneralInfo.controlledPlayerSprite], eax
    writeMemory(esi + 84, 1, 1);            // mov byte ptr [esi+TeamGeneralInfo.ballOutOfPlayOrKeeper], 1
    ax = *(word *)&g_memByte[523140];       // mov ax, cameraDirection
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 42, 2, ax);           // mov [esi+Sprite.direction], ax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 86, 1, 1);            // mov byte ptr [esi+TeamGeneralInfo.goaliePlayingOrOut], 1
    UpdatePlayerWithBall();                 // call UpdatePlayerWithBall
    *(word *)&g_memByte[449796] = 0;        // mov cameraXVelocity, 0
    *(word *)&g_memByte[449798] = 0;        // mov cameraYVelocity, 0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> sprite
//
// Set coordinates of player that has the ball. Make him dodge
// a little, by varying x and y coordinates by 1.
//
void UpdatePlayerWithBall()
{
    A0 = 328988;                            // mov A0, offset ballSprite
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 524212;                            // mov A0, offset kPlayerWithBallOffsets
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = (word)readMemory(esi + ebx + 2, 2); // mov ax, [esi+ebx+2]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 32, 2, ax);           // mov word ptr [esi+(Sprite.x+2)], ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 36, 2, ax);           // mov word ptr [esi+(Sprite.y+2)], ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
}

// =============== S U B R O U T I N E =======================================
//
void ResetBothTeamSpinTimers()
{
    *(word *)&g_memByte[522922] = -1;       // mov topTeamData.spinTimer, -1
    *(word *)&g_memByte[523070] = -1;       // mov bottomTeamData.spinTimer, -1
}

// =============== S U B R O U T I N E =======================================

// in:
//      A6 -> team data
//
// Apply "after effects" to pass/kick. Apply spin if player holding left/right
// directions, and high kick if player holding back direction. Also update ball
// for normal kicks too. Slow down ball after kick/pass.
//
void ApplyBallAfterTouch()
{
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 128, 2);    // mov ax, [esi+TeamGeneralInfo.passInProgress]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_passing_now;                 // jnz @@passing_now

    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 76, 2);     // mov ax, [esi+TeamGeneralInfo.goalkeeperSavedCommentTimer]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_reset_spin_timer_out;        // js @@reset_spin_timer_out

    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (flags.zero)
        goto l_game_in_progress;            // jz short @@game_in_progress

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (flags.zero)
        goto l_reset_spin_timer_out;        // jz @@reset_spin_timer_out

l_game_in_progress:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 118, 2);    // mov ax, [esi+TeamGeneralInfo.spinTimer]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js @@out

    if (!flags.zero)
        goto l_accepting_spin;              // jnz short @@accepting_spin

    writeMemory(esi + 120, 2, 0);           // mov [esi+TeamGeneralInfo.leftSpin], 0
    writeMemory(esi + 122, 2, 0);           // mov [esi+TeamGeneralInfo.rightSpin], 0

l_accepting_spin:;
    A1 = 328988;                            // mov A1, offset ballSprite
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 120, 2);    // mov ax, [esi+TeamGeneralInfo.leftSpin]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_already_spining_left;        // jnz @@already_spining_left

    ax = (word)readMemory(esi + 122, 2);    // mov ax, [esi+TeamGeneralInfo.rightSpin]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_already_spining_right;       // jnz short @@already_spining_right

    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+TeamGeneralInfo.currentAllowedDirection]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_not_starting_spin;           // js @@not_starting_spin

    ax = (word)readMemory(esi + 56, 2);     // mov ax, [esi+TeamGeneralInfo.controlledPlDirection]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        goto l_not_starting_spin;           // jz @@not_starting_spin

    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (flags.zero)
        goto l_not_starting_spin;           // jz @@not_starting_spin

    if (flags.carry)
        goto l_spin_left;                   // jb short @@spin_left

    writeMemory(esi + 122, 2, 1);           // mov [esi+TeamGeneralInfo.rightSpin], 1

l_already_spining_right:;
    D1 = 4;                                 // mov D1, 4
    goto l_calculate_initial_spin;          // jmp short @@calculate_initial_spin

l_spin_left:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 120, 2, 1);           // mov [esi+TeamGeneralInfo.leftSpin], 1

l_already_spining_left:;
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

l_calculate_initial_spin:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 56, 2);     // mov ax, [esi+TeamGeneralInfo.controlledPlDirection]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 325806;                            // mov A0, offset kKickSpinFactor
    {
        word res = *(word *)&D0 << 3;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 3
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    A2 = 325786;                            // mov A2, offset kSpinMultiplierFactor
    ax = (word)readMemory(esi + 118, 2);    // mov ax, [esi+TeamGeneralInfo.spinTimer]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        word res = *(word *)&D2 << 1;
        *(word *)&D2 = res;
    }                                       // shl word ptr D2, 1
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int32_t res = (int16_t)ax * *(int16_t *)&D2;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul word ptr D2
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 58, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 58, 2, src);
    }                                       // add [esi+Sprite.destX], ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx + 2, 2); // mov ax, [esi+ebx+2]
    {
        int32_t res = (int16_t)ax * *(int16_t *)&D2;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 60, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 60, 2, src);
    }                                       // add [esi+Sprite.destY], ax

l_not_starting_spin:;
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 118, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.spinTimer], 4
    if (!flags.zero)
        goto l_increase_spin_timer;         // jnz @@increase_spin_timer

    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+TeamGeneralInfo.currentAllowedDirection]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_normal_not_high_kick;        // js short @@normal_not_high_kick

    ax = (word)readMemory(esi + 56, 2);     // mov ax, [esi+TeamGeneralInfo.controlledPlDirection]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        goto l_jmp_increase_spin_timer;     // jz short @@jmp_increase_spin_timer

    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (flags.zero)
        goto l_normal_not_high_kick;        // jz short @@normal_not_high_kick

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 6
    if (flags.zero)
        goto l_normal_not_high_kick;        // jz short @@normal_not_high_kick

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 3
    if (flags.carry)
        goto l_jmp_increase_spin_timer;     // jb short @@jmp_increase_spin_timer

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 5
    if (!flags.carry && !flags.zero)
        goto l_jmp_increase_spin_timer;     // ja short @@jmp_increase_spin_timer

    eax = *(dword *)&g_memByte[325774];     // mov eax, kHighKickDeltaZ
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 54, 4, eax);          // mov [esi+Sprite.deltaZ], eax
    ax = *(word *)&g_memByte[325778];       // mov ax, kHighKickBallSpeed
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    goto l_do_some_speed_adjustment;        // jmp short @@do_some_speed_adjustment

l_normal_not_high_kick:;
    eax = *(dword *)&g_memByte[325780];     // mov eax, kNormalKickDeltaZ
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 54, 4, eax);          // mov [esi+Sprite.deltaZ], eax
    ax = *(word *)&g_memByte[325784];       // mov ax, kNormalKickBallSpeed
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    goto l_do_some_speed_adjustment;        // jmp short @@do_some_speed_adjustment

l_jmp_increase_spin_timer:;
    goto l_increase_spin_timer;             // jmp @@increase_spin_timer

l_do_some_speed_adjustment:;
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 56, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.controlledPlDirection], 0
    if (flags.zero)
        goto l_decrease_ball_speed_by_quarter; // jz @@decrease_ball_speed_by_quarter

    {
        word src = (word)readMemory(esi + 56, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.controlledPlDirection], 4
    if (flags.zero)
        goto l_decrease_ball_speed_by_quarter; // jz short @@decrease_ball_speed_by_quarter

    {
        byte src = (byte)readMemory(esi + 56, 1);
        byte res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+TeamGeneralInfo.controlledPlDirection], 1
    if (flags.zero)
        goto l_increase_spin_timer;         // jz @@increase_spin_timer

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 >> 2;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 2
    *(int16_t *)&D1 = -*(int16_t *)&D1;     // neg word ptr D1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        word res = *(word *)&D2 >> 3;
        *(word *)&D2 = res;
    }                                       // shr word ptr D2, 3
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    goto l_increase_spin_timer;             // jmp short @@increase_spin_timer

l_decrease_ball_speed_by_quarter:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 >> 2;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 2
    *(int16_t *)&D1 = -*(int16_t *)&D1;     // neg word ptr D1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax

l_increase_spin_timer:;
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 118, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 118, 2, src);
    }                                       // add [esi+TeamGeneralInfo.spinTimer], 1
    {
        word src = (word)readMemory(esi + 118, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.spinTimer], 10
    if (!flags.zero)
        return;                             // jnz short @@out

l_reset_spin_timer_out:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 118, 2, -1);          // mov [esi+TeamGeneralInfo.spinTimer], -1

l_out:;
    return;                                 // retn

l_passing_now:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 76, 2);     // mov ax, [esi+TeamGeneralInfo.goalkeeperSavedCommentTimer]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_out_reset_spin_timer;        // js @@out_reset_spin_timer

    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, 100
    if (flags.zero)
        goto l_game_in_progress2;           // jz short @@game_in_progress2

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (flags.zero)
        goto l_out_reset_spin_timer;        // jz @@out_reset_spin_timer

l_game_in_progress2:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 118, 2);    // mov ax, [esi+TeamGeneralInfo.spinTimer]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js @@out2

    if (!flags.zero)
        goto l_spin_timer_running;          // jnz short @@spin_timer_running

    writeMemory(esi + 120, 2, 0);           // mov [esi+TeamGeneralInfo.leftSpin], 0
    writeMemory(esi + 122, 2, 0);           // mov [esi+TeamGeneralInfo.rightSpin], 0
    writeMemory(esi + 124, 2, 0);           // mov [esi+TeamGeneralInfo.longPass], 0
    writeMemory(esi + 126, 2, 0);           // mov [esi+TeamGeneralInfo.longSpinPass], 0

l_spin_timer_running:;
    A1 = 328988;                            // mov A1, offset ballSprite
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 120, 2);    // mov ax, [esi+TeamGeneralInfo.leftSpin]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_pass_spining_left;           // jnz @@pass_spining_left

    ax = (word)readMemory(esi + 122, 2);    // mov ax, [esi+TeamGeneralInfo.rightSpin]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_pass_spining_right;          // jnz short @@pass_spining_right

    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+TeamGeneralInfo.currentAllowedDirection]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_no_spin_to_apply;            // js @@no_spin_to_apply

    ax = (word)readMemory(esi + 56, 2);     // mov ax, [esi+TeamGeneralInfo.controlledPlDirection]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        goto l_no_spin_to_apply;            // jz @@no_spin_to_apply

    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (flags.zero)
        goto l_no_spin_to_apply;            // jz @@no_spin_to_apply

    if (flags.carry)
        goto l_turn_on_left_spin;           // jb short @@turn_on_left_spin

    writeMemory(esi + 122, 2, 1);           // mov [esi+TeamGeneralInfo.rightSpin], 1

l_pass_spining_right:;
    D1 = 4;                                 // mov D1, 4
    goto l_apply_spin_factor;               // jmp short @@apply_spin_factor

l_turn_on_left_spin:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 120, 2, 1);           // mov [esi+TeamGeneralInfo.leftSpin], 1

l_pass_spining_left:;
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

l_apply_spin_factor:;
    ax = *(word *)&g_memByte[329030];       // mov ax, ballSprite.direction
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 325870;                            // mov A0, offset kPassingSpinFactor
    {
        word res = *(word *)&D0 << 3;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 3
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    A2 = 325786;                            // mov A2, offset kSpinMultiplierFactor
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 118, 2);    // mov ax, [esi+TeamGeneralInfo.spinTimer]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        word res = *(word *)&D2 << 1;
        *(word *)&D2 = res;
    }                                       // shl word ptr D2, 1
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int32_t res = (int16_t)ax * *(int16_t *)&D2;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul word ptr D2
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 58, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 58, 2, src);
    }                                       // add [esi+Sprite.destX], ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx + 2, 2); // mov ax, [esi+ebx+2]
    {
        int32_t res = (int16_t)ax * *(int16_t *)&D2;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 60, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 60, 2, src);
    }                                       // add [esi+Sprite.destY], ax

l_no_spin_to_apply:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 124, 4);         // mov eax, dword ptr [esi+TeamGeneralInfo.longPass]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto l_update_spin_timer;           // jnz @@update_spin_timer

    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+TeamGeneralInfo.currentAllowedDirection]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_holding_left_or_right;       // js @@holding_left_or_right

    ax = (word)readMemory(esi + 56, 2);     // mov ax, [esi+TeamGeneralInfo.controlledPlDirection]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        goto l_update_spin_timer2;          // jz @@update_spin_timer2

    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (flags.zero)
        goto l_holding_left_or_right;       // jz short @@holding_left_or_right

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 6
    if (flags.zero)
        goto l_holding_left_or_right;       // jz short @@holding_left_or_right

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 3
    if (flags.carry)
        goto l_update_spin_timer2;          // jb short @@update_spin_timer2

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 5
    if (!flags.carry && !flags.zero)
        goto l_update_spin_timer2;          // ja short @@update_spin_timer2

    writeMemory(esi + 126, 2, 1);           // mov [esi+TeamGeneralInfo.longSpinPass], 1
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // add [esi+Sprite.speed], ax
    goto l_update_spin_timer;               // jmp short @@update_spin_timer

l_holding_left_or_right:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 124, 2, 1);           // mov [esi+TeamGeneralInfo.longPass], 1
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // add [esi+Sprite.speed], ax
    goto l_update_spin_timer;               // jmp short @@update_spin_timer

l_update_spin_timer2:;

l_update_spin_timer:;
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 118, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 118, 2, src);
    }                                       // add [esi+TeamGeneralInfo.spinTimer], 1
    {
        word src = (word)readMemory(esi + 118, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.spinTimer], 10
    if (!flags.zero)
        return;                             // jnz short @@out2

l_out_reset_spin_timer:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 118, 2, -1);          // mov [esi+TeamGeneralInfo.spinTimer], -1
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> sprite
//      A6 -> team data
//
// Set how much time will player be lying on the ground after tackle.
// Better tackling skill means less time.
//
void SetPlayerDowntimeAfterTackle()
{
    GetPlayerPointerFromShirtNumber();      // call GetPlayerPointerFromShirtNumber
    A0 = 524012;                            // mov A0, offset kPlayerTacklingDownTime
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 106, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.tacklingTimer], -1
    if (!flags.zero)
        goto l_ordinary_player;             // jnz short @@ordinary_player

    A0 = 524028;                            // mov A0, offset kComputerTacklingDownTime

l_ordinary_player:;
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 72, 1);     // mov al, [esi+PlayerGameHeader.tackling]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 13, 1, al);           // mov [esi+Sprite.playerDownTimer], al
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player sprite
//      A6 -> player team (general)
//
void UpdatePlayerSpeed()
{
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_NORMAL
    if (!flags.zero)
        return;                             // jnz @@out

    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (!flags.zero)
        goto l_not_goalkeeper;              // jnz short @@not_goalkeeper

    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerOrdinal], 1
    if (!flags.zero)
        goto l_not_goalkeeper;              // jnz short @@not_goalkeeper

    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, eax
    if (!flags.zero)
        return;                             // jnz @@out

l_not_goalkeeper:;
    GetPlayerPointerFromShirtNumber();      // call GetPlayerPointerFromShirtNumber
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 74, 1);     // mov al, [esi+PlayerGameHeader.speed]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    A0 = 524044;                            // mov A0, offset kPlayerSpeedsGameInProgress
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (flags.zero)
        goto l_convert_speed;               // jz short @@convert_speed

    A0 = 524060;                            // mov A0, offset kPlayerSpeedsGameStopped

l_convert_speed:;
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    ax = *(word *)&g_memByte[457534];       // mov ax, runSlower
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_try_to_run_full_speed;       // jz short @@try_to_run_full_speed

    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // sub [esi+Sprite.speed], ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // sub [esi+Sprite.speed], ax

l_try_to_run_full_speed:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+TeamGeneralInfo.playerNumber]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_player_controlling;          // jnz short @@player_controlling

    ax = (word)readMemory(esi + 6, 2);      // mov ax, [esi+TeamGeneralInfo.playerCoachNumber]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_player_not_injured;          // jz short @@player_not_injured

l_player_controlling:;
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 77, 1);     // mov al, [esi+PlayerGameHeader.injuriesBitfield]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_player_not_injured;          // jz short @@player_not_injured

    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 4;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 4
    A0 = 524196;                            // mov A0, offset kInjuriesSpeedHandicap
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // add [esi+Sprite.speed], ax

l_player_not_injured:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, eax
    if (!flags.zero)
        goto l_not_this_player;             // jnz short @@not_this_player

    ax = (word)readMemory(esi + 40, 2);     // mov ax, [esi+TeamGeneralInfo.playerHasBall]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_this_player;             // jz short @@not_this_player

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // sub [esi+Sprite.speed], ax

l_not_this_player:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+TeamGeneralInfo.playerNumber]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_pass_to_player;           // jz @@no_pass_to_player

    eax = readMemory(esi + 36, 4);          // mov eax, [esi+TeamGeneralInfo.passToPlayerPtr]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, eax
    if (!flags.zero)
        goto l_no_pass_to_player;           // jnz @@no_pass_to_player

    ax = (word)readMemory(esi + 90, 2);     // mov ax, [esi+TeamGeneralInfo.passingToPlayer]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_pass_to_player;           // jz @@no_pass_to_player

    eax = readMemory(esi + 124, 4);         // mov eax, dword ptr [esi+TeamGeneralInfo.longPass]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto l_long_pass_to_player;         // jnz short @@long_pass_to_player

    ax = (word)readMemory(esi + 120, 2);    // mov ax, [esi+TeamGeneralInfo.leftSpin]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_long_pass_to_player;         // jnz short @@long_pass_to_player

    ax = (word)readMemory(esi + 122, 2);    // mov ax, [esi+TeamGeneralInfo.rightSpin]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_pass_to_player;           // jz short @@no_pass_to_player

l_long_pass_to_player:;
    ax = *(word *)&g_memByte[329032];       // mov ax, ballSprite.speed
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_pass_to_player;           // jz short @@no_pass_to_player

    ax = *(word *)&g_memByte[329070];       // mov ax, ballSprite.fullDirection
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 82, 1);     // mov al, byte ptr [esi+Sprite.fullDirection]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 7;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 7
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_no_pass_to_player;           // jg short @@no_pass_to_player

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = -7;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, -7
    if (flags.sign != flags.overflow)
        goto l_no_pass_to_player;           // jl short @@no_pass_to_player

    *(word *)&D1 = 512;                     // mov word ptr D1, 512
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 5;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 5
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_set_pass_to_player_speed;    // jg short @@set_pass_to_player_speed

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 251;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 251
    if (flags.sign != flags.overflow)
        goto l_set_pass_to_player_speed;    // jl short @@set_pass_to_player_speed

    *(word *)&D1 = 256;                     // mov word ptr D1, 256

l_set_pass_to_player_speed:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax

l_no_pass_to_player:;
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (flags.zero)
        goto l_calc_frame_delay;            // jz @@calc_frame_delay

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 29;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FIRST_HALF_ENDED
    if (flags.zero)
        goto l_half_or_game_end;            // jz @@half_or_game_end

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_GAME_ENDED
    if (flags.zero)
        goto l_half_or_game_end;            // jz @@half_or_game_end

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 23;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_GOING_TO_HALFTIME
    if (flags.zero)
        goto l_players_leaving_pitch;       // jz short @@players_leaving_pitch

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 24;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PLAYERS_GOING_TO_SHOWER
    if (!flags.zero)
        goto l_calc_frame_delay;            // jnz @@calc_frame_delay

l_players_leaving_pitch:;
    ax = *(word *)&g_memByte[523124];       // mov ax, stoppageTimerTotal
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 100
    if (flags.carry || flags.zero)
        goto l_set_players_leaving_pitch_speed; // jbe short @@set_players_leaving_pitch_speed

    *(word *)&D0 = 100;                     // mov word ptr D0, 100

l_set_players_leaving_pitch_speed:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 44, 2);
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul [esi+Sprite.speed]
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    goto l_calc_frame_delay;                // jmp short @@calc_frame_delay

l_half_or_game_end:;
    ax = *(word *)&g_memByte[523124];       // mov ax, stoppageTimerTotal
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 5;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 5
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // sub [esi+Sprite.speed], ax
    if (!flags.sign)
        goto l_calc_frame_delay;            // jns short @@calc_frame_delay

    writeMemory(esi + 44, 2, 0);            // mov [esi+Sprite.speed], 0

l_calc_frame_delay:;
    *(word *)&D0 = 1280;                    // mov word ptr D0, 1280
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (!flags.sign)
        goto l_speed_difference_in_range;   // jns short @@speed_difference_in_range

    *(word *)&D0 = 0;                       // mov word ptr D0, 0

l_speed_difference_in_range:;
    {
        word res = *(word *)&D0 >> 7;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 6
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 24, 2, ax);           // mov [esi+Sprite.frameDelay], ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> sprite (player)
//      A6 -> team data
//
void UpdateTeamShotChanceTable()
{
    GetPlayerPointerFromShirtNumber();      // call GetPlayerPointerFromShirtNumber
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+PlayerGameHeader.position]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_goalkeeper;                  // jz short @@goalkeeper

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 24, 4, 526976);       // mov [esi+TeamGeneralInfo.shotChanceTable], offset kPlayerShotChanceTable
    return;                                 // retn

l_goalkeeper:;
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 76, 1);     // mov al, [esi+PlayerGameHeader.goalieSkill]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    A0 = 524164;                            // mov A0, offset kGoalieSkillTables
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 24, 4, eax);          // mov [esi+TeamGeneralInfo.shotChanceTable], eax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> sprite (player)
//      A6 -> team data
// out:
//      A4 -> player + header (in-game)
//
void GetPlayerPointerFromShirtNumber()
{
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+Sprite.playerOrdinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    A4 = 332510;                            // mov A4, offset inGameTeamPlayerOffsets
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A4;                               // mov esi, A4
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 10, 4);          // mov eax, [esi+TeamGeneralInfo.inGameTeamPtr]
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A4 = eax;                               // mov A4, eax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player sprite
//      A2 -> ball sprite
//      A6 -> team (general)
//
void UpdateBallVariables()
{
    push(D0);                               // push D0
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 30, 4);          // mov eax, [esi+Sprite.x]
    D1 = eax;                               // mov D1, eax
    eax = readMemory(esi + 34, 4);          // mov eax, [esi+Sprite.y]
    D2 = eax;                               // mov D2, eax
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+Sprite.z]
    D3 = eax;                               // mov D3, eax
    eax = readMemory(esi + 46, 4);          // mov eax, [esi+Sprite.deltaX]
    D4 = eax;                               // mov D4, eax
    eax = readMemory(esi + 50, 4);          // mov eax, [esi+Sprite.deltaY]
    D5 = eax;                               // mov D5, eax
    eax = readMemory(esi + 54, 4);          // mov eax, [esi+Sprite.deltaZ]
    D6 = eax;                               // mov D6, eax
    eax = *(dword *)&g_memByte[325648];     // mov eax, kGravityConstant
    D7 = eax;                               // mov D7, eax
    {
        int32_t dstSigned = D5;
        int32_t srcSigned = -65536;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D5, -10000h
    if (flags.sign != flags.overflow)
        goto l_ball_going_up;               // jl short @@ball_going_up

    {
        int32_t dstSigned = D5;
        int32_t srcSigned = 65536;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D5, 10000h
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_ball_going_down;             // jg @@ball_going_down

    {
        int32_t dstSigned = D4;
        int32_t srcSigned = -65536;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D4, -10000h
    if (flags.sign != flags.overflow)
        goto l_ball_going_left;             // jl @@ball_going_left

    {
        int32_t dstSigned = D4;
        int32_t srcSigned = 65536;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D4, 10000h
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_ball_going_right;            // jg @@ball_going_right

    goto l_ball_not_moving;                 // jmp @@ball_not_moving

l_ball_going_up:;
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (!flags.zero)
        goto l_ball_not_moving;             // jnz @@ball_not_moving

    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 34, 4);          // mov eax, [esi+Sprite.y]
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // sub D2, eax
    if (flags.sign == flags.overflow)
        goto l_set_ball_y_to_0;             // jge short @@set_ball_y_to_0

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&g_memByte[524746] = ax;       // mov ballDefensiveX, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&g_memByte[524748] = ax;       // mov ballDefensiveY, ax
    ax = (word)readMemory(esi + 40, 2);     // mov ax, word ptr [esi+(Sprite.z+2)]
    *(word *)&g_memByte[524750] = ax;       // mov ballDefensiveZ, ax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 34, 4);          // mov eax, [esi+Sprite.y]
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // add D2, eax
    goto l_ball_above_player_check;         // jmp @@ball_above_player_check

l_set_ball_y_to_0:;
    eax = D7;                               // mov eax, D7
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D6 = res;
    }                                       // sub D6, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D3 = res;
    }                                       // add D3, eax
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // add D2, eax
    if (flags.sign == flags.overflow)
        goto l_set_ball_y_to_0;             // jge short @@set_ball_y_to_0

    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D2 = res;
    }                                       // sub D2, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D3 = res;
    }                                       // sub D3, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 34, 4);          // mov eax, [esi+Sprite.y]
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D2 = res;
    }                                       // add D2, eax
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[524746] = ax;       // mov ballDefensiveX, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[524748] = ax;       // mov ballDefensiveY, ax
    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_77879;                    // jns short cseg_77879

    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_77879:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[524750] = ax;       // mov ballDefensiveZ, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax

l_ball_above_player_check:;
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = 8847360;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // sub D2, 870000h
    if (flags.sign == flags.overflow)
        goto l_ball_above_135;              // jge short @@ball_above_135

    ax = *(word *)&g_memByte[524746];       // mov ax, ballDefensiveX
    *(word *)&g_memByte[524752] = ax;       // mov ballNotHighX, ax
    ax = *(word *)&g_memByte[524748];       // mov ax, ballDefensiveY
    *(word *)&g_memByte[524754] = ax;       // mov ballNotHighY, ax
    ax = *(word *)&g_memByte[524750];       // mov ax, ballDefensiveZ
    *(word *)&g_memByte[524756] = ax;       // mov ballNotHighZ, ax
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = 8847360;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // add D2, 870000h
    goto cseg_779F5;                        // jmp cseg_779F5

l_ball_above_135:;
    eax = D7;                               // mov eax, D7
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D6 = res;
    }                                       // sub D6, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D3 = res;
    }                                       // add D3, eax
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // add D2, eax
    if (flags.sign == flags.overflow)
        goto l_ball_above_135;              // jge short @@ball_above_135

    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D3 = res;
    }                                       // sub D3, eax
    D2 = 8847360;                           // mov D2, 870000h
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[524752] = ax;       // mov ballNotHighX, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[524754] = ax;       // mov ballNotHighY, ax
    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_779B0;                    // jns short cseg_779B0

    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_779B0:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[524756] = ax;       // mov ballNotHighZ, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax

cseg_779F5:;
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = 8454144;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // sub D2, 810000h
    if (flags.sign == flags.overflow)
        goto l_ball_between_129_135;        // jge short @@ball_between_129_135

    *(word *)&g_memByte[524758] = 0;        // mov strikeDestX, 0
    *(word *)&g_memByte[524760] = 0;        // mov dseg_17E661, 0
    *(word *)&g_memByte[524762] = 0;        // mov dseg_17E663, 0
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = 8454144;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // add D2, 810000h
    goto l_out;                             // jmp @@out

l_ball_between_129_135:;
    eax = D7;                               // mov eax, D7
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D6 = res;
    }                                       // sub D6, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D3 = res;
    }                                       // add D3, eax
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // add D2, eax
    if (flags.sign == flags.overflow)
        goto l_ball_between_129_135;        // jge short @@ball_between_129_135

    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D3 = res;
    }                                       // sub D3, eax
    D2 = 8454144;                           // mov D2, 810000h
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[524758] = ax;       // mov strikeDestX, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[524760] = ax;       // mov dseg_17E661, ax
    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_77ADE;                    // jns short cseg_77ADE

    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_77ADE:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[524762] = ax;       // mov dseg_17E663, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    goto l_out;                             // jmp @@out

l_ball_going_down:;
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522952;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset bottomTeamData
    if (!flags.zero)
        goto l_ball_not_moving;             // jnz @@ball_not_moving

    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 34, 4);          // mov eax, [esi+Sprite.y]
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // sub D2, eax
    if (flags.sign != flags.overflow)
        goto l_ball_above_player;           // jl short @@ball_above_player

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&g_memByte[524746] = ax;       // mov ballDefensiveX, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&g_memByte[524748] = ax;       // mov ballDefensiveY, ax
    ax = (word)readMemory(esi + 40, 2);     // mov ax, word ptr [esi+(Sprite.z+2)]
    *(word *)&g_memByte[524750] = ax;       // mov ballDefensiveZ, ax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 34, 4);          // mov eax, [esi+Sprite.y]
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // add D2, eax
    goto cseg_77C95;                        // jmp cseg_77C95

l_ball_above_player:;
    eax = D7;                               // mov eax, D7
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D6 = res;
    }                                       // sub D6, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D3 = res;
    }                                       // add D3, eax
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // add D2, eax
    if (flags.sign != flags.overflow)
        goto l_ball_above_player;           // jl short @@ball_above_player

    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D2 = res;
    }                                       // sub D2, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D3 = res;
    }                                       // sub D3, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 34, 4);          // mov eax, [esi+Sprite.y]
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D2 = res;
    }                                       // add D2, eax
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[524746] = ax;       // mov ballDefensiveX, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[524748] = ax;       // mov ballDefensiveY, ax
    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_77C50;                    // jns short cseg_77C50

    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_77C50:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[524750] = ax;       // mov ballDefensiveZ, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax

cseg_77C95:;
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = 50003968;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // sub D2, 2FB0000h
    if (flags.sign != flags.overflow)
        goto cseg_77CDD;                    // jl short cseg_77CDD

    ax = *(word *)&g_memByte[524746];       // mov ax, ballDefensiveX
    *(word *)&g_memByte[524752] = ax;       // mov ballNotHighX, ax
    ax = *(word *)&g_memByte[524748];       // mov ax, ballDefensiveY
    *(word *)&g_memByte[524754] = ax;       // mov ballNotHighY, ax
    ax = *(word *)&g_memByte[524750];       // mov ax, ballDefensiveZ
    *(word *)&g_memByte[524756] = ax;       // mov ballNotHighZ, ax
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = 50003968;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // add D2, 2FB0000h
    goto cseg_77DD5;                        // jmp cseg_77DD5

cseg_77CDD:;
    eax = D7;                               // mov eax, D7
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D6 = res;
    }                                       // sub D6, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D3 = res;
    }                                       // add D3, eax
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // add D2, eax
    if (flags.sign != flags.overflow)
        goto cseg_77CDD;                    // jl short cseg_77CDD

    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D3 = res;
    }                                       // sub D3, eax
    D2 = 50003968;                          // mov D2, 2FB0000h
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[524752] = ax;       // mov ballNotHighX, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[524754] = ax;       // mov ballNotHighY, ax
    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_77D90;                    // jns short cseg_77D90

    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_77D90:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[524756] = ax;       // mov ballNotHighZ, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax

cseg_77DD5:;
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = 50397184;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // sub D2, 3010000h
    if (flags.sign != flags.overflow)
        goto cseg_77E0B;                    // jl short cseg_77E0B

    *(word *)&g_memByte[524758] = 0;        // mov strikeDestX, 0
    *(word *)&g_memByte[524760] = 0;        // mov dseg_17E661, 0
    *(word *)&g_memByte[524762] = 0;        // mov dseg_17E663, 0
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = 50397184;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // add D2, 3010000h
    goto l_out;                             // jmp @@out

cseg_77E0B:;
    eax = D7;                               // mov eax, D7
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D6 = res;
    }                                       // sub D6, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D3 = res;
    }                                       // add D3, eax
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D2 = res;
    }                                       // add D2, eax
    if (flags.sign != flags.overflow)
        goto cseg_77E0B;                    // jl short cseg_77E0B

    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D3 = res;
    }                                       // sub D3, eax
    D2 = 50397184;                          // mov D2, 3010000h
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[524758] = ax;       // mov strikeDestX, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[524760] = ax;       // mov dseg_17E661, ax
    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_77EBE;                    // jns short cseg_77EBE

    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_77EBE:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[524762] = ax;       // mov dseg_17E663, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    goto l_out;                             // jmp @@out

l_ball_going_left:;
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 30, 4);          // mov eax, [esi+Sprite.x]
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // sub D1, eax
    if (flags.sign == flags.overflow)
        goto l_ball_right_of_player;        // jge short @@ball_right_of_player

    eax = readMemory(esi + 30, 4);          // mov eax, [esi+Sprite.x]
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // add D1, eax
    goto l_ball_not_moving;                 // jmp @@ball_not_moving

l_ball_right_of_player:;
    eax = D7;                               // mov eax, D7
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D6 = res;
    }                                       // sub D6, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D3 = res;
    }                                       // add D3, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D2 = res;
    }                                       // add D2, eax
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // add D1, eax
    if (flags.sign == flags.overflow)
        goto l_ball_right_of_player;        // jge short @@ball_right_of_player

    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D2 = res;
    }                                       // sub D2, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D3 = res;
    }                                       // sub D3, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 30, 4);          // mov eax, [esi+Sprite.x]
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[524746] = ax;       // mov ballDefensiveX, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[524748] = ax;       // mov ballDefensiveY, ax
    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_77FF6;                    // jns short cseg_77FF6

    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_77FF6:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[524750] = ax;       // mov ballDefensiveZ, ax
    goto cseg_78136;                        // jmp cseg_78136

l_ball_going_right:;
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 30, 4);          // mov eax, [esi+Sprite.x]
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // sub D1, eax
    if (flags.sign != flags.overflow)
        goto l_ball_left_of_player;         // jl short @@ball_left_of_player

    eax = readMemory(esi + 30, 4);          // mov eax, [esi+Sprite.x]
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // add D1, eax
    goto l_ball_not_moving;                 // jmp @@ball_not_moving

l_ball_left_of_player:;
    eax = D7;                               // mov eax, D7
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D6 = res;
    }                                       // sub D6, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D3 = res;
    }                                       // add D3, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D2 = res;
    }                                       // add D2, eax
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // add D1, eax
    if (flags.sign != flags.overflow)
        goto l_ball_left_of_player;         // jl short @@ball_left_of_player

    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D2 = res;
    }                                       // sub D2, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D3 = res;
    }                                       // sub D3, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 30, 4);          // mov eax, [esi+Sprite.x]
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[524746] = ax;       // mov ballDefensiveX, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[524748] = ax;       // mov ballDefensiveY, ax
    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_780F5;                    // jns short cseg_780F5

    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_780F5:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[524750] = ax;       // mov ballDefensiveZ, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    goto cseg_78136;                        // jmp short cseg_78136

l_ball_not_moving:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&g_memByte[524746] = ax;       // mov ballDefensiveX, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&g_memByte[524748] = ax;       // mov ballDefensiveY, ax
    ax = (word)readMemory(esi + 40, 2);     // mov ax, word ptr [esi+(Sprite.z+2)]
    *(word *)&g_memByte[524750] = ax;       // mov ballDefensiveZ, ax

cseg_78136:;
    ax = *(word *)&g_memByte[524746];       // mov ax, ballDefensiveX
    *(word *)&g_memByte[524752] = ax;       // mov ballNotHighX, ax
    ax = *(word *)&g_memByte[524748];       // mov ax, ballDefensiveY
    *(word *)&g_memByte[524754] = ax;       // mov ballNotHighY, ax
    ax = *(word *)&g_memByte[524750];       // mov ax, ballDefensiveZ
    *(word *)&g_memByte[524756] = ax;       // mov ballNotHighZ, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    *(word *)&g_memByte[524758] = 0;        // mov strikeDestX, 0
    *(word *)&g_memByte[524760] = 0;        // mov dseg_17E661, 0
    *(word *)&g_memByte[524762] = 0;        // mov dseg_17E663, 0

l_out:;
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A2 -> ball sprite
//
void CalculateBallNextGroundXYPositions()
{
    push(D0);                               // push D0
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 30, 4);          // mov eax, [esi+Sprite.x]
    D1 = eax;                               // mov D1, eax
    eax = readMemory(esi + 34, 4);          // mov eax, [esi+Sprite.y]
    D2 = eax;                               // mov D2, eax
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+Sprite.z]
    D3 = eax;                               // mov D3, eax
    eax = readMemory(esi + 46, 4);          // mov eax, [esi+Sprite.deltaX]
    D4 = eax;                               // mov D4, eax
    eax = readMemory(esi + 50, 4);          // mov eax, [esi+Sprite.deltaY]
    D5 = eax;                               // mov D5, eax
    {
        int32_t dstSigned = D5;
        int32_t srcSigned = -65536;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D5, -10000h
    if (flags.sign != flags.overflow)
        goto l_ball_moving;                 // jl short @@ball_moving

    {
        int32_t dstSigned = D5;
        int32_t srcSigned = 65536;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D5, 10000h
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_ball_moving;                 // jg short @@ball_moving

    {
        int32_t dstSigned = D4;
        int32_t srcSigned = -65536;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D4, -10000h
    if (flags.sign != flags.overflow)
        goto l_ball_moving;                 // jl short @@ball_moving

    {
        int32_t dstSigned = D4;
        int32_t srcSigned = 65536;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D4, 10000h
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_ball_moving;                 // jg short @@ball_moving

    goto l_ball_standing;                   // jmp @@ball_standing

l_ball_moving:;
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 54, 4);          // mov eax, [esi+Sprite.deltaZ]
    D6 = eax;                               // mov D6, eax
    eax = *(dword *)&g_memByte[325648];     // mov eax, kGravityConstant
    D7 = eax;                               // mov D7, eax
    D0 = 1310720;                           // mov D0, 140000h

l_subtract_z:;
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D3 = res;
    }                                       // sub D3, eax
    if (!flags.sign)
        goto l_z_in_range;                  // jns short @@z_in_range

    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 851968;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 0D0000h
    if (flags.zero)
        goto l_ball_standing;               // jz @@ball_standing

    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D3 = res;
    }                                       // add D3, eax
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 65536;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D0 = res;
    }                                       // sub D0, 10000h
    goto l_subtract_z;                      // jmp short @@subtract_z

l_z_in_range:;
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    eax = D5;                               // mov eax, D5
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D2 = res;
    }                                       // add D2, eax
    eax = D7;                               // mov eax, D7
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D6 = res;
    }                                       // sub D6, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D3 = res;
    }                                       // add D3, eax
    if (!flags.sign)
        goto l_z_in_range;                  // jns short @@z_in_range

    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D3 = res;
    }                                       // add D3, eax
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[524764] = ax;       // mov ballNextGroundX, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[524766] = ax;       // mov ballNextYGroundY, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[524768] = 0;        // mov ballNextZDeadVar, 0
    goto l_out;                             // jmp short @@out

l_ball_standing:;
    *(word *)&g_memByte[524764] = -1;       // mov ballNextGroundX, -1

l_out:;
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 -  direction
//      D1 -  goalkeeper far jump speed flag, overrides goalkeeper jump speed if:
//                0 - no influence, use high speed as usual (2048)
//                1 - use lower speed (1280)
//                * - anything else: use low speed (1024) + low byte of currentGameTick
//                    effectively random: 1024..1279
//      D3 -  also some direction
//      A1 -> player sprite
//      A6 -> player team (general)
//
void GoalkeeperJumping()
{
    esi = A1;                               // mov esi, A1
    {
        dword src = readMemory(esi + 74, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 128;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.ballDistance], 128
    if (!flags.carry && !flags.zero)
        goto l_ball_far_away;               // ja short @@ball_far_away

    ax = *(word *)&g_memByte[524010];       // mov ax, kGoalkeeperNearJumpSpeed
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    goto l_speed_setting_done;              // jmp short @@speed_setting_done

l_ball_far_away:;
    ax = *(word *)&g_memByte[324036];       // mov ax, kGoalkeeperFarJumpSpeed
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_speed_setting_done;          // jz short @@speed_setting_done

    ax = *(word *)&g_memByte[324038];       // mov ax, kGoalkeeperFarJumpSlowerSpeed
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1
    if (flags.zero)
        goto l_speed_setting_done;          // jz short @@speed_setting_done

    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 255;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFh
    ax = *(word *)&g_memByte[524010];       // mov ax, kGoalkeeperNearJumpSpeed
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax

l_speed_setting_done:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 70, 1, 0);            // mov byte ptr [esi+TeamGeneralInfo.field_46], 0
    writeMemory(esi + 80, 2, 0);            // mov [esi+TeamGeneralInfo.goalkeeperDivingRight], 0
    {
        word src = *(word *)&g_memByte[524756];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp ballNotHighZ, 5
    if (!flags.carry && !flags.zero)
        goto l_goalie_jumping_high;         // ja short @@goalie_jumping_high

    esi = A1;                               // mov esi, A1
    writeMemory(esi + 12, 1, 7);            // mov [esi+Sprite.playerState], PL_GOALIE_DIVING_LOW
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522952;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset bottomTeamData
    if (flags.zero)
        goto l_right_goalie_jumping_low;    // jz short @@right_goalie_jumping_low

    A0 = 454698;                            // mov A0, offset leftGoalieJumpingLowAnimTable
    SetPlayerAnimationTable();              // call SetPlayerAnimationTable
    goto l_set_down_timer;                  // jmp short @@set_down_timer

l_right_goalie_jumping_low:;
    A0 = 454828;                            // mov A0, offset rightGoalieJumpingLowAnimTable
    SetPlayerAnimationTable();              // call SetPlayerAnimationTable
    goto l_set_down_timer;                  // jmp short @@set_down_timer

l_goalie_jumping_high:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 12, 1, 6);            // mov [esi+Sprite.playerState], PL_GOALIE_DIVING_HIGH
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522952;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset bottomTeamData
    if (flags.zero)
        goto l_right_goalie_jumping_high;   // jz short @@right_goalie_jumping_high

    A0 = 454308;                            // mov A0, offset leftGoalieJumpingHighAnimTable
    SetPlayerAnimationTable();              // call SetPlayerAnimationTable
    goto l_set_down_timer;                  // jmp short @@set_down_timer

l_right_goalie_jumping_high:;
    A0 = 454568;                            // mov A0, offset rightGoalieJumpingHighAnimTable
    SetPlayerAnimationTable();              // call SetPlayerAnimationTable

l_set_down_timer:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 13, 1, 75);           // mov [esi+Sprite.playerDownTimer], 75
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 56, 2, ax);           // mov [esi+TeamGeneralInfo.controlledPlDirection], ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A5 = 523306;                            // mov A5, offset kDefaultDestinations
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0 -  currently pressed direction
//     A1 -> player sprite that's tackling
//
// Set player state to tackling. Set his dest x and y with a table, and set speed to taclking speed.
//
void PlayerBeginTackling()
{
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 96, 2, 0);            // mov [esi+Sprite.tackleState], 0
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 56, 2, ax);           // mov [esi+TeamGeneralInfo.controlledPlDirection], ax
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 42, 2, ax);           // mov [esi+Sprite.direction], ax
    A0 = 453364;                            // mov A0, offset plTacklingAnimTable
    SetPlayerAnimationTable();              // call SetPlayerAnimationTable
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 12, 1, 1);            // mov [esi+Sprite.playerState], PL_TACKLING
    writeMemory(esi + 13, 1, g_memByte[540868]); // mov [esi+Sprite.playerDownTimer], playerDownTacklingInterval
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+Sprite.playerOrdinal]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    A0 = 332510;                            // mov A0, offset inGameTeamPlayerOffsets
    {
        word res = *(word *)&D1 << 1;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 10, 4);          // mov eax, [esi+TeamGeneralInfo.inGameTeamPtr]
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 50, 1);     // mov al, [esi+PlayerGameHeader.fasterTackle]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_no_faster_tackle;            // jz short @@no_faster_tackle

    esi = A1;                               // mov esi, A1
    writeMemory(esi + 13, 1, 25);           // mov [esi+Sprite.playerDownTimer], 25

l_no_faster_tackle:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 13, 1, -1);           // mov [esi+Sprite.playerDownTimer], -1
    A5 = 523306;                            // mov A5, offset kDefaultDestinations
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    ax = *(word *)&g_memByte[325742];       // mov ax, kPlayerTacklingSpeed
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    writeMemory(esi + 106, 2, 0);           // mov [esi+Sprite.tacklingTimer], 0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> sprite (player)
//      A6 -> team (general)
//
// Player is tackling and hitting the ball. Adjust ball direction according to the player direction and
// controls direction (do deflected tackles). Set ball destination coordinates far away in that direction.
// Adjust ball speed after tackle to 125% of player's speed (100% if CPU player). Set player's speed
// afterward to 50%. If opponent's controlled player is more than 9u away from the ball and distance
// between the 2 players is greater than 32u it is considered a good tackle.
//  u = sqr((x1 - x2) ^ 2) + sqr((y1 - y2) ^ 2)
//
void PlayersTackledTheBallStrong()
{
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+TeamGeneralInfo.currentAllowedDirection]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_current_direction_allowed;   // jns short @@current_direction_allowed

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_current_direction_allowed:;
    A2 = 328988;                            // mov A2, offset ballSprite
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        goto l_set_controlled_player_direction; // jz short @@set_controlled_player_direction

    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (flags.zero)
        goto l_set_controlled_player_direction; // jz short @@set_controlled_player_direction

    if (flags.carry)
        goto l_controls_leaning_leftward;   // jb short @@controls_leaning_leftward

    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    goto l_set_new_direction;               // jmp short @@set_new_direction

l_controls_leaning_leftward:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    goto l_set_new_direction;               // jmp short @@set_new_direction

l_set_controlled_player_direction:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

l_set_new_direction:;
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 56, 2, ax);           // mov [esi+TeamGeneralInfo.controlledPlDirection], ax
    A0 = 523306;                            // mov A0, offset kDefaultDestinations
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx + 2, 2); // mov ax, [esi+ebx+2]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+TeamGeneralInfo.playerNumber]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_player_not_cpu;              // jnz short @@player_not_cpu

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    goto l_halve_player_speed;              // jmp short @@halve_player_speed

l_player_not_cpu:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax

l_halve_player_speed:;
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 44, 2);
        word res = src >> 1;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // shr [esi+Sprite.speed], 1
    writeMemory(esi + 96, 2, 1);            // mov [esi+Sprite.tackleState], 1
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        goto l_out;                         // jz @@out

    esi = A0;                               // mov esi, A0
    {
        dword src = readMemory(esi + 74, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 9;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.ballDistance], 9
    if (flags.carry)
        goto l_out;                         // jb @@out

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    bx = D0;                                // mov bx, word ptr D0
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    bx = D1;                                // mov bx, word ptr D1
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    eax = D1;                               // mov eax, D1
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D0 = res;
    }                                       // add D0, eax
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 32;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 32
    if (flags.carry || flags.zero)
        goto l_out;                         // jbe short @@out

    SWOS::PlayGoodTackleComment();          // call PlayGoodTackleComment
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 96, 2, 2);            // mov [esi+Sprite.tackleState], TS_GOOD_TACKLE

l_out:;
    SWOS::PlayKickSample();                 // call PlayKickSample
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> goalkeeper sprite
//      A2 -> ball sprite
//      A6 -> team data
// out:
//      D0 - return bool, can goalkeeper at least try saving this
//
void ShouldGoalkeeperDive()
{
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (flags.zero)
        goto l_check_goalkeeper_ball_distance; // jz short @@check_goalkeeper_ball_distance

    *(int16_t *)&D0 = -*(int16_t *)&D0;     // neg word ptr D0

l_check_goalkeeper_ball_distance:;
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_ball_in_front_of_goalkeeper; // jns short @@ball_in_front_of_goalkeeper

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -10;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -10
    if (flags.sign != flags.overflow)
        goto l_goalkeeper_wont_dive;        // jl @@goalkeeper_wont_dive

    goto l_try_saving;                      // jmp @@try_saving

l_ball_in_front_of_goalkeeper:;
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_goalkeeper_wont_dive;        // js @@goalkeeper_wont_dive

    ax = *(word *)&g_memByte[523160];       // mov ax, playingPenalties
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_penalty_shot;                // jnz short @@penalty_shot

    ax = *(word *)&g_memByte[523112];       // mov ax, penalty
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_normal_shot;                 // jz short @@normal_shot

l_penalty_shot:;
    ax = *(word *)&g_memByte[325562];       // mov ax, kKeeperPenaltySaveDistanceFar
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    push(D0);                               // push small [word ptr D0]
    SWOS::Rand();                           // call Rand
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int32_t val = stack[stackTop++];
        *(word *)&D0 = val;
    }                                       // pop small [word ptr D0]
    {
        word res = *(word *)&D2 & 24;
        *(word *)&D2 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D2, 18h
    if (flags.zero)
        goto l_penalty_compare_distance;    // jz short @@penalty_compare_distance

    ax = *(word *)&g_memByte[325564];       // mov ax, kKeeperPenaltySaveDistanceNear
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_penalty_compare_distance:;
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_goalkeeper_wont_dive;        // jg @@goalkeeper_wont_dive

    goto l_try_saving;                      // jmp @@try_saving

l_normal_shot:;
    ax = *(word *)&g_memByte[325560];       // mov ax, kKeeperSaveDistance
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_goalkeeper_wont_dive;        // jg @@goalkeeper_wont_dive

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, ax
    if (!flags.sign)
        goto cseg_78AE6;                    // jns short cseg_78AE6

    flags.carry = *(int16_t *)&D4 != 0;
    flags.overflow = *(int16_t *)&D4 == INT16_MIN;
    *(int16_t *)&D4 = -*(int16_t *)&D4;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // neg word ptr D4

cseg_78AE6:;
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 50, 4);          // mov eax, [esi+Sprite.deltaY]
    D0 = eax;                               // mov D0, eax
    GetFramesNeededToCoverDistance();       // call GetFramesNeededToCoverDistance
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_goalkeeper_wont_dive;        // jz @@goalkeeper_wont_dive

    ax = *(word *)&g_memByte[524746];       // mov ax, ballDefensiveX
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, ax
    if (!flags.sign)
        goto cseg_78B34;                    // jns short cseg_78B34

    flags.carry = *(int16_t *)&D4 != 0;
    flags.overflow = *(int16_t *)&D4 == INT16_MIN;
    *(int16_t *)&D4 = -*(int16_t *)&D4;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // neg word ptr D4

cseg_78B34:;
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 46, 4);          // mov eax, [esi+Sprite.deltaX]
    D0 = eax;                               // mov D0, eax
    GetFramesNeededToCoverDistance();       // call GetFramesNeededToCoverDistance
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_goalkeeper_wont_dive;        // jz @@goalkeeper_wont_dive

    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.carry || flags.zero)
        goto l_goalkeeper_wont_dive;        // jbe @@goalkeeper_wont_dive

    ax = *(word *)&g_memByte[524746];       // mov ax, ballDefensiveX
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, ax
    if (!flags.sign)
        goto cseg_78B95;                    // jns short cseg_78B95

    *(int16_t *)&D4 = -*(int16_t *)&D4;     // neg word ptr D4

cseg_78B95:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 24, 4);          // mov eax, [esi+TeamGeneralInfo.shotChanceTable]
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0Fh
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx + 10, 2); // mov ax, [esi+ebx+10]
    (ax)--;
    flags.overflow = (int16_t)(ax) == INT16_MIN;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // dec ax
    if (!flags.sign)
        goto l_calc_frames;                 // jns short @@calc_frames

    ax = 0;                                 // mov ax, 0

l_calc_frames:;
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 324072;                            // mov A0, offset kGoalkeeperDiveDeltas
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    D0 = eax;                               // mov D0, eax
    {
        word src = *(word *)&g_memByte[337190];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[337190] = src;
    }                                       // add goalkeeperDiveDeadVar, 1
    GetFramesNeededToCoverDistance();       // call GetFramesNeededToCoverDistance
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_goalkeeper_wont_dive;        // jz short @@goalkeeper_wont_dive

    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (flags.carry)
        goto l_goalkeeper_wont_dive;        // jb short @@goalkeeper_wont_dive

l_try_saving:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    return;                                 // retn

l_goalkeeper_wont_dive:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - movement delta, distance in a single frame (fixed point)
//           (absolute value is taken)
//      D4 - distance to cover (integer)
// out:
//      D7 - frames needed to cover the given distance (integer)
//
// Does division D4/D0 using loops, without direct divide instruction.
// If they're exactly divisible it will return one more, e.g. 9/3 -> 4.
// If D0 is less than 1, scales it up as well as the value which gets
// subtracted from D4 in a loop, to limit the number of loops when D0 < 1.
// It will fail for extremely low D0 values.
// Called to calculate on both x and y directions.
//
void GetFramesNeededToCoverDistance()
{
    eax = D0;                               // mov eax, D0
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto l_not_moving;                  // jz short @@not_moving

    if (!flags.sign)
        goto l_positive;                    // jns short @@positive

    *(int32_t *)&D0 = -*(int32_t *)&D0;     // neg D0

l_positive:;
    *(word *)&D5 = 1;                       // mov word ptr D5, 1
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 65536;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 10000h
    if (!flags.carry)
        goto l_goalkeeper_delta_eq_1_or_more; // jnb short @@goalkeeper_delta_eq_1_or_more

l_scale_loop:;
    {
        dword res = D0 << 1;
        D0 = res;
    }                                       // shl D0, 1
    {
        word res = *(word *)&D5 << 1;
        *(word *)&D5 = res;
    }                                       // shl word ptr D5, 1
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 65536;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 10000h
    if (flags.carry)
        goto l_scale_loop;                  // jb short @@scale_loop

l_goalkeeper_delta_eq_1_or_more:;
    ax = D4;                                // mov ax, word ptr D4
    {
        word tmp = *(word *)((byte *)&D4 + 2);
        *(word *)((byte *)&D4 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D4+2
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    *(word *)&D7 = 0;                       // mov word ptr D7, 0

l_divide_loop:;
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, ax
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = D4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D4 = res;
    }                                       // sub D4, eax
    if (!flags.sign)
        goto l_divide_loop;                 // jns short @@divide_loop

    return;                                 // retn

l_not_moving:;
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================

// There was a shot on goal, but goalkeeper managed to throw himself and catch
// the ball (and save the day). (I think)
//
void GoalkeeperCaughtTheBall()
{
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (!flags.zero)
        goto l_right_team;                  // jnz short @@right_team

    esi = A1;                               // mov esi, A1
    writeMemory(esi + 42, 2, 4);            // mov [esi+Sprite.direction], 4
    goto l_set_anim_table;                  // jmp short @@set_anim_table

l_right_team:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 42, 2, 0);            // mov [esi+Sprite.direction], 0

l_set_anim_table:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 82, 2, 0);            // mov [esi+TeamGeneralInfo.goalkeeperDivingLeft], 0
    A0 = 453658;                            // mov A0, offset goalieCatchingBallAnimTable
    SetPlayerAnimationTable();              // call SetPlayerAnimationTable
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 12, 1, 4);            // mov [esi+Sprite.playerState], PL_GOALIE_CATCHING_BALL
    writeMemory(esi + 13, 1, 15);           // mov [esi+Sprite.playerDownTimer], 15
    ax = *(word *)&g_memByte[324032];       // mov ax, kGoalkeeperCatchSpeed
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    ax = *(word *)&g_memByte[524764];       // mov ax, ballNextGroundX
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = *(word *)&g_memByte[524766];       // mov ax, ballNextYGroundY
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    {
        word src = (word)readMemory(esi + 60, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 137;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.destY], 137
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_78D7F;                    // jg short cseg_78D7F

    writeMemory(esi + 60, 2, 137);          // mov [esi+Sprite.destY], 137

cseg_78D7F:;
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 60, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 761;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.destY], 761
    if (flags.sign != flags.overflow)
        return;                             // jl short @@out

    writeMemory(esi + 60, 2, 761);          // mov [esi+Sprite.destY], 761
}

// =============== S U B R O U T I N E =======================================

// in:
//      A2 -> ball sprite
//      A6 -> player team (general)
//
void cseg_78D9A()
{
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522952;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset bottomTeamData
    if (flags.zero)
        goto cseg_78DB8;                    // jz short cseg_78DB8

    *(word *)&D0 = 4;                       // mov word ptr D0, 4

cseg_78DB8:;
    A0 = 523306;                            // mov A0, offset kDefaultDestinations
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx + 2, 2); // mov ax, [esi+ebx+2]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 31;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1Fh
    {
        word res = *(word *)&D0 << 5;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 512;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 512
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 58, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 58, 2, src);
    }                                       // add [esi+Sprite.destX], ax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 24, 4);          // mov eax, [esi+TeamGeneralInfo.shotChanceTable]
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 60;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 3Ch
    {
        word res = *(word *)&D1 >> 2;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 2
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 52, 2);     // mov ax, [esi+52]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    if (flags.sign)
        goto cseg_78EDF;                    // js short cseg_78EDF

    ax = (word)readMemory(esi + 54, 2);     // mov ax, [esi+54]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    if (flags.sign)
        goto cseg_78ECE;                    // js short cseg_78ECE

    ax = *(word *)&g_memByte[324044];       // mov ax, dseg_1105FF
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    goto cseg_78EEE;                        // jmp short cseg_78EEE

cseg_78ECE:;
    ax = *(word *)&g_memByte[324042];       // mov ax, dseg_1105FD
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    goto cseg_78EEE;                        // jmp short cseg_78EEE

cseg_78EDF:;
    ax = *(word *)&g_memByte[324040];       // mov ax, dseg_1105FB
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_78EEE:;
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 511;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1FFh
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 256;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 256
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    eax = *(dword *)&g_memByte[324046];     // mov eax, dseg_110601
    D1 = eax;                               // mov D1, eax
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        dword res = D0 & 127;
        D0 = res;
    }                                       // and D0, 7Fh
    {
        dword res = D0 << 8;
        D0 = res;
    }                                       // shl D0, 8
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 16384;
        dword res = dstSigned - srcSigned;
        D0 = res;
    }                                       // sub D0, 16384
    eax = D1;                               // mov eax, D1
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D0 = res;
    }                                       // add D0, eax
    eax = D0;                               // mov eax, D0
    writeMemory(esi + 54, 4, eax);          // mov [esi+Sprite.deltaZ], eax
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
    SWOS::PlayKickSample();                 // call PlayKickSample
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> sprite (player)
//      A2 -> sprite (ball)
//      A6 -> team data
//
// Check if the tackle ends up in faul, there must be a few conditions satisfied:
// - opponent has a controlled player
// - distance between them is more than 32 units
//
void PlayerTacklingTestFoul()
{
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A2 = eax;                               // mov A2, eax
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    A2 = eax;                               // mov A2, eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, 0
    if (flags.zero)
        return;                             // jz @@out

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    bx = D0;                                // mov bx, word ptr D0
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    bx = D1;                                // mov bx, word ptr D1
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    eax = D1;                               // mov eax, D1
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D0 = res;
    }                                       // add D0, eax
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 32;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 32
    if (flags.carry || flags.zero)
        goto l_players_very_close;          // jbe short @@players_very_close

l_out:;
    return;                                 // retn

l_play_foul_comment_and_return:;
    SWOS::PlayDangerousPlayComment();       // call PlayDangerousPlayComment
    return;                                 // retn

l_opponents_player_goalkeeper:;
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 44, 2);
        word res = src >> 1;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // shr [esi+Sprite.speed], 1
    {
        word src = (word)readMemory(esi + 44, 2);
        word res = src >> 1;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // shr [esi+Sprite.speed], 1
    {
        word src = (word)readMemory(esi + 44, 2);
        src |= 1;
        writeMemory(esi + 44, 2, src);
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // or [esi+Sprite.speed], 1
    return;                                 // retn

l_players_very_close:;
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerOrdinal], 1
    if (flags.zero)
        goto l_opponents_player_goalkeeper; // jz short @@opponents_player_goalkeeper

    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerOrdinal], 1
    if (flags.zero)
        return;                             // jz short @@out

    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 81;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.x+2)], 81
    if (flags.sign != flags.overflow)
        return;                             // jl short @@out

    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.y+2)], 129
    if (flags.sign != flags.overflow)
        return;                             // jl short @@out

    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 590;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.x+2)], 590
    if (!flags.zero && flags.sign == flags.overflow)
        return;                             // jg short @@out

    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 769;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.y+2)], 769
    if (!flags.zero && flags.sign == flags.overflow)
        return;                             // jg short @@out

    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 44, 2);
        word res = src >> 1;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // shr [esi+Sprite.speed], 1
    {
        word src = (word)readMemory(esi + 44, 2);
        word res = src >> 1;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // shr [esi+Sprite.speed], 1
    {
        word src = (word)readMemory(esi + 44, 2);
        src |= 1;
        writeMemory(esi + 44, 2, src);
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // or [esi+Sprite.speed], 1
    push(A1);                               // push A1
    push(A6);                               // push A6
    eax = A2;                               // mov eax, A2
    A1 = eax;                               // mov A1, eax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A6 = eax;                               // mov A6, eax
    PlayerTackled();                        // call PlayerTackled
    pop(A6);                                // pop A6
    pop(A1);                                // pop A1
    esi = A2;                               // mov esi, A2
    {
        dword src = readMemory(esi + 74, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 800;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.ballDistance], 800
    if (!flags.carry && !flags.zero)
        return;                             // ja @@out

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 96, 2);     // mov ax, [esi+Sprite.tackleState]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_foul_concedeed;              // jz short @@foul_concedeed

    {
        word src = (word)readMemory(esi + 96, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.tackleState], TS_GOOD_TACKLE
    if (flags.zero)
        goto l_play_foul_comment_and_return; // jz @@play_foul_comment_and_return

    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -1
    if (flags.sign != flags.overflow)
        return;                             // jl @@out

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero && flags.sign == flags.overflow)
        return;                             // jg @@out

l_foul_concedeed:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 14, 4);          // mov eax, [esi+TeamGeneralInfo.teamStatsPtr]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 4, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 4, 2, src);
    }                                       // add [esi+TeamStatisticsData.foulsConceded], 1
    ax = *(word *)&g_memByte[523648];       // mov ax, cardsDisallowed
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_no_cards_given;              // jnz @@no_cards_given

    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_no_cards_given;              // jnz @@no_cards_given

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 193;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 193
    if (flags.sign != flags.overflow)
        goto l_not_in_penalty_area;         // jl short @@not_in_penalty_area

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 478;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 478
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_not_in_penalty_area;         // jg short @@not_in_penalty_area

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 129
    if (flags.sign != flags.overflow)
        goto l_not_in_penalty_area;         // jl short @@not_in_penalty_area

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 769;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 769
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_not_in_penalty_area;         // jg short @@not_in_penalty_area

    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (!flags.zero)
        goto l_right_team;                  // jnz short @@right_team

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 216;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 216
    if (flags.zero || flags.sign != flags.overflow)
        goto l_in_penalty_area;             // jle @@in_penalty_area

    goto l_not_in_penalty_area;             // jmp short @@not_in_penalty_area

l_right_team:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 682;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 682
    if (flags.sign == flags.overflow)
        goto l_in_penalty_area;             // jge @@in_penalty_area

l_not_in_penalty_area:;
    *(word *)&D1 = 336;                     // mov word ptr D1, 336
    *(word *)&D2 = 129;                     // mov word ptr D2, 129
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (flags.zero)
        goto l_left_team;                   // jz short @@left_team

    *(word *)&D2 = 769;                     // mov word ptr D2, 769

l_left_team:;
    eax = A2;                               // mov eax, A2
    A5 = eax;                               // mov A5, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, ax
    ax = D6;                                // mov ax, word ptr D6
    bx = D6;                                // mov bx, word ptr D6
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)((byte *)&D6 + 2) = dx;        // mov word ptr D6+2, dx
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D3 = res;
    }                                       // sub word ptr D3, ax
    ax = D3;                                // mov ax, word ptr D3
    bx = D3;                                // mov bx, word ptr D3
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    *(word *)((byte *)&D3 + 2) = dx;        // mov word ptr D3+2, dx
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D3 = res;
    }                                       // add D3, eax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+TeamGeneralInfo.spritesTable]
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 10;                      // mov word ptr D0, 10

l_players_loop:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    A4 = eax;                               // mov A4, eax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 108, 2);    // mov ax, [esi+Sprite.sentAway]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_next_player;                 // jnz @@next_player

    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerOrdinal], 1
    if (flags.zero)
        goto l_next_player;                 // jz @@next_player

    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (flags.zero)
        goto l_next_player;                 // jz @@next_player

    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, ax
    ax = D6;                                // mov ax, word ptr D6
    bx = D6;                                // mov bx, word ptr D6
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)((byte *)&D6 + 2) = dx;        // mov word ptr D6+2, dx
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    ax = D7;                                // mov ax, word ptr D7
    bx = D7;                                // mov bx, word ptr D7
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    eax = D7;                               // mov eax, D7
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D6 = res;
    }                                       // add D6, eax
    eax = D3;                               // mov eax, D3
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D6, eax
    if (!flags.carry && !flags.zero)
        goto l_next_player;                 // ja short @@next_player

    eax = D6;                               // mov eax, D6
    D3 = eax;                               // mov D3, eax
    eax = A4;                               // mov eax, A4
    A5 = eax;                               // mov A5, eax

l_next_player:;
    (*(int16_t *)&D0)--;
    flags.overflow = (int16_t)(*(int16_t *)&D0) == INT16_MIN;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_players_loop;                // jns @@players_loop

    eax = A5;                               // mov eax, A5
    *(dword *)&g_memByte[337208] = eax;     // mov dseg_114EC2, eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, eax
    if (flags.zero)
        goto cseg_79444;                    // jz short cseg_79444

l_in_penalty_area:;
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 30;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1Eh
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = *(word *)&g_memByte[523662];       // mov ax, playerCardChance
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto l_no_cards_given;              // jnb short @@no_cards_given

    SWOS::Rand();                           // call Rand
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 32
    if (flags.carry)
        goto l_direct_red_card;             // jb short @@direct_red_card

l_yellow_card:;
    TryBookingThePlayer();                  // call TryBookingThePlayer
    if (!flags.zero)
        goto l_no_cards_given;              // jnz short @@no_cards_given

    TestFoulForPenaltyAndFreeKick();        // call TestFoulForPenaltyAndFreeKick
    push(A1);                               // push A1
    SWOS::ActivateReferee();                // call ActivateReferee
    pop(A1);                                // pop A1
    return;                                 // retn

cseg_79444:;
    SWOS::Rand();                           // call Rand
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 32
    if (flags.carry)
        goto l_yellow_card;                 // jb short @@yellow_card

l_direct_red_card:;
    TrySendingOffThePlayer();               // call TrySendingOffThePlayer
    if (!flags.zero)
        goto l_no_cards_given;              // jnz short @@no_cards_given

    TestFoulForPenaltyAndFreeKick();        // call TestFoulForPenaltyAndFreeKick
    push(A1);                               // push A1
    SWOS::ActivateReferee();                // call ActivateReferee
    pop(A1);                                // pop A1
    return;                                 // retn

l_no_cards_given:;
    TestFoulForPenaltyAndFreeKick();        // jmp TestFoulForPenaltyAndFreeKick
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_28()
{
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player sprite
//      A6 -> team (general)
// out:
//      zero flag = 1, D0 = 0, card given
//      zero flag = 0, D0 = 1, card not given
//
void TryBookingThePlayer()
{
    ax = *(word *)&g_memByte[449320];       // mov ax, plg_D3_param
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_794A5;                    // jnz short cseg_794A5

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+TeamGeneralInfo.playerNumber]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_player_controls_team;        // jnz short @@player_controls_team

    ax = (word)readMemory(esi + 6, 2);      // mov ax, [esi+TeamGeneralInfo.playerCoachNumber]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_player_controls_team;        // jnz short @@player_controls_team

    goto l_no_card_out;                     // jmp @@no_card_out

cseg_794A5:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+TeamGeneralInfo.playerNumber]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_player_controls_team;        // jnz short @@player_controls_team

    ax = (word)readMemory(esi + 6, 2);      // mov ax, [esi+TeamGeneralInfo.playerCoachNumber]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_player_controls_team;        // jnz short @@player_controls_team

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 102, 2);    // mov ax, [esi+Sprite.cards]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_no_card_out;                 // jnz @@no_card_out

l_player_controls_team:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 102, 2);    // mov ax, [esi+Sprite.cards]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_player_has_no_cards;         // jz short @@player_has_no_cards

    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 18, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.teamNumber], 1
    if (!flags.zero)
        goto l_second_team;                 // jnz short @@second_team

    ax = *(word *)&g_memByte[449322];       // mov ax, team1NumAllowedInjuries
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_card_out;                 // jz @@no_card_out

    goto l_player_has_no_cards;             // jmp short @@player_has_no_cards

l_second_team:;
    ax = *(word *)&g_memByte[449324];       // mov ax, team2NumAllowedInjuries
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_card_out;                 // jz @@no_card_out

l_player_has_no_cards:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 10, 4);          // mov eax, [esi+TeamGeneralInfo.inGameTeamPtr]
    A5 = eax;                               // mov A5, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+Sprite.playerOrdinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    A0 = 332510;                            // mov A0, offset inGameTeamPlayerOffsets
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 102, 2);    // mov ax, [esi+Sprite.cards]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = *(word *)&g_memByte[449320];       // mov ax, plg_D3_param
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_795E0;                    // jnz short cseg_795E0

    A0 = 524244;                            // mov A0, offset dseg_17E3EE
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 51, 1);     // mov al, [esi+PlayerGameHeader.previousCards]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_795B7;                    // jz short cseg_795B7

    A0 = 524249;                            // mov A0, offset dseg_17E3F3

cseg_795B7:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 52, 1);     // mov al, [esi+PlayerGameHeader.cards]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 52, 1, al);           // mov [esi+PlayerGameHeader.cards], al
    goto l_jmp_give_yellow_card;            // jmp short @@jmp_give_yellow_card

cseg_795E0:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 52, 1);     // mov al, [esi+PlayerGameHeader.cards]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_79603;                    // jnz short cseg_79603

    writeMemory(esi + 52, 1, 1);            // mov [esi+PlayerGameHeader.cards], 1
    goto l_give_yellow_card_to_player;      // jmp short @@give_yellow_card_to_player

cseg_79603:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 52, 1, 3);            // mov [esi+PlayerGameHeader.cards], 3

l_jmp_give_yellow_card:;
    goto l_give_yellow_card_to_player;      // jmp short @@give_yellow_card_to_player

l_no_card_out:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    return;                                 // retn

l_give_yellow_card_to_player:;
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 102, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 102, 2, src);
    }                                       // add [esi+Sprite.cards], 1
    eax = A6;                               // mov eax, A6
    *(dword *)&g_memByte[523656] = eax;     // mov lastTeamBooked, eax
    eax = A1;                               // mov eax, A1
    *(dword *)&g_memByte[523652] = eax;     // mov bookedPlayer, eax
    *(word *)&g_memByte[523660] = 0;        // mov refTimer, 0
    {
        word src = (word)readMemory(esi + 102, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.cards], 2
    if (flags.zero)
        goto l_second_yellow_card;          // jz short @@second_yellow_card

    *(word *)&g_memByte[523650] = 1;        // mov whichCard, CARD_YELLOW
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 14, 4);          // mov eax, [esi+TeamGeneralInfo.teamStatsPtr]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 6, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 6, 2, src);
    }                                       // add [esi+TeamStatisticsData.bookings], 1
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

l_second_yellow_card:;
    *(word *)&g_memByte[523650] = 3;        // mov whichCard, CARD_SECOND_YELLOW
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 14, 4);          // mov eax, [esi+TeamGeneralInfo.teamStatsPtr]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 6, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 6, 2, src);
    }                                       // sub [esi+TeamStatisticsData.bookings], 1
    {
        word src = (word)readMemory(esi + 8, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 8, 2, src);
    }                                       // add [esi+TeamStatisticsData.sendingsOff], 1
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 18, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.teamNumber], 1
    if (!flags.zero)
        goto l_team2_red_card;              // jnz short @@team2_red_card

    {
        word src = *(word *)&g_memByte[449322];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[449322] = src;
    }                                       // sub team1NumAllowedInjuries, 1
    goto l_given_card_ok;                   // jmp short @@given_card_ok

l_team2_red_card:;
    {
        word src = *(word *)&g_memByte[449324];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[449324] = src;
    }                                       // sub team2NumAllowedInjuries, 1

l_given_card_ok:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player (sprite)
//      A6 -> team (general)
//
void TrySendingOffThePlayer()
{
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+TeamGeneralInfo.playerNumber]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_player;                      // jnz short @@player

    ax = (word)readMemory(esi + 6, 2);      // mov ax, [esi+TeamGeneralInfo.playerCoachNumber]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_computer_team_no_red_card;   // jz @@computer_team_no_red_card

l_player:;
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 18, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.teamNumber], 1
    if (!flags.zero)
        goto l_team2;                       // jnz short @@team2

    ax = *(word *)&g_memByte[449322];       // mov ax, team1NumAllowedInjuries
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_computer_team_no_red_card;   // jz @@computer_team_no_red_card

    goto cseg_7972E;                        // jmp short cseg_7972E

l_team2:;
    ax = *(word *)&g_memByte[449324];       // mov ax, team2NumAllowedInjuries
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_computer_team_no_red_card;   // jz @@computer_team_no_red_card

cseg_7972E:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 10, 4);          // mov eax, [esi+TeamGeneralInfo.inGameTeamPtr]
    A5 = eax;                               // mov A5, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+Sprite.playerOrdinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    A0 = 332510;                            // mov A0, offset inGameTeamPlayerOffsets
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 102, 2);    // mov ax, [esi+Sprite.cards]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D0 ^= 1;                      // xor word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 3
    ax = *(word *)&g_memByte[449320];       // mov ax, plg_D3_param
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_79804;                    // jnz short cseg_79804

    A0 = 524244;                            // mov A0, offset dseg_17E3EE
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 51, 1);     // mov al, [esi+PlayerGameHeader.previousCards]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_797DB;                    // jz short cseg_797DB

    A0 = 524249;                            // mov A0, offset dseg_17E3F3

cseg_797DB:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 52, 1);     // mov al, [esi+PlayerGameHeader.cards]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 52, 1, al);           // mov [esi+PlayerGameHeader.cards], al
    goto l_jmp_to_update;                   // jmp short @@jmp_to_update

cseg_79804:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 52, 1);     // mov al, [esi+PlayerGameHeader.cards]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    writeMemory(esi + 52, 1, 3);            // mov [esi+PlayerGameHeader.cards], 3

l_jmp_to_update:;
    goto l_update_statistics_with_red_card; // jmp short @@update_statistics_with_red_card

l_computer_team_no_red_card:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    return;                                 // retn

l_update_statistics_with_red_card:;
    eax = A6;                               // mov eax, A6
    *(dword *)&g_memByte[523656] = eax;     // mov lastTeamBooked, eax
    eax = A1;                               // mov eax, A1
    *(dword *)&g_memByte[523652] = eax;     // mov bookedPlayer, eax
    *(word *)&g_memByte[523660] = 0;        // mov refTimer, 0
    *(word *)&g_memByte[523650] = 2;        // mov whichCard, CARD_RED
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 14, 4);          // mov eax, [esi+TeamGeneralInfo.teamStatsPtr]
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 102, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.cards], 1
    if (!flags.zero)
        goto l_no_yellow_card;              // jnz short @@no_yellow_card

    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 6, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 6, 2, src);
    }                                       // sub [esi+TeamStatisticsData.bookings], 1

l_no_yellow_card:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 8, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 8, 2, src);
    }                                       // add [esi+TeamStatisticsData.sendingsOff], 1
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 18, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.teamNumber], 1
    if (!flags.zero)
        goto l_second_team_player;          // jnz short @@second_team_player

    {
        word src = *(word *)&g_memByte[449322];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[449322] = src;
    }                                       // sub team1NumAllowedInjuries, 1
    goto l_red_card_given_out;              // jmp short @@red_card_given_out

l_second_team_player:;
    {
        word src = *(word *)&g_memByte[449324];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[449324] = src;
    }                                       // sub team2NumAllowedInjuries, 1

l_red_card_given_out:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A2 -> fouled player (sprite)
//      A6 -> team that fouled (general info)
//
// Foul has been made. See where, and make it a penalty or
// free kick, depending on location. If not in appropriate
// areas, it's an ordinary foul.
//
void TestFoulForPenaltyAndFreeKick()
{
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 101;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, 101
    if (flags.zero)
        return;                             // jz @@out

    SWOS::PlayFoulWhistleSample();          // call PlayFoulWhistleSample
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (flags.zero)
        goto l_left_team;                   // jz @@left_team

    *(word *)&g_memByte[523140] = 4;        // mov cameraDirection, 4
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 682;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 682
    if (flags.sign != flags.overflow)
        goto l_not_in_lower_penalty_area;   // jl @@not_in_lower_penalty_area

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 193;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 193
    if (flags.sign != flags.overflow)
        goto l_not_in_lower_penalty_area;   // jl @@not_in_lower_penalty_area

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 478;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 478
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_not_in_lower_penalty_area;   // jg @@not_in_lower_penalty_area

    *(word *)&g_memByte[523130] = 14;       // mov gameState, ST_PENALTY
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    g_memByte[523142] = 56;                 // mov byte ptr playerTurnFlags, 38h
    *(word *)&g_memByte[523136] = 336;      // mov foulXCoordinate, 336
    *(word *)&g_memByte[523138] = 711;      // mov foulYCoordinate, 711
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    SWOS::PlayPenaltyComment();             // call PlayPenaltyComment
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    goto l_continue_after_penalty;          // jmp @@continue_after_penalty

l_left_team:;
    *(word *)&g_memByte[523140] = 0;        // mov cameraDirection, 0
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 216;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 216
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_not_in_upper_penalty_area;   // jg @@not_in_upper_penalty_area

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 193;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 193
    if (flags.sign != flags.overflow)
        goto l_not_in_upper_penalty_area;   // jl @@not_in_upper_penalty_area

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 478;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 478
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_not_in_upper_penalty_area;   // jg @@not_in_upper_penalty_area

    *(word *)&g_memByte[523130] = 14;       // mov gameState, ST_PENALTY
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    g_memByte[523142] = 131;                // mov byte ptr playerTurnFlags, 83h
    *(word *)&g_memByte[523136] = 336;      // mov foulXCoordinate, 336
    *(word *)&g_memByte[523138] = 187;      // mov foulYCoordinate, 187
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    SWOS::PlayPenaltyComment();             // call PlayPenaltyComment
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    goto l_continue_after_penalty;          // jmp @@continue_after_penalty

l_not_in_upper_penalty_area:;
    SWOS::PlayFoulComment();                // call PlayFoulComment
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 216;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 216
    if (flags.sign != flags.overflow)
        goto l_ordinary_foul;               // jl @@ordinary_foul

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 331;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 331
    if (flags.sign != flags.overflow)
        goto l_its_a_free_kick;             // jl short @@its_a_free_kick

    goto l_ordinary_foul;                   // jmp @@ordinary_foul

l_not_in_lower_penalty_area:;
    SWOS::PlayFoulComment();                // call PlayFoulComment
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 567;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 567
    if (flags.sign != flags.overflow)
        goto l_ordinary_foul;               // jl @@ordinary_foul

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 682;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 682
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_ordinary_foul;               // jg @@ordinary_foul

l_its_a_free_kick:;
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522952;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset bottomTeamData
    if (flags.zero)
        goto l_right_team_made_foul;        // jz short @@right_team_made_foul

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 153;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 153
    if (flags.sign != flags.overflow)
        goto l_free_kick_left_1;            // jl @@free_kick_left_1

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 261;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 261
    if (flags.sign != flags.overflow)
        goto l_free_kick_left_2;            // jl @@free_kick_left_2

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 309;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 309
    if (flags.sign != flags.overflow)
        goto l_free_kick_left_3;            // jl @@free_kick_left_3

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 362;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 362
    if (flags.sign != flags.overflow)
        goto l_free_kick_center;            // jl @@free_kick_center

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 410;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 410
    if (flags.sign != flags.overflow)
        goto l_free_kick_right_1;           // jl @@free_kick_right_1

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 518;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 518
    if (flags.sign != flags.overflow)
        goto l_free_kick_right_2;           // jl @@free_kick_right_2

    goto l_free_kick_right_3;               // jmp @@free_kick_right_3

l_right_team_made_foul:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 153;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 153
    if (flags.sign != flags.overflow)
        goto l_free_kick_right_3;           // jl @@free_kick_right_3

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 261;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 261
    if (flags.sign != flags.overflow)
        goto l_free_kick_right_2;           // jl short @@free_kick_right_2

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 309;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 309
    if (flags.sign != flags.overflow)
        goto l_free_kick_right_1;           // jl short @@free_kick_right_1

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 362;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 362
    if (flags.sign != flags.overflow)
        goto l_free_kick_center;            // jl short @@free_kick_center

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 410;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 410
    if (flags.sign != flags.overflow)
        goto l_free_kick_left_3;            // jl short @@free_kick_left_3

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 518;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 518
    if (flags.sign != flags.overflow)
        goto l_free_kick_left_2;            // jl short @@free_kick_left_2

l_free_kick_left_1:;
    *(word *)&g_memByte[523130] = 6;        // mov gameState, ST_FREE_KICK_LEFT1
    goto l_save_foul_coordinates;           // jmp short @@save_foul_coordinates

l_free_kick_left_2:;
    *(word *)&g_memByte[523130] = 7;        // mov gameState, ST_FREE_KICK_LEFT2
    goto l_save_foul_coordinates;           // jmp short @@save_foul_coordinates

l_free_kick_left_3:;
    *(word *)&g_memByte[523130] = 8;        // mov gameState, ST_FREE_KICK_LEFT3
    goto l_save_foul_coordinates;           // jmp short @@save_foul_coordinates

l_free_kick_center:;
    *(word *)&g_memByte[523130] = 9;        // mov gameState, ST_FREE_KICK_CENTER
    goto l_save_foul_coordinates;           // jmp short @@save_foul_coordinates

l_free_kick_right_1:;
    *(word *)&g_memByte[523130] = 10;       // mov gameState, ST_FREE_KICK_RIGHT1
    goto l_save_foul_coordinates;           // jmp short @@save_foul_coordinates

l_free_kick_right_2:;
    *(word *)&g_memByte[523130] = 11;       // mov gameState, ST_FREE_KICK_RIGHT2
    goto l_save_foul_coordinates;           // jmp short @@save_foul_coordinates

l_free_kick_right_3:;
    *(word *)&g_memByte[523130] = 12;       // mov gameState, ST_FREE_KICK_RIGHT3
    goto l_save_foul_coordinates;           // jmp short @@save_foul_coordinates

l_ordinary_foul:;
    *(word *)&g_memByte[523130] = 13;       // mov gameState, ST_FOUL

l_save_foul_coordinates:;
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    g_memByte[523142] = -1;                 // mov byte ptr playerTurnFlags, -1
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[523136] = ax;       // mov foulXCoordinate, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[523138] = ax;       // mov foulYCoordinate, ax

l_continue_after_penalty:;
    {
        word src = *(word *)&g_memByte[455970];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp forceLeftTeam, 1
    if (!flags.zero)
        goto l_jump_here;                   // jnz short @@jump_here

    A6 = 522952;                            // mov A6, offset bottomTeamData

l_jump_here:;
    *(word *)&g_memByte[523128] = 101;      // mov gameStatePl, 101
    *(word *)&g_memByte[523116] = 0;        // mov gameNotInProgressCounterWriteOnly, 0
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    *(dword *)&g_memByte[523120] = eax;     // mov lastTeamPlayedBeforeBreak, eax
    *(word *)&g_memByte[523124] = 0;        // mov stoppageTimerTotal, 0
    *(word *)&g_memByte[523126] = 0;        // mov stoppageTimerActive, 0
    SWOS::StopAllPlayers();                 // call StopAllPlayers
    *(word *)&g_memByte[449796] = 0;        // mov cameraXVelocity, 0
    *(word *)&g_memByte[449798] = 0;        // mov cameraYVelocity, 0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player sprite
//      A6 -> team (general)
//
// This function is called when this player was tackled.
// It sets player's state to tackled and sets animation
// table. Also randomly sets injury and injury level.
//
void PlayerTackled()
{
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_a_training_game;         // jz short @@not_a_training_game

    SWOS::Rand();                           // call Rand
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 3
    if (!flags.zero)
        goto l_set_tackled_anim_table;      // jnz @@set_tackled_anim_table

l_not_a_training_game:;
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 18, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.teamNumber], 1
    if (!flags.zero)
        goto l_second_team;                 // jnz short @@second_team

    ax = *(word *)&g_memByte[449322];       // mov ax, team1NumAllowedInjuries
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_set_tackled_anim_table;      // jz @@set_tackled_anim_table

    goto l_injury_allowed;                  // jmp short @@injury_allowed

l_second_team:;
    ax = *(word *)&g_memByte[449324];       // mov ax, team2NumAllowedInjuries
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_set_tackled_anim_table;      // jz @@set_tackled_anim_table

l_injury_allowed:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+Sprite.playerOrdinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    A0 = 332510;                            // mov A0, offset inGameTeamPlayerOffsets
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 10, 4);          // mov eax, [esi+TeamGeneralInfo.inGameTeamPtr]
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[449306];       // mov ax, gameLengthInGame
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    A5 = 524002;                            // mov A5, offset kTackleInjuryProbability
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 77, 1);     // mov al, [esi+PlayerGameHeader.injuriesBitfield]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 20h
    if (!flags.zero)
        goto l_not_injured;                 // jnz short @@not_injured

    A5 = 524006;                            // mov A5, offset kTackleInjuryProbabilityAlreadyInjured

l_not_injured:;
    SWOS::Rand();                           // call Rand
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.carry)
        goto l_set_tackled_anim_table;      // jnb @@set_tackled_anim_table

    SWOS::PlayInjuryComment();              // call PlayInjuryComment
    A5 = 523972;                            // mov A5, offset kInjuryLevels
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 77, 1);     // mov al, [esi+PlayerGameHeader.injuriesBitfield]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 20h
    if (!flags.zero)
        goto cseg_79E4D;                    // jnz short cseg_79E4D

    A5 = 523979;                            // mov A5, offset kInjuryLevelAlreadyInjured

cseg_79E4D:;
    SWOS::Rand();                           // call Rand
    {
        word res = *(word *)&D0 & 63;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 3Fh
    *(word *)&D1 = 32;                      // mov word ptr D1, 32
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_set_injury_level;            // jb @@set_injury_level

    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 32
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_set_injury_level;            // jb @@set_injury_level

    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 32
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_set_injury_level;            // jb @@set_injury_level

    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 32
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_set_injury_level;            // jb @@set_injury_level

    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 32
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_set_injury_level;            // jb short @@set_injury_level

    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 32
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_set_injury_level;            // jb short @@set_injury_level

    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 32
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_set_injury_level;            // jb short @@set_injury_level

    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 32

l_set_injury_level:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 48, 1, 1);            // mov [esi+PlayerGameHeader.isInjured], 1
    al = (byte)readMemory(esi + 77, 1);     // mov al, [esi+PlayerGameHeader.injuriesBitfield]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.carry || flags.zero)
        goto cseg_79FD7;                    // jbe short cseg_79FD7

    al = D1;                                // mov al, byte ptr D1
    writeMemory(esi + 77, 1, al);           // mov [esi+PlayerGameHeader.injuriesBitfield], al

cseg_79FD7:;
    {
        word res = *(word *)&D1 & 224;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0E0h
    {
        word res = *(word *)&D1 >> 5;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 5
    A0 = 523986;                            // mov A0, offset dseg_17E2EC
    {
        word res = *(word *)&D1 << 1;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 104, 2, ax);          // mov [esi+Sprite.injuryLevel], ax
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 18, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.teamNumber], 1
    if (!flags.zero)
        goto l_team2_injury;                // jnz short @@team2_injury

    {
        word src = *(word *)&g_memByte[449322];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[449322] = src;
    }                                       // sub team1NumAllowedInjuries, 1
    goto l_set_tackled_anim_table;          // jmp short @@set_tackled_anim_table

l_team2_injury:;
    {
        word src = *(word *)&g_memByte[449324];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[449324] = src;
    }                                       // sub team2NumAllowedInjuries, 1

l_set_tackled_anim_table:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 12, 1, 3);            // mov [esi+Sprite.playerState], PL_TACKLED
    writeMemory(esi + 13, 1, 50);           // mov [esi+Sprite.playerDownTimer], 50
    A0 = 453576;                            // mov A0, offset playerTackledAnimTable
    SetPlayerAnimationTable();              // call SetPlayerAnimationTable
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> sprite of player that holds the ball
//
// Set ball coordinates in regard to player that controls it. Ball is
// always about a pixel in front of player, wherever he may be turned.
// If it's in the air, steady it down.
//
void UpdateBallWithControllingGoalkeeper()
{
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 523940;                            // mov A0, offset kBallPlOffsets
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx + 2, 2); // mov ax, [esi+ebx+2]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    A0 = 328988;                            // mov A0, offset ballSprite
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 44, 2, 0);            // mov [esi+Sprite.speed], 0
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 32, 2, ax);           // mov word ptr [esi+(Sprite.x+2)], ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 36, 2, ax);           // mov word ptr [esi+(Sprite.y+2)], ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    eax = readMemory(esi + 54, 4);          // mov eax, [esi+Sprite.deltaZ]
    D0 = eax;                               // mov D0, eax
    {
        int32_t res = *(int32_t *)&D0 >> 1;
        flags.carry = ((dword)*(int32_t *)&D0 >> 31) & 1;
        *(int32_t *)&D0 = res;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // sar D0, 1
    if (flags.sign)
        goto l_delta_z_negative;            // js short @@delta_z_negative

    flags.carry = *(int32_t *)&D0 != 0;
    *(int32_t *)&D0 = -*(int32_t *)&D0;
    flags.sign = (*(int32_t *)&D0 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&D0 == 0;      // neg D0

l_delta_z_negative:;
    eax = D0;                               // mov eax, D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 54, 4, eax);          // mov [esi+Sprite.deltaZ], eax
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 =  current player direction
//      A6 -> team data
//      A1 -> current player sprite
//
// When running.
// Sets team's direction of player controlling the ball.
// Updates the ball when controlled by the player (makes it "run away" a bit).
//
void CalculateIfPlayerWinsBall()
{
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 128, 2, 0);           // mov [esi+TeamGeneralInfo.passInProgress], 0
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 138, 2);    // mov ax, [esi+TeamGeneralInfo.wonTheBallTimer]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_set_team_direction;          // jnz @@set_team_direction

    ax = (word)readMemory(esi + 40, 2);     // mov ax, [esi+TeamGeneralInfo.playerHasBall]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_set_team_direction;          // jz @@set_team_direction

    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+TeamGeneralInfo.currentAllowedDirection]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_set_team_direction;          // js @@set_team_direction

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(A1);                               // push A1
    push(A6);                               // push A6
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    A1 = eax;                               // mov A1, eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, 0
    if (flags.zero)
        goto l_no_opponent_controlled_player; // jz @@no_opponent_controlled_player

    GetPlayerPointerFromShirtNumber();      // call GetPlayerPointerFromShirtNumber
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 72, 1);     // mov al, [esi+PlayerGameHeader.tackling]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 73, 1);     // mov al, [esi+PlayerGameHeader.ballControl]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, al
    {
        byte res = *(byte *)&D1 >> 1;
        *(byte *)&D1 = res;
    }                                       // shr byte ptr D1, 1
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A6 = eax;                               // mov A6, eax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    A1 = eax;                               // mov A1, eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, 0
    if (flags.zero)
        goto l_no_opponent_controlled_player; // jz @@no_opponent_controlled_player

    GetPlayerPointerFromShirtNumber();      // call GetPlayerPointerFromShirtNumber
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 72, 1);     // mov al, [esi+PlayerGameHeader.tackling]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 73, 1);     // mov al, [esi+PlayerGameHeader.ballControl]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, al
    {
        byte res = *(byte *)&D0 >> 1;
        *(byte *)&D0 = res;
    }                                       // shr byte ptr D0, 1
    al = D0;                                // mov al, byte ptr D0
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D1 = res;
    }                                       // sub byte ptr D1, al
    if (!flags.sign)
        goto cseg_7A26D;                    // jns short cseg_7A26D

    flags.carry = *(int8_t *)&D1 != 0;
    flags.overflow = *(int8_t *)&D1 == INT8_MIN;
    *(int8_t *)&D1 = -*(int8_t *)&D1;
    flags.sign = (*(int8_t *)&D1 & 0x80) != 0;
    flags.zero = *(int8_t *)&D1 == 0;       // neg byte ptr D1
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A6 = eax;                               // mov A6, eax

cseg_7A26D:;
    al = D1;                                // mov al, byte ptr D1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    A0 = 523932;                            // mov A0, offset kPlAvgTacklingBallControlDiffChance
    SWOS::Rand();                           // call Rand
    {
        word res = *(word *)&D0 & 31;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1Fh
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_init_ball_winner_team;       // jb short @@init_ball_winner_team

    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A6 = eax;                               // mov A6, eax

l_init_ball_winner_team:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 138, 2, 12);          // mov [esi+TeamGeneralInfo.wonTheBallTimer], 12
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 44, 2, 0);            // mov [esi+Sprite.speed], 0
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    pop(A6);                                // pop A6
    pop(A1);                                // pop A1
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    return;                                 // jmp @@out

l_no_opponent_controlled_player:;
    pop(A6);                                // pop A6
    pop(A1);                                // pop A1
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

l_set_team_direction:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 56, 2, ax);           // mov [esi+TeamGeneralInfo.controlledPlDirection], ax
    A2 = 328988;                            // mov A2, offset ballSprite
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 54, 4);          // mov eax, [esi+Sprite.deltaZ]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_7A362;                    // jle short cseg_7A362

    writeMemory(esi + 54, 4, -1);           // mov [esi+Sprite.deltaZ], -1

cseg_7A362:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (!flags.zero)
        goto l_set_player_destination;      // jnz short @@set_player_destination

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 4
    if (flags.sign == flags.overflow)
        goto l_set_player_destination;      // jge short @@set_player_destination

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = -4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, -4
    if (flags.zero || flags.sign != flags.overflow)
        goto l_set_player_destination;      // jle short @@set_player_destination

    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_nudge_ball_right;            // jns short @@nudge_ball_right

    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 32, 2, src);
    }                                       // sub word ptr [esi+(Sprite.x+2)], 1
    goto l_set_player_destination;          // jmp short @@set_player_destination

l_nudge_ball_right:;
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 32, 2, src);
    }                                       // add word ptr [esi+(Sprite.x+2)], 1

l_set_player_destination:;
    A0 = 523306;                            // mov A0, offset kDefaultDestinations
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx + 2, 2); // mov ax, [esi+ebx+2]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    GetPlayerPointerFromShirtNumber();      // call GetPlayerPointerFromShirtNumber
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    {
        byte src = g_memByte[323906];
        byte res = src & 2;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr currentTick, 2
    if (flags.zero)
        goto l_update_ball_speed;           // jz short @@update_ball_speed

    A0 = 523916;                            // mov A0, offset kBallSpeedDeltaWhenControlled
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 73, 1);     // mov al, [esi+PlayerGameHeader.ballControl]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 << 1;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_update_ball_speed:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 82, 2);     // mov ax, [esi+Sprite.fullDirection]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 128;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 128
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 << 5;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 5
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 64;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 64
    if (flags.sign == flags.overflow)
        goto cseg_7A517;                    // jge short cseg_7A517

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 192;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 192
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_7A523;                    // jg short cseg_7A523

cseg_7A517:;
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 256;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // add [esi+Sprite.speed], 256

cseg_7A523:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 56, 2);     // mov ax, [esi+TeamGeneralInfo.controlledPlDirection]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_reset_ball_spin;             // jz short @@reset_ball_spin

    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 108, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 108, 2, src);
    }                                       // add [esi+TeamGeneralInfo.unkBallTimer], 1
    A0 = 523868;                            // mov A0, offset dseg_17E276
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 73, 1);     // mov al, [esi+PlayerGameHeader.ballControl]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 108, 2);    // mov ax, [esi+TeamGeneralInfo.unkBallTimer]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto l_reset_ball_spin;             // ja short @@reset_ball_spin

    writeMemory(esi + 138, 2, 8);           // mov [esi+TeamGeneralInfo.wonTheBallTimer], 8

l_reset_ball_spin:;
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player sprite
//      A6 -> team
//
void DoPass()
{
    *(word *)&g_memByte[523670] = 0;        // mov goodPassSampleCommand, 0
    *(word *)&g_memByte[456270] = 0;        // mov stateGoal, 0
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 56, 2, ax);           // mov [esi+TeamGeneralInfo.controlledPlDirection], ax
    push(D0);                               // push D0
    GetPlayerPointerFromShirtNumber();      // call GetPlayerPointerFromShirtNumber
    pop(D0);                                // pop D0
    push(D7);                               // push D7
    GetClosestNonControlledPlayerInDirection(); // call GetClosestNonControlledPlayerInDirection
    pop(D7);                                // pop D7
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, -1
    if (flags.zero)
        goto l_no_closest_player;           // jz @@no_closest_player

    eax = A0;                               // mov eax, A0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 36, 4, eax);          // mov [esi+TeamGeneralInfo.passToPlayerPtr], eax
    writeMemory(esi + 88, 2, 1);            // mov [esi+TeamGeneralInfo.passingBall], 1
    writeMemory(esi + 90, 2, 1);            // mov [esi+TeamGeneralInfo.passingToPlayer], 1
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (!flags.zero)
        goto l_calculate_pass_to_player_delta_x_y; // jnz @@calculate_pass_to_player_delta_x_y

    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+TeamGeneralInfo.playerNumber]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_calculate_pass_to_player_delta_x_y; // jnz @@calculate_pass_to_player_delta_x_y

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 69, 1);     // mov al, [esi+PlayerGameHeader.passing]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    A1 = 523884;                            // mov A1, offset kAIFailedPassChance
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        word res = *(word *)&D7 & 30;
        *(word *)&D7 = res;
    }                                       // and word ptr D7, 1Eh
    {
        word res = *(word *)&D7 >> 1;
        *(word *)&D7 = res;
    }                                       // shr word ptr D7, 1
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.carry)
        goto l_calculate_pass_to_player_delta_x_y; // jnb @@calculate_pass_to_player_delta_x_y

    *(word *)&g_memByte[523670] = -2;       // mov goodPassSampleCommand, -2
    A1 = 328988;                            // mov A1, offset ballSprite
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        byte src = g_memByte[323904];
        byte res = src & 32;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr currentGameTick, 20h
    if (!flags.zero)
        goto l_multiply_dx;                 // jnz short @@multiply_dx

    {
        int16_t res = *(int16_t *)&D0 >> 1;
        *(int16_t *)&D0 = res;
    }                                       // sar word ptr D0, 1

l_multiply_dx:;
    {
        word res = *(word *)&D0 << 5;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 5
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        byte src = g_memByte[323904];
        byte res = src & 32;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr currentGameTick, 20h
    if (flags.zero)
        goto l_multiply_dy;                 // jz short @@multiply_dy

    {
        int16_t res = *(int16_t *)&D0 >> 1;
        *(int16_t *)&D0 = res;
    }                                       // sar word ptr D0, 1

l_multiply_dy:;
    {
        word res = *(word *)&D0 << 5;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 5
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    goto l_determine_ball_speed;            // jmp @@determine_ball_speed

l_calculate_pass_to_player_delta_x_y:;
    A1 = 328988;                            // mov A1, offset ballSprite
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_increase_distances_loop;     // jnz short @@increase_distances_loop

    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_increase_distances_loop;     // jnz short @@increase_distances_loop

    *(word *)&D1 = 1;                       // mov word ptr D1, 1

l_increase_distances_loop:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    if (flags.sign)
        goto l_set_dest_x_y;                // js short @@set_dest_x_y

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 672;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 672
    if (flags.sign == flags.overflow)
        goto l_set_dest_x_y;                // jge short @@set_dest_x_y

    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    if (flags.sign)
        goto l_set_dest_x_y;                // js short @@set_dest_x_y

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 880;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 880
    if (flags.sign == flags.overflow)
        goto l_set_dest_x_y;                // jge short @@set_dest_x_y

    {
        word res = *(word *)&D1 << 1;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 1
    {
        word res = *(word *)&D2 << 1;
        flags.carry = ((word)*(word *)&D2 >> 15) & 1;
        flags.overflow = (((*(word *)&D2 >> 15) & 1) ^ ((*(word *)&D2 >> 14) & 1)) != 0;
        *(word *)&D2 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D2, 1
    goto l_increase_distances_loop;         // jmp short @@increase_distances_loop

l_set_dest_x_y:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax

l_determine_ball_speed:;
    ax = *(word *)&g_memByte[523834];       // mov ax, kPassingSpeedCloserThan2500
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    D0 = eax;                               // mov D0, eax
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 2500;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 2500
    if (flags.carry)
        goto l_set_ball_speed;              // jb @@set_ball_speed

    ax = *(word *)&g_memByte[523836];       // mov ax, kPassingSpeed_2500_10000
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 10000;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 10000
    if (flags.carry)
        goto l_set_ball_speed;              // jb @@set_ball_speed

    ax = *(word *)&g_memByte[523838];       // mov ax, kPassingSpeed_10000_22500
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 22500;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 22500
    if (flags.carry)
        goto l_set_ball_speed;              // jb @@set_ball_speed

    ax = *(word *)&g_memByte[523840];       // mov ax, kPassingSpeed_22500_40000
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 40000;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 40000
    if (flags.carry)
        goto l_set_ball_speed;              // jb @@set_ball_speed

    ax = *(word *)&g_memByte[523842];       // mov ax, kPassingSpeed_40000_62500
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 62500;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 62500
    if (flags.carry)
        goto l_set_ball_speed;              // jb short @@set_ball_speed

    ax = *(word *)&g_memByte[523844];       // mov ax, kPassingSpeed_62500_90000
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 90000;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 90000
    if (flags.carry)
        goto l_set_ball_speed;              // jb short @@set_ball_speed

    ax = *(word *)&g_memByte[523846];       // mov ax, kPassingSpeed_90000_122500
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 122500;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 122500
    if (flags.carry)
        goto l_set_ball_speed;              // jb short @@set_ball_speed

    ax = *(word *)&g_memByte[523848];       // mov ax, kPassingSpeedFurtherThan122500
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_set_ball_speed:;
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 69, 1);     // mov al, [esi+PlayerGameHeader.passing]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    A0 = 523818;                            // mov A0, offset kBallSpeedPassingIncrease
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    *(word *)&g_memByte[523670] = -1;       // mov goodPassSampleCommand, -1
    goto l_reset_spin_timers;               // jmp @@reset_spin_timers

l_no_closest_player:;
    GetBallDestCoordinatesTable();          // call GetBallDestCoordinatesTable
    A1 = 328988;                            // mov A1, offset ballSprite
    {
        word res = *(word *)&D7 << 2;
        *(word *)&D7 = res;
    }                                       // shl word ptr D7, 2
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx + 2, 2); // mov ax, [esi+ebx+2]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    ax = *(word *)&g_memByte[523850];       // mov ax, kFreePassReleasingBallSpeed
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax

l_reset_spin_timers:;
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+TeamGeneralInfo.playerNumber]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_player_passing;              // jz short @@player_passing

    writeMemory(esi + 118, 2, 0);           // mov [esi+TeamGeneralInfo.spinTimer], 0

l_player_passing:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 128, 2, 1);           // mov [esi+TeamGeneralInfo.passInProgress], 1
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (flags.zero)
        goto l_play_kick_and_pass_samples;  // jz short @@play_kick_and_pass_samples

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_THROW_IN_FORWARD_RIGHT
    if (flags.carry)
        goto l_play_kick_and_pass_samples;  // jb short @@play_kick_and_pass_samples

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_THROW_IN_BACK_LEFT
    if (flags.carry || flags.zero)
        return;                             // jbe short @@out

l_play_kick_and_pass_samples:;
    SWOS::PlayKickSample();                 // call PlayKickSample
    PlayStopGoodPassSampleIfNeeded();       // call PlayStopGoodPassSampleIfNeeded
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player sprite
//      A6 -> team
//
void PlayerKickingBall()
{
    *(word *)&g_memByte[456270] = 0;        // mov stateGoal, 0
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 56, 2, ax);           // mov [esi+TeamGeneralInfo.controlledPlDirection], ax
    GetBallDestCoordinatesTable();          // call GetBallDestCoordinatesTable
    A2 = 328988;                            // mov A2, offset ballSprite
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx + 2, 2); // mov ax, [esi+ebx+2]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    ax = *(word *)&g_memByte[325772];       // mov ax, kBallKickingSpeed
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    eax = *(dword *)&g_memByte[325768];     // mov eax, kBallKickingDeltaZ
    writeMemory(esi + 54, 4, eax);          // mov [esi+Sprite.deltaZ], eax
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (flags.zero)
        goto l_game_in_progress;            // jz short @@game_in_progress

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_THROW_IN_FORWARD_RIGHT
    if (flags.carry)
        goto l_game_in_progress;            // jb short @@game_in_progress

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_THROW_IN_BACK_LEFT
    if (flags.carry || flags.zero)
        return;                             // jbe @@out

l_game_in_progress:;
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (flags.zero)
        goto l_left_team;                   // jz short @@left_team

    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 342;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.y+2)], 342
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_not_a_shot_on_goal;          // jg @@not_a_shot_on_goal

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 56, 2);     // mov ax, [esi+TeamGeneralInfo.controlledPlDirection]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_possible_shot_on_goal;       // jz short @@possible_shot_on_goal

    {
        word src = (word)readMemory(esi + 56, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.controlledPlDirection], 1
    if (flags.zero)
        goto l_possible_shot_on_goal;       // jz short @@possible_shot_on_goal

    {
        word src = (word)readMemory(esi + 56, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.controlledPlDirection], 7
    if (flags.zero)
        goto l_possible_shot_on_goal;       // jz short @@possible_shot_on_goal

    goto l_not_a_shot_on_goal;              // jmp @@not_a_shot_on_goal

l_left_team:;
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 556;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.y+2)], 556
    if (flags.sign != flags.overflow)
        goto l_not_a_shot_on_goal;          // jl @@not_a_shot_on_goal

    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 56, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.controlledPlDirection], 4
    if (flags.zero)
        goto l_possible_shot_on_goal;       // jz short @@possible_shot_on_goal

    {
        word src = (word)readMemory(esi + 56, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.controlledPlDirection], 3
    if (flags.zero)
        goto l_possible_shot_on_goal;       // jz short @@possible_shot_on_goal

    {
        word src = (word)readMemory(esi + 56, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.controlledPlDirection], 5
    if (!flags.zero)
        goto l_not_a_shot_on_goal;          // jnz @@not_a_shot_on_goal

l_possible_shot_on_goal:;
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 241;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.x+2)], 241
    if (flags.sign != flags.overflow)
        goto l_its_a_long_shot;             // jl @@its_a_long_shot

    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 431;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.x+2)], 431
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_its_a_long_shot;             // jg short @@its_a_long_shot

    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 204;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.y+2)], 204
    if (flags.sign != flags.overflow)
        goto l_its_a_finishing_shot;        // jl short @@its_a_finishing_shot

    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 694;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.y+2)], 694
    if (flags.sign != flags.overflow)
        goto l_its_a_long_shot;             // jl short @@its_a_long_shot

l_its_a_finishing_shot:;
    GetPlayerPointerFromShirtNumber();      // call GetPlayerPointerFromShirtNumber
    A0 = 523900;                            // mov A0, offset kBallSpeedFinishing
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 75, 1);     // mov al, [esi+PlayerGameHeader.finishing]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // add [esi+Sprite.speed], ax
    goto l_not_a_shot_on_goal;              // jmp short @@not_a_shot_on_goal

l_its_a_long_shot:;
    GetPlayerPointerFromShirtNumber();      // call GetPlayerPointerFromShirtNumber
    A0 = 523852;                            // mov A0, offset kBallSpeedKicking
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 70, 1);     // mov al, [esi+PlayerGameHeader.shooting]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // add [esi+Sprite.speed], ax

l_not_a_shot_on_goal:;
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerOrdinal], 1
    if (!flags.zero)
        goto cseg_7AE0E;                    // jnz short cseg_7AE0E

    {
        word src = (word)readMemory(esi + 42, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.direction], 2
    if (flags.zero)
        goto l_play_kick_sample_and_leave;  // jz short @@play_kick_sample_and_leave

    {
        word src = (word)readMemory(esi + 42, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.direction], 6
    if (flags.zero)
        goto l_play_kick_sample_and_leave;  // jz short @@play_kick_sample_and_leave

cseg_7AE0E:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 76, 2);     // mov ax, [esi+TeamGeneralInfo.goalkeeperSavedCommentTimer]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_play_kick_sample_and_leave;  // js short @@play_kick_sample_and_leave

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 118, 2, 0);           // mov [esi+TeamGeneralInfo.spinTimer], 0

l_play_kick_sample_and_leave:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 128, 2, 0);           // mov [esi+TeamGeneralInfo.passInProgress], 0
    SWOS::PlayKickSample();                 // call PlayKickSample
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 -  direction
//      A6 -> team (general)
// out:
//      A0 -> player sprite
//      D2 -  ball distance
//
// Return pointer to player closest to the ball facing approximately given
// direction. Also return his distance from the ball.
//
void GetClosestNonControlledPlayerInDirection()
{
    eax = A1;                               // mov eax, A1
    A5 = eax;                               // mov A5, eax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+TeamGeneralInfo.spritesTable]
    A2 = eax;                               // mov A2, eax
    A0 = 328988;                            // mov A0, offset ballSprite
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    {
        word res = *(word *)&D0 << 5;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 5
    A0 = -1;                                // mov A0, -1
    D2 = -1;                                // mov D2, -1
    *(word *)&D7 = 10;                      // mov word ptr D7, 10

l_players_loop:;
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 4
    A1 = eax;                               // mov A1, eax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, eax
    if (flags.zero)
        goto l_next;                        // jz short @@next

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 108, 2);    // mov ax, [esi+Sprite.sentAway]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_next;                        // jnz short @@next

    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_NORMAL
    if (!flags.zero)
        goto l_next;                        // jnz short @@next

    ax = (word)readMemory(esi + 82, 2);     // mov ax, [esi+Sprite.fullDirection]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    al = D0;                                // mov al, byte ptr D0
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D1 = res;
    }                                       // sub byte ptr D1, al
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 240;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, 240
    if (flags.sign != flags.overflow)
        goto l_next;                        // jl short @@next

    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 16;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, 16
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_next;                        // jg short @@next

    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    D1 = eax;                               // mov D1, eax
    eax = D2;                               // mov eax, D2
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, eax
    if (!flags.carry)
        goto l_next;                        // jnb short @@next

    eax = D1;                               // mov eax, D1
    D2 = eax;                               // mov D2, eax
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax

l_next:;
    (*(int16_t *)&D7)--;
    flags.overflow = (int16_t)(*(int16_t *)&D7) == INT16_MIN;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_players_loop;                // jns @@players_loop
}

// =============== S U B R O U T I N E =======================================

// out:
//      A0 -> ball factor table, depending on game state
//
// Even indices are delta x, odd are delta y. They are added to ball
// delta x and y. Tables are different for each type of game halt.
// Called when player kicks the ball or does a pass.
//
void GetBallDestCoordinatesTable()
{
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_THROW_IN_FORWARD_RIGHT
    if (flags.carry)
        goto l_not_throw_in;                // jb short @@not_throw_in

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_THROW_IN_BACK_LEFT
    if (!flags.carry && !flags.zero)
        goto l_not_throw_in;                // ja short @@not_throw_in

    {
        word src = *(word *)&g_memByte[523136];
        int16_t dstSigned = src;
        int16_t srcSigned = 336;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp foulXCoordinate, 336
    if (!flags.carry && !flags.zero)
        goto l_right_throw_in;              // ja short @@right_throw_in

    A0 = 523338;                            // mov A0, offset kLeftThrowInBallDestDelta
    return;                                 // retn

l_right_throw_in:;
    A0 = 523370;                            // mov A0, offset kRightThrowInBallDestDelta
    return;                                 // retn

l_not_throw_in:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 14;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PENALTY
    if (flags.zero)
        goto l_penalty;                     // jz short @@penalty

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PENALTIES
    if (!flags.zero)
        goto l_not_penalty;                 // jnz short @@not_penalty

l_penalty:;
    A0 = 523402;                            // mov A0, offset kPenaltyBallDestDelta
    return;                                 // retn

l_not_penalty:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_CORNER_LEFT
    if (flags.zero)
        goto l_corner;                      // jz short @@corner

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_CORNER_RIGHT
    if (!flags.zero)
        goto l_not_corner;                  // jnz short @@not_corner

l_corner:;
    {
        word src = *(word *)&g_memByte[523138];
        int16_t dstSigned = src;
        int16_t srcSigned = 449;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp foulYCoordinate, 449
    if (!flags.carry && !flags.zero)
        goto l_lower_corner;                // ja short @@lower_corner

    {
        word src = *(word *)&g_memByte[523136];
        int16_t dstSigned = src;
        int16_t srcSigned = 336;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp foulXCoordinate, 336
    if (!flags.carry && !flags.zero)
        goto l_upper_right_corner;          // ja short @@upper_right_corner

    A0 = 523434;                            // mov A0, offset kUpperLeftCornerBallDestDelta
    return;                                 // retn

l_upper_right_corner:;
    A0 = 523466;                            // mov A0, offset kUpperRightCornerBallDestDelta
    return;                                 // retn

l_lower_corner:;
    {
        word src = *(word *)&g_memByte[523136];
        int16_t dstSigned = src;
        int16_t srcSigned = 336;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp foulXCoordinate, 336
    if (!flags.carry && !flags.zero)
        goto l_lower_right_corner;          // ja short @@lower_right_corner

    A0 = 523498;                            // mov A0, offset kLowerLeftCornerBallDestDelta
    return;                                 // retn

l_lower_right_corner:;
    A0 = 523530;                            // mov A0, offset kLowerRightCornerBallDestDelta
    return;                                 // retn

l_not_corner:;
    A0 = 523306;                            // mov A0, offset kDefaultDestinations
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 -  direction
//      A1 -> player sprite
//
// Player starts jumping in attempt to hit the ball with his head. Set his state
// and render him 'inoperable' for the next 55 cycles. Sets his animation table,
// dest x and y, and his speed. Only triggers for flying and lob header attempts,
// not for static ones.
//
void PlayerAttemptingJumpHeader()
{
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 98, 2, 0);            // mov [esi+Sprite.heading], 0
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 42, 2, ax);           // mov [esi+Sprite.direction], ax
    A0 = 452584;                            // mov A0, offset jumpHeaderAttemptAnimTable
    SetPlayerAnimationTable();              // call SetPlayerAnimationTable
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 13, 1, g_memByte[540872]); // mov [esi+Sprite.playerDownTimer], playerDownHeadingInterval
    writeMemory(esi + 12, 1, 9);            // mov [esi+Sprite.playerState], PL_JUMP_HEADING
    A5 = 523306;                            // mov A5, offset kDefaultDestinations
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    ax = *(word *)&g_memByte[325744];       // mov ax, kJumpHeaderSpeed
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
}

// =============== S U B R O U T I N E =======================================

// in:
//     A1 -> player
//     A6 -> team
//
// Hitting flying or lob header. Only triggers on ball contact.
//
void PlayerHittingJumpHeader()
{
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 128, 2, 0);           // mov [esi+TeamGeneralInfo.passInProgress], 0
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+TeamGeneralInfo.currentAllowedDirection]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_set_player_z_and_ball_speed; // jns short @@set_player_z_and_ball_speed

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_set_player_z_and_ball_speed:;
    A2 = 328988;                            // mov A2, offset ballSprite
    eax = *(dword *)&g_memByte[325636];     // mov eax, kBallJumpHeaderDeltaZ
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 54, 4, eax);          // mov [esi+Sprite.deltaZ], eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    ax = D0;                                // mov ax, word ptr D0
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // add [esi+Sprite.speed], ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+TeamGeneralInfo.currentAllowedDirection]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_do_static_header;            // js short @@do_static_header

    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 7
    if (flags.zero)
        goto l_use_allowed_direction;       // jz @@use_allowed_direction

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (flags.zero)
        goto l_lob_header;                  // jz short @@lob_header

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto l_aim_left;                    // jz short @@aim_left

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 7
    if (flags.zero)
        goto l_aim_right;                   // jz short @@aim_right

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (flags.zero)
        goto l_left_held;                   // jz short @@left_held

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 6
    if (flags.zero)
        goto l_right_held;                  // jz short @@right_held

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 3
    if (flags.zero)
        goto l_down_left_held;              // jz short @@down_left_held

    DoLobHeader();                          // call DoLobHeader
    goto l_aim_right;                       // jmp short @@aim_right

l_down_left_held:;
    DoLobHeader();                          // call DoLobHeader
    goto l_aim_left;                        // jmp short @@aim_left

l_right_held:;
    DoFlyingHeader();                       // call DoFlyingHeader
    goto l_aim_right;                       // jmp short @@aim_right

l_left_held:;
    DoFlyingHeader();                       // call DoFlyingHeader
    goto l_aim_left;                        // jmp short @@aim_left

l_do_static_header:;
    DoFlyingHeader();                       // call DoFlyingHeader
    goto l_use_allowed_direction;           // jmp short @@use_allowed_direction

l_lob_header:;
    DoLobHeader();                          // call DoLobHeader
    goto l_use_allowed_direction;           // jmp short @@use_allowed_direction

l_aim_right:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    goto l_update_player_direction;         // jmp short @@update_player_direction

l_aim_left:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    goto l_update_player_direction;         // jmp short @@update_player_direction

l_use_allowed_direction:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+TeamGeneralInfo.allowedDirections]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

l_update_player_direction:;
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 56, 2, ax);           // mov [esi+TeamGeneralInfo.controlledPlDirection], ax
    A0 = 523306;                            // mov A0, offset kDefaultDestinations
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx + 2, 2); // mov ax, [esi+ebx+2]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    GetPlayerPointerFromShirtNumber();      // call GetPlayerPointerFromShirtNumber
    A0 = 523778;                            // mov A0, offset kPlayerHeaderSpeedIncrease
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 71, 1);     // mov al, [esi+PlayerGameHeader.heading]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // add [esi+Sprite.speed], ax
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 44, 2);
        word res = src >> 1;
        flags.carry = ((word)src >> 15) & 1;
        src = res;
        writeMemory(esi + 44, 2, src);
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr [esi+Sprite.speed], 1
    writeMemory(esi + 98, 2, 1);            // mov [esi+Sprite.heading], 1
    SWOS::PlayKickSample();                 // call PlayKickSample
    SWOS::PlayHeaderComment();              // call PlayHeaderComment
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
}

// =============== S U B R O U T I N E =======================================
//
void DoFlyingHeader()
{
    eax = *(dword *)&g_memByte[523810];     // mov eax, kHeaderLowJumpHeight
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 54, 4, eax);          // mov [esi+Sprite.deltaZ], eax
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // sub [esi+Sprite.speed], ax
    SetPlayerJumpHeaderHitAnimationTable(); // call SetPlayerJumpHeaderHitAnimationTable
}

// =============== S U B R O U T I N E =======================================

// in:
//     A1 -> player sprite
//     A2 -> ball sprite
//
void DoLobHeader()
{
    eax = *(dword *)&g_memByte[523814];     // mov eax, kHeaderHighJumpHeight
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 54, 4, eax);          // mov [esi+Sprite.deltaZ], eax
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 4;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 4
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // sub [esi+Sprite.speed], ax
    SetPlayerJumpHeaderHitAnimationTable(); // call SetPlayerJumpHeaderHitAnimationTable
}

// =============== S U B R O U T I N E =======================================

// in:
//     A1 -> player sprite
//
// Table for flying and lob headers.
//
void SetPlayerJumpHeaderHitAnimationTable()
{
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 28, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.frameSwitchCounter], 2
    if (!flags.carry && !flags.zero)
        return;                             // ja short @@out

    A0 = 452714;                            // mov A0, offset jumpHeaderHitAnimTable
    SetAnimationTableAndPictureIndex();     // call SetAnimationTableAndPictureIndex
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> animation table
//      A1 -> player (sprite)
//
void SetAnimationTableAndPictureIndex()
{
    eax = A0;                               // mov eax, A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 6, 4, eax);           // mov [esi+Sprite.animationTable], eax
    push(D0);                               // push D0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+Sprite.teamNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerOrdinal], 1
    if (!flags.zero)
        goto l_calc_table_index;            // jnz short @@calc_table_index

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 2

l_calc_table_index:;
    {
        word res = *(word *)&D0 << 3;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 3
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 24, 2, ax);           // mov [esi+Sprite.frameDelay], ax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx + 2, 4);     // mov eax, [esi+ebx+2]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 18, 4, eax);          // mov [esi+Sprite.frameIndicesTable], eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto l_fatal_error;                 // jz @@fatal_error

    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    writeMemory(esi + 10, 2, ax);           // mov [esi+Sprite.startingDirection], ax
    eax = readMemory(esi + 18, 4);          // mov eax, [esi+Sprite.frameIndicesTable]
    A0 = eax;                               // mov A0, eax
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+Sprite.frameIndex]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_out;                         // js short @@out

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+Sprite.frameOffset]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 70, 2, ax);           // mov [esi+Sprite.imageIndex], ax

l_out:;
    pop(D0);                                // pop D0
    return;                                 // retn

l_fatal_error:;
    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> sprite (player)
//
void UpdateControllingPlayer()
{
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 523940;                            // mov A0, offset kBallPlOffsets
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx + 2, 2); // mov ax, [esi+ebx+2]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    A0 = 328988;                            // mov A0, offset ballSprite
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 44, 2, 0);            // mov [esi+Sprite.speed], 0
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 32, 2, ax);           // mov word ptr [esi+(Sprite.x+2)], ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 36, 2, ax);           // mov word ptr [esi+(Sprite.y+2)], ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    writeMemory(esi + 40, 2, 0);            // mov word ptr [esi+(Sprite.z+2)], 0
    eax = readMemory(esi + 54, 4);          // mov eax, [esi+Sprite.deltaZ]
    D0 = eax;                               // mov D0, eax
    {
        int32_t res = *(int32_t *)&D0 >> 1;
        flags.carry = ((dword)*(int32_t *)&D0 >> 31) & 1;
        *(int32_t *)&D0 = res;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // sar D0, 1
    eax = D0;                               // mov eax, D0
    writeMemory(esi + 54, 4, eax);          // mov [esi+Sprite.deltaZ], eax
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player sprite that's taking the throw-in
//
// Sets the coordinates of a player that takes the throw in.
//
void SetThrowInPlayerDestinationCoordinates()
{
    A0 = 328988;                            // mov A0, offset ballSprite
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 336;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 336
    if (flags.carry)
        goto l_left_half;                   // jb short @@left_half

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 3
    goto l_set_player_x;                    // jmp short @@set_player_x

l_left_half:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 3

l_set_player_x:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 32, 2, ax);           // mov word ptr [esi+(Sprite.x+2)], ax
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 36, 2, ax);           // mov word ptr [esi+(Sprite.y+2)], ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
}

// =============== S U B R O U T I N E =======================================

// in:
//     A1 -> player
//     A6 -> team (general info)
//
// Weak tackle: player speed goes down to 50%, ball speed = 75% of original player speed.
//
void PlayerTackledTheBallWeak()
{
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 128, 2, 0);           // mov [esi+TeamGeneralInfo.passInProgress], 0
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+TeamGeneralInfo.currentAllowedDirection]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_controls_something;          // jns short @@controls_something

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_controls_something:;
    A2 = 328988;                            // mov A2, offset ballSprite
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        goto l_tackling_in_same_or_oposite_direction; // jz short @@tackling_in_same_or_oposite_direction

    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (flags.zero)
        goto l_tackling_in_same_or_oposite_direction; // jz short @@tackling_in_same_or_oposite_direction

    if (flags.carry)
        goto l_strive_left;                 // jb short @@strive_left

    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    goto l_set_new_ball_direction_and_speed; // jmp short @@set_new_ball_direction_and_speed

l_strive_left:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    goto l_set_new_ball_direction_and_speed; // jmp short @@set_new_ball_direction_and_speed

l_tackling_in_same_or_oposite_direction:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

l_set_new_ball_direction_and_speed:;
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 56, 2, ax);           // mov [esi+TeamGeneralInfo.controlledPlDirection], ax
    A0 = 523306;                            // mov A0, offset kDefaultDestinations
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx + 2, 2); // mov ax, [esi+ebx+2]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // sub [esi+Sprite.speed], ax
    {
        word src = (word)readMemory(esi + 44, 2);
        src |= 1;
        writeMemory(esi + 44, 2, src);
    }                                       // or [esi+Sprite.speed], 1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 96, 2, 1);            // mov [esi+Sprite.tackleState], TS_TACKLING_THE_BALL
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        goto l_out;                         // jz @@out

    esi = A0;                               // mov esi, A0
    {
        dword src = readMemory(esi + 74, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 9;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.ballDistance], 9
    if (flags.carry)
        goto l_out;                         // jb @@out

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    eax = *(int16_t *)&D0;                  // movsx eax, word ptr D0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int64_t res = (int64_t)eax * (int32_t)ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // imul ebx
    D0 = eax;                               // mov D0, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    bx = D1;                                // mov bx, word ptr D1
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    eax = D1;                               // mov eax, D1
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D0 = res;
    }                                       // add D0, eax
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 32;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 32
    if (flags.carry || flags.zero)
        goto l_out;                         // jbe short @@out

    esi = A1;                               // mov esi, A1
    writeMemory(esi + 96, 2, 2);            // mov [esi+Sprite.tackleState], TS_GOOD_TACKLE

l_out:;
    SWOS::PlayKickSample();                 // call PlayKickSample
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
}

// =============== S U B R O U T I N E =======================================
//
void UpdateBall()
{
    A0 = 328988;                            // mov A0, offset ballSprite
    ax = *(word *)&g_memByte[449800];       // mov ax, hideBall
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_show_ball;                   // jz short @@show_ball

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 70, 2, -1);           // mov [esi+Sprite.imageIndex], -1
    *(word *)&g_memByte[329170] = -1;       // mov ballShadowSprite.imageIndex, -1
    goto l_calculate_deltas;                // jmp @@calculate_deltas

l_show_ball:;
    *(word *)&g_memByte[329170] = 1183;     // mov ballShadowSprite.imageIndex, SPR_BALL_SHADOW
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 46, 4);          // mov eax, [esi+Sprite.deltaX]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto l_moving;                      // jnz short @@moving

    eax = readMemory(esi + 50, 4);          // mov eax, [esi+Sprite.deltaY]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto l_moving;                      // jnz short @@moving

    {
        dword src = readMemory(esi + 18, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 455982;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.frameIndicesTable], offset ballStaticFrameIndices
    if (flags.zero)
        goto l_set_ball_frame_index;        // jz short @@set_ball_frame_index

    writeMemory(esi + 18, 4, 455982);       // mov [esi+Sprite.frameIndicesTable], offset ballStaticFrameIndices
    writeMemory(esi + 22, 2, 0);            // mov [esi+Sprite.frameIndex], 0
    goto l_set_ball_frame_index;            // jmp short @@set_ball_frame_index

l_moving:;
    esi = A0;                               // mov esi, A0
    {
        dword src = readMemory(esi + 18, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 455972;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.frameIndicesTable], offset ballMovingFrameIndices
    if (flags.zero)
        goto l_set_ball_frame_index;        // jz short @@set_ball_frame_index

    writeMemory(esi + 18, 4, 455972);       // mov [esi+Sprite.frameIndicesTable], offset ballMovingFrameIndices
    writeMemory(esi + 22, 2, 0);            // mov [esi+Sprite.frameIndex], 0

l_set_ball_frame_index:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_check_if_picture_set;        // jz short @@check_if_picture_set

    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 26, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 26, 2, src);
    }                                       // sub [esi+Sprite.cycleFramesTimer], ax
    if (!flags.sign)
        goto l_check_if_picture_set;        // jns short @@check_if_picture_set

    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+Sprite.frameIndex], 1
    ax = (word)readMemory(esi + 24, 2);     // mov ax, [esi+Sprite.frameDelay]
    writeMemory(esi + 26, 2, ax);           // mov [esi+Sprite.cycleFramesTimer], ax
    goto l_extract_frame;                   // jmp short @@extract_frame

l_check_if_picture_set:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 70, 2);     // mov ax, [esi+Sprite.imageIndex]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_calculate_deltas;            // jns short @@calculate_deltas

l_extract_frame:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 18, 4);          // mov eax, [esi+Sprite.frameIndicesTable]
    A1 = eax;                               // mov A1, eax
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+Sprite.frameIndex]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_set_picture_index;           // jns short @@set_picture_index

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, 0);            // mov [esi+Sprite.frameIndex], 0
    goto l_extract_frame;                   // jmp short @@extract_frame

l_set_picture_index:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 70, 2, ax);           // mov [esi+Sprite.imageIndex], ax

l_calculate_deltas:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 30, 4);          // mov eax, [esi+Sprite.x]
    D5 = eax;                               // mov D5, eax
    eax = readMemory(esi + 34, 4);          // mov eax, [esi+Sprite.y]
    D6 = eax;                               // mov D6, eax
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+Sprite.z]
    D7 = eax;                               // mov D7, eax
    ax = (word)readMemory(esi + 58, 2);     // mov ax, [esi+Sprite.destX]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 60, 2);     // mov ax, [esi+Sprite.destY]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    SWOS::CalculateDeltaXAndY();            // call CalculateDeltaXAndY
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    eax = D1;                               // mov eax, D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 46, 4, eax);          // mov [esi+Sprite.deltaX], eax
    eax = D2;                               // mov eax, D2
    writeMemory(esi + 50, 4, eax);          // mov [esi+Sprite.deltaY], eax
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_set_direction;               // js short @@set_direction

    writeMemory(esi + 82, 2, ax);           // mov [esi+Sprite.fullDirection], ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 16
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5

l_set_direction:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 42, 2, ax);           // mov [esi+Sprite.direction], ax
    ax = *(word *)&g_memByte[325628];       // mov ax, kBallGroundConstant
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[522844];       // mov ax, topTeamData.playerHasBall
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_check_z_coordinate;          // jnz short @@check_z_coordinate

    ax = *(word *)&g_memByte[522992];       // mov ax, bottomTeamData.playerHasBall
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_check_z_coordinate;          // jnz short @@check_z_coordinate

    ax = *(word *)&g_memByte[325644];       // mov ax, pitchBallSpeedFactor
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax

l_check_z_coordinate:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 40, 2);     // mov ax, word ptr [esi+(Sprite.z+2)]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_on_the_ground;               // jz short @@on_the_ground

    ax = *(word *)&g_memByte[325630];       // mov ax, kBallAirConstant
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

l_on_the_ground:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // sub [esi+Sprite.speed], ax
    if (!flags.sign)
        goto l_apply_deltas;                // jns short @@apply_deltas

    writeMemory(esi + 44, 2, 0);            // mov [esi+Sprite.speed], 0

l_apply_deltas:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 46, 4);          // mov eax, [esi+Sprite.deltaX]
    D1 = eax;                               // mov D1, eax
    eax = readMemory(esi + 50, 4);          // mov eax, [esi+Sprite.deltaY]
    D2 = eax;                               // mov D2, eax
    eax = readMemory(esi + 54, 4);          // mov eax, [esi+Sprite.deltaZ]
    D3 = eax;                               // mov D3, eax
    eax = D1;                               // mov eax, D1
    {
        dword src = readMemory(esi + 30, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 30, 4, src);
    }                                       // add [esi+Sprite.x], eax
    eax = D2;                               // mov eax, D2
    {
        dword src = readMemory(esi + 34, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 34, 4, src);
    }                                       // add [esi+Sprite.y], eax
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (!flags.zero)
        goto l_keeper_doesnt_hold_the_ball; // jnz @@keeper_doesnt_hold_the_ball

    ax = *(word *)&g_memByte[486168];       // mov ax, g_substituteInProgress
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_keeper_is_controlled;        // jz short @@keeper_is_controlled

    eax = *(dword *)&g_memByte[486176];     // mov eax, teamThatSubstitutes
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[523120];     // mov eax, lastTeamPlayedBeforeBreak
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, eax
    if (!flags.zero)
        goto l_keeper_is_controlled;        // jnz short @@keeper_is_controlled

    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto l_keeper_is_controlled;        // jnz short @@keeper_is_controlled

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 40, 2, 0);            // mov word ptr [esi+(Sprite.z+2)], 0
    goto l_set_delta_z_to_0;                // jmp @@set_delta_z_to_0

l_keeper_is_controlled:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_check_keeper_z;              // jz @@check_keeper_z

    {
        word src = *(word *)&g_memByte[455958];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[455958] = src;
    }                                       // add writeOnlyVar04, 1
    eax = *(dword *)&g_memByte[523120];     // mov eax, lastTeamPlayedBeforeBreak
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    A1 = eax;                               // mov A1, eax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    UpdateBallWithControllingGoalkeeper();  // call UpdateBallWithControllingGoalkeeper
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

l_check_keeper_z:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 40, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.z+2)], 5
    if (flags.zero)
        goto l_set_delta_z_to_0;            // jz @@set_delta_z_to_0

    if (!flags.carry && !flags.zero)
        goto l_height_higher_than_5;        // ja short @@height_higher_than_5

    D3 = 131076;                            // mov D3, 20004h
    goto l_apply_delta_z;                   // jmp short @@apply_delta_z

l_height_higher_than_5:;
    D3 = -65538;                            // mov D3, -10002h
    goto l_apply_delta_z;                   // jmp short @@apply_delta_z

l_keeper_doesnt_hold_the_ball:;
    eax = D3;                               // mov eax, D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto l_assign_delta_z;              // jz @@assign_delta_z

    eax = *(dword *)&g_memByte[325648];     // mov eax, kGravityConstant
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D3 = res;
    }                                       // sub D3, eax
    D3 |= 1;                                // or D3, 1

l_apply_delta_z:;
    eax = D3;                               // mov eax, D3
    esi = A0;                               // mov esi, A0
    {
        dword src = readMemory(esi + 38, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 38, 4, src);
    }                                       // add [esi+Sprite.z], eax
    if (!flags.sign)
        goto l_assign_delta_z;              // jns @@assign_delta_z

    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    bx = *(word *)&g_memByte[325640];       // mov bx, ballSpeedBounceFactor
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        dword res = D0 >> 8;
        D0 = res;
    }                                       // shr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // sub [esi+Sprite.speed], ax
    writeMemory(esi + 40, 2, 0);            // mov word ptr [esi+(Sprite.z+2)], 0
    *(int32_t *)&D3 = -*(int32_t *)&D3;     // neg D3
    eax = D3;                               // mov eax, D3
    D0 = eax;                               // mov D0, eax
    {
        int32_t res = *(int32_t *)&D0 >> 8;
        *(int32_t *)&D0 = res;
    }                                       // sar D0, 8
    ax = D0;                                // mov ax, word ptr D0
    bx = *(word *)&g_memByte[325642];       // mov bx, ballBounceFactor
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D3 = res;
    }                                       // sub D3, eax
    D3 |= 1;                                // or D3, 1
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = 40960;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D3, 0A000h
    if (!flags.carry && !flags.zero)
        goto l_play_ball_bounce_sample;     // ja short @@play_ball_bounce_sample

l_set_delta_z_to_0:;
    D3 = 0;                                 // mov D3, 0
    goto l_assign_delta_z;                  // jmp short @@assign_delta_z

l_play_ball_bounce_sample:;
    eax = D3;                               // mov eax, D3
    D0 = eax;                               // mov D0, eax
    push(D3);                               // push D3
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    SWOS::PlayBallBounceSample();           // call PlayBallBounceSample
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D3);                                // pop D3

l_assign_delta_z:;
    eax = D3;                               // mov eax, D3
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 54, 4, eax);          // mov [esi+Sprite.deltaZ], eax
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (flags.zero)
        goto l_in_allowed_range_y;          // jz @@in_allowed_range_y

    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 53;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.x+2)], 53
    if (flags.sign != flags.overflow)
        goto l_bounce_off_invisible_barrier_x; // jl short @@bounce_off_invisible_barrier_x

    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 618;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.x+2)], 618
    if (flags.zero || flags.sign != flags.overflow)
        goto l_check_y_range;               // jle @@check_y_range

l_bounce_off_invisible_barrier_x:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 58, 2);     // mov ax, [esi+Sprite.destX]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    {
        word src = (word)readMemory(esi + 44, 2);
        word res = src >> 1;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // shr [esi+Sprite.speed], 1
    eax = D5;                               // mov eax, D5
    writeMemory(esi + 30, 4, eax);          // mov [esi+Sprite.x], eax
    eax = D6;                               // mov eax, D6
    writeMemory(esi + 34, 4, eax);          // mov [esi+Sprite.y], eax
    eax = D7;                               // mov eax, D7
    writeMemory(esi + 38, 4, eax);          // mov [esi+Sprite.z], eax

l_check_y_range:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.y+2)], 100
    if (flags.sign != flags.overflow)
        goto l_bounce_off_invisible_barrier_y; // jl short @@bounce_off_invisible_barrier_y

    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 799;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.y+2)], 799
    if (flags.zero || flags.sign != flags.overflow)
        goto l_in_allowed_range_y;          // jle @@in_allowed_range_y

l_bounce_off_invisible_barrier_y:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 60, 2);     // mov ax, [esi+Sprite.destY]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    {
        word src = (word)readMemory(esi + 44, 2);
        word res = src >> 1;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // shr [esi+Sprite.speed], 1
    eax = D5;                               // mov eax, D5
    writeMemory(esi + 30, 4, eax);          // mov [esi+Sprite.x], eax
    eax = D6;                               // mov eax, D6
    writeMemory(esi + 34, 4, eax);          // mov [esi+Sprite.y], eax
    eax = D7;                               // mov eax, D7
    writeMemory(esi + 38, 4, eax);          // mov [esi+Sprite.z], eax

l_in_allowed_range_y:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.y+2)], 129
    if (flags.sign != flags.overflow)
        goto l_goal_or_gol_out;             // jl short @@goal_or_gol_out

    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 769;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.y+2)], 769
    if (flags.zero || flags.sign != flags.overflow)
        goto l_not_in_lower_goal;           // jle @@not_in_lower_goal

l_goal_or_gol_out:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 40, 2);     // mov ax, word ptr [esi+(Sprite.z+2)]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 128;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 128
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_not_in_upper_goal;           // jg short @@not_in_upper_goal

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 112;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 112
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_in_upper_goal_y;             // jg @@in_upper_goal_y

l_not_in_upper_goal:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 770;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 770
    if (flags.sign != flags.overflow)
        goto l_not_in_lower_goal;           // jl @@not_in_lower_goal

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 785;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 785
    if (flags.sign == flags.overflow)
        goto l_not_in_lower_goal;           // jge @@not_in_lower_goal

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 19;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 19
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_not_in_lower_goal;           // jg @@not_in_lower_goal

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 295;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 295
    if (flags.zero || flags.sign != flags.overflow)
        goto l_not_in_lower_goal;           // jle @@not_in_lower_goal

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 372;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 372
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_not_in_lower_goal;           // jg @@not_in_lower_goal

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 15
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_ball_in_top_of_lower_goal;   // jg @@ball_in_top_of_lower_goal

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 302;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 302
    if (flags.sign != flags.overflow)
        goto l_left_edge_of_lower_goal;     // jl @@left_edge_of_lower_goal

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 366;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 366
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_left_edge_of_lower_goal;     // jg @@left_edge_of_lower_goal

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 778;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 778
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_ball_in_net;                 // jg @@ball_in_net

    goto l_not_in_lower_goal;               // jmp @@not_in_lower_goal

l_in_upper_goal_y:;
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 19;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 19
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_not_in_lower_goal;           // jg @@not_in_lower_goal

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 295;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 295
    if (flags.zero || flags.sign != flags.overflow)
        goto l_not_in_lower_goal;           // jle @@not_in_lower_goal

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 372;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 372
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_not_in_lower_goal;           // jg @@not_in_lower_goal

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 123;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 123
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_ball_just_in_upper_goal;     // jg short @@ball_just_in_upper_goal

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 10
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_top_of_upper_goal;           // jg short @@top_of_upper_goal

    goto l_ball_in_upper_net;               // jmp short @@ball_in_upper_net

l_ball_just_in_upper_goal:;
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 15
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_top_of_upper_goal;           // jg short @@top_of_upper_goal

l_ball_in_upper_net:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 302;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 302
    if (flags.sign != flags.overflow)
        goto l_left_edge_of_lower_goal;     // jl @@left_edge_of_lower_goal

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 366;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 366
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_left_edge_of_lower_goal;     // jg @@left_edge_of_lower_goal

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 119;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 119
    if (flags.sign != flags.overflow)
        goto l_ball_in_net;                 // jl @@ball_in_net

    goto l_not_in_lower_goal;               // jmp @@not_in_lower_goal

l_top_of_upper_goal:;
    eax = D7;                               // mov eax, D7
    D0 = eax;                               // mov D0, eax
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 15
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_top_of_the_goal;             // jg short @@top_of_the_goal

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 54, 4, 1);            // mov [esi+Sprite.deltaZ], 1
    writeMemory(esi + 44, 2, 0);            // mov [esi+Sprite.speed], 0
    eax = D5;                               // mov eax, D5
    writeMemory(esi + 30, 4, eax);          // mov [esi+Sprite.x], eax
    eax = D6;                               // mov eax, D6
    writeMemory(esi + 34, 4, eax);          // mov [esi+Sprite.y], eax
    eax = D7;                               // mov eax, D7
    writeMemory(esi + 38, 4, eax);          // mov [esi+Sprite.z], eax
    goto l_not_in_lower_goal;               // jmp @@not_in_lower_goal

l_top_of_the_goal:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 54, 4, 1);            // mov [esi+Sprite.deltaZ], 1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1000;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1000
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    writeMemory(esi + 44, 2, 512);          // mov [esi+Sprite.speed], 512
    eax = D7;                               // mov eax, D7
    writeMemory(esi + 38, 4, eax);          // mov [esi+Sprite.z], eax
    goto l_not_in_lower_goal;               // jmp @@not_in_lower_goal

l_ball_in_top_of_lower_goal:;
    eax = D7;                               // mov eax, D7
    D0 = eax;                               // mov D0, eax
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 15
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_7C69B;                    // jg short cseg_7C69B

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 54, 4, 1);            // mov [esi+Sprite.deltaZ], 1
    writeMemory(esi + 44, 2, 0);            // mov [esi+Sprite.speed], 0
    eax = D5;                               // mov eax, D5
    writeMemory(esi + 30, 4, eax);          // mov [esi+Sprite.x], eax
    eax = D6;                               // mov eax, D6
    writeMemory(esi + 34, 4, eax);          // mov [esi+Sprite.y], eax
    eax = D7;                               // mov eax, D7
    writeMemory(esi + 38, 4, eax);          // mov [esi+Sprite.z], eax
    goto l_not_in_lower_goal;               // jmp @@not_in_lower_goal

cseg_7C69B:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 54, 4, 1);            // mov [esi+Sprite.deltaZ], 1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1000;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1000
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    writeMemory(esi + 44, 2, 512);          // mov [esi+Sprite.speed], 512
    eax = D7;                               // mov eax, D7
    writeMemory(esi + 38, 4, eax);          // mov [esi+Sprite.z], eax
    goto l_not_in_lower_goal;               // jmp @@not_in_lower_goal

l_ball_in_net:;
    ReverseDestYDirection();                // call ReverseDestYDirection
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 3;
        flags.carry = ((word)*(word *)&D0 >> 13) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 3
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    goto cseg_7C756;                        // jmp short cseg_7C756

l_left_edge_of_lower_goal:;
    ReverseDestXDirection();                // call ReverseDestXDirection
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax

cseg_7C756:;
    eax = D5;                               // mov eax, D5
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 30, 4, eax);          // mov [esi+Sprite.x], eax
    eax = D6;                               // mov eax, D6
    writeMemory(esi + 34, 4, eax);          // mov [esi+Sprite.y], eax

l_not_in_lower_goal:;
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (!flags.zero)
        goto cseg_7CA2C;                    // jnz cseg_7CA2C

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 40, 2);     // mov ax, word ptr [esi+(Sprite.z+2)]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 128;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 128
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_7CA2C;                    // jle cseg_7CA2C

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 132;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 132
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_7C7F0;                    // jle short cseg_7C7F0

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 770;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 770
    if (flags.sign == flags.overflow)
        goto cseg_7CA2C;                    // jge cseg_7CA2C

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 766;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 766
    if (flags.sign != flags.overflow)
        goto cseg_7CA2C;                    // jl cseg_7CA2C

cseg_7C7F0:;
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 19;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 19
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_7CA2C;                    // jg cseg_7CA2C

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 295;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 295
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_7CA2C;                    // jle cseg_7CA2C

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 372;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 372
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_7CA2C;                    // jg cseg_7CA2C

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 15
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_penalty_goal;                // jg short @@penalty_goal

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 302;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 302
    if (flags.sign != flags.overflow)
        goto l_own_goal;                    // jl short @@own_goal

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 366;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 366
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_own_goal;                    // jg short @@own_goal

    goto cseg_7CA2C;                        // jmp cseg_7CA2C

l_penalty_goal:;
    *(word *)&g_memByte[456256] = 1;        // mov goalTypeScored, GT_PENALTY
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    {
        word res = *(word *)&D4 & 31;
        *(word *)&D4 = res;
    }                                       // and word ptr D4, 1Fh
    {
        word res = *(word *)&D4 << 4;
        *(word *)&D4 = res;
    }                                       // shl word ptr D4, 4
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 256;
        word res = dstSigned - srcSigned;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 256
    esi = A0;                               // mov esi, A0
    {
        dword src = readMemory(esi + 50, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = -20480;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.deltaY], -5000h
    if (flags.sign != flags.overflow)
        goto cseg_7C911;                    // jl cseg_7C911

    {
        dword src = readMemory(esi + 50, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 20480;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.deltaY], 5000h
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_7C911;                    // jg cseg_7C911

    goto l_reverse_delta_z;                 // jmp @@reverse_delta_z

l_own_goal:;
    *(word *)&g_memByte[456256] = 2;        // mov goalTypeScored, GT_OWN_GOAL
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    {
        word res = *(word *)&D4 & 31;
        *(word *)&D4 = res;
    }                                       // and word ptr D4, 1Fh
    {
        word res = *(word *)&D4 << 4;
        *(word *)&D4 = res;
    }                                       // shl word ptr D4, 4
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 256;
        word res = dstSigned - srcSigned;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 256
    esi = A0;                               // mov esi, A0
    {
        dword src = readMemory(esi + 50, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = -20480;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.deltaY], -5000h
    if (flags.sign != flags.overflow)
        goto cseg_7C911;                    // jl short cseg_7C911

    {
        dword src = readMemory(esi + 50, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 20480;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.deltaY], 5000h
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_7C911;                    // jg short cseg_7C911

    push(D4);                               // push D4
    ReverseDestYDirection();                // call ReverseDestYDirection
    pop(D4);                                // pop D4
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
    ax = D4;                                // mov ax, word ptr D4
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 60, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 60, 2, src);
    }                                       // add [esi+Sprite.destY], ax
    goto cseg_7C989;                        // jmp short cseg_7C989

cseg_7C911:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 449;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 449
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_7C92F;                    // jg short cseg_7C92F

    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 50, 4);          // mov eax, [esi+Sprite.deltaY]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.sign)
        goto cseg_7CA2C;                    // jns cseg_7CA2C

    goto cseg_7C940;                        // jmp short cseg_7C940

cseg_7C92F:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 50, 4);          // mov eax, [esi+Sprite.deltaY]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.sign)
        goto cseg_7CA2C;                    // js cseg_7CA2C

cseg_7C940:;
    push(D4);                               // push D4
    ReverseDestYDirection();                // call ReverseDestYDirection
    pop(D4);                                // pop D4
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
    ax = D4;                                // mov ax, word ptr D4
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 58, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 58, 2, src);
    }                                       // add [esi+Sprite.destX], ax
    goto cseg_7C989;                        // jmp short cseg_7C989

l_reverse_delta_z:;
    esi = A0;                               // mov esi, A0
    {
        int32_t src = readMemory(esi + 54, 4);
        src = -src;
        writeMemory(esi + 54, 4, src);
    }                                       // neg [esi+Sprite.deltaZ]
    eax = D7;                               // mov eax, D7
    writeMemory(esi + 38, 4, eax);          // mov [esi+Sprite.z], eax
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = 65536;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D6 = res;
    }                                       // add D6, 10000h

cseg_7C989:;
    SWOS::Rand();                           // call Rand
    {
        word res = *(word *)&D0 & 1;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D0, 1
    if (flags.zero)
        goto l_play_frame_hit_comment;      // jz short @@play_frame_hit_comment

    {
        word src = *(word *)&g_memByte[456256];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp goalTypeScored, GT_OWN_GOAL
    if (!flags.zero)
        goto l_play_bar_hit_comment;        // jnz short @@play_bar_hit_comment

    push(A0);                               // push A0
    SWOS::PlayPostHitComment();             // call PlayPostHitComment
    pop(A0);                                // pop A0
    goto l_play_miss_goal_sample;           // jmp short @@play_miss_goal_sample

l_play_bar_hit_comment:;
    push(A0);                               // push A0
    SWOS::PlayBarHitComment();              // call PlayBarHitComment
    pop(A0);                                // pop A0
    goto l_play_miss_goal_sample;           // jmp short @@play_miss_goal_sample

l_play_frame_hit_comment:;
    push(A0);                               // push A0
    SWOS::PlayPostHitComment();             // call PlayPostHitComment
    pop(A0);                                // pop A0

l_play_miss_goal_sample:;
    SWOS::PlayMissGoalSample();             // call PlayMissGoalSample
    *(word *)&g_memByte[456256] = 0;        // mov goalTypeScored, GT_REGULAR
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // sub [esi+Sprite.speed], ax
    eax = D5;                               // mov eax, D5
    writeMemory(esi + 30, 4, eax);          // mov [esi+Sprite.x], eax
    eax = D6;                               // mov eax, D6
    writeMemory(esi + 34, 4, eax);          // mov [esi+Sprite.y], eax

cseg_7CA2C:;
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (!flags.zero)
        goto l_update_ball_shadow;          // jnz @@update_ball_shadow

    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 81;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.x+2)], 81
    if (flags.sign == flags.overflow)
        goto cseg_7CAA5;                    // jge short cseg_7CAA5

    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(A0);                               // push A0
    CheckIfBallOutOfPlay();                 // call CheckIfBallOutOfPlay
    pop(A0);                                // pop A0
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    goto l_update_ball_shadow;              // jmp @@update_ball_shadow

cseg_7CAA5:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 590;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.x+2)], 590
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_7CB11;                    // jle short cseg_7CB11

    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(A0);                               // push A0
    CheckIfBallOutOfPlay();                 // call CheckIfBallOutOfPlay
    pop(A0);                                // pop A0
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    goto l_update_ball_shadow;              // jmp @@update_ball_shadow

cseg_7CB11:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.y+2)], 129
    if (flags.sign == flags.overflow)
        goto cseg_7CB7A;                    // jge short cseg_7CB7A

    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(A0);                               // push A0
    CheckIfBallOutOfPlay();                 // call CheckIfBallOutOfPlay
    pop(A0);                                // pop A0
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    goto l_update_ball_shadow;              // jmp short @@update_ball_shadow

cseg_7CB7A:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 769;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.y+2)], 769
    if (flags.zero || flags.sign != flags.overflow)
        goto l_update_ball_shadow;          // jle short @@update_ball_shadow

    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(A0);                               // push A0
    CheckIfBallOutOfPlay();                 // call CheckIfBallOutOfPlay
    pop(A0);                                // pop A0
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1

l_update_ball_shadow:;
    A1 = 329100;                            // mov A1, offset ballShadowSprite
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 40, 2);     // mov ax, word ptr [esi+(Sprite.z+2)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 32, 2, ax);           // mov word ptr [esi+(Sprite.x+2)], ax
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 32, 2, src);
    }                                       // add word ptr [esi+(Sprite.x+2)], ax
    {
        word src = (word)readMemory(esi + 32, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 32, 2, src);
    }                                       // add word ptr [esi+(Sprite.x+2)], 1
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 36, 2, ax);           // mov word ptr [esi+(Sprite.y+2)], ax
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 36, 2, src);
    }                                       // add word ptr [esi+(Sprite.y+2)], ax
    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 36, 2, src);
    }                                       // add word ptr [esi+(Sprite.y+2)], 1
    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 36, 2, src);
    }                                       // sub word ptr [esi+(Sprite.y+2)], 10
    writeMemory(esi + 40, 2, -10);          // mov word ptr [esi+(Sprite.z+2)], -10
    CalculateNextBallPosition();            // call CalculateNextBallPosition
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, 100
    if (flags.zero)
        goto l_game_in_progress;            // jz short @@game_in_progress

    ax = *(word *)&g_memByte[523136];       // mov ax, foulXCoordinate
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[523138];       // mov ax, foulYCoordinate
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (flags.zero)
        goto l_keepers_ball_or_goal_out;    // jz short @@keepers_ball_or_goal_out

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_GOAL_OUT_LEFT
    if (flags.zero)
        goto l_keepers_ball_or_goal_out;    // jz short @@keepers_ball_or_goal_out

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_GOAL_OUT_RIGHT
    if (!flags.zero)
        goto l_calc_x_ball_quadrant;        // jnz short @@calc_x_ball_quadrant

l_keepers_ball_or_goal_out:;
    *(word *)&D1 = 336;                     // mov word ptr D1, 336
    *(word *)&D2 = 449;                     // mov word ptr D2, 449
    goto l_calc_x_ball_quadrant;            // jmp short @@calc_x_ball_quadrant

l_game_in_progress:;
    ax = *(word *)&g_memByte[523672];       // mov ax, ballNextX
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[523674];       // mov ax, ballNextY
    *(word *)&D2 = ax;                      // mov word ptr D2, ax

l_calc_x_ball_quadrant:;
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    A1 = 523684;                            // mov A1, (offset ballXQuadrantLimits+2)
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.carry)
        goto l_calc_y_ball_quadrant;        // jb @@calc_y_ball_quadrant

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 1
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.carry)
        goto l_calc_y_ball_quadrant;        // jb short @@calc_y_ball_quadrant

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 1
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.carry)
        goto l_calc_y_ball_quadrant;        // jb short @@calc_y_ball_quadrant

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 1
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.carry)
        goto l_calc_y_ball_quadrant;        // jb short @@calc_y_ball_quadrant

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 1
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2
    A1 = eax;                               // mov A1, eax

l_calc_y_ball_quadrant:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[523770] = ax;       // mov ballXQuadrantDead, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + -4, 2);     // mov ax, [esi-4]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 51;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 51
    ax = D1;                                // mov ax, word ptr D1
    bx = 5;                                 // mov bx, 5
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    bx = 15;                                // mov bx, 15
    {
        int32_t dividend = ((int16_t)dx << 16) | (int16_t)ax;
        int16_t quot = (int16_t)(dividend / (int16_t)bx);
        int16_t rem = (int16_t)(dividend % (int16_t)bx);
        ax = quot;
        dx = rem;
    }                                       // idiv bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    *(word *)&g_memByte[523774] = ax;       // mov playerXQuadrantOffset, ax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    A1 = 523694;                            // mov A1, (offset ballYQuadrantLimits+2)
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.carry)
        goto l_set_y_quadrant;              // jb @@set_y_quadrant

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 5
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.carry)
        goto l_set_y_quadrant;              // jb @@set_y_quadrant

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 5
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.carry)
        goto l_set_y_quadrant;              // jb @@set_y_quadrant

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 5
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.carry)
        goto l_set_y_quadrant;              // jb short @@set_y_quadrant

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 5
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.carry)
        goto l_set_y_quadrant;              // jb short @@set_y_quadrant

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 5
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.carry)
        goto l_set_y_quadrant;              // jb short @@set_y_quadrant

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 5
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2
    A1 = eax;                               // mov A1, eax

l_set_y_quadrant:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[523772] = ax;       // mov ballYQuadrantDead, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + -4, 2);     // mov ax, [esi-4]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 45;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 45
    ax = D2;                                // mov ax, word ptr D2
    bx = 5;                                 // mov bx, 5
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    bx = 15;                                // mov bx, 15
    {
        int32_t dividend = ((int16_t)dx << 16) | (int16_t)ax;
        int16_t quot = (int16_t)(dividend / (int16_t)bx);
        int16_t rem = (int16_t)(dividend % (int16_t)bx);
        ax = quot;
        dx = rem;
    }                                       // idiv bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    *(word *)&g_memByte[523776] = ax;       // mov playerYQuadrantOffset, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[523768] = ax;       // mov ballQuadrantIndex, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D5 -  ball x
//      A0 -> ball sprite
//
// Reverse dest x direction around x (by the same delta x amount).
//
void ReverseDestXDirection()
{
    eax = D5;                               // mov eax, D5
    D4 = eax;                               // mov D4, eax
    {
        word tmp = *(word *)((byte *)&D4 + 2);
        *(word *)((byte *)&D4 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D4+2
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 58, 2);     // mov ax, [esi+Sprite.destX]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, ax
    ax = D4;                                // mov ax, word ptr D4
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D6 -  ball y
//      A0 -> ball sprite
//
// Reverse dest y direction around y (by the same delta y amount).
//
void ReverseDestYDirection()
{
    eax = D6;                               // mov eax, D6
    D4 = eax;                               // mov D4, eax
    {
        word tmp = *(word *)((byte *)&D4 + 2);
        *(word *)((byte *)&D4 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D4+2
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 60, 2);     // mov ax, [esi+Sprite.destY]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, ax
    ax = D4;                                // mov ax, word ptr D4
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
}

// =============== S U B R O U T I N E =======================================
//
void DoGoalkeeperSprites()
{
    A6 = 522804;                            // mov A6, offset topTeamData
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 80, 2);     // mov ax, [esi+TeamGeneralInfo.goalkeeperDivingRight]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_goalie1_diving_right;        // jnz short @@goalie1_diving_right

    ax = (word)readMemory(esi + 82, 2);     // mov ax, [esi+TeamGeneralInfo.goalkeeperDivingLeft]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_goalie1_diving_left;         // jnz @@goalie1_diving_left

    A6 = 522952;                            // mov A6, offset bottomTeamData
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 80, 2);     // mov ax, [esi+TeamGeneralInfo.goalkeeperDivingRight]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_goalie2_diving_right;        // jnz short @@goalie2_diving_right

    ax = (word)readMemory(esi + 82, 2);     // mov ax, [esi+TeamGeneralInfo.goalkeeperDivingLeft]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_goalie2_diving_left;         // jnz @@goalie2_diving_left

    return;                                 // retn

l_goalie1_diving_right:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    goto l_set_goalie2_picture_index;       // jmp short @@set_goalie2_picture_index

l_goalie2_diving_right:;
    *(word *)&D0 = -1;                      // mov word ptr D0, -1

l_set_goalie2_picture_index:;
    A5 = 326524;                            // mov A5, offset goalie1Sprite
    *(word *)&D1 = 971;                     // mov word ptr D1, 971
    esi = A5;                               // mov esi, A5
    {
        word src = (word)readMemory(esi + 70, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1029;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.imageIndex], 1029
    if (flags.carry)
        goto cseg_7D122;                    // jb short cseg_7D122

    {
        word src = (word)readMemory(esi + 70, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1057;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.imageIndex], 1057
    if (!flags.carry)
        goto cseg_7D122;                    // jnb short cseg_7D122

    *(word *)&D1 = 1029;                    // mov word ptr D1, 1029

cseg_7D122:;
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 18, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.teamNumber], 1
    if (flags.zero)
        goto l_team1;                       // jz short @@team1

    A5 = 327756;                            // mov A5, offset goalie2Sprite
    *(word *)&D1 = 1087;                    // mov word ptr D1, 1087
    esi = A5;                               // mov esi, A5
    {
        word src = (word)readMemory(esi + 70, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1145;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.imageIndex], 1145
    if (flags.carry)
        goto l_team1;                       // jb short @@team1

    {
        word src = (word)readMemory(esi + 70, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1173;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.imageIndex], 1173
    if (!flags.carry)
        goto l_team1;                       // jnb short @@team1

    *(word *)&D1 = 1145;                    // mov word ptr D1, 1145

l_team1:;
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+(Sprite.x+2)]
    *(dword *)&g_memByte[329020] = eax;     // mov ballSprite.x+2, eax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[329024] = ax;       // mov word ptr ballSprite.y+2, ax
    *(word *)&g_memByte[329028] = 0;        // mov word ptr ballSprite.z+2, 0
    *(dword *)&g_memByte[329042] = 0;       // mov ballSprite.deltaZ, 0
    *(word *)&g_memByte[329032] = 0;        // mov ballSprite.speed, 0
    ax = (word)readMemory(esi + 70, 2);     // mov ax, [esi+Sprite.imageIndex]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 28;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 28
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    A0 = 523562;                            // mov A0, offset dseg_17DEF4
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&g_memByte[329028] = ax;       // mov word ptr ballSprite.z+2, ax
    return;                                 // retn

l_goalie1_diving_left:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    goto l_diving_side_determined;          // jmp short @@diving_side_determined

l_goalie2_diving_left:;
    *(word *)&D0 = -1;                      // mov word ptr D0, -1

l_diving_side_determined:;
    A5 = 326524;                            // mov A5, offset goalie1Sprite
    *(word *)&D1 = 971;                     // mov word ptr D1, 971
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 18, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.teamNumber], 1
    if (flags.zero)
        goto cseg_7D245;                    // jz short cseg_7D245

    A5 = 327756;                            // mov A5, offset goalie2Sprite
    *(word *)&D1 = 1087;                    // mov word ptr D1, 1087

cseg_7D245:;
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+(Sprite.x+2)]
    *(dword *)&g_memByte[329020] = eax;     // mov ballSprite.x+2, eax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[329024] = ax;       // mov word ptr ballSprite.y+2, ax
    *(dword *)&g_memByte[329042] = 0;       // mov ballSprite.deltaZ, 0
    *(word *)&g_memByte[329032] = 0;        // mov ballSprite.speed, 0
    ax = (word)readMemory(esi + 28, 2);     // mov ax, [esi+Sprite.frameSwitchCounter]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 523618;                            // mov A0, offset kGoalKeeperClaimingBallHeight
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&g_memByte[329028] = ax;       // mov word ptr ballSprite.z+2, ax
}

// =============== S U B R O U T I N E =======================================
//
void CheckIfBallOutOfPlay()
{
    *(word *)&g_memByte[456270] = 0;        // mov stateGoal, 0
    *(word *)&g_memByte[523680] = 0;        // mov playRefereeWhistle, 0
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 101;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_STOPPED
    if (flags.zero)
        goto l_starting_the_game;           // jz @@starting_the_game

    *(word *)&g_memByte[523680] = 1;        // mov playRefereeWhistle, 1
    A6 = 328988;                            // mov A6, offset ballSprite
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 40, 2);     // mov ax, word ptr [esi+(Sprite.z+2)]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 15
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_not_in_goal_check_near_miss; // jg @@not_in_goal_check_near_miss

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 302;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 302
    if (flags.sign != flags.overflow)
        goto l_not_in_goal_check_near_miss; // jl @@not_in_goal_check_near_miss

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 366;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 366
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_not_in_goal_check_near_miss; // jg @@not_in_goal_check_near_miss

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 449;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 449
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_lower_goal;                  // jg @@lower_goal

    A6 = 522952;                            // mov A6, offset bottomTeamData
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 18, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.teamNumber], 1
    if (flags.zero)
        goto l_team1_scored;                // jz @@team1_scored

l_team2_scored:;
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    eax = *(dword *)&g_memByte[523108];     // mov eax, lastPlayerPlayed
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[523099];     // mov eax, lastKeeperPlayed
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto l_keeper_didnt_play;           // jz short @@keeper_didnt_play

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 326524;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset goalie1Sprite
    if (flags.zero)
        goto l_keeper_played;               // jz short @@keeper_played

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 327756;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset goalie2Sprite
    if (!flags.zero)
        goto l_keeper_didnt_play;           // jnz short @@keeper_didnt_play

l_keeper_played:;
    eax = *(dword *)&g_memByte[523099];     // mov eax, lastKeeperPlayed
    A0 = eax;                               // mov A0, eax

l_keeper_didnt_play:;
    ax = *(word *)&g_memByte[336636];       // mov ax, statsTeam1Goals
    *(word *)&g_memByte[336624] = ax;       // mov statsTeam1GoalsCopy2, ax
    ax = *(word *)&g_memByte[336638];       // mov ax, statsTeam2Goals
    *(word *)&g_memByte[336626] = ax;       // mov statsTeam2GoalsCopy2, ax
    push(A6);                               // push A6
    SWOS::GoalScored();                     // call GoalScored
    pop(A6);                                // pop A6
    *(word *)&g_memByte[455992] = 1;        // mov goalCameraMode, 1
    *(word *)&g_memByte[456652] = 2;        // mov teamNumThatScored, 2
    goto l_goal_handled;                    // jmp @@goal_handled

l_lower_goal:;
    A6 = 522804;                            // mov A6, offset topTeamData
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 18, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.teamNumber], 2
    if (flags.zero)
        goto l_team2_scored;                // jz @@team2_scored

l_team1_scored:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    eax = *(dword *)&g_memByte[523108];     // mov eax, lastPlayerPlayed
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[523099];     // mov eax, lastKeeperPlayed
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_7D45F;                    // jz short cseg_7D45F

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 326524;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset goalie1Sprite
    if (flags.zero)
        goto cseg_7D455;                    // jz short cseg_7D455

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 327756;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset goalie2Sprite
    if (!flags.zero)
        goto cseg_7D45F;                    // jnz short cseg_7D45F

cseg_7D455:;
    eax = *(dword *)&g_memByte[523099];     // mov eax, lastKeeperPlayed
    A0 = eax;                               // mov A0, eax

cseg_7D45F:;
    ax = *(word *)&g_memByte[336636];       // mov ax, statsTeam1Goals
    *(word *)&g_memByte[336624] = ax;       // mov statsTeam1GoalsCopy2, ax
    ax = *(word *)&g_memByte[336638];       // mov ax, statsTeam2Goals
    *(word *)&g_memByte[336626] = ax;       // mov statsTeam2GoalsCopy2, ax
    push(A6);                               // push A6
    SWOS::GoalScored();                     // call GoalScored
    pop(A6);                                // pop A6
    *(word *)&g_memByte[455992] = 1;        // mov goalCameraMode, 1
    *(word *)&g_memByte[456652] = 1;        // mov teamNumThatScored, 1

l_goal_handled:;
    eax = A6;                               // mov eax, A6
    *(dword *)&g_memByte[456656] = eax;     // mov teamScoredDataPtr, eax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 10, 4);          // mov eax, [esi+TeamGeneralInfo.inGameTeamPtr]
    *(dword *)&g_memByte[456660] = eax;     // mov teamScoredGamePtr, eax
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A6 = eax;                               // mov A6, eax
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (flags.zero)
        goto cseg_7D4DD;                    // jz short cseg_7D4DD

    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    *(byte *)&D4 = 199;                     // mov byte ptr D4, 0C7h
    goto l_play_goal_comment;               // jmp short @@play_goal_comment

cseg_7D4DD:;
    *(word *)&D3 = 4;                       // mov word ptr D3, 4
    *(byte *)&D4 = 124;                     // mov byte ptr D4, 7Ch

l_play_goal_comment:;
    {
        word src = *(word *)&g_memByte[456256];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp goalTypeScored, GT_OWN_GOAL
    if (flags.zero)
        goto l_own_goal;                    // jz short @@own_goal

    SWOS::PlayGoalComment();                // call PlayGoalComment
    goto l_check_if_home_goal;              // jmp short @@check_if_home_goal

l_own_goal:;
    SWOS::PlayOwnGoalComment();             // call PlayOwnGoalComment

l_check_if_home_goal:;
    {
        word src = *(word *)&g_memByte[456652];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNumThatScored, 2
    if (flags.zero)
        goto l_guests_scored;               // jz short @@guests_scored

    SWOS::PlayHomeGoalSample();             // call PlayHomeGoalSample
    goto l_set_goal_state;                  // jmp short @@set_goal_state

l_guests_scored:;
    SWOS::PlayAwayGoalSample();             // call PlayAwayGoalSample

l_set_goal_state:;
    *(word *)&g_memByte[456270] = -1;       // mov stateGoal, -1
    *(word *)&g_memByte[523680] = 0;        // mov playRefereeWhistle, 0
    SWOS::Rand();                           // call Rand
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 100;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 100
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[523160];       // mov ax, playingPenalties
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_penalty_scored;              // jnz @@penalty_scored

    ax = *(word *)&g_memByte[336636];       // mov ax, statsTeam1Goals
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[336638];       // mov ax, statsTeam2Goals
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        goto cseg_7D5F6;                    // jz cseg_7D5F6

    ax = *(word *)&g_memByte[336624];       // mov ax, statsTeam1GoalsCopy2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[336626];       // mov ax, statsTeam2GoalsCopy2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        goto cseg_7D5E0;                    // jz short cseg_7D5E0

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto cseg_7D5A8;                    // jz short cseg_7D5A8

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -1
    if (!flags.zero)
        goto cseg_7D5D5;                    // jnz short cseg_7D5D5

cseg_7D5A8:;
    ax = *(word *)&g_memByte[336636];       // mov ax, statsTeam1Goals
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[336638];       // mov ax, statsTeam2Goals
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (flags.zero)
        goto cseg_7D5EB;                    // jz short cseg_7D5EB

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -2
    if (flags.zero)
        goto cseg_7D5EB;                    // jz short cseg_7D5EB

cseg_7D5D5:;
    *(word *)&D1 = 100;                     // mov word ptr D1, 100
    goto cseg_7D5FF;                        // jmp short cseg_7D5FF

cseg_7D5E0:;
    *(word *)&D1 = 300;                     // mov word ptr D1, 300
    goto cseg_7D5FF;                        // jmp short cseg_7D5FF

cseg_7D5EB:;
    *(word *)&D1 = 200;                     // mov word ptr D1, 200
    goto cseg_7D5FF;                        // jmp short cseg_7D5FF

cseg_7D5F6:;
    *(word *)&D1 = 200;                     // mov word ptr D1, 200

cseg_7D5FF:;
    SWOS::Rand();                           // call Rand
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax

l_penalty_scored:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[455988] = ax;       // mov goalCounter, ax
    *(word *)&g_memByte[521028] = 1;        // mov patternsGoalCounter, 1
    *(word *)&D1 = 336;                     // mov word ptr D1, 336
    *(word *)&D2 = 449;                     // mov word ptr D2, 449
    *(word *)&g_memByte[523130] = 0;        // mov gameState, ST_PLAYERS_TO_INITIAL_POSITIONS
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    goto l_break_handled;                   // jmp @@break_handled

l_not_in_goal_check_near_miss:;
    A6 = 328988;                            // mov A6, offset ballSprite
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 40, 2);     // mov ax, word ptr [esi+(Sprite.z+2)]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 2
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 768;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.speed], 768
    if (flags.carry)
        goto l_check_for_corner_goal_out;   // jb short @@check_for_corner_goal_out

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 290;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 290
    if (flags.sign != flags.overflow)
        goto l_check_for_corner_goal_out;   // jl short @@check_for_corner_goal_out

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 381;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 381
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_check_for_corner_goal_out;   // jg short @@check_for_corner_goal_out

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 25
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_check_for_corner_goal_out;   // jg short @@check_for_corner_goal_out

    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    SWOS::PlayNearMissComment();            // call PlayNearMissComment
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    SWOS::PlayMissGoalSample();             // call PlayMissGoalSample
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    *(word *)&g_memByte[523680] = 0;        // mov playRefereeWhistle, 0

l_check_for_corner_goal_out:;
    SWOS::FixPenaltyBug();                  // call FixPenaltyBug
    A6 = 522804;                            // mov A6, offset topTeamData
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 129
    if (flags.sign == flags.overflow)
        goto l_not_upper_corner_goal_out;   // jge short @@not_upper_corner_goal_out

    eax = *(dword *)&g_memByte[523104];     // mov eax, lastTeamPlayed
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, eax
    if (!flags.zero)
        goto l_upper_goal_out;              // jnz @@upper_goal_out

    A6 = 522952;                            // mov A6, offset bottomTeamData
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 336;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 336
    if (flags.sign != flags.overflow)
        goto l_left_upper_corner;           // jl @@left_upper_corner

    goto l_right_upper_corner;              // jmp @@right_upper_corner

l_not_upper_corner_goal_out:;
    A6 = 522952;                            // mov A6, offset bottomTeamData
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 769;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 769
    if (flags.zero || flags.sign != flags.overflow)
        goto l_ball_in_pitch;               // jle @@ball_in_pitch

    eax = *(dword *)&g_memByte[523104];     // mov eax, lastTeamPlayed
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, eax
    if (!flags.zero)
        goto l_lower_goal_out;              // jnz @@lower_goal_out

    A6 = 522804;                            // mov A6, offset topTeamData
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 336;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 336
    if (flags.sign != flags.overflow)
        goto l_lower_left_corner;           // jl short @@lower_left_corner

    {
        word src = *(word *)&g_memByte[455970];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp forceLeftTeam, 1
    if (flags.zero)
        goto l_right_upper_corner;          // jz short @@right_upper_corner

    *(word *)&D1 = 585;                     // mov word ptr D1, 585
    *(word *)&D2 = 764;                     // mov word ptr D2, 764
    *(word *)&D3 = 6;                       // mov word ptr D3, 6
    *(byte *)&D4 = 193;                     // mov byte ptr D4, 0C1h
    *(word *)&g_memByte[523130] = 4;        // mov gameState, ST_CORNER_LEFT
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    goto l_its_a_corner;                    // jmp @@its_a_corner

l_lower_left_corner:;
    {
        word src = *(word *)&g_memByte[455970];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp forceLeftTeam, 1
    if (flags.zero)
        goto l_left_upper_corner;           // jz short @@left_upper_corner

    *(word *)&D1 = 86;                      // mov word ptr D1, 86
    *(word *)&D2 = 764;                     // mov word ptr D2, 764
    *(word *)&D3 = 2;                       // mov word ptr D3, 2
    *(byte *)&D4 = 7;                       // mov byte ptr D4, 7
    *(word *)&g_memByte[523130] = 5;        // mov gameState, ST_CORNER_RIGHT
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    goto l_its_a_corner;                    // jmp short @@its_a_corner

l_right_upper_corner:;
    *(word *)&D1 = 585;                     // mov word ptr D1, 585
    *(word *)&D2 = 134;                     // mov word ptr D2, 134
    *(word *)&D3 = 6;                       // mov word ptr D3, 6
    *(byte *)&D4 = 112;                     // mov byte ptr D4, 70h
    *(word *)&g_memByte[523130] = 5;        // mov gameState, ST_CORNER_RIGHT
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    goto l_its_a_corner;                    // jmp short @@its_a_corner

l_left_upper_corner:;
    *(word *)&D1 = 86;                      // mov word ptr D1, 86
    *(word *)&D2 = 134;                     // mov word ptr D2, 134
    *(word *)&D3 = 2;                       // mov word ptr D3, 2
    *(byte *)&D4 = 28;                      // mov byte ptr D4, 1Ch
    *(word *)&g_memByte[523130] = 4;        // mov gameState, ST_CORNER_LEFT
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1

l_its_a_corner:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 14, 4);          // mov eax, [esi+TeamGeneralInfo.teamStatsPtr]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 2, 2, src);
    }                                       // add [esi+TeamStatisticsData.cornersWon], 1
    EnqueueCornerSample();                  // call EnqueueCornerSample
    goto l_break_handled;                   // jmp @@break_handled

l_upper_goal_out:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 336;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 336
    if (flags.sign != flags.overflow)
        goto l_left_upper_goal_out;         // jl short @@left_upper_goal_out

cseg_7D8C0:;
    *(word *)&D1 = 396;                     // mov word ptr D1, 396
    *(word *)&D2 = 154;                     // mov word ptr D2, 154
    *(word *)&D3 = 4;                       // mov word ptr D3, 4
    *(byte *)&D4 = 124;                     // mov byte ptr D4, 7Ch
    *(word *)&g_memByte[523130] = 1;        // mov gameState, ST_GOAL_OUT_LEFT
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    goto cseg_7D9C3;                        // jmp cseg_7D9C3

l_left_upper_goal_out:;
    *(word *)&D1 = 276;                     // mov word ptr D1, 276
    *(word *)&D2 = 154;                     // mov word ptr D2, 154
    *(word *)&D3 = 4;                       // mov word ptr D3, 4
    *(byte *)&D4 = 124;                     // mov byte ptr D4, 7Ch
    *(word *)&g_memByte[523130] = 2;        // mov gameState, ST_GOAL_OUT_RIGHT
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    goto cseg_7D9C3;                        // jmp cseg_7D9C3

l_lower_goal_out:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 336;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 336
    if (flags.sign != flags.overflow)
        goto l_left_lower_goal_out;         // jl short @@left_lower_goal_out

    {
        word src = *(word *)&g_memByte[455970];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp forceLeftTeam, 1
    if (flags.zero)
        goto cseg_7D8C0;                    // jz cseg_7D8C0

    *(word *)&D1 = 396;                     // mov word ptr D1, 396
    *(word *)&D2 = 744;                     // mov word ptr D2, 744
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    *(byte *)&D4 = 199;                     // mov byte ptr D4, 0C7h
    *(word *)&g_memByte[523130] = 2;        // mov gameState, ST_GOAL_OUT_RIGHT
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    goto cseg_7D9C3;                        // jmp short cseg_7D9C3

l_left_lower_goal_out:;
    {
        word src = *(word *)&g_memByte[455970];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp forceLeftTeam, 1
    if (flags.zero)
        goto l_left_upper_goal_out;         // jz @@left_upper_goal_out

    *(word *)&D1 = 276;                     // mov word ptr D1, 276
    *(word *)&D2 = 744;                     // mov word ptr D2, 744
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    *(byte *)&D4 = 199;                     // mov byte ptr D4, 0C7h
    *(word *)&g_memByte[523130] = 1;        // mov gameState, ST_GOAL_OUT_LEFT
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1

cseg_7D9C3:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+TeamGeneralInfo.playerNumber]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_its_goal_out;                // jnz short @@its_goal_out

    {
        byte res = *(byte *)&D4 & 187;
        *(byte *)&D4 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and byte ptr D4, 0BBh

l_its_goal_out:;
    *(word *)&g_memByte[523114] = 1;        // mov goalOut, 1
    goto l_break_handled;                   // jmp @@break_handled

l_ball_in_pitch:;
    eax = *(dword *)&g_memByte[523104];     // mov eax, lastTeamPlayed
    A6 = eax;                               // mov A6, eax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A6 = eax;                               // mov A6, eax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 336;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 336
    if (flags.sign != flags.overflow)
        goto l_left_half_of_pitch;          // jl short @@left_half_of_pitch

    *(word *)&D1 = 590;                     // mov word ptr D1, 590
    *(word *)&D3 = 6;                       // mov word ptr D3, 6
    *(byte *)&D4 = 241;                     // mov byte ptr D4, 0F1h
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (!flags.zero)
        goto l_rh_right_team_throw_in;      // jnz short @@rh_right_team_throw_in

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 342;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 342
    if (flags.sign != flags.overflow)
        goto cseg_7DAC7;                    // jl cseg_7DAC7

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 556;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 556
    if (flags.sign != flags.overflow)
        goto cseg_7DAD2;                    // jl cseg_7DAD2

    goto cseg_7DADD;                        // jmp cseg_7DADD

l_rh_right_team_throw_in:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 342;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 342
    if (flags.sign != flags.overflow)
        goto cseg_7DAFE;                    // jl cseg_7DAFE

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 556;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 556
    if (flags.sign != flags.overflow)
        goto cseg_7DAF3;                    // jl cseg_7DAF3

    goto cseg_7DAE8;                        // jmp short cseg_7DAE8

l_left_half_of_pitch:;
    *(word *)&D1 = 81;                      // mov word ptr D1, 81
    *(word *)&D3 = 2;                       // mov word ptr D3, 2
    *(byte *)&D4 = 31;                      // mov byte ptr D4, 1Fh
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (!flags.zero)
        goto l_lh_right_team_throw_in;      // jnz short @@lh_right_team_throw_in

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 342;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 342
    if (flags.sign != flags.overflow)
        goto cseg_7DAE8;                    // jl short cseg_7DAE8

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 556;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 556
    if (flags.sign != flags.overflow)
        goto cseg_7DAF3;                    // jl short cseg_7DAF3

    goto cseg_7DAFE;                        // jmp short cseg_7DAFE

l_lh_right_team_throw_in:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 342;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 342
    if (flags.sign != flags.overflow)
        goto cseg_7DADD;                    // jl short cseg_7DADD

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 556;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 556
    if (flags.sign != flags.overflow)
        goto cseg_7DAD2;                    // jl short cseg_7DAD2

cseg_7DAC7:;
    *(word *)&g_memByte[523130] = 15;       // mov gameState, ST_THROW_IN_FORWARD_RIGHT
    goto l_enqueue_throw_in_sample;         // jmp short @@enqueue_throw_in_sample

cseg_7DAD2:;
    *(word *)&g_memByte[523130] = 16;       // mov gameState, ST_THROW_IN_CENTER_RIGHT
    goto l_enqueue_throw_in_sample;         // jmp short @@enqueue_throw_in_sample

cseg_7DADD:;
    *(word *)&g_memByte[523130] = 17;       // mov gameState, ST_THROW_IN_BACK_RIGHT
    goto l_enqueue_throw_in_sample;         // jmp short @@enqueue_throw_in_sample

cseg_7DAE8:;
    *(word *)&g_memByte[523130] = 18;       // mov gameState, ST_THROW_IN_FORWARD_LEFT
    goto l_enqueue_throw_in_sample;         // jmp short @@enqueue_throw_in_sample

cseg_7DAF3:;
    *(word *)&g_memByte[523130] = 19;       // mov gameState, ST_THROW_IN_CENTER_LEFT
    goto l_enqueue_throw_in_sample;         // jmp short @@enqueue_throw_in_sample

cseg_7DAFE:;
    *(word *)&g_memByte[523130] = 20;       // mov gameState, ST_THROW_IN_BACK_LEFT

l_enqueue_throw_in_sample:;
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    EnqueueThrowInSample();                 // call EnqueueThrowInSample

l_break_handled:;
    {
        word src = *(word *)&g_memByte[455970];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp forceLeftTeam, 1
    if (!flags.zero)
        goto cseg_7DB29;                    // jnz short cseg_7DB29

    A6 = 522804;                            // mov A6, offset topTeamData

cseg_7DB29:;
    *(word *)&g_memByte[523128] = 101;      // mov gameStatePl, 101
    *(word *)&g_memByte[523116] = 0;        // mov gameNotInProgressCounterWriteOnly, 0
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[523136] = ax;       // mov foulXCoordinate, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[523138] = ax;       // mov foulYCoordinate, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[523140] = ax;       // mov cameraDirection, ax
    al = D4;                                // mov al, byte ptr D4
    g_memByte[523142] = al;                 // mov byte ptr playerTurnFlags, al
    eax = A6;                               // mov eax, A6
    *(dword *)&g_memByte[523120] = eax;     // mov lastTeamPlayedBeforeBreak, eax
    *(word *)&g_memByte[523124] = 0;        // mov stoppageTimerTotal, 0
    *(word *)&g_memByte[523126] = 0;        // mov stoppageTimerActive, 0
    SWOS::StopAllPlayers();                 // call StopAllPlayers
    *(word *)&g_memByte[449796] = 0;        // mov cameraXVelocity, 0
    *(word *)&g_memByte[449798] = 0;        // mov cameraYVelocity, 0

l_starting_the_game:;
    ax = *(word *)&g_memByte[523680];       // mov ax, playRefereeWhistle
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    SWOS::PlayRefereeWhistleSample();       // call PlayRefereeWhistleSample
}

// =============== S U B R O U T I N E =======================================
//
void CalculateNextBallPosition()
{
    A0 = 328988;                            // mov A0, offset ballSprite
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 30, 4);          // mov eax, [esi+Sprite.x]
    D5 = eax;                               // mov D5, eax
    eax = readMemory(esi + 34, 4);          // mov eax, [esi+Sprite.y]
    D6 = eax;                               // mov D6, eax
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+Sprite.z]
    D7 = eax;                               // mov D7, eax
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_standing_still;              // jz @@standing_still

    eax = readMemory(esi + 46, 4);          // mov eax, [esi+Sprite.deltaX]
    D1 = eax;                               // mov D1, eax
    eax = readMemory(esi + 50, 4);          // mov eax, [esi+Sprite.deltaY]
    D2 = eax;                               // mov D2, eax
    eax = readMemory(esi + 54, 4);          // mov eax, [esi+Sprite.deltaZ]
    D3 = eax;                               // mov D3, eax
    eax = *(dword *)&g_memByte[325648];     // mov eax, kGravityConstant
    D4 = eax;                               // mov D4, eax
    eax = D3;                               // mov eax, D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_ball_very_high;              // jg short @@ball_very_high

    ax = (word)readMemory(esi + 40, 2);     // mov ax, word ptr [esi+(Sprite.z+2)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 20
    if (flags.carry || flags.zero)
        goto l_ball_low;                    // jbe @@ball_low

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 30
    if (flags.carry || flags.zero)
        goto l_ball_a_little_bit_high;      // jbe @@ball_a_little_bit_high

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 35;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 35
    if (flags.carry || flags.zero)
        goto l_ball_high;                   // jbe short @@ball_high

l_ball_very_high:;
    {
        dword res = D1 << 3;
        D1 = res;
    }                                       // shl D1, 3
    {
        dword res = D2 << 3;
        D2 = res;
    }                                       // shl D2, 3
    {
        dword res = D4 << 3;
        D4 = res;
    }                                       // shl D4, 3
    {
        int32_t res = *(int32_t *)&D7 >> 3;
        *(int32_t *)&D7 = res;
    }                                       // sar D7, 3

l_ball_still_in_the_air:;
    eax = D1;                               // mov eax, D1
    {
        int32_t dstSigned = D5;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D5 = res;
    }                                       // add D5, eax
    eax = D2;                               // mov eax, D2
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D6 = res;
    }                                       // add D6, eax
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D3 = res;
    }                                       // sub D3, eax
    eax = D3;                               // mov eax, D3
    {
        int32_t dstSigned = D7;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D7 = res;
    }                                       // add D7, eax
    if (!flags.sign)
        goto l_ball_still_in_the_air;       // jns short @@ball_still_in_the_air

    goto l_standing_still;                  // jmp @@standing_still

l_ball_high:;
    {
        dword res = D1 << 2;
        D1 = res;
    }                                       // shl D1, 2
    {
        dword res = D2 << 2;
        D2 = res;
    }                                       // shl D2, 2
    {
        dword res = D4 << 2;
        D4 = res;
    }                                       // shl D4, 2
    {
        int32_t res = *(int32_t *)&D7 >> 2;
        *(int32_t *)&D7 = res;
    }                                       // sar D7, 2

l_ball_still_in_the_air_2:;
    eax = D1;                               // mov eax, D1
    {
        int32_t dstSigned = D5;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D5 = res;
    }                                       // add D5, eax
    eax = D2;                               // mov eax, D2
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D6 = res;
    }                                       // add D6, eax
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D3 = res;
    }                                       // sub D3, eax
    eax = D3;                               // mov eax, D3
    {
        int32_t dstSigned = D7;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D7 = res;
    }                                       // add D7, eax
    if (!flags.sign)
        goto l_ball_still_in_the_air_2;     // jns short @@ball_still_in_the_air_2

    goto l_standing_still;                  // jmp short @@standing_still

l_ball_a_little_bit_high:;
    {
        dword res = D1 << 1;
        D1 = res;
    }                                       // shl D1, 1
    {
        dword res = D2 << 1;
        D2 = res;
    }                                       // shl D2, 1
    {
        dword res = D4 << 1;
        D4 = res;
    }                                       // shl D4, 1
    {
        int32_t res = *(int32_t *)&D7 >> 1;
        *(int32_t *)&D7 = res;
    }                                       // sar D7, 1

l_ball_still_in_the_air_3:;
    eax = D1;                               // mov eax, D1
    {
        int32_t dstSigned = D5;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D5 = res;
    }                                       // add D5, eax
    eax = D2;                               // mov eax, D2
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D6 = res;
    }                                       // add D6, eax
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D3 = res;
    }                                       // sub D3, eax
    eax = D3;                               // mov eax, D3
    {
        int32_t dstSigned = D7;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D7 = res;
    }                                       // add D7, eax
    if (!flags.sign)
        goto l_ball_still_in_the_air_3;     // jns short @@ball_still_in_the_air_3

    goto l_standing_still;                  // jmp short @@standing_still

l_ball_low:;
    eax = D1;                               // mov eax, D1
    {
        int32_t dstSigned = D5;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D5 = res;
    }                                       // add D5, eax
    eax = D2;                               // mov eax, D2
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D6 = res;
    }                                       // add D6, eax
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D3 = res;
    }                                       // sub D3, eax
    eax = D3;                               // mov eax, D3
    {
        int32_t dstSigned = D7;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D7 = res;
    }                                       // add D7, eax
    if (!flags.sign)
        goto l_ball_low;                    // jns short @@ball_low

l_standing_still:;
    ax = D5;                                // mov ax, word ptr D5
    {
        word tmp = *(word *)((byte *)&D5 + 2);
        *(word *)((byte *)&D5 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D5+2
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    ax = D6;                                // mov ax, word ptr D6
    {
        word tmp = *(word *)((byte *)&D6 + 2);
        *(word *)((byte *)&D6 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D6+2
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&g_memByte[523672] = ax;       // mov ballNextX, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&g_memByte[523674] = ax;       // mov ballNextY, ax
}

// =============== S U B R O U T I N E =======================================
//
void PlayStopGoodPassSampleIfNeeded()
{
    {
        word src = *(word *)&g_memByte[523670];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp goodPassSampleCommand, -1
    if (flags.zero)
        goto l_enqueue_good_pass_sample;    // jz short @@enqueue_good_pass_sample

    {
        word src = *(word *)&g_memByte[523670];
        int16_t dstSigned = src;
        int16_t srcSigned = -2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp goodPassSampleCommand, -2
    if (flags.zero)
        goto l_stop_sample;                 // jz short @@stop_sample

    return;                                 // retn

    *(word *)&g_memByte[523670] = 0;        // mov goodPassSampleCommand, 0
    EnqueueDeletedSample();                 // call EnqueueDeletedSample
    return;                                 // retn

l_stop_sample:;
    *(word *)&g_memByte[523670] = 0;        // mov goodPassSampleCommand, 0
    StopGoodPassSample();                   // call StopGoodPassSample
    return;                                 // retn

l_enqueue_good_pass_sample:;
    *(word *)&g_memByte[523670] = 0;        // mov goodPassSampleCommand, 0
    EnqueuPlayingGoodPassSample();          // call EnqueuPlayingGoodPassSample
}

// =============== S U B R O U T I N E =======================================
//
void EndFirstHalf()
{
    *(word *)&g_memByte[449800] = 0;        // mov hideBall, 0
    *(word *)&g_memByte[523134] = 100;      // mov stoppageEventTimer, 100
    *(word *)&g_memByte[523130] = 29;       // mov gameState, ST_FIRST_HALF_ENDED
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    *(word *)&g_memByte[523128] = 101;      // mov gameStatePl, 101
    *(word *)&g_memByte[523116] = 0;        // mov gameNotInProgressCounterWriteOnly, 0
    *(word *)&g_memByte[523140] = -1;       // mov cameraDirection, -1
    *(dword *)&g_memByte[523120] = 522804;  // mov lastTeamPlayedBeforeBreak, offset topTeamData
    *(word *)&g_memByte[523124] = 0;        // mov stoppageTimerTotal, 0
    *(word *)&g_memByte[523126] = 0;        // mov stoppageTimerActive, 0
    ResetBothTeamsPlayerPassingKicking();   // call ResetBothTeamsPlayerPassingKicking
    *(word *)&g_memByte[449796] = 0;        // mov cameraXVelocity, 0
    *(word *)&g_memByte[449798] = 0;        // mov cameraYVelocity, 0
    ax = *(word *)&g_memByte[252376];       // mov ax, playGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    ax = *(word *)&g_memByte[455988];       // mov ax, goalCounter
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&g_memByte[457544] = 25;       // mov writeOnlyAtEndOfHalf, 25
}

// =============== S U B R O U T I N E =======================================
//
void EndOfGame()
{
    *(word *)&g_memByte[449800] = 0;        // mov hideBall, 0
    *(word *)&g_memByte[523134] = 150;      // mov stoppageEventTimer, 150
    *(word *)&g_memByte[523130] = 30;       // mov gameState, ST_GAME_ENDED
    *(word *)&g_memByte[523132] = -1;       // mov breakCameraMode, -1
    *(word *)&g_memByte[523128] = 101;      // mov gameStatePl, 101
    *(word *)&g_memByte[523116] = 0;        // mov gameNotInProgressCounterWriteOnly, 0
    *(word *)&g_memByte[523140] = -1;       // mov cameraDirection, -1
    *(dword *)&g_memByte[523120] = 522804;  // mov lastTeamPlayedBeforeBreak, offset topTeamData
    *(word *)&g_memByte[523124] = 0;        // mov stoppageTimerTotal, 0
    *(word *)&g_memByte[523126] = 0;        // mov stoppageTimerActive, 0
    ResetBothTeamsPlayerPassingKicking();   // call ResetBothTeamsPlayerPassingKicking
    *(word *)&g_memByte[449796] = 0;        // mov cameraXVelocity, 0
    *(word *)&g_memByte[449798] = 0;        // mov cameraYVelocity, 0
    ax = *(word *)&g_memByte[252376];       // mov ax, playGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    ax = *(word *)&g_memByte[455988];       // mov ax, goalCounter
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&g_memByte[457544] = 25;       // mov writeOnlyAtEndOfHalf, 25
}

// =============== S U B R O U T I N E =======================================
//
void ResetBothTeamsPlayerPassingKicking()
{
    push(A1);                               // push A1
    push(A2);                               // push A2
    ax = *(word *)&g_memByte[523140];       // mov ax, cameraDirection
    *(word *)&g_memByte[449802] = ax;       // mov dseg_130FF9, ax
    ax = *(word *)&g_memByte[523142];       // mov ax, playerTurnFlags
    *(word *)&g_memByte[449804] = ax;       // mov lastPlayerTurnFlags, ax
    A0 = 522804;                            // mov A0, offset topTeamData
    ResetPlayerPassingKicking();            // call ResetPlayerPassingKicking
    A0 = 522952;                            // mov A0, offset bottomTeamData
    ResetPlayerPassingKicking();            // call ResetPlayerPassingKicking
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 140, 2, 0);           // mov [esi+TeamGeneralInfo.goalkeeperPlaying], 0
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team data
//
void ResetPlayerPassingKicking()
{
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 94, 2, 0);            // mov [esi+TeamGeneralInfo.ballInPlay], 0
    writeMemory(esi + 96, 2, 0);            // mov [esi+TeamGeneralInfo.ballOutOfPlay], 0
    writeMemory(esi + 32, 4, 0);            // mov [esi+TeamGeneralInfo.controlledPlayerSprite], 0
    writeMemory(esi + 36, 4, 0);            // mov [esi+TeamGeneralInfo.passToPlayerPtr], 0
    writeMemory(esi + 88, 2, 0);            // mov [esi+TeamGeneralInfo.passingBall], 0
    writeMemory(esi + 90, 2, 0);            // mov [esi+TeamGeneralInfo.passingToPlayer], 0
    writeMemory(esi + 92, 2, 0);            // mov [esi+TeamGeneralInfo.playerSwitchTimer], 0
    writeMemory(esi + 104, 4, 0);           // mov [esi+TeamGeneralInfo.passingKickingPlayer], 0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player
//
void SetJumpHeaderHitAnimTable()
{
    esi = A1;                               // mov esi, A1
    {
        dword src = readMemory(esi + 6, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 452714;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.animationTable], offset jumpHeaderHitAnimTable
    if (flags.zero)
        return;                             // jz short @@out

    ax = (word)readMemory(esi + 98, 2);     // mov ax, [esi+Sprite.heading]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    {
        byte src = (byte)readMemory(esi + 13, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 40;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerDownTimer], 40
    if (!flags.zero)
        return;                             // jnz short @@out

    {
        word src = (word)readMemory(esi + 28, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.frameSwitchCounter], 2
    if (!flags.carry && !flags.zero)
        return;                             // ja short @@out

    {
        byte src = g_memByte[323905];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr currentGameTick+1, 2
    if (flags.zero)
        return;                             // jz short @@out

    A0 = 452714;                            // mov A0, offset jumpHeaderHitAnimTable
    SetAnimationTableAndPictureIndex();     // call SetAnimationTableAndPictureIndex
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 44, 2);
        word res = src >> 1;
        flags.carry = ((word)src >> 15) & 1;
        src = res;
        writeMemory(esi + 44, 2, src);
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr [esi+Sprite.speed], 1
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player (sprite)
//      A6 -> team general data
//
// Static header was activated now we need to aim it somewhere.
//
void SetStaticHeaderDirection()
{
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+TeamGeneralInfo.currentAllowedDirection]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js short @@out

    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 13, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 18;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerDownTimer], 18
    if (!flags.carry && !flags.zero)
        return;                             // ja short @@out

    {
        dword src = readMemory(esi + 6, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 452194;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.animationTable], offset staticHeaderAttemptAnimTable
    if (!flags.zero)
        return;                             // jnz short @@out

    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (flags.zero)
        return;                             // jz short @@out

    if (flags.carry)
        goto l_turn_right;                  // jb short @@turn_right

    {
        word src = (word)readMemory(esi + 42, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 42, 2, src);
    }                                       // sub [esi+Sprite.direction], 1
    goto l_normalize_direction;             // jmp short @@normalize_direction

l_turn_right:;
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 42, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 42, 2, src);
    }                                       // add [esi+Sprite.direction], 1

l_normalize_direction:;
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 42, 2);
        word res = src & 7;
        src = res;
        writeMemory(esi + 42, 2, src);
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and [esi+Sprite.direction], 7
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player (sprite)
//      A6 -> team general info
//
// Runs when a player makes contact with the ball while doing static header.
// Applies ball speed and destination. Increases player speed, updates delta z
// and plays kick sample.
//
void PlayerHittingStaticHeader()
{
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 128, 2, 0);           // mov [esi+TeamGeneralInfo.passInProgress], 0
    esi = A1;                               // mov esi, A1
    {
        dword src = readMemory(esi + 6, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 452454;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.animationTable], offset staticHeaderHitAnimTable
    if (flags.zero)
        goto l_set_static_header_anim_table; // jz @@set_static_header_anim_table

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+TeamGeneralInfo.currentAllowedDirection]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        goto l_set_static_header_anim_table; // jz @@set_static_header_anim_table

    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (flags.zero)
        goto l_set_static_header_anim_table; // jz @@set_static_header_anim_table

    if (flags.carry)
        goto l_turn_player_right;           // jb short @@turn_player_right

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 42, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 42, 2, src);
    }                                       // sub [esi+Sprite.direction], 1
    {
        word src = (word)readMemory(esi + 42, 2);
        word res = src & 7;
        src = res;
        writeMemory(esi + 42, 2, src);
    }                                       // and [esi+Sprite.direction], 7
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_fix_sprite_direction;        // jz short @@fix_sprite_direction

    {
        word src = (word)readMemory(esi + 42, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 42, 2, src);
    }                                       // sub [esi+Sprite.direction], 1
    goto l_fix_sprite_direction;            // jmp short @@fix_sprite_direction

l_turn_player_right:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+Sprite.speed]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 42, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 42, 2, src);
    }                                       // add [esi+Sprite.direction], 1
    {
        word src = (word)readMemory(esi + 42, 2);
        word res = src & 7;
        src = res;
        writeMemory(esi + 42, 2, src);
    }                                       // and [esi+Sprite.direction], 7
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_fix_sprite_direction;        // jz short @@fix_sprite_direction

    {
        word src = (word)readMemory(esi + 42, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 42, 2, src);
    }                                       // add [esi+Sprite.direction], 1

l_fix_sprite_direction:;
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 42, 2);
        word res = src & 7;
        src = res;
        writeMemory(esi + 42, 2, src);
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and [esi+Sprite.direction], 7

l_set_static_header_anim_table:;
    A0 = 452454;                            // mov A0, offset staticHeaderHitAnimTable
    SetAnimationTableAndPictureIndex();     // call SetAnimationTableAndPictureIndex
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 44, 2);     // mov ax, [esi+TeamGeneralInfo.currentAllowedDirection]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    if (!flags.sign)
        goto l_got_direction;               // jns short @@got_direction

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_got_direction:;
    A2 = 328988;                            // mov A2, offset ballSprite
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 56, 2, ax);           // mov [esi+TeamGeneralInfo.controlledPlDirection], ax
    A0 = 523306;                            // mov A0, offset kDefaultDestinations
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx + 2, 2); // mov ax, [esi+ebx+2]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    ax = *(word *)&g_memByte[524734];       // mov ax, kStaticHeaderBallSpeed
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    GetPlayerPointerFromShirtNumber();      // call GetPlayerPointerFromShirtNumber
    A0 = 523778;                            // mov A0, offset kPlayerHeaderSpeedIncrease
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 71, 1);     // mov al, [esi+PlayerGameHeader.heading]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 44, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 44, 2, src);
    }                                       // add [esi+Sprite.speed], ax
    eax = readMemory(esi + 54, 4);          // mov eax, [esi+Sprite.deltaZ]
    D0 = eax;                               // mov D0, eax
    *(int32_t *)&D0 = -*(int32_t *)&D0;     // neg D0
    {
        int32_t res = *(int32_t *)&D0 >> 1;
        flags.carry = ((dword)*(int32_t *)&D0 >> 31) & 1;
        *(int32_t *)&D0 = res;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // sar D0, 1
    eax = D0;                               // mov eax, D0
    writeMemory(esi + 54, 4, eax);          // mov [esi+Sprite.deltaZ], eax
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 98, 2, 1);            // mov [esi+Sprite.heading], 1
    SWOS::PlayKickSample();                 // call PlayKickSample
    ResetBothTeamSpinTimers();              // call ResetBothTeamSpinTimers
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - some direction
//      A1 -> player sprite
//
// Players jumps in place trying to hit static header.
//
void AttemptStaticHeader()
{
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 98, 2, 0);            // mov [esi+Sprite.heading], 0
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 42, 2, ax);           // mov [esi+Sprite.direction], ax
    A5 = 523306;                            // mov A5, offset kDefaultDestinations
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 58, 2, ax);           // mov [esi+Sprite.destX], ax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 60, 2, ax);           // mov [esi+Sprite.destY], ax
    ax = *(word *)&g_memByte[524736];       // mov ax, kStaticHeaderPlayerSpeed
    writeMemory(esi + 44, 2, ax);           // mov [esi+Sprite.speed], ax
    A0 = 452194;                            // mov A0, offset staticHeaderAttemptAnimTable
    SetPlayerAnimationTable();              // call SetPlayerAnimationTable
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 12, 1, 8);            // mov [esi+Sprite.playerState], PL_STATIC_HEADING
    writeMemory(esi + 13, 1, 20);           // mov [esi+Sprite.playerDownTimer], 20
}

// =============== S U B R O U T I N E =======================================

// in:
//      A6 -> team data
//
void AI_SetControlsDirection()
{
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 142, 2);    // mov ax, [esi+TeamGeneralInfo.resetControls]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz return

    ax = *(word *)&g_memByte[527066];       // mov ax, AI_counter
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_bump_resume_play_ai_timer;   // jz short @@bump_resume_play_ai_timer

    {
        word src = *(word *)&g_memByte[527066];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[527066] = src;
    }                                       // sub AI_counter, 1

l_bump_resume_play_ai_timer:;
    ax = *(word *)&g_memByte[527038];       // mov ax, AI_resumePlayTimer
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_generate_rand;               // jz short @@generate_rand

    {
        word src = *(word *)&g_memByte[527038];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[527038] = src;
    }                                       // sub AI_resumePlayTimer, 1

l_generate_rand:;
    SWOS::Rand();                           // call Rand
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[527040] = ax;       // mov AI_rand, ax
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 130, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 130, 2, src);
    }                                       // add [esi+TeamGeneralInfo.AI_timer], 1
    writeMemory(esi + 44, 2, -1);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], -1
    writeMemory(esi + 50, 1, 0);            // mov [esi+TeamGeneralInfo.firePressed], 0
    writeMemory(esi + 51, 1, 0);            // mov [esi+TeamGeneralInfo.fireThisFrame], 0
    writeMemory(esi + 48, 1, 0);            // mov [esi+TeamGeneralInfo.quickFire], 0
    writeMemory(esi + 49, 1, 0);            // mov [esi+TeamGeneralInfo.normalFire], 0
    ax = *(word *)&g_memByte[486154];       // mov ax, g_inSubstitutesMenu
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz return

    *(word *)&D7 = -1;                      // mov word ptr D7, -1
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    A5 = eax;                               // mov A5, eax
    eax = readMemory(esi + 36, 4);          // mov eax, [esi+TeamGeneralInfo.passToPlayerPtr]
    A4 = eax;                               // mov A4, eax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A5, 0
    if (flags.zero)
        goto l_player_direction_set;        // jz short @@player_direction_set

    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax

l_player_direction_set:;
    A0 = 328988;                            // mov A0, offset ballSprite
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522952;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset bottomTeamData
    if (flags.zero)
        goto l_bottom_team;                 // jz short @@bottom_team

    *(word *)&D2 = 769;                     // mov word ptr D2, 769
    goto l_calc_distance;                   // jmp short @@calc_distance

l_bottom_team:;
    *(word *)&D2 = 129;                     // mov word ptr D2, 129

l_calc_distance:;
    *(word *)&D1 = 336;                     // mov word ptr D1, 336
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D3 = res;
    }                                       // sub word ptr D3, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, ax
    ax = D3;                                // mov ax, word ptr D3
    bx = D3;                                // mov bx, word ptr D3
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    *(word *)((byte *)&D3 + 2) = dx;        // mov word ptr D3+2, dx
    ax = D4;                                // mov ax, word ptr D4
    bx = D4;                                // mov bx, word ptr D4
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)((byte *)&D4 + 2) = dx;        // mov word ptr D4+2, dx
    eax = D4;                               // mov eax, D4
    {
        int32_t dstSigned = D3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D3 = res;
    }                                       // add D3, eax
    eax = D3;                               // mov eax, D3
    D6 = eax;                               // mov D6, eax
    ax = (word)readMemory(esi + 32, 2);     // mov ax, word ptr [esi+(Sprite.x+2)]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, word ptr [esi+(Sprite.y+2)]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)&D0 = 256;                     // mov word ptr D0, 256
    push(D5);                               // push D5
    SWOS::CalculateDeltaXAndY();            // call CalculateDeltaXAndY
    pop(D5);                                // pop D5
    if (!flags.sign)
        goto l_save_angle;                  // jns short @@save_angle

    *(word *)&D0 = 0;                       // mov word ptr D0, 0

l_save_angle:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    {
        word src = *(word *)&g_memByte[523128];
        int16_t dstSigned = src;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameStatePl, ST_GAME_IN_PROGRESS
    if (flags.zero)
        goto l_game_in_progress;            // jz @@game_in_progress

    eax = *(dword *)&g_memByte[523120];     // mov eax, lastTeamPlayedBeforeBreak
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, eax
    if (!flags.zero)
        return;                             // jnz return

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 21;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_STARTING_GAME
    if (flags.carry)
        goto l_game_not_over;               // jb @@game_not_over

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_GAME_ENDED
    if (!flags.carry && !flags.zero)
        goto l_game_not_over;               // ja @@game_not_over

    ax = *(word *)&g_memByte[449302];       // mov ax, team1Computer
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_game_not_over;               // jz @@game_not_over

    ax = *(word *)&g_memByte[449304];       // mov ax, team2Computer
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_game_not_over;               // jz @@game_not_over

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_RESULT_ON_HALFTIME
    if (flags.zero)
        goto l_showing_result_on_halftime;  // jz short @@showing_result_on_halftime

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 26;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_RESULT_AFTER_THE_GAME
    if (!flags.zero)
        goto l_not_showing_final_result;    // jnz short @@not_showing_final_result

    {
        word src = *(word *)&g_memByte[523124];
        int16_t dstSigned = src;
        int16_t srcSigned = *(word *)&g_memByte[540876];
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp stoppageTimerTotal, clearResultInterval
    if (flags.carry)
        return;                             // jb return

    goto l_interval_expired_fire;           // jmp short @@interval_expired_fire

l_showing_result_on_halftime:;
    {
        word src = *(word *)&g_memByte[523124];
        int16_t dstSigned = src;
        int16_t srcSigned = *(word *)&g_memByte[540876];
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp stoppageTimerTotal, clearResultInterval
    if (flags.carry)
        return;                             // jb return

    goto l_interval_expired_fire;           // jmp short @@interval_expired_fire

l_not_showing_final_result:;
    {
        word src = *(word *)&g_memByte[523124];
        int16_t dstSigned = src;
        int16_t srcSigned = *(word *)&g_memByte[540880];
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp stoppageTimerTotal, clearResultHalftimeInterval
    if (flags.carry)
        return;                             // jb return

l_interval_expired_fire:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 50, 1, 1);            // mov [esi+TeamGeneralInfo.firePressed], 1
    return;                                 // retn

l_set_direction:;

l_check_if_result_shown:;
    ax = *(word *)&g_memByte[449742];       // mov ax, resultTimer
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz return

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_GOAL_OUT_LEFT
    if (flags.zero)
        goto l_update_turn_direction;       // jz @@update_turn_direction

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_GOAL_OUT_RIGHT
    if (flags.zero)
        goto l_update_turn_direction;       // jz @@update_turn_direction

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (flags.zero)
        goto l_update_turn_direction;       // jz @@update_turn_direction

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_THROW_IN_FORWARD_RIGHT
    if (flags.carry)
        goto l_no_throw_in;                 // jb short @@no_throw_in

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_THROW_IN_BACK_LEFT
    if (flags.carry || flags.zero)
        goto l_update_turn_direction;       // jbe @@update_turn_direction

l_no_throw_in:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FOUL
    if (flags.zero)
        goto l_foul_or_free_kick;           // jz short @@foul_or_free_kick

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FREE_KICK_LEFT1
    if (flags.carry)
        return;                             // jb return

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 12;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FREE_KICK_RIGHT3
    if (!flags.carry && !flags.zero)
        return;                             // ja return

l_foul_or_free_kick:;
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 16
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 >> 5;
        flags.carry = ((word)*(word *)&D0 >> 11) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 5
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    return;                                 // jmp return

l_game_not_over:;
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 63;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 3Fh
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 50;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 50
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 50;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 50
    ax = *(word *)&g_memByte[523126];       // mov ax, stoppageTimerActive
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto l_set_direction;               // ja @@set_direction

    ax = *(word *)&g_memByte[523160];       // mov ax, playingPenalties
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_doing_penalties;             // jnz @@doing_penalties

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 14;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PENALTY
    if (flags.zero)
        goto l_doing_penalties;             // jz @@doing_penalties

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_KEEPER_HOLDS_BALL
    if (flags.zero)
        goto l_keepers_ball;                // jz @@keepers_ball

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_GOAL_OUT_LEFT
    if (flags.zero)
        goto l_keepers_ball;                // jz @@keepers_ball

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_GOAL_OUT_RIGHT
    if (flags.zero)
        goto l_keepers_ball;                // jz @@keepers_ball

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PLAYERS_TO_INITIAL_POSITIONS
    if (flags.zero)
        goto l_goal_scored;                 // jz @@goal_scored

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FREE_KICK_LEFT1
    if (flags.carry)
        goto l_test_throw_in;               // jb short @@test_throw_in

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 12;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FREE_KICK_RIGHT3
    if (flags.carry || flags.zero)
        goto l_free_kick;                   // jbe @@free_kick

l_test_throw_in:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_THROW_IN_FORWARD_RIGHT
    if (flags.carry)
        goto l_test_foul;                   // jb short @@test_foul

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_THROW_IN_BACK_LEFT
    if (!flags.carry && !flags.zero)
        goto l_test_foul;                   // ja short @@test_foul

    ax = *(word *)&g_memByte[523130];       // mov ax, gameState
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ST_THROW_IN_FORWARD_RIGHT
    A0 = 527072;                            // mov A0, offset AI_throwInDirections
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522952;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset bottomTeamData
    if (flags.zero)
        goto cseg_84671;                    // jz cseg_84671

    {
        int newCarry = (*(byte *)&D1 >> 3) & 1;
        *(byte *)&D1 = ((byte)*(byte *)&D1 >> 4) | (*(byte *)&D1 << 4);
        flags.carry = newCarry != 0;
    }                                       // ror byte ptr D1, 4
    goto cseg_84671;                        // jmp cseg_84671

l_test_foul:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FOUL
    if (flags.zero)
        goto l_free_kick;                   // jz @@free_kick

    goto l_apply_after_touch;               // jmp @@apply_after_touch

l_keepers_ball:;
    ax = *(word *)&g_memByte[527040];       // mov ax, AI_rand
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 1;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 1
    if (flags.zero)
        goto cseg_84775;                    // jz cseg_84775

    ax = *(word *)&g_memByte[523140];       // mov ax, cameraDirection
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (flags.zero)
        goto l_apply_after_touch;           // jz @@apply_after_touch

    {
        word src = *(word *)&g_memByte[329020];
        int16_t dstSigned = src;
        int16_t srcSigned = 336;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr ballSprite.x+2, 336
    if (!flags.carry && !flags.zero)
        goto cseg_845CC;                    // ja short cseg_845CC

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 1
    if (flags.zero)
        goto l_apply_after_touch;           // jz @@apply_after_touch

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 3
    if (flags.zero)
        goto l_apply_after_touch;           // jz @@apply_after_touch

    goto cseg_84775;                        // jmp cseg_84775

cseg_845CC:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 5
    if (flags.zero)
        goto l_apply_after_touch;           // jz @@apply_after_touch

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 7
    if (flags.zero)
        goto l_apply_after_touch;           // jz @@apply_after_touch

    goto cseg_84775;                        // jmp cseg_84775

l_goal_scored:;
    {
        word src = *(word *)&g_memByte[523126];
        int16_t dstSigned = src;
        int16_t srcSigned = 150;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp stoppageTimerActive, 150
    if (flags.carry)
        goto cseg_84775;                    // jb cseg_84775

    ax = *(word *)&g_memByte[523140];       // mov ax, cameraDirection
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (flags.zero)
        goto l_apply_after_touch;           // jz @@apply_after_touch

    goto cseg_84775;                        // jmp cseg_84775

    ax = *(word *)&g_memByte[527040];       // mov ax, AI_rand
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Fh
    if (!flags.zero)
        goto l_apply_after_touch;           // jnz @@apply_after_touch

    goto cseg_84775;                        // jmp cseg_84775

    ax = *(word *)&g_memByte[527040];       // mov ax, AI_rand
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Fh
    if (!flags.zero)
        goto cseg_84775;                    // jnz cseg_84775

    goto l_apply_after_touch;               // jmp @@apply_after_touch

l_free_kick:;
    ax = *(word *)&g_memByte[527040];       // mov ax, AI_rand
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Fh
    if (!flags.zero)
        goto cseg_8470F;                    // jnz cseg_8470F

    goto cseg_84775;                        // jmp cseg_84775

cseg_84671:;
    ax = *(word *)&g_memByte[527040];       // mov ax, AI_rand
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Fh
    if (!flags.zero)
        goto cseg_84775;                    // jnz cseg_84775

    cx = D7;                                // mov cx, word ptr D7
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    {
        dword res = D1 & eax;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D1, eax
    if (!flags.zero)
        goto l_apply_after_touch;           // jnz @@apply_after_touch

    goto cseg_84775;                        // jmp cseg_84775

l_doing_penalties:;
    ax = *(word *)&g_memByte[527040];       // mov ax, AI_rand
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    cl = D0;                                // mov cl, byte ptr D0
    ax = 1;                                 // mov ax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            word res = ax << shiftCount;
            ax = res;
        }
    }                                       // shl ax, cl
    {
        word src = *(word *)&g_memByte[523142];
        word res = src & ax;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test playerTurnFlags, ax
    if (flags.zero)
        goto l_penalty_random_direction_disallowed; // jz short @@penalty_random_direction_disallowed

    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    return;                                 // jmp return

l_penalty_random_direction_disallowed:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz return

    {
        word src = (word)readMemory(esi + 42, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.direction], 4
    if (flags.zero)
        return;                             // jz return

    goto l_apply_after_touch;               // jmp short @@apply_after_touch

cseg_8470F:;
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 16
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_apply_after_touch;           // jz short @@apply_after_touch

    goto cseg_84815;                        // jmp cseg_84815

l_apply_after_touch:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js return

    {
        word res = *(word *)&D2 << 5;
        *(word *)&D2 = res;
    }                                       // shl word ptr D2, 5
    al = D5;                                // mov al, byte ptr D5
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D2 = res;
    }                                       // sub byte ptr D2, al
    goto l_update_max_stoppage_time;        // jmp @@update_max_stoppage_time

cseg_84775:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 5;
        flags.carry = ((word)*(word *)&D0 >> 11) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 5
    FindClosestPlayerToBallFacing();        // call FindClosestPlayerToBallFacing
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, -1
    if (flags.zero)
        goto l_update_turn_direction;       // jz @@update_turn_direction

    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+Sprite.teamNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+Sprite.teamNumber]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_update_turn_direction;       // jnz @@update_turn_direction

    goto l_our_player_closest;              // jmp @@our_player_closest

    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 5;
        flags.carry = ((word)*(word *)&D0 >> 11) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 5
    FindClosestPlayerToBallFacing();        // call FindClosestPlayerToBallFacing
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, -1
    if (flags.zero)
        goto l_apply_after_touch;           // jz @@apply_after_touch

    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+Sprite.teamNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+Sprite.teamNumber]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_apply_after_touch;           // jnz @@apply_after_touch

    goto l_our_player_closest;              // jmp @@our_player_closest

cseg_84815:;
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 16
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 >> 5;
        flags.carry = ((word)*(word *)&D0 >> 11) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 5
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    return;                                 // retn

l_update_turn_direction:;
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 14;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Eh
    if (!flags.zero)
        return;                             // jnz return

    ax = *(word *)&g_memByte[527036];       // mov ax, AI_turnDirection
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_8489B;                    // jns short cseg_8489B

    {
        word src = *(word *)&g_memByte[527036];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp AI_turnDirection, -1
    if (flags.zero)
        goto cseg_84890;                    // jz short cseg_84890

    {
        word src = *(word *)&g_memByte[527036];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[527036] = src;
    }                                       // add AI_turnDirection, 1
    {
        word src = *(word *)&g_memByte[527036];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp AI_turnDirection, -1
    if (!flags.zero)
        return;                             // jnz return

cseg_84890:;
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    goto l_apply_turn_direction;            // jmp short @@apply_turn_direction

cseg_8489B:;
    {
        word src = *(word *)&g_memByte[527036];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp AI_turnDirection, 1
    if (flags.zero)
        goto cseg_848BB;                    // jz short cseg_848BB

    {
        word src = *(word *)&g_memByte[527036];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[527036] = src;
    }                                       // sub AI_turnDirection, 1
    {
        word src = *(word *)&g_memByte[527036];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp AI_turnDirection, 1
    if (!flags.zero)
        return;                             // jnz return

cseg_848BB:;
    *(word *)&D1 = -1;                      // mov word ptr D1, -1

l_apply_turn_direction:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[527036];       // mov ax, AI_turnDirection
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    cl = D0;                                // mov cl, byte ptr D0
    ax = 1;                                 // mov ax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            word res = ax << shiftCount;
            ax = res;
        }
    }                                       // shl ax, cl
    {
        word src = *(word *)&g_memByte[523142];
        word res = src & ax;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test playerTurnFlags, ax
    if (flags.zero)
        goto l_save_for_next_frame;         // jz short @@save_for_next_frame

    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    return;                                 // retn

l_save_for_next_frame:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[527036] = ax;       // mov AI_turnDirection, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    return;                                 // retn

l_game_in_progress:;
    ax = *(word *)&g_memByte[523160];       // mov ax, playingPenalties
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_penalty;                     // jnz short @@penalty

    ax = *(word *)&g_memByte[523112];       // mov ax, penalty
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_penalty;                  // jz short @@no_penalty

l_penalty:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 118, 2);    // mov ax, [esi+TeamGeneralInfo.spinTimer]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_ball_after_touch_allowed;    // jns @@ball_after_touch_allowed

l_no_penalty:;
    ax = *(word *)&g_memByte[527066];       // mov ax, AI_counter
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_direction_updated;           // jz short @@direction_updated

    AI_SetDirectionTowardOpponentsGoal();   // call AI_SetDirectionTowardOpponentsGoal

l_direction_updated:;
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A5, 0
    if (flags.zero)
        return;                             // jz return

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 118, 2);    // mov ax, [esi+TeamGeneralInfo.spinTimer]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_ball_after_touch_allowed;    // jns @@ball_after_touch_allowed

    al = (byte)readMemory(esi + 61, 1);     // mov al, [esi+TeamGeneralInfo.plVeryCloseToBall]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_theres_a_player_near;        // jnz short @@theres_a_player_near

    al = (byte)readMemory(esi + 62, 1);     // mov al, [esi+TeamGeneralInfo.plCloseToBall]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_theres_a_player_near;        // jnz short @@theres_a_player_near

    goto l_noone_near;                      // jmp @@noone_near

    eax = *(dword *)&g_memByte[523104];     // mov eax, lastTeamPlayed
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, eax
    if (flags.zero)
        goto l_noone_near;                  // jz @@noone_near

    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 40, 2);     // mov ax, [esi+TeamGeneralInfo.playerHasBall]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_noone_near;                  // jz @@noone_near

    goto cseg_855B1;                        // jmp cseg_855B1

l_theres_a_player_near:;
    AI_DecideWhetherToTriggerFire();        // call AI_DecideWhetherToTriggerFire
    if (flags.zero)
        return;                             // jz return

    ax = *(word *)&g_memByte[449467];       // mov ax, deadVarAlways0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_84A0D;                    // jz short cseg_84A0D

    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[449493];     // mov eax, dseg_1309C1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, eax
    if (!flags.zero)
        goto cseg_84A0D;                    // jnz short cseg_84A0D

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 40, 2);     // mov ax, [esi+TeamGeneralInfo.playerHasBall]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz return

cseg_84A0D:;
    esi = A5;                               // mov esi, A5
    {
        word src = (word)readMemory(esi + 42, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.direction], 2
    if (flags.zero)
        goto l_player_facing_left_or_right; // jz short @@player_facing_left_or_right

    {
        word src = (word)readMemory(esi + 42, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.direction], 6
    if (!flags.zero)
        goto cseg_84A53;                    // jnz short cseg_84A53

l_player_facing_left_or_right:;
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (flags.zero)
        goto l_top_team_test;               // jz short @@top_team_test

    {
        word src = *(word *)&g_memByte[329024];
        int16_t dstSigned = src;
        int16_t srcSigned = 158;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr ballSprite.y+2, 158
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_84AEB;                    // jle cseg_84AEB

    goto cseg_84A53;                        // jmp short cseg_84A53

l_top_team_test:;
    {
        word src = *(word *)&g_memByte[329024];
        int16_t dstSigned = src;
        int16_t srcSigned = 740;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr ballSprite.y+2, 740
    if (flags.sign == flags.overflow)
        goto cseg_84AEB;                    // jge cseg_84AEB

cseg_84A53:;
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = 28800;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D6, 28800
    if (!flags.carry && !flags.zero)
        goto cseg_84AEB;                    // ja cseg_84AEB

    {
        int32_t dstSigned = D6;
        int32_t srcSigned = 12800;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D6, 12800
    if (flags.carry)
        goto cseg_84A85;                    // jb short cseg_84A85

    ax = *(word *)&g_memByte[527040];       // mov ax, AI_rand
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 3
    if (!flags.zero)
        goto cseg_84AEB;                    // jnz short cseg_84AEB

cseg_84A85:;
    *(byte *)&D1 = 15;                      // mov byte ptr D1, 0Fh
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = 3200;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D6, 3200
    if (!flags.carry && !flags.zero)
        goto cseg_84A9F;                    // ja short cseg_84A9F

    *(byte *)&D1 = 50;                      // mov byte ptr D1, 32h

cseg_84A9F:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+42]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_84AEB;                    // js short cseg_84AEB

    {
        word res = *(word *)&D2 << 5;
        *(word *)&D2 = res;
    }                                       // shl word ptr D2, 5
    al = D5;                                // mov al, byte ptr D5
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D2 = res;
    }                                       // sub byte ptr D2, al
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_84AEB;                    // jg short cseg_84AEB

    *(int8_t *)&D1 = -*(int8_t *)&D1;       // neg byte ptr D1
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_850F9;                    // jg cseg_850F9

cseg_84AEB:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 132, 2);    // mov ax, [esi+TeamGeneralInfo.field_84]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_84B5B;                    // jz short cseg_84B5B

    {
        word src = (word)readMemory(esi + 132, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 132, 2, src);
    }                                       // sub [esi+TeamGeneralInfo.field_84], 1
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 5;
        flags.carry = ((word)*(word *)&D0 >> 11) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 5
    FindClosestPlayerToBallFacing();        // call FindClosestPlayerToBallFacing
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, -1
    if (flags.zero)
        goto cseg_84D57;                    // jz cseg_84D57

    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+Sprite.teamNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_our_player_closest;          // jz @@our_player_closest

    goto cseg_84D57;                        // jmp cseg_84D57

cseg_84B5B:;
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = 9800;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D6, 9800
    if (flags.carry)
        goto cseg_84DD3;                    // jb cseg_84DD3

    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A5, 0
    if (flags.zero)
        goto cseg_84DD3;                    // jz cseg_84DD3

    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    A2 = eax;                               // mov A2, eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, 0
    if (flags.zero)
        goto cseg_84BBE;                    // jz short cseg_84BBE

    esi = A2;                               // mov esi, A2
    {
        dword src = readMemory(esi + 74, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 800;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi+74], 800
    if (flags.carry)
        goto cseg_84C00;                    // jb short cseg_84C00

    {
        dword src = readMemory(esi + 74, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 5000;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi+74], 5000
    if (flags.carry)
        goto cseg_84C93;                    // jb cseg_84C93

cseg_84BBE:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 36, 4);          // mov eax, [esi+TeamGeneralInfo.passToPlayerPtr]
    A2 = eax;                               // mov A2, eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, 0
    if (flags.zero)
        goto cseg_84DD3;                    // jz cseg_84DD3

    esi = A2;                               // mov esi, A2
    {
        dword src = readMemory(esi + 74, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 800;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.ballDistance], 800
    if (flags.carry)
        goto cseg_84C00;                    // jb short cseg_84C00

    {
        dword src = readMemory(esi + 74, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 5000;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.ballDistance], 5000
    if (flags.carry)
        goto cseg_84C93;                    // jb cseg_84C93

    goto cseg_84DD3;                        // jmp cseg_84DD3

cseg_84C00:;
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = 180000;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D6, 180000
    if (!flags.carry && !flags.zero)
        goto cseg_84F4B;                    // ja cseg_84F4B

    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 5;
        flags.carry = ((word)*(word *)&D0 >> 11) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 5
    FindClosestPlayerToBallFacing();        // call FindClosestPlayerToBallFacing
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, -1
    if (flags.zero)
        goto cseg_84D10;                    // jz cseg_84D10

    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+Sprite.teamNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_our_player_closest;          // jz @@our_player_closest

    goto cseg_84D10;                        // jmp cseg_84D10

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, -1
    if (!flags.zero)
        goto l_our_player_closest;          // jnz @@our_player_closest

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 130, 2);    // mov ax, [esi+130]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 3
    if (!flags.zero)
        goto cseg_84DD3;                    // jnz cseg_84DD3

    goto l_our_player_closest;              // jmp @@our_player_closest

cseg_84C93:;
    {
        word src = *(word *)&g_memByte[527040];
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp AI_rand, 8
    if (!flags.carry && !flags.zero)
        goto cseg_84CAD;                    // ja short cseg_84CAD

    {
        int32_t dstSigned = D6;
        int32_t srcSigned = 48400;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D6, 48400
    if (!flags.carry && !flags.zero)
        goto cseg_84F4B;                    // ja cseg_84F4B

cseg_84CAD:;
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 12;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Ch
    if (!flags.zero)
        goto cseg_84DD3;                    // jnz cseg_84DD3

    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 5;
        flags.carry = ((word)*(word *)&D0 >> 11) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 5
    FindClosestPlayerToBallFacing();        // call FindClosestPlayerToBallFacing
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, -1
    if (flags.zero)
        goto cseg_84D10;                    // jz short cseg_84D10

    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_our_player_closest;          // jz @@our_player_closest

cseg_84D10:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 132, 2);    // mov ax, [esi+TeamGeneralInfo.field_84]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_84DD3;                    // jnz cseg_84DD3

    ax = *(word *)&g_memByte[323898];       // mov ax, frameCount
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 127;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7Fh
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 20h
    if (!flags.carry)
        goto cseg_84DD3;                    // jnb cseg_84DD3

    writeMemory(esi + 132, 2, 4);           // mov [esi+TeamGeneralInfo.field_84], 4

cseg_84D57:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 61, 1);     // mov al, [esi+TeamGeneralInfo.plVeryCloseToBall]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_84E16;                    // jz cseg_84E16

    {
        byte src = g_memByte[323904];
        byte res = src & 128;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr currentGameTick, 80h
    if (flags.zero)
        goto l_turn_left;                   // jz short @@turn_left

    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 7
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    return;                                 // retn

l_turn_left:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 7
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    return;                                 // retn

cseg_84DD3:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 61, 1);     // mov al, [esi+TeamGeneralInfo.plVeryCloseToBall]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_84E16;                    // jz short cseg_84E16

cseg_84DE0:;
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 16
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 >> 5;
        flags.carry = ((word)*(word *)&D0 >> 11) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 5
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    return;                                 // retn

cseg_84E16:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    return;                                 // retn

l_decide_if_flipping_direction:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 82, 2);     // mov ax, [esi+Sprite.fullDirection]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 128;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 128
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 16
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_set_opposite_direction;      // jz short @@set_opposite_direction

    {
        dword src = readMemory(esi + 74, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 800;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.ballDistance], 800
    if (flags.carry)
        goto l_set_opposite_direction;      // jb short @@set_opposite_direction

    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 14;
        *(word *)&D1 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D1, 0Eh
    if (flags.zero)
        goto l_set_opposite_direction;      // jz short @@set_opposite_direction

    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    return;                                 // retn

l_set_opposite_direction:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    return;                                 // retn

l_use_current_player_direction:;
    ax = D7;                                // mov ax, word ptr D7
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    SWOS::WriteAmigaModeDirectionFlip();    // call WriteAmigaModeDirectionFlip
    return;                                 // retn

l_our_player_closest:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 132, 2, 0);           // mov [esi+TeamGeneralInfo.field_84], 0
    ax = *(word *)&g_memByte[527038];       // mov ax, AI_resumePlayTimer
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz return

    AI_ResumeGameDelay();                   // call AI_ResumeGameDelay
    if (!flags.carry)
        return;                             // jnb return

    *(word *)&g_memByte[527038] = 15;       // mov AI_resumePlayTimer, 15
    ax = D7;                                // mov ax, word ptr D7
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    writeMemory(esi + 48, 1, 1);            // mov [esi+TeamGeneralInfo.quickFire], 1
    ax = *(word *)&g_memByte[455990];       // mov ax, AI_maxStoppageTime
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[523126];       // mov ax, stoppageTimerActive
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto l_jmp_return;                  // ja short @@jmp_return

    ax = *(word *)&g_memByte[523126];       // mov ax, stoppageTimerActive
    *(word *)&g_memByte[455990] = ax;       // mov AI_maxStoppageTime, ax

l_jmp_return:;
    return;                                 // jmp return

cseg_84F4B:;
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 16
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 7
    if (flags.zero)
        goto cseg_84FA0;                    // jz short cseg_84FA0

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto cseg_84FA0;                    // jz short cseg_84FA0

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -1
    if (flags.zero)
        goto cseg_84FA0;                    // jz short cseg_84FA0

    goto cseg_84D10;                        // jmp cseg_84D10

cseg_84FA0:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 134, 2, 2);           // mov [esi+TeamGeneralInfo.AI_afterTouchStrength], 2
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = 115600;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D6, 115600
    if (!flags.carry && !flags.zero)
        goto cseg_84FCA;                    // ja short cseg_84FCA

    writeMemory(esi + 134, 2, 1);           // mov [esi+TeamGeneralInfo.AI_afterTouchStrength], 1

cseg_84FCA:;
    ax = D7;                                // mov ax, word ptr D7
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    writeMemory(esi + 49, 1, 1);            // mov [esi+TeamGeneralInfo.normalFire], 1
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        word res = *(word *)&D2 << 5;
        *(word *)&D2 = res;
    }                                       // shl word ptr D2, 5
    al = D5;                                // mov al, byte ptr D5
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D2 = res;
    }                                       // sub byte ptr D2, al
    *(word *)&g_memByte[527038] = 15;       // mov AI_resumePlayTimer, 15
    *(word *)&D0 = -1;                      // mov word ptr D0, -1
    al = D2;                                // mov al, byte ptr D2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.sign)
        goto cseg_85025;                    // jns short cseg_85025

    *(int16_t *)&D0 = -*(int16_t *)&D0;     // neg word ptr D0

cseg_85025:;
    eax = *(dword *)&g_memByte[329038];     // mov eax, ballSprite.deltaY
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.sign)
        goto cseg_8503F;                    // js short cseg_8503F

    {
        word src = *(word *)&g_memByte[329024];
        int16_t dstSigned = src;
        int16_t srcSigned = 555;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr ballSprite.y+2, 555
    if (!flags.carry && !flags.zero)
        goto cseg_850E1;                    // ja cseg_850E1

    goto cseg_8504E;                        // jmp short cseg_8504E

cseg_8503F:;
    {
        word src = *(word *)&g_memByte[329024];
        int16_t dstSigned = src;
        int16_t srcSigned = 342;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr ballSprite.y+2, 342
    if (flags.carry)
        goto cseg_850E1;                    // jb cseg_850E1

cseg_8504E:;
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 28;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 1Ch
    {
        word res = *(word *)&D1 >> 2;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 2
    {
        word src = *(word *)&g_memByte[329020];
        int16_t dstSigned = src;
        int16_t srcSigned = 193;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr ballSprite.x+2, 193
    if (flags.carry)
        goto cseg_85080;                    // jb short cseg_85080

    {
        word src = *(word *)&g_memByte[329020];
        int16_t dstSigned = src;
        int16_t srcSigned = 478;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr ballSprite.x+2, 478
    if (flags.carry)
        goto cseg_85097;                    // jb short cseg_85097

cseg_85080:;
    {
        word src = *(word *)&g_memByte[329020];
        int16_t dstSigned = src;
        int16_t srcSigned = 118;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr ballSprite.x+2, 118
    if (flags.carry)
        goto cseg_850C5;                    // jb short cseg_850C5

    {
        word src = *(word *)&g_memByte[329020];
        int16_t dstSigned = src;
        int16_t srcSigned = 553;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr ballSprite.x+2, 553
    if (!flags.carry && !flags.zero)
        goto cseg_850C5;                    // ja short cseg_850C5

    goto cseg_850AE;                        // jmp short cseg_850AE

cseg_85097:;
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_850CF;                    // jz short cseg_850CF

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 5
    if (flags.carry)
        goto cseg_850E1;                    // jb short cseg_850E1

    goto cseg_850DA;                        // jmp short cseg_850DA

cseg_850AE:;
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_850DA;                    // jz short cseg_850DA

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 4
    if (flags.carry)
        goto cseg_850CF;                    // jb short cseg_850CF

    goto cseg_850E1;                        // jmp short cseg_850E1

cseg_850C5:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 4
    if (flags.carry)
        goto cseg_850E1;                    // jb short cseg_850E1

cseg_850CF:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    goto cseg_850E1;                        // jmp short cseg_850E1

cseg_850DA:;
    flags.carry = *(int16_t *)&D0 != 0;
    flags.overflow = *(int16_t *)&D0 == INT16_MIN;
    *(int16_t *)&D0 = -*(int16_t *)&D0;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // neg word ptr D0

cseg_850E1:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 136, 2, ax);          // mov [esi+TeamGeneralInfo.AI_ballSpinDirection], ax
    return;                                 // jmp return

cseg_850F9:;
    ax = *(word *)&g_memByte[527038];       // mov ax, AI_resumePlayTimer
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz return

    AI_ResumeGameDelay();                   // call AI_ResumeGameDelay
    if (!flags.carry)
        return;                             // jnb return

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 134, 2, 0);           // mov [esi+TeamGeneralInfo.AI_afterTouchStrength], 0
    goto cseg_85178;                        // jmp short cseg_85178

    ax = *(word *)&g_memByte[527038];       // mov ax, AI_resumePlayTimer
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz return

    AI_ResumeGameDelay();                   // call AI_ResumeGameDelay
    if (!flags.carry)
        return;                             // jnb return

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 134, 2, 1);           // mov [esi+TeamGeneralInfo.AI_afterTouchStrength], 1
    goto cseg_85178;                        // jmp short cseg_85178

    ax = *(word *)&g_memByte[527038];       // mov ax, AI_resumePlayTimer
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz return

    AI_ResumeGameDelay();                   // call AI_ResumeGameDelay
    if (!flags.carry)
        return;                             // jnb return

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 134, 2, 2);           // mov [esi+TeamGeneralInfo.AI_afterTouchStrength], 2

cseg_85178:;
    *(word *)&g_memByte[527038] = 15;       // mov AI_resumePlayTimer, 15
    ax = D7;                                // mov ax, word ptr D7
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    writeMemory(esi + 49, 1, 1);            // mov [esi+TeamGeneralInfo.normalFire], 1
    *(word *)&D0 = -1;                      // mov word ptr D0, -1
    al = D2;                                // mov al, byte ptr D2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.sign)
        goto cseg_851B4;                    // jns short cseg_851B4

    flags.carry = *(int16_t *)&D0 != 0;
    flags.overflow = *(int16_t *)&D0 == INT16_MIN;
    *(int16_t *)&D0 = -*(int16_t *)&D0;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // neg word ptr D0

cseg_851B4:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 136, 2, ax);          // mov [esi+TeamGeneralInfo.AI_ballSpinDirection], ax
    return;                                 // jmp return

l_update_max_stoppage_time:;
    ax = *(word *)&g_memByte[455990];       // mov ax, AI_maxStoppageTime
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[523126];       // mov ax, stoppageTimerActive
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto l_decide_after_touch_strength; // ja short @@decide_after_touch_strength

    ax = *(word *)&g_memByte[523126];       // mov ax, stoppageTimerActive
    *(word *)&g_memByte[455990] = ax;       // mov AI_maxStoppageTime, ax

l_decide_after_touch_strength:;
    *(word *)&g_memByte[527038] = 15;       // mov AI_resumePlayTimer, 15
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 14;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PENALTY
    if (flags.zero)
        goto l_weak_after_touch;            // jz @@weak_after_touch

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PENALTIES
    if (flags.zero)
        goto l_weak_after_touch;            // jz @@weak_after_touch

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FREE_KICK_LEFT1
    if (flags.carry)
        goto l_test_corner;                 // jb short @@test_corner

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 12;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FREE_KICK_RIGHT3
    if (flags.carry || flags.zero)
        goto l_check_distance_from_the_goal; // jbe short @@check_distance_from_the_goal

l_test_corner:;
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_CORNER_LEFT
    if (flags.zero)
        goto l_medium_after_touch;          // jz short @@medium_after_touch

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_CORNER_RIGHT
    if (flags.zero)
        goto l_medium_after_touch;          // jz short @@medium_after_touch

    ax = *(word *)&g_memByte[527040];       // mov ax, AI_rand
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 24;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 18h
    if (!flags.zero)
        goto l_check_distance_from_the_goal; // jnz short @@check_distance_from_the_goal

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 10h
    if (flags.zero)
        goto l_weak_after_touch;            // jz short @@weak_after_touch

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 8
    if (flags.zero)
        goto l_medium_after_touch;          // jz short @@medium_after_touch

    goto l_strong_after_touch;              // jmp short @@strong_after_touch

l_check_distance_from_the_goal:;
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = 28800;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D6, 28800
    if (flags.carry)
        goto l_weak_after_touch;            // jb short @@weak_after_touch

    {
        int32_t dstSigned = D6;
        int32_t srcSigned = 57800;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D6, 57800
    if (flags.carry)
        goto l_medium_after_touch;          // jb short @@medium_after_touch

l_strong_after_touch:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 134, 2, 2);           // mov [esi+TeamGeneralInfo.AI_afterTouchStrength], 2
    goto l_activate_normal_fire;            // jmp short @@activate_normal_fire

l_medium_after_touch:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 134, 2, 1);           // mov [esi+TeamGeneralInfo.AI_afterTouchStrength], 1
    goto l_activate_normal_fire;            // jmp short @@activate_normal_fire

l_weak_after_touch:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 134, 2, 0);           // mov [esi+TeamGeneralInfo.AI_afterTouchStrength], 0

l_activate_normal_fire:;
    ax = D7;                                // mov ax, word ptr D7
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    writeMemory(esi + 49, 1, 1);            // mov [esi+TeamGeneralInfo.normalFire], 1
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 14;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PENALTY
    if (flags.zero)
        goto l_no_after_touch;              // jz @@no_after_touch

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_PENALTIES
    if (flags.zero)
        goto l_no_after_touch;              // jz @@no_after_touch

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_CORNER_LEFT
    if (flags.zero)
        goto l_corner;                      // jz @@corner

    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_CORNER_RIGHT
    if (flags.zero)
        goto l_corner;                      // jz @@corner

    *(word *)&g_memByte[527038] = 15;       // mov AI_resumePlayTimer, 15
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    writeMemory(esi + 49, 1, 1);            // mov [esi+TeamGeneralInfo.normalFire], 1
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    {
        word src = *(word *)&g_memByte[523130];
        int16_t dstSigned = src;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp gameState, ST_FOUL
    if (!flags.zero)
        goto cseg_8536B;                    // jnz short cseg_8536B

    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (!flags.zero)
        goto cseg_8535D;                    // jnz short cseg_8535D

    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 682;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.y+2)], 682
    if (flags.sign == flags.overflow)
        goto cseg_85384;                    // jge short cseg_85384

    goto cseg_8536B;                        // jmp short cseg_8536B

cseg_8535D:;
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 36, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 216;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+(Sprite.y+2)], 216
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_85384;                    // jle short cseg_85384

cseg_8536B:;
    *(word *)&D0 = -1;                      // mov word ptr D0, -1
    al = D2;                                // mov al, byte ptr D2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.sign)
        goto cseg_85384;                    // jns short cseg_85384

    flags.carry = *(int16_t *)&D0 != 0;
    flags.overflow = *(int16_t *)&D0 == INT16_MIN;
    *(int16_t *)&D0 = -*(int16_t *)&D0;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // neg word ptr D0

cseg_85384:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 136, 2, ax);          // mov [esi+TeamGeneralInfo.AI_ballSpinDirection], ax
    return;                                 // jmp return

l_corner:;
    ax = *(word *)&g_memByte[527040];       // mov ax, AI_rand
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 3
    if (flags.carry)
        goto cseg_853FA;                    // jb short cseg_853FA

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 6
    if (flags.carry)
        goto cseg_853DB;                    // jb short cseg_853DB

l_no_after_touch:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 136, 2, 0);           // mov [esi+TeamGeneralInfo.AI_ballSpinDirection], 0
    return;                                 // jmp return

cseg_853DB:;
    *(word *)&D1 = -1;                      // mov word ptr D1, -1
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    goto cseg_85417;                        // jmp short cseg_85417

cseg_853FA:;
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1

cseg_85417:;
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    cl = D0;                                // mov cl, byte ptr D0
    ax = 1;                                 // mov ax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            word res = ax << shiftCount;
            ax = res;
        }
    }                                       // shl ax, cl
    {
        word src = *(word *)&g_memByte[523142];
        word res = src & ax;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test playerTurnFlags, ax
    if (flags.zero)
        goto l_no_after_touch;              // jz short @@no_after_touch

    ax = D1;                                // mov ax, word ptr D1
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 136, 2, ax);          // mov [esi+TeamGeneralInfo.AI_ballSpinDirection], ax
    return;                                 // jmp return

l_noone_near:;
    AI_DecideWhetherToTriggerFire();        // call AI_DecideWhetherToTriggerFire
    if (flags.zero)
        return;                             // jz return

    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, 0
    if (flags.zero)
        goto l_pass_to_player_too_far_or_null; // jz short @@pass_to_player_too_far_or_null

    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    D0 = eax;                               // mov D0, eax
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D0 = res;
    }                                       // sub D0, eax
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 50;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 50
    if (flags.sign != flags.overflow)
        goto l_pass_to_player_too_far_or_null; // jl short @@pass_to_player_too_far_or_null

    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 36, 4);          // mov eax, [esi+TeamGeneralInfo.passToPlayerPtr]
    D0 = eax;                               // mov D0, eax
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    writeMemory(esi + 36, 4, eax);          // mov [esi+TeamGeneralInfo.passToPlayerPtr], eax
    eax = D0;                               // mov eax, D0
    writeMemory(esi + 32, 4, eax);          // mov [esi+TeamGeneralInfo.controlledPlayerSprite], eax
    return;                                 // jmp return

l_pass_to_player_too_far_or_null:;
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, 0
    if (flags.zero)
        goto l_decide_if_flipping_direction; // jz @@decide_if_flipping_direction

    ax = *(word *)&g_memByte[449467];       // mov ax, deadVarAlways0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_84DE0;                    // jnz cseg_84DE0

    ax = *(word *)&g_memByte[522808];       // mov ax, topTeamData.playerNumber
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_jmp_decide_if_flipping_direction; // jnz short @@jmp_decide_if_flipping_direction

    ax = *(word *)&g_memByte[522956];       // mov ax, bottomTeamData.playerNumber
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_jmp_decide_if_flipping_direction; // jnz short @@jmp_decide_if_flipping_direction

    goto l_randomly_flip_or_continue_direction; // jmp short @@randomly_flip_or_continue_direction

l_jmp_decide_if_flipping_direction:;
    goto l_decide_if_flipping_direction;    // jmp @@decide_if_flipping_direction

    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    D0 = eax;                               // mov D0, eax
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D0 = res;
    }                                       // sub D0, eax
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 800;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 800
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_decide_if_flipping_direction; // jg @@decide_if_flipping_direction

l_randomly_flip_or_continue_direction:;
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 24;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 18h
    if (!flags.zero)
        goto l_use_current_player_direction; // jnz @@use_current_player_direction

    SWOS::CheckForAmigaModeDirectionFlipBan(); // call CheckForAmigaModeDirectionFlipBan
    ax = *(word *)&g_memByte[527040];       // mov ax, AI_rand
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 2;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 2
    A0 = 527044;                            // mov A0, offset AI_randomRotateTable
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 82, 2);     // mov ax, [esi+Sprite.fullDirection]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 128;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 128
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 16
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 >> 5;
        flags.carry = ((word)*(word *)&D0 >> 11) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 5
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    return;                                 // retn

cseg_855B1:;
    goto cseg_84DD3;                        // jmp cseg_84DD3

    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, 0
    if (flags.zero)
        goto l_decide_if_flipping_direction; // jz @@decide_if_flipping_direction

    esi = A5;                               // mov esi, A5
    {
        dword src = readMemory(esi + 74, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 2450;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.ballDistance], 2450
    if (!flags.carry && !flags.zero)
        goto l_decide_if_flipping_direction; // ja @@decide_if_flipping_direction

    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_decide_if_flipping_direction; // js @@decide_if_flipping_direction

    {
        word res = *(word *)&D0 << 5;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 5
    al = D5;                                // mov al, byte ptr D5
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 15;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 15
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_decide_if_flipping_direction; // jg @@decide_if_flipping_direction

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 241;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 241
    if (flags.sign != flags.overflow)
        goto l_decide_if_flipping_direction; // jl @@decide_if_flipping_direction

    ax = D7;                                // mov ax, word ptr D7
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    writeMemory(esi + 51, 1, 1);            // mov [esi+TeamGeneralInfo.fireThisFrame], 1
    return;                                 // jmp return

l_ball_after_touch_allowed:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 56, 2);     // mov ax, [esi+TeamGeneralInfo.controlledPlDirection]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[523160];       // mov ax, playingPenalties
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_no_ball_after_touch;         // jnz short @@no_ball_after_touch

    ax = *(word *)&g_memByte[523112];       // mov ax, penalty
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_no_ball_after_touch;         // jnz short @@no_ball_after_touch

    ax = *(word *)&g_memByte[527040];       // mov ax, AI_rand
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 1;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 1
    if (flags.zero)
        goto l_no_ball_after_touch;         // jz short @@no_ball_after_touch

    ax = (word)readMemory(esi + 136, 2);    // mov ax, [esi+TeamGeneralInfo.AI_ballSpinDirection]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_apply_left_spin;             // js short @@apply_left_spin

    if (!flags.zero)
        goto l_apply_right_spin;            // jnz short @@apply_right_spin

l_no_ball_after_touch:;
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 134, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.AI_afterTouchStrength], 1
    if (!flags.zero)
        goto l_do_long_kick;                // jnz short @@do_long_kick

    writeMemory(esi + 44, 2, -1);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], -1
    return;                                 // retn

    ax = (word)readMemory(esi + 56, 2);     // mov ax, [esi+TeamGeneralInfo.controlledPlDirection]
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    return;                                 // retn

l_do_long_kick:;
    A0 = 527060;                            // mov A0, offset AI_longKickTable
    goto l_set_new_direction_for_kick_pass; // jmp short @@set_new_direction_for_kick_pass

l_apply_left_spin:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 7
    A0 = 527048;                            // mov A0, offset AI_leftSpinTable
    goto l_set_new_direction_for_kick_pass; // jmp short @@set_new_direction_for_kick_pass

l_apply_right_spin:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    A0 = 527054;                            // mov A0, offset AI_rotateRightTable

l_set_new_direction_for_kick_pass:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 134, 2);    // mov ax, [esi+TeamGeneralInfo.AI_afterTouchStrength]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    {
        word res = *(word *)&D1 & 7;
        *(word *)&D1 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D1, 7
    ax = D1;                                // mov ax, word ptr D1
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
}

// =============== S U B R O U T I N E =======================================

// in:
//     A6 -> team data
//
// Set the direction toward the opposing goal and the ball.
// Limits for ball x are less than 300, 300...371 and greater than 371.
//
void AI_SetDirectionTowardOpponentsGoal()
{
    ax = *(word *)&g_memByte[527066];       // mov ax, AI_counter
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    ax = *(word *)&g_memByte[329020];       // mov ax, word ptr ballSprite.x+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word src = *(word *)&g_memByte[527068];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp AI_attackHalf, 1
    if (flags.zero)
        goto l_attacking_top;               // jz short @@attacking_top

    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (!flags.zero)
        return;                             // jnz @@out

    *(word *)&D1 = 3;                       // mov word ptr D1, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 300;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 300
    if (flags.carry)
        goto l_set_allowed_direction;       // jb short @@set_allowed_direction

    *(word *)&D1 = 5;                       // mov word ptr D1, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 371;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 371
    if (!flags.carry && !flags.zero)
        goto l_set_allowed_direction;       // ja short @@set_allowed_direction

    *(word *)&D1 = 4;                       // mov word ptr D1, 4
    goto l_set_allowed_direction;           // jmp short @@set_allowed_direction

l_attacking_top:;
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522952;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset bottomTeamData
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 300;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 300
    if (flags.carry)
        goto l_set_allowed_direction;       // jb short @@set_allowed_direction

    *(word *)&D1 = 7;                       // mov word ptr D1, 7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 371;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 371
    if (!flags.carry && !flags.zero)
        goto l_set_allowed_direction;       // ja short @@set_allowed_direction

    *(word *)&D1 = 0;                       // mov word ptr D1, 0

l_set_allowed_direction:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    return;                                 // jmp short return

l_out:;
    return;                                 // retn
}

// =============== S U B R O U T I N E =======================================

// in:
//      D7 - controlled player direction
//      A5 -> controlled player sprite
//      A6 -> team general data
// out:
//      D0, zero flag - 0/set: firing, !0/clear: not gonna fire
//
void AI_DecideWhetherToTriggerFire()
{
    esi = A5;                               // mov esi, A5
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerOrdinal], 1
    if (flags.zero)
        goto l_no_fire;                     // jz @@no_fire

    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (!flags.zero)
        goto l_we_are_top;                  // jnz short @@we_are_top

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 3
    if (flags.zero)
        goto l_facing_toward_opponents_goal; // jz short @@facing_toward_opponents_goal

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 4
    if (flags.zero)
        goto l_facing_toward_opponents_goal; // jz short @@facing_toward_opponents_goal

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 5
    if (flags.zero)
        goto l_facing_toward_opponents_goal; // jz short @@facing_toward_opponents_goal

    goto l_no_fire;                         // jmp @@no_fire

l_we_are_top:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 7
    if (flags.zero)
        goto l_facing_toward_opponents_goal; // jz short @@facing_toward_opponents_goal

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 0
    if (flags.zero)
        goto l_facing_toward_opponents_goal; // jz short @@facing_toward_opponents_goal

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 1
    if (!flags.zero)
        goto l_no_fire;                     // jnz @@no_fire

l_facing_toward_opponents_goal:;
    esi = A5;                               // mov esi, A5
    {
        dword src = readMemory(esi + 74, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 648;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.ballDistance], 648
    if (!flags.carry && !flags.zero)
        goto l_no_fire;                     // ja @@no_fire

    eax = *(dword *)&g_memByte[329042];     // mov eax, ballSprite.deltaZ
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.sign)
        goto l_ball_falling;                // js short @@ball_falling

    {
        word src = *(word *)&g_memByte[329028];
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr ballSprite.z+2, 8
    if (flags.carry)
        goto l_no_fire;                     // jb @@no_fire

    {
        word src = *(word *)&g_memByte[329028];
        int16_t dstSigned = src;
        int16_t srcSigned = 14;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr ballSprite.z+2, 14
    if (!flags.carry && !flags.zero)
        goto l_no_fire;                     // ja @@no_fire

    goto l_trigger_joypad;                  // jmp short @@trigger_joypad

l_ball_falling:;
    {
        word src = *(word *)&g_memByte[329028];
        int16_t dstSigned = src;
        int16_t srcSigned = 12;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr ballSprite.z+2, 12
    if (flags.carry)
        goto l_no_fire;                     // jb @@no_fire

    {
        word src = *(word *)&g_memByte[329028];
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr ballSprite.z+2, 20
    if (!flags.carry && !flags.zero)
        goto l_no_fire;                     // ja @@no_fire

l_trigger_joypad:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 51, 1, 1);            // mov [esi+TeamGeneralInfo.fireThisFrame], 1
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 82, 2);     // mov ax, [esi+Sprite.fullDirection]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 128;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 128
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 82, 2);     // mov ax, [esi+Sprite.fullDirection]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 128;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 128
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 16
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_no_fire;                     // jnz short @@no_fire

    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    *(word *)&g_memByte[527066] = 15;       // mov AI_counter, 15
    *(word *)&g_memByte[527070] = ax;       // mov AI_counterWriteOnly, ax
    *(word *)&g_memByte[527068] = 2;        // mov AI_attackHalf, 2
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 522804;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset topTeamData
    if (flags.zero)
        goto l_out_fire;                    // jz short @@out_fire

    *(word *)&g_memByte[527068] = 1;        // mov AI_attackHalf, 1

l_out_fire:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

l_no_fire:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A6 -> team (general)
// out:
//      A0 -> opponents team
//      carry flag = pass/kick time == 13
//
// Only used by AI.
//
void AI_ResumeGameDelay()
{
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A0 = eax;                               // mov A0, eax
    {
        word src = (word)readMemory(esi + 102, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGeneralInfo.passKickTimer], 13
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 -  full direction player must be facing (+/- 16)
//      A6 -> team (general)
// out:
//      D2 - ball distance
//      A0 -> player
//
// Find player closest to ball facing specified direction. Search both teams.
//
void FindClosestPlayerToBallFacing()
{
    A0 = -1;                                // mov A0, -1
    D2 = -1;                                // mov D2, -1
    *(word *)&D3 = 1;                       // mov word ptr D3, 1
    *(word *)&D4 = 10;                      // mov word ptr D4, 10
    A3 = 522804;                            // mov A3, offset topTeamData
    esi = A3;                               // mov esi, A3
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+TeamGeneralInfo.spritesTable]
    A2 = eax;                               // mov A2, eax

l_players_loop:;
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 4
    A1 = eax;                               // mov A1, eax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, eax
    if (flags.zero)
        goto l_next_player;                 // jz short @@next_player

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 108, 2);    // mov ax, [esi+Sprite.sentAway]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_next_player;                 // jnz short @@next_player

    {
        byte src = (byte)readMemory(esi + 12, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.playerState], PL_NORMAL
    if (!flags.zero)
        goto l_next_player;                 // jnz short @@next_player

    ax = (word)readMemory(esi + 82, 2);     // mov ax, [esi+Sprite.fullDirection]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    al = D0;                                // mov al, byte ptr D0
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D1 = res;
    }                                       // sub byte ptr D1, al
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 240;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, 240
    if (flags.sign != flags.overflow)
        goto l_next_player;                 // jl short @@next_player

    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 16;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, 16
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_next_player;                 // jg short @@next_player

    eax = readMemory(esi + 74, 4);          // mov eax, [esi+Sprite.ballDistance]
    D1 = eax;                               // mov D1, eax
    eax = D2;                               // mov eax, D2
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, eax
    if (!flags.carry)
        goto l_next_player;                 // jnb short @@next_player

    eax = D1;                               // mov eax, D1
    D2 = eax;                               // mov D2, eax
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax

l_next_player:;
    (*(int16_t *)&D4)--;
    flags.overflow = (int16_t)(*(int16_t *)&D4) == INT16_MIN;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto l_players_loop;                // jns @@players_loop

    *(word *)&D4 = 10;                      // mov word ptr D4, 10
    A3 = 522952;                            // mov A3, offset bottomTeamData
    esi = A3;                               // mov esi, A3
    eax = readMemory(esi + 20, 4);          // mov eax, [esi+TeamGeneralInfo.spritesTable]
    A2 = eax;                               // mov A2, eax
    (*(int16_t *)&D3)--;
    flags.overflow = (int16_t)(*(int16_t *)&D3) == INT16_MIN;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto l_players_loop;                // jns @@players_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> player controlling the ball
//      A6 -> team general info
//
void AI_Kick()
{
    ax = *(word *)&g_memByte[449467];       // mov ax, deadVarAlways0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_85B62;                    // jz short cseg_85B62

    eax = *(dword *)&g_memByte[449493];     // mov eax, dseg_1309C1
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, eax
    if (flags.zero)
        return;                             // jz @@out

    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[449493];     // mov eax, dseg_1309C1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, eax
    if (flags.zero)
        return;                             // jz @@out

cseg_85B62:;
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 6;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 6
    esi = A1;                               // mov esi, A1
    {
        dword src = readMemory(esi + 74, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 200;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+Sprite.ballDistance], 200
    if (!flags.carry && !flags.zero)
        return;                             // ja @@out

    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+TeamGeneralInfo.allowedDirections]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi+TeamGeneralInfo.opponentsTeam]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 40, 2);     // mov ax, [esi+TeamGeneralInfo.playerHasBall]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    eax = readMemory(esi + 32, 4);          // mov eax, [esi+TeamGeneralInfo.controlledPlayerSprite]
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        return;                             // jz short @@out

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+TeamGeneralInfo.allowedDirections]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 5;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 5
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 42, 2);     // mov ax, [esi+Sprite.direction]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 << 5;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 5
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 224;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 224
    if (flags.sign != flags.overflow)
        goto l_kick;                        // jl short @@kick

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 32;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 32
    if (flags.zero || flags.sign != flags.overflow)
        return;                             // jle short @@out

l_kick:;
    ax = D7;                                // mov ax, word ptr D7
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 44, 2, ax);           // mov [esi+TeamGeneralInfo.currentAllowedDirection], ax
    writeMemory(esi + 50, 1, 1);            // mov [esi+TeamGeneralInfo.firePressed], 1
    writeMemory(esi + 51, 1, 1);            // mov [esi+TeamGeneralInfo.fireThisFrame], 1
    writeMemory(esi + 49, 1, 1);            // mov [esi+TeamGeneralInfo.normalFire], 1
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - number of teams
//
void cseg_87D60()
{
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A3 = eax;                               // mov A3, eax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_87D72:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A3 = res;
    }                                       // add A3, 684
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_87D72;                    // jns short cseg_87D72
}

// =============== S U B R O U T I N E =======================================
//
void cseg_87DA0()
{
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 10, 1);
        byte res = src & 0;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+0Ah], 0
    if (flags.zero)
        goto cseg_87DAF;                    // jz short cseg_87DAF

    debugBreak();                           // int 3

cseg_87DAD:;
    goto cseg_87DAD;                        // jmp short cseg_87DAD

cseg_87DAF:;
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    push(A5);                               // push A5
    InitDIYCup();                           // call InitDIYCup
    pop(A5);                                // pop A5
    A6 = 318643;                            // mov A6, offset DIY_competitionStart
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 59, 2, 1);            // mov word ptr [esi+3Bh], 1
    A1 = 27119;                             // mov A1, offset dseg_C707E

cseg_87DEA:;
    esi = A1;                               // mov esi, A1
    {
        dword src = readMemory(esi, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi], 0FFFFFFFFh
    if (flags.zero)
        goto cseg_87E18;                    // jz short cseg_87E18

    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A5, eax
    if (!flags.zero)
        goto cseg_87DEA;                    // jnz short cseg_87DEA

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 59, 2, 0);            // mov word ptr [esi+3Bh], 0

cseg_87E18:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 45, 1, al);           // mov [esi+2Dh], al
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 13, 1);     // mov al, [esi+0Dh]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 91, 2, ax);           // mov [esi+5Bh], ax
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 3, 1);      // mov al, [esi+3]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 55, 1, al);           // mov [esi+37h], al
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 4, 1);      // mov al, [esi+4]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 56, 1, al);           // mov [esi+38h], al
    writeMemory(esi + 51, 2, 1);            // mov word ptr [esi+33h], 1
    {
        word src = *(word *)&g_memByte[131708];
        int16_t dstSigned = src;
        int16_t srcSigned = 65534;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_pitchType, SEASONAL
    if (flags.zero)
        goto cseg_87EAA;                    // jz short cseg_87EAA

    writeMemory(esi + 51, 2, 0);            // mov word ptr [esi+33h], 0
    ax = *(word *)&g_memByte[131708];       // mov ax, g_pitchType
    writeMemory(esi + 53, 2, ax);           // mov [esi+35h], ax

cseg_87EAA:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 10, 1);     // mov al, [esi+0Ah]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 49, 2, ax);           // mov [esi+31h], ax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4
    A1 = eax;                               // mov A1, eax
    cseg_95C18();                           // call cseg_95C18
    if (flags.zero)
        goto cseg_87F5B;                    // jz short cseg_87F5B

    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 24755;                             // mov A0, offset countriesTable
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 1
    A0 = eax;                               // mov A0, eax

cseg_87F34:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_87F34;                    // jnz short cseg_87F34

    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 32);                // mov byte ptr [esi], 20h
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 1

cseg_87F5B:;
    A0 = 18110;                             // mov A0, offset aCup
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_87FAC;                    // jz short cseg_87FAC

    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, offset aChairmanScenes
    A0 = eax;                               // mov A0, eax

cseg_87FAC:;
    eax = A0;                               // mov eax, A0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 39, 4, eax);          // mov [esi+27h], eax
    StringCopy();                           // call StringCopy
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 11, 1);     // mov al, [esi+0Bh]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 93, 2, ax);           // mov [esi+5Dh], ax
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 12, 1);     // mov al, [esi+0Ch]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 240;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0F0h
    {
        word res = *(word *)&D0 >> 4;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 4
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 95, 2, ax);           // mov [esi+5Fh], ax
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 12, 1);     // mov al, [esi+0Ch]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0Fh
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 97, 2, ax);           // mov [esi+61h], ax
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1

cseg_8805F:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    {
        word res = *(word *)&D0 >> 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 1
    if (!flags.zero)
        goto cseg_8805F;                    // jnz short cseg_8805F

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1
    eax = A5;                               // mov eax, A5
    A0 = eax;                               // mov A0, eax
    eax = A6;                               // mov eax, A6
    A1 = eax;                               // mov A1, eax

cseg_8808C:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 14, 1);     // mov al, [esi+0Eh]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 192;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0C0h
    {
        word res = *(word *)&D0 >> 6;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 6
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 101, 2, ax);          // mov [esi+65h], ax
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 48;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 30h
    {
        word res = *(word *)&D0 >> 4;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 4
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 113, 2, ax);          // mov [esi+71h], ax
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 12;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0Ch
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 125, 2, ax);          // mov [esi+7Dh], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 1
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_8808C;                    // jns cseg_8808C

    push(A5);                               // push A5
    cseg_268C6();                           // call cseg_268C6
    pop(A5);                                // pop A5
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 9, 1);      // mov al, [esi+9]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_88170;                    // jz short cseg_88170

    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[318732] = ax;       // mov dseg_10EF02, ax

cseg_88170:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 8, 1);      // mov al, [esi+8]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        return;                             // jnz short cseg_88182

    cseg_28139();                           // call cseg_28139
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0
//
void cseg_88183()
{
    {
        word src = *(word *)&g_memByte[126568];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp competitionFileBuffer, 1
    if (flags.zero)
        goto l_diy_cup;                     // jz short @@diy_cup

    {
        word src = *(word *)&g_memByte[126568];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp competitionFileBuffer, 2
    if (flags.zero)
        goto l_diy_tournament;              // jz short @@diy_tournament

    A1 = 126869;                            // mov A1, offset dseg_DF623
    ax = *(word *)&g_memByte[126617];       // mov ax, numDiyTeams
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    goto cseg_881E6;                        // jmp short cseg_881E6

l_diy_cup:;
    A1 = 127157;                            // mov A1, offset dseg_DF743
    ax = *(word *)&g_memByte[126617];       // mov ax, numDiyTeams
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    goto cseg_881E6;                        // jmp short cseg_881E6

l_diy_tournament:;
    A1 = 126721;                            // mov A1, offset dseg_DF58F
    ax = *(word *)&g_memByte[126617];       // mov ax, numDiyTeams
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_881E6:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax

cseg_88200:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        return;                             // jz short @@out

    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_88200;                    // jns short cseg_88200

    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_88373()
{
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 64h
    if (!flags.carry)
        { cseg_883A5(); return; }           // jnb short cseg_883A5

    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 48);                // mov byte ptr [esi], 30h
    (*(int32_t *)&A1)++;                    // inc A1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0Ah
    if (!flags.carry)
        { cseg_883A5(); return; }           // jnb short cseg_883A5

    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 48);                // mov byte ptr [esi], 30h
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1

    cseg_883A5();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_883A5()
{
    push(D0);                               // push D0
    SWOS::Int2Ascii();                      // call Int2Ascii
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_883B8()
{
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 0
    if (flags.zero)
        { cseg_8F1F2(); return; }           // jz cseg_8F1F2

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 1
    if (flags.zero)
        { cseg_87DA0(); return; }           // jz cseg_87DA0

    cseg_24DFA();                           // jmp cseg_24DFA
}

// =============== S U B R O U T I N E =======================================
//
void cseg_883DD()
{
    A4 = 318643;                            // mov A4, offset DIY_competitionStart
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+79]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+81]
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    {
        word res = *(word *)&D5 << 1;
        *(word *)&D5 = res;
    }                                       // shl word ptr D5, 1
    D6 = 0;                                 // mov D6, 0

cseg_88420:;
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 109;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 109
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = D6;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, D6
    A1 = eax;                               // mov A1, eax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+81]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        *(word *)&D3 = res;
    }                                       // sub word ptr D3, 2

cseg_8844B:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2
    A2 = eax;                               // mov A2, eax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D2 = ax;                      // mov word ptr D2, ax

cseg_88464:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A4;                               // mov eax, A4
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A4;                               // mov eax, A4
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A3 = eax;                               // mov A3, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 707, 2);    // mov ax, [esi+707]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 707, 2);    // mov ax, [esi+707]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto cseg_88644;                    // ja cseg_88644

    if (flags.carry)
        goto cseg_88610;                    // jb cseg_88610

    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 707, 2);    // mov ax, [esi+707]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto cseg_88644;                    // ja cseg_88644

    if (flags.carry)
        goto cseg_88610;                    // jb cseg_88610

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 703, 2);    // mov ax, [esi+703]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 705, 2);    // mov ax, [esi+705]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 703, 2);    // mov ax, [esi+703]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 705, 2);    // mov ax, [esi+705]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_88644;                    // jg cseg_88644

    if (flags.sign != flags.overflow)
        goto cseg_88610;                    // jl cseg_88610

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 703, 2);    // mov ax, [esi+703]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 703, 2);    // mov ax, [esi+703]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto cseg_88644;                    // ja cseg_88644

    if (flags.carry)
        goto cseg_88610;                    // jb short cseg_88610

    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    A5 = eax;                               // mov A5, eax
    A6 = eax;                               // mov A6, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+691]
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, eax
    esi = A3;                               // mov esi, A3
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+691]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, eax

cseg_885DF:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_88644;                    // jz short cseg_88644

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A6)++;                    // inc A6
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_88644;                    // jb short cseg_88644

    if (!flags.carry && !flags.zero)
        goto cseg_88610;                    // ja short cseg_88610

    goto cseg_885DF;                        // jmp short cseg_885DF

cseg_88610:;
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        A3 = res;
    }                                       // sub A3, eax
    ax = A3;                                // mov ax, word ptr A3
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        A0 = res;
    }                                       // sub A0, eax
    ax = A0;                                // mov ax, word ptr A0
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, ax);                // mov [esi], ax

cseg_88644:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A2 = res;
    }                                       // add A2, 2
    (*(int16_t *)&D2)--;
    flags.overflow = (int16_t)(*(int16_t *)&D2) == INT16_MIN;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_88464;                    // jns cseg_88464

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D3)--;
    flags.overflow = (int16_t)(*(int16_t *)&D3) == INT16_MIN;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_8844B;                    // jns cseg_8844B

    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax
    (*(int16_t *)&D7)--;
    flags.overflow = (int16_t)(*(int16_t *)&D7) == INT16_MIN;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_88420;                    // jns cseg_88420
}

// =============== S U B R O U T I N E =======================================
//
void cseg_88688()
{
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    {
        word src = *(word *)&g_memByte[318736];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp diyLeaguePlayEachTeam, 1
    if (!flags.zero)
        goto cseg_886A2;                    // jnz short cseg_886A2

    *(byte *)&D0 = 255;                     // mov byte ptr D0, 0FFh

cseg_886A2:;
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 99, 2);     // mov ax, [esi+63h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 101, 2);    // mov ax, [esi+65h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+2Bh]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_2B7D8();                           // call cseg_2B7D8
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    *(byte *)&D7 = 0;                       // mov byte ptr D7, 0
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_8871F;                    // jnz short cseg_8871F

    *(byte *)&D7 |= 128;                    // or byte ptr D7, 80h
    {
        byte res = *(byte *)&D7 & 253;
        *(byte *)&D7 = res;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and byte ptr D7, 0FDh
    goto cseg_8874A;                        // jmp short cseg_8874A

cseg_8871F:;
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.carry && !flags.zero)
        goto cseg_88735;                    // ja short cseg_88735

    {
        byte res = *(byte *)&D7 & 254;
        *(byte *)&D7 = res;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and byte ptr D7, 0FEh
    goto cseg_8873C;                        // jmp short cseg_8873C

cseg_88735:;
    *(byte *)&D7 |= 1;                      // or byte ptr D7, 1

cseg_8873C:;
    *(byte *)&D7 |= 128;                    // or byte ptr D7, 80h
    *(byte *)&D7 |= 2;                      // or byte ptr D7, 2

cseg_8874A:;
    ax = *(word *)&g_memByte[379876];       // mov ax, dseg_11F9CC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_88960

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_88775;                    // jz short cseg_88775

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (!flags.zero)
        return;                             // jnz cseg_88960

cseg_88775:;
    *(word *)&g_memByte[529332] = 0;        // mov dseg_180584, 0
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_88796;                    // jnz short cseg_88796

    *(word *)&g_memByte[529332] = 65535;    // mov dseg_180584, 0FFFFh

cseg_88796:;
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_908B4();                           // call cseg_908B4
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2D553();                           // call cseg_2D553
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    *(word *)&g_memByte[91350] = 0;         // mov dseg_D6B64, 0
    {
        byte res = *(byte *)&D7 & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr D7, 2
    if (flags.zero)
        return;                             // jz short cseg_88960

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_88945;                    // jz short cseg_88945

    {
        byte res = *(byte *)&D7 & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr D7, 1
    if (!flags.zero)
        goto cseg_8894E;                    // jnz short cseg_8894E

    return;                                 // jmp short cseg_88960

cseg_88945:;
    {
        byte res = *(byte *)&D7 & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr D7, 1
    if (!flags.zero)
        return;                             // jnz short cseg_88960

cseg_8894E:;
    *(word *)&g_memByte[529332] = 65535;    // mov dseg_180584, 0FFFFh
    *(word *)&g_memByte[91350] = 1;         // mov dseg_D6B64, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_88961()
{
    cseg_89758();                           // call cseg_89758
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+691]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 4, 1);      // mov al, [esi+4]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+2B3h]
    A2 = eax;                               // mov A2, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, eax
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 4, 1);      // mov al, [esi+4]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = D1;                                // mov al, byte ptr D1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        return;                             // jz short cseg_88A10

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1
    if (flags.zero)
        return;                             // jz short cseg_88A10

    eax = D0;                               // mov eax, D0
    {
        dword tmp = D1;
        D1 = eax;
        eax = tmp;
    }                                       // xchg eax, D1
    D0 = eax;                               // mov D0, eax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1
    if (flags.zero)
        return;                             // jz short cseg_88A10

    *(word *)&D0 = 2;                       // mov word ptr D0, 2
}

