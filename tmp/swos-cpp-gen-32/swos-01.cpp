// automatically generated by ida2asm, do not edit!

#include "vm.h"
#include "defs.h"

#ifdef _MSC_VER
# pragma warning(disable: 4309 4146 4333 4805 4102)
#endif

using namespace SwosVM;

extern void ShowMenu();
extern void CheckIsTeamNational();
extern void PlayTrainingGame();
extern void ActivateMenu();
extern void DrawMenu();
extern void GetBankBalance();
extern void GetPlayerGameBreakPosition();
extern void SetBenchPlayersNumbers();
extern void IsPlayerInjured();
extern void IsTeamNational();
extern void cseg_3E04F();
extern void DrawMultipleItems();
extern void SetupTeamSubstitutes();
extern void cseg_3E608();
extern void DrawMenuItem();
extern void ShowDesignDIYTournamentMenu();
extern void ShowDesignDIYCupMenu();
extern void ShowDesignDIYLeagueMenu();
extern void SelectTeamsForPresetCompetition();
extern void cseg_87D60();
extern void cseg_8F1F2();
extern void cseg_89AC8();
extern void cseg_87DA0();
extern void cseg_89A34();
extern void cseg_4C6EE();
extern void InitNewSeason();
extern void RestoreDIYTournament();
extern void cseg_89A7E();
extern void cseg_89B5C();
extern void cseg_89956();
extern void cseg_8AC02();
extern void cseg_899A0();
extern void cseg_899EA();
extern void cseg_8AC90();
extern void cseg_45B51();
extern void cseg_8AED0();
extern void ShowDiyLeaguesTournamentMenu();
extern void SaveDIYFile();
extern void SavePresetCompetitionFile();
extern void j_SaveCareerFile();
extern void SelectFileToSaveDialog();
extern void SaveCareerFile();
extern void GetFilenameAndExtension();
extern void ShowErrorMenu();
extern void LoadDIYFile();
extern void LoadPresetFile();
extern void j_LoadCareerFile();
extern void LoadCareerFile();
extern void SetZeroFlag();
extern void EditCustomTeam();
extern void EditTactics();
extern void nullsub_9();
extern void SetCurrentEntry();
extern void Int2Ascii();
extern void GoGetTeamsForPlay();
extern void SaveSelectedTeams();
extern void RestoreSelectedTeams();
extern void cseg_31F79();
extern void cseg_32024();
extern void LoadSomeEuroCup();
extern void cseg_320A3();
extern void InitializeInGameTeamsAndStartGame();
extern void cseg_3E642();
extern void ShowPlayMatchMenu();
extern void LoadTeamFile();
extern void cseg_94C7E();
extern void nullsub_12();
extern void DoContinueAbortMenu();
extern void cseg_95C18();
extern void cseg_31CFE();
extern void EndProgram();
extern void GetAveragePlayerPrice();
extern void Rand2();
extern void cseg_2D64E();
extern void FadeAndPlayWinCupAnimation();
extern void FadeAndPlayLoseCupAnimation();
extern void cseg_908B4();
extern void cseg_2D553();
extern void cseg_2C3CC();
extern void cseg_2CFD5();
extern void cseg_2C9D9();
extern void cseg_64D5A();
extern void cseg_903B1();
extern void cseg_2C88E();
extern void cseg_2C47D();
extern void cseg_94A16();

// first pass forward declarations
void SelectAndShowSquadToView();
void cseg_10520();
void cseg_1053F();
void SquadInit();
void SquadFinish();
void SelectTraining();
void SelectGoals();
void SquadOnSelect11();
void j_SetExitMenuFlag();
void SquadOnSelect45();
void Squad45AfterDraw();
void cseg_114EC();
void nullsub_25();
void cseg_116E8();
void SquadCommon();
void cseg_125F4();
void SquadAfterDrawCommon();
void cseg_1377B();
void SquadMenuSavePlayerPositions();
void cseg_1390D();
void UpdateBigCheckMark();
void cseg_13A55();
void cseg_13DFB();
void SetMenuEntryPlayerFace();
void SelTeamForTacticsInit();
void SelTeamForTacticsExit();
void SelTeamForTacticsCommon();
void cseg_147AB();
void ChooseTeamForEditTactics();
void RotatePlayersLeft();
void FormTopSkillsString();
void cseg_15075();
void AssignFakeGoalsToScorers();
void EnqueueCornerSample();
void EnqueueThrowInSample();
void EnqueueDeletedSample();
void StopGoodPassSample();
void EnqueuPlayingGoodPassSample();
void RingABell();
void ProgramPIT();
void InitMenuMusic();
void ConvertSpriteColors();
void DrawSpriteCentered();
void DrawSprite();
void SetExitMenuFlag();
void ReadTimerDelta();
void SetDefaultNameAndSurname();
void CalcMenuEntryAddress();
void CallDrawMultipleItems();
void CallDrawMenuItem();
void CopyWholeSprite();
void nullsub_5();
void ZeroOutStars();
void InitCareerVariables();
void StringCopy();
void Randomize2();
void GetStringLength();
void PrintFormatted();
void InitUserTactics();
void InitializeTacticsPositions();
void nullsub_17();
void StringCopyUntilChar();
void ChangePitchType();
void ChangeGameLength();
void ChangeAutoReplays();
void ChangeAllPlTeamsEqual();
void ChangeAutoSaveHighlights();
void SaveOptions();
void RestoreOptions();
void CycleMenuMusic();
void GlobalRetn();
void CommonMenuExit();
void FriendlyMenu();
void DIYCompetitionMenu();
void PresetCompetitionMenu();
void SeasonMenu();
void CareerMenu();
void StartContest();
void SaveContest();
void LoadOldCompetitionMenu();
void EditCustomTeamMenu();
void EditTacticsMenu();
void SaveDiskFilingMenu();
void FriendlyMenuInit();
void FriendlyMenuReinit();
void DrawNumbersOfSubstitutes();
void DisableEntries();
void FriendlyOK();
void jmpSetExitMenuFlag();
void ChooseTeamsMenu();
void PitchTypeOrSeasonProc();
void SetFriendlyPitchOrSeason();
void FriendlyPitchTypeProc();
void MinSubstitutes();
void MaxSubstitutes();
void SetSelectTwoTeamsText();
void RandomlySwapTeams();
void Friendly();
void ShowFriendlyMenu();
void ContestInProgress();
void cseg_234DF();
void cseg_2352D();
void cseg_23538();
void cseg_235E4();
void cseg_2364C();
void SearchTeamInTmdFile();
void FindTeamInCache();
void InitTeams();
void TeamInit();
void RetnProc();
void PlayFriendly();
void InitAndPlayGame();
void SetupPlayers();
void GetPlayerAtIndex();
void cseg_24132();
void GetTeamPointer();
void GetPlayer();
void cseg_243BD();
void ExtractSurname();
void cseg_247C8();
void cseg_2484B();
void cseg_24AB6();
void GetPlayerRandomNum();
void CheckContinueAbortPrompt();
void CareerInitVars();
void cseg_24DFA();
void cseg_254F8();
void cseg_2573C();
void cseg_258E4();
void nullsub_13();
void cseg_260A9();
void cseg_26280();
void cseg_26395();
void cseg_2653B();
void InitDIYCup();
void cseg_268C6();
void cseg_26A78();
void cseg_26DFC();
void VerifyTeamLoaded();
void cseg_27227();
void cseg_2730A();
void cseg_27436();
void cseg_275C4();
void cseg_277E5();
void cseg_27B4B();
void cseg_27F08();
void SaveDIYTournament();
void cseg_27FFF();
void cseg_28049();
void cseg_28076();
void cseg_280C0();
void cseg_28139();
void RestoreDIYLeague();
void cseg_28243();
void SaveDIYLeague();
void cseg_283BD();
void cseg_284AB();
void cseg_284D8();
void cseg_288E2();
void cseg_289AC();
void cseg_28DC6();
void cseg_28E76();
void cseg_29635();
void cseg_29659();
void cseg_2974C();
void cseg_29858();
void cseg_29B4A();
void cseg_29E00();
void cseg_29E79();
void cseg_2A71E();
void cseg_2AA86();
void cseg_2ABF0();
void cseg_2AC34();
void cseg_2ACAE();
void cseg_2AE07();
void cseg_2AE97();
void cseg_2B7D8();
void cseg_2B81B();
void cseg_2B84D();
void CalculateViewResult();
void cseg_2C05E();
void cseg_2C0D3();

// =============== S U B R O U T I N E =======================================
//
void SelectAndShowSquadToView()
{
    A0 = 16750;                             // mov A0, offset aSelectSquadToV
    push(D1);                               // push D1
    ChooseTeamForEditTactics();             // call ChooseTeamForEditTactics
    pop(D1);                                // pop D1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        return;                             // jz short @@out

    cseg_1053F();                           // jmp short cseg_1053F
}

// =============== S U B R O U T I N E =======================================
//
void cseg_10520()
{
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    pop(D1);                                // pop D1

    cseg_1053F();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_1053F()
{
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[483808] = eax;     // mov dseg_16F486, eax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[483796] = ax;       // mov dseg_16F47A, ax
    *(word *)&g_memByte[131753] = ax;       // mov inEditTactics, ax
    ax = *(word *)&g_memByte[318686];       // mov ax, dseg_10EED4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (!flags.zero)
        goto cseg_1057A;                    // jnz short cseg_1057A

    *(word *)&D0 = 0;                       // mov word ptr D0, 0

cseg_1057A:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[483812] = ax;       // mov teamSkillDiffAfterChange, ax
    ax = *(word *)&g_memByte[129472];       // mov ax, g_gameType
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto cseg_105BB;                    // jz short cseg_105BB

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (flags.zero)
        goto cseg_105BB;                    // jz short cseg_105BB

    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_105BB;                    // jz short cseg_105BB

    *(word *)&g_memByte[483812] = -1;       // mov teamSkillDiffAfterChange, -1

cseg_105BB:;
    A6 = 484144;                            // mov A6, offset squadMenu
    push(A5);                               // push A5
    SWOS::ShowMenu();                       // call ShowMenu
    pop(A5);                                // pop A5
}

// =============== S U B R O U T I N E =======================================
//
void SquadInit()
{
    *(word *)&g_memByte[483822] = 0;        // mov isNationalSquad, 0
    {
        dword src = *(dword *)&g_memByte[483808];
        int32_t dstSigned = src;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_16F486, offset careerTeam
    if (!flags.zero)
        goto cseg_10600;                    // jnz short cseg_10600

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_10600;                    // jz short cseg_10600

    *(word *)&g_memByte[483822] = 1;        // mov isNationalSquad, 1

cseg_10600:;
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    D0 = eax;                               // mov D0, eax
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    D0 |= eax;                              // or D0, eax
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    D0 |= eax;
    flags.carry = false;
    flags.sign = (D0 & 0x80000000) != 0;
    flags.zero = D0 == 0;                   // or D0, eax
    if (!flags.zero)
        goto cseg_10856;                    // jnz cseg_10856

    eax = A0;                               // mov eax, A0
    push(D0);                               // push D0
    D0 = 59;                                // mov D0, 59
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 60;                                // mov D0, 60
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 61;                                // mov D0, 61
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 62;                                // mov D0, 62
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 21;                                // mov D0, 21
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20

cseg_10856:;
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto cseg_10A07;                    // jnz cseg_10A07

    eax = A0;                               // mov eax, A0
    push(D0);                               // push D0
    D0 = 59;                                // mov D0, 59
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 60;                                // mov D0, 60
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 61;                                // mov D0, 61
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20

cseg_10A07:;
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto cseg_10B2C;                    // jnz cseg_10B2C

    eax = A0;                               // mov eax, A0
    push(D0);                               // push D0
    D0 = 59;                                // mov D0, 59
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 60;                                // mov D0, 60
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20

cseg_10B2C:;
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto cseg_10BC5;                    // jnz cseg_10BC5

    eax = A0;                               // mov eax, A0
    push(D0);                               // push D0
    D0 = 59;                                // mov D0, 59
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+20], 20

cseg_10BC5:;
    ax = *(word *)&g_memByte[483812];       // mov ax, teamSkillDiffAfterChange
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_10EA2;                    // jns cseg_10EA2

    push(D0);                               // push D0
    D0 = 59;                                // mov D0, 59
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+20]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 183;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 183
    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1
    ax = *(word *)&g_memByte[483822];       // mov ax, isNationalSquad
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_10C63;                    // jz short cseg_10C63

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 8
    push(D0);                               // push D0
    D0 = 16;                                // mov D0, 16
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub word ptr [esi+20], 8
    push(D0);                               // push D0
    D0 = 59;                                // mov D0, 59
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0

cseg_10C63:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+20], ax
    push(D0);                               // push D0
    D0 = 60;                                // mov D0, 60
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+20], ax
    push(D0);                               // push D0
    D0 = 61;                                // mov D0, 61
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+20], ax
    push(D0);                               // push D0
    D0 = 62;                                // mov D0, 62
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+20], ax
    push(D0);                               // push D0
    D0 = 63;                                // mov D0, 63
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+20], ax
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+20], ax
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+20], ax
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+20], ax
    push(D0);                               // push D0
    D0 = 21;                                // mov D0, 21
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+20], ax
    push(D0);                               // push D0
    D0 = 22;                                // mov D0, 22
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+20], ax
    push(D0);                               // push D0
    D0 = 24;                                // mov D0, 24
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+20], ax
    push(D0);                               // push D0
    D0 = 25;                                // mov D0, 25
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+20], ax
    push(D0);                               // push D0
    D0 = 26;                                // mov D0, 26
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+20], ax
    push(D0);                               // push D0
    D0 = 27;                                // mov D0, 27
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+20], ax

cseg_10EA2:;
    ax = *(word *)&g_memByte[483812];       // mov ax, teamSkillDiffAfterChange
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_10F39;                    // js cseg_10F39

    push(D0);                               // push D0
    D0 = 24;                                // mov D0, 24
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 50;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub word ptr [esi+20], 50
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub word ptr [esi+22], 10
    push(D0);                               // push D0
    D0 = 25;                                // mov D0, 25
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 50;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub word ptr [esi+20], 50
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub word ptr [esi+22], 10
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub word ptr [esi+20], 31

cseg_10F39:;

    SquadFinish();
}

// =============== S U B R O U T I N E =======================================
//
void SquadFinish()
{
    ax = *(word *)&g_memByte[483822];       // mov ax, isNationalSquad
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_1100A;                    // jnz cseg_1100A

    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 80
    if (flags.carry)
        goto cseg_1100A;                    // jb cseg_1100A

    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 85;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 85
    if (!flags.carry && !flags.zero)
        goto cseg_1100A;                    // ja cseg_1100A

    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub word ptr [esi+20], 13
    push(D0);                               // push D0
    D0 = 55;                                // mov D0, 55
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub word ptr [esi+20], 13
    push(D0);                               // push D0
    D0 = 24;                                // mov D0, 24
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub word ptr [esi+20], 13
    push(D0);                               // push D0
    D0 = 25;                                // mov D0, 25
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub word ptr [esi+20], 13

cseg_1100A:;
    CheckIsTeamNational();                  // call CheckIsTeamNational
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A0 = eax;                               // mov A0, eax
    SetBenchPlayersNumbers();               // call SetBenchPlayersNumbers
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -1
    if (flags.zero)
        goto cseg_11050;                    // jz short cseg_11050

    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_1105B;                    // jz short cseg_1105B

cseg_11050:;
    *(word *)&D0 = 16;                      // mov word ptr D0, 16
    goto cseg_11067;                        // jmp short cseg_11067

cseg_1105B:;
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_11067:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[483806] = ax;       // mov dseg_16F484, ax
    *(dword *)&g_memByte[483818] = 0;       // mov dseg_16F490, 0
    *(word *)&g_memByte[483814] = -1;       // mov dseg_16F48C, -1
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A6 = eax;                               // mov A6, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    *(word *)&D0 = 44;                      // mov word ptr D0, 44
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 45;                      // mov word ptr D0, 45
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[483806];       // mov ax, dseg_16F484
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 16
    if (flags.zero)
        goto cseg_1111A;                    // jz short cseg_1111A

    *(word *)&D0 = 44;                      // mov word ptr D0, 44
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1
    if (flags.zero)
        goto cseg_1111A;                    // jz short cseg_1111A

    *(word *)&D0 = 45;                      // mov word ptr D0, 45
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_1111A:;
    push(D0);                               // push D0
    D0 = 21;                                // mov D0, 21
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A1 = 24755;                             // mov A1, offset countriesTable
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A1 = 332112;                            // mov A1, offset dseg_113A32
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax
    ax = *(word *)&g_memByte[483822];       // mov ax, isNationalSquad
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_112C6;                    // jz cseg_112C6

    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    A1 = eax;                               // mov A1, eax
    cseg_15075();                           // call cseg_15075
    push(D0);                               // push D0
    D0 = 22;                                // mov D0, 22
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    A1 = eax;                               // mov A1, eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, 0
    if (flags.zero)
        goto cseg_112B8;                    // jz cseg_112B8

    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A2;                               // mov eax, A2
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax
    cseg_15075();                           // call cseg_15075
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    A1 = eax;                               // mov A1, eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, 0
    if (flags.zero)
        goto cseg_112B8;                    // jz short cseg_112B8

    eax = A2;                               // mov eax, A2
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax
    cseg_15075();                           // call cseg_15075
    push(D0);                               // push D0
    D0 = 20;                                // mov D0, 20
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A2;                               // mov eax, A2
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax
    *(word *)&D0 = 20;                      // mov word ptr D0, 20
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    goto cseg_112C6;                        // jmp short cseg_112C6

cseg_112B8:;
    eax = A2;                               // mov eax, A2
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax

cseg_112C6:;
    *(word *)&g_memByte[483798] = 0;        // mov dseg_16F47C, 0
    cseg_116E8();                           // call cseg_116E8
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[483812];       // mov ax, teamSkillDiffAfterChange
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_11313;                    // jns short cseg_11313

    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_11313:;
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 19496);        // mov dword ptr [esi+38], offset aGoals
    ax = *(word *)&g_memByte[483822];       // mov ax, isNationalSquad
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_11353;                    // jz short cseg_11353

    writeMemory(esi + 38, 4, 6348);         // mov dword ptr [esi+38], offset aClubs

cseg_11353:;
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A6 = eax;                               // mov A6, eax
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (!flags.zero)
        goto cseg_113EC;                    // jnz cseg_113EC

    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 'P';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 'P'
    if (flags.carry)
        goto cseg_113EC;                    // jb short cseg_113EC

    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 'U';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 'U'
    if (!flags.carry && !flags.zero)
        goto cseg_113EC;                    // ja short cseg_113EC

    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 2, 207);          // mov word ptr [esi+20], 0CFh

cseg_113EC:;
    cseg_114EC();                           // call cseg_114EC
    cseg_1390D();                           // call cseg_1390D
    SquadMenuSavePlayerPositions();         // call SquadMenuSavePlayerPositions
}

// =============== S U B R O U T I N E =======================================
//
void SelectTraining()
{
    PlayTrainingGame();                     // call PlayTrainingGame
    A6 = 484144;                            // mov A6, offset squadMenu
    SWOS::ActivateMenu();                   // call ActivateMenu
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void SelectGoals()
{
    *(word *)&g_memByte[483814] = -1;       // mov dseg_16F48C, -1
    SquadMenuSavePlayerPositions();         // call SquadMenuSavePlayerPositions
    *(word *)&g_memByte[483798] = 1;        // mov dseg_16F47C, 1
    cseg_116E8();                           // call cseg_116E8
    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void SquadOnSelect11()
{
    *(word *)&g_memByte[483798] = 0;        // mov dseg_16F47C, 0
    cseg_116E8();                           // call cseg_116E8
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    *(word *)&g_memByte[456238] = 0;        // mov mouseInstalled, 0
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void j_SetExitMenuFlag()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void SquadOnSelect45()
{
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A0 = eax;                               // mov A0, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    RotatePlayersLeft();                    // call RotatePlayersLeft
    A0 = 256;                               // mov A0, offset cseg_114A6
    nullsub_17();                           // jmp nullsub_17
}

// =============== S U B R O U T I N E =======================================
//
void Squad45AfterDraw()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 44;                                // mov D0, 44
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    SWOS::DrawMenuItem();                   // jmp DrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void cseg_114EC()
{
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A6 = eax;                               // mov A6, eax
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 3Ch
    A1 = eax;                               // mov A1, eax
    *(word *)&D7 = 16;                      // mov word ptr D7, 10h
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0FFFFh
    if (flags.zero)
        goto cseg_1155F;                    // jz short cseg_1155F

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_1155F;                    // jnz short cseg_1155F

    A1 = 92766;                             // mov A1, offset currentMatchPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    ax = *(word *)&g_memByte[94094];        // mov ax, dseg_D761C
    *(word *)&D6 = ax;                      // mov word ptr D6, ax

cseg_1155F:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 22, 1);     // mov al, [esi+16h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax

cseg_1158B:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A6;                               // mov eax, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 109, 1);    // mov al, [esi+6Dh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax
    al = (byte)readMemory(esi + 110, 1);    // mov al, [esi+6Eh]
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax
    al = (byte)readMemory(esi + 111, 1);    // mov al, [esi+6Fh]
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax
    al = (byte)readMemory(esi + 112, 1);    // mov al, [esi+70h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 38;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 26h
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_1158B;                    // jns cseg_1158B

    push(D0);                               // push D0
    D0 = 16;                                // mov D0, 10h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    A0 = 19496;                             // mov A0, offset aGoals
    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 32);                // mov byte ptr [esi], 20h
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 40);                // mov byte ptr [esi], 28h
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SWOS::Int2Ascii();                      // call Int2Ascii
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 41);                // mov byte ptr [esi], 29h
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_25()
{
}

// =============== S U B R O U T I N E =======================================
//
void cseg_116E8()
{
    UpdateBigCheckMark();                   // call UpdateBigCheckMark
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A6 = eax;                               // mov A6, eax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 12;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ch
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_117E2;                    // jz cseg_117E2

    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Bh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 2
    if (flags.zero)
        goto cseg_117E2;                    // jz short cseg_117E2

    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 13;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Dh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax

cseg_117E2:;
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 24755;                             // mov A0, offset countriesTable
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 1
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 40);                // mov byte ptr [esi], 28h
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 1
    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 41);                // mov byte ptr [esi], 29h
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    push(D0);                               // push D0
    D0 = 25;                                // mov D0, 19h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 22, 1);     // mov al, [esi+16h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    *(word *)&D0 = 15;                      // mov word ptr D0, 0Fh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 13;                      // mov word ptr D0, 0Dh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[483798];       // mov ax, dseg_16F47C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_1191E;                    // jnz short cseg_1191E

    *(word *)&D0 = 13;                      // mov word ptr D0, 0Dh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_1191E:;
    *(word *)&D0 = 14;                      // mov word ptr D0, 0Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 50h
    if (flags.carry)
        goto cseg_11958;                    // jb short cseg_11958

    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 85;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 55h
    if (flags.carry || flags.zero)
        goto cseg_1197D;                    // jbe short cseg_1197D

cseg_11958:;
    ax = *(word *)&g_memByte[483798];       // mov ax, dseg_16F47C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_1197D;                    // jnz short cseg_1197D

    *(word *)&D0 = 14;                      // mov word ptr D0, 0Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_1197D:;
    ax = *(word *)&g_memByte[483798];       // mov ax, dseg_16F47C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_11E38;                    // jz cseg_11E38

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0FFFFh
    if (flags.zero)
        goto cseg_11A32;                    // jz short cseg_11A32

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_11A32;                    // jnz short cseg_11A32

    *(word *)&D0 = 26;                      // mov word ptr D0, 1Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 27;                      // mov word ptr D0, 1Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    push(D0);                               // push D0
    D0 = 27;                                // mov D0, 1Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[94094];        // mov ax, dseg_D761C
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    goto cseg_11A66;                        // jmp short cseg_11A66

cseg_11A32:;
    *(word *)&D0 = 26;                      // mov word ptr D0, 1Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 27;                      // mov word ptr D0, 1Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1

cseg_11A66:;
    *(word *)&D0 = 24;                      // mov word ptr D0, 18h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 25;                      // mov word ptr D0, 19h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 16;                      // mov word ptr D0, 10h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    writeMemory(esi + 60, 2, 0);            // mov word ptr [esi+3Ch], 0
    writeMemory(esi + 116, 2, 0);           // mov word ptr [esi+74h], 0
    writeMemory(esi + 172, 2, 0);           // mov word ptr [esi+0ACh], 0
    writeMemory(esi + 228, 2, 0);           // mov word ptr [esi+0E4h], 0
    writeMemory(esi + 284, 2, 0);           // mov word ptr [esi+11Ch], 0
    writeMemory(esi + 340, 2, 0);           // mov word ptr [esi+154h], 0
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[483822];       // mov ax, isNationalSquad
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_11C26;                    // jz cseg_11C26

    *(word *)&D0 = 16;                      // mov word ptr D0, 10h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 60, 2, 1);            // mov word ptr [esi+3Ch], 1
    writeMemory(esi + 116, 2, 1);           // mov word ptr [esi+74h], 1
    writeMemory(esi + 172, 2, 1);           // mov word ptr [esi+0ACh], 1
    writeMemory(esi + 228, 2, 1);           // mov word ptr [esi+0E4h], 1
    writeMemory(esi + 284, 2, 1);           // mov word ptr [esi+11Ch], 1
    writeMemory(esi + 340, 2, 1);           // mov word ptr [esi+154h], 1
    *(word *)&D0 = 26;                      // mov word ptr D0, 1Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 27;                      // mov word ptr D0, 1Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 24;                      // mov word ptr D0, 18h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 25;                      // mov word ptr D0, 19h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    goto cseg_12372;                        // jmp cseg_12372

cseg_11C26:;
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    D0 = eax;                               // mov D0, eax
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    D0 |= eax;                              // or D0, eax
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    D0 |= eax;
    flags.carry = false;
    flags.sign = (D0 & 0x80000000) != 0;
    flags.zero = D0 == 0;                   // or D0, eax
    if (!flags.zero)
        goto cseg_11CB5;                    // jnz short cseg_11CB5

    *(word *)&D0 = 18;                      // mov word ptr D0, 12h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 17;                      // mov word ptr D0, 11h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 19;                      // mov word ptr D0, 13h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 21;                      // mov word ptr D0, 15h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    goto cseg_12372;                        // jmp cseg_12372

cseg_11CB5:;
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto cseg_11CD8;                    // jnz short cseg_11CD8

    *(word *)&D0 = 21;                      // mov word ptr D0, 15h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1

cseg_11CD8:;
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto cseg_11D1A;                    // jnz short cseg_11D1A

    *(word *)&D0 = 17;                      // mov word ptr D0, 11h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 19;                      // mov word ptr D0, 13h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    goto cseg_12372;                        // jmp cseg_12372

cseg_11D1A:;
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto cseg_11D42;                    // jnz short cseg_11D42

    *(word *)&D0 = 17;                      // mov word ptr D0, 11h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    goto cseg_12372;                        // jmp cseg_12372

cseg_11D42:;
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_11E19;                    // jz cseg_11E19

    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_11E19;                    // jz cseg_11E19

    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_11E19;                    // jz cseg_11E19

    *(word *)&D0 = 17;                      // mov word ptr D0, 11h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 20;                      // mov word ptr D0, 14h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 11h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 20;                                // mov D0, 14h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+14h]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 20, 2, ax);           // mov [esi+14h], ax
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+14h], 0Bh
    goto cseg_12372;                        // jmp cseg_12372

cseg_11E19:;
    *(word *)&D0 = 19;                      // mov word ptr D0, 13h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    goto cseg_12372;                        // jmp cseg_12372

cseg_11E38:;
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (!flags.zero)
        goto cseg_11E92;                    // jnz short cseg_11E92

    {
        dword src = *(dword *)&g_memByte[483808];
        int32_t dstSigned = src;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_16F486, offset careerTeam
    if (!flags.zero)
        goto cseg_11E92;                    // jnz short cseg_11E92

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_11E92;                    // jnz short cseg_11E92

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    goto cseg_11F6D;                        // jmp cseg_11F6D

cseg_11E92:;
    ax = *(word *)&g_memByte[483812];       // mov ax, teamSkillDiffAfterChange
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_11F6D;                    // jns cseg_11F6D

    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 2, 222);          // mov word ptr [esi+14h], 0DEh
    writeMemory(esi + 24, 2, 60);           // mov word ptr [esi+18h], 3Ch
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 2, 222);          // mov word ptr [esi+14h], 0DEh
    writeMemory(esi + 24, 2, 60);           // mov word ptr [esi+18h], 3Ch
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, 185);          // mov word ptr [esi+16h], 0B9h
    writeMemory(esi + 26, 2, 15);           // mov word ptr [esi+1Ah], 0Fh
    writeMemory(esi + 20, 2, 259);          // mov word ptr [esi+14h], 103h
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, 185);          // mov word ptr [esi+16h], 0B9h
    writeMemory(esi + 26, 2, 15);           // mov word ptr [esi+1Ah], 0Fh
    writeMemory(esi + 20, 2, 198);          // mov word ptr [esi+14h], 0C6h

cseg_11F6D:;
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Eh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A0 = eax;                               // mov A0, eax
    {
        word src = (word)readMemory(esi + 23, 2);
        word res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr [esi+17h], 1
    if (flags.zero)
        goto cseg_12032;                    // jz short cseg_12032

    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1

cseg_12032:;
    ax = *(word *)&g_memByte[483812];       // mov ax, teamSkillDiffAfterChange
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_12105;                    // js cseg_12105

    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 2, 222);          // mov word ptr [esi+14h], 0DEh
    writeMemory(esi + 24, 2, 60);           // mov word ptr [esi+18h], 3Ch
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 2, 222);          // mov word ptr [esi+14h], 0DEh
    writeMemory(esi + 24, 2, 60);           // mov word ptr [esi+18h], 3Ch
    writeMemory(esi + 22, 2, 185);          // mov word ptr [esi+16h], 0B9h
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_12105;                    // jz short cseg_12105

    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 50h
    if (flags.carry)
        goto cseg_12105;                    // jb short cseg_12105

    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 85;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 55h
    if (!flags.carry && !flags.zero)
        goto cseg_12105;                    // ja short cseg_12105

    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 14;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub word ptr [esi+14h], 0Eh

cseg_12105:;
    *(word *)&D0 = 26;                      // mov word ptr D0, 1Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 27;                      // mov word ptr D0, 1Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 16;                      // mov word ptr D0, 10h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 60, 2, 1);            // mov word ptr [esi+3Ch], 1
    writeMemory(esi + 116, 2, 1);           // mov word ptr [esi+74h], 1
    writeMemory(esi + 172, 2, 1);           // mov word ptr [esi+0ACh], 1
    writeMemory(esi + 228, 2, 1);           // mov word ptr [esi+0E4h], 1
    writeMemory(esi + 284, 2, 1);           // mov word ptr [esi+11Ch], 1
    writeMemory(esi + 340, 2, 1);           // mov word ptr [esi+154h], 1
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    ax = *(word *)&g_memByte[483812];       // mov ax, teamSkillDiffAfterChange
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_1233E;                    // jns cseg_1233E

    *(word *)&D0 = 24;                      // mov word ptr D0, 18h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 25;                      // mov word ptr D0, 19h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[483822];       // mov ax, isNationalSquad
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_1233C;                    // jz cseg_1233C

    *(word *)&D0 = 24;                      // mov word ptr D0, 18h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 25;                      // mov word ptr D0, 19h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 16;                      // mov word ptr D0, 10h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    writeMemory(esi + 60, 2, 0);            // mov word ptr [esi+3Ch], 0
    writeMemory(esi + 116, 2, 0);           // mov word ptr [esi+74h], 0
    writeMemory(esi + 172, 2, 0);           // mov word ptr [esi+0ACh], 0
    writeMemory(esi + 228, 2, 0);           // mov word ptr [esi+0E4h], 0
    writeMemory(esi + 284, 2, 0);           // mov word ptr [esi+11Ch], 0
    writeMemory(esi + 340, 2, 0);           // mov word ptr [esi+154h], 0
    *(word *)&D0 = 13;                      // mov word ptr D0, 0Dh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 24;                                // mov D0, 18h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, 178);          // mov word ptr [esi+16h], 0B2h
    push(D0);                               // push D0
    D0 = 25;                                // mov D0, 19h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, 178);          // mov word ptr [esi+16h], 0B2h
    goto cseg_11C26;                        // jmp cseg_11C26

cseg_1233C:;
    goto cseg_12372;                        // jmp short cseg_12372

cseg_1233E:;
    *(word *)&D0 = 24;                      // mov word ptr D0, 18h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 25;                      // mov word ptr D0, 19h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_12372:;
    ax = *(word *)&g_memByte[483798];       // mov ax, dseg_16F47C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_1240C;                    // jnz cseg_1240C

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (!flags.zero)
        goto cseg_1240C;                    // jnz cseg_1240C

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_1240C;                    // jnz short cseg_1240C

    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_1240C;                    // jnz short cseg_1240C

    *(word *)&D0 = 12;                      // mov word ptr D0, 0Ch
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 0Ch
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    GetBankBalance();                       // call GetBankBalance
    goto cseg_12426;                        // jmp short cseg_12426

cseg_1240C:;
    *(word *)&D0 = 12;                      // mov word ptr D0, 0Ch
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1

cseg_12426:;
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 5
    A2 = eax;                               // mov A2, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 36;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 24h
    A2 = eax;                               // mov A2, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
}

// =============== S U B R O U T I N E =======================================
//
void SquadCommon()
{
    push(D0);                               // push D0
    D0 = 28;                                // mov D0, 28
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A0 = eax;                               // mov A0, eax
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    ax = *(word *)&g_memByte[483814];       // mov ax, dseg_16F48C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_12594;                    // js cseg_12594

    ax = *(word *)&g_memByte[483814];       // mov ax, dseg_16F48C
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (flags.zero)
        goto cseg_1258B;                    // jz short cseg_1258B

    ax = *(word *)&g_memByte[483814];       // mov ax, dseg_16F48C
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[483816];       // mov ax, dseg_16F48E
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    cseg_125F4();                           // call cseg_125F4
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A0 = eax;                               // mov A0, eax
    SetBenchPlayersNumbers();               // call SetBenchPlayersNumbers
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 59, 1, 1);            // mov byte ptr [esi+3Bh], 1
    cseg_1390D();                           // call cseg_1390D
    *(word *)&g_memByte[483814] = 65535;    // mov dseg_16F48C, 0FFFFh
    { SWOS::DrawMenu(); return; }           // jmp DrawMenu

cseg_1258B:;
    *(word *)&D7 = 65535;                   // mov word ptr D7, 0FFFFh

cseg_12594:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&g_memByte[483814] = ax;       // mov dseg_16F48C, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&g_memByte[483816] = ax;       // mov dseg_16F48E, ax
    eax = *(dword *)&g_memByte[483818];     // mov eax, dseg_16F490
    A0 = eax;                               // mov A0, eax
    eax = A5;                               // mov eax, A5
    *(dword *)&g_memByte[483818] = eax;     // mov dseg_16F490, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        goto cseg_125E4;                    // jz short cseg_125E4

    push(A5);                               // push A5
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
    pop(A5);                                // pop A5

cseg_125E4:;
    CallDrawMenuItem();                     // call CallDrawMenuItem
    SquadMenuSavePlayerPositions();         // call SquadMenuSavePlayerPositions
    cseg_1377B();                           // call cseg_1377B
}

// =============== S U B R O U T I N E =======================================
//
void cseg_125F4()
{
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 10h
    if (!flags.carry)
        goto cseg_12630;                    // jnb short cseg_12630

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 10h
    if (!flags.carry)
        goto cseg_12630;                    // jnb short cseg_12630

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 0Bh
    if (!flags.carry)
        goto cseg_12622;                    // jnb short cseg_12622

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 0Bh
    if (flags.carry)
        goto cseg_1271C;                    // jb cseg_1271C

    goto cseg_12630;                        // jmp short cseg_12630

cseg_12622:;
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 0Bh
    if (!flags.carry)
        goto cseg_1271C;                    // jnb cseg_1271C

cseg_12630:;
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    A2 = 378790;                            // mov A2, offset playerPositionsArray
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    al = D0;                                // mov al, byte ptr D0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+4Eh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+4Eh]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al
    al = D0;                                // mov al, byte ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 78, 1, al);           // mov [esi+4Eh], al

cseg_1271C:;
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (!flags.zero)
        goto cseg_1277B;                    // jnz short cseg_1277B

    A0 = 92766;                             // mov A0, offset currentMatchPlayers

cseg_12730:;
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    al = D0;                                // mov al, byte ptr D0
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    return;                                 // retn

cseg_1277B:;
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 3Ch
    A0 = eax;                               // mov A0, eax
    goto cseg_12730;                        // jmp short cseg_12730
}

// =============== S U B R O U T I N E =======================================
//
void SquadAfterDrawCommon()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 28;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1Ch
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A6 = eax;                               // mov A6, eax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 10h
    if (!flags.zero)
        goto cseg_1285C;                    // jnz cseg_1285C

    *(word *)&D5 = 1;                       // mov word ptr D5, 1
    push(D0);                               // push D0
    D0 = 46;                                // mov D0, 2Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    push(D0);                               // push D0
    D0 = 48;                                // mov D0, 30h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    goto cseg_12BF7;                        // jmp cseg_12BF7

cseg_1285C:;
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 0Bh
    if (!flags.carry)
        goto cseg_12A3F;                    // jnb cseg_12A3F

    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_12921;                    // jz cseg_12921

    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_129B0;                    // jz cseg_129B0

    push(D0);                               // push D0
    D0 = 46;                                // mov D0, 2Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 13;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Dh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    push(D0);                               // push D0
    D0 = 48;                                // mov D0, 30h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 13;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Dh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    goto cseg_12BF7;                        // jmp cseg_12BF7

cseg_12921:;
    push(D0);                               // push D0
    D0 = 46;                                // mov D0, 2Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ah
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    push(D0);                               // push D0
    D0 = 48;                                // mov D0, 30h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ah
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    goto cseg_12BF7;                        // jmp cseg_12BF7

cseg_129B0:;
    push(D0);                               // push D0
    D0 = 46;                                // mov D0, 2Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Eh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    push(D0);                               // push D0
    D0 = 48;                                // mov D0, 30h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Eh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    goto cseg_12BF7;                        // jmp cseg_12BF7

cseg_12A3F:;
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_12B6D;                    // jz cseg_12B6D

    push(D0);                               // push D0
    D0 = 46;                                // mov D0, 2Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Bh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    push(D0);                               // push D0
    D0 = 48;                                // mov D0, 30h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Bh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    goto cseg_12BF7;                        // jmp cseg_12BF7

    push(D0);                               // push D0
    D0 = 46;                                // mov D0, 2Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Eh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    push(D0);                               // push D0
    D0 = 48;                                // mov D0, 30h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Eh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    goto cseg_12BF7;                        // jmp cseg_12BF7

cseg_12B6D:;
    push(D0);                               // push D0
    D0 = 46;                                // mov D0, 2Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 12;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ch
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    push(D0);                               // push D0
    D0 = 48;                                // mov D0, 30h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 12;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ch
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax

cseg_12BF7:;
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A0 = eax;                               // mov A0, eax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = *(word *)&g_memByte[483796];       // mov ax, dseg_16F47A
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    IsPlayerInjured();                      // call IsPlayerInjured
    pop(D1);                                // pop D1
    if (flags.zero)
        goto cseg_12CE1;                    // jz cseg_12CE1

    push(D0);                               // push D0
    D0 = 46;                                // mov D0, 2Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ah
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    push(D0);                               // push D0
    D0 = 48;                                // mov D0, 30h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Ah
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax

cseg_12CE1:;
    ax = *(word *)&g_memByte[483814];       // mov ax, dseg_16F48C
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto cseg_12D7E;                    // jnz cseg_12D7E

    push(D0);                               // push D0
    D0 = 46;                                // mov D0, 2Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 6
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    push(D0);                               // push D0
    D0 = 48;                                // mov D0, 30h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 6
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax

cseg_12D7E:;
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&g_memByte[483804] = ax;       // mov dseg_16F482, ax
    eax = A6;                               // mov eax, A6
    *(dword *)&g_memByte[483800] = eax;     // mov dseg_16F47E, eax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    push(D0);                               // push D0
    D0 = 46;                                // mov D0, 2Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    ax = *(word *)&g_memByte[483796];       // mov ax, dseg_16F47A
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_13A55();                           // call cseg_13A55
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 0Bh
    if (!flags.carry)
        goto cseg_12E47;                    // jnb short cseg_12E47

    A1 = 378790;                            // mov A1, offset playerPositionsArray
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    A1 = 378822;                            // mov A1, offset oldPlayerPositionsArray
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.carry && !flags.zero)
        goto cseg_12E3B;                    // ja short cseg_12E3B

    if (flags.zero)
        goto cseg_12E47;                    // jz short cseg_12E47

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, 209);          // mov word ptr [esi+26h], 0D1h
    goto cseg_12E47;                        // jmp short cseg_12E47

cseg_12E3B:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, 208);          // mov word ptr [esi+26h], 0D0h

cseg_12E47:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_12E98;                    // jnz short cseg_12E98

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+4Eh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_12E98:;
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4Fh
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    A2 = 332080;                            // mov A2, offset playerPositionsStringTable
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    push(D4);                               // push small [word ptr D4]
    FormTopSkillsString();                  // call FormTopSkillsString
    {
        int32_t val = stack[stackTop++];
        *(word *)&D4 = val;
    }                                       // pop small [word ptr D4]
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 50h
    if (flags.carry)
        goto cseg_1300B;                    // jb short cseg_1300B

    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 85;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 55h
    if (flags.carry || flags.zero)
        goto cseg_13109;                    // jbe cseg_13109

cseg_1300B:;
    ax = *(word *)&g_memByte[483798];       // mov ax, dseg_16F47C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_13109;                    // jnz cseg_13109

    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 76, 1);     // mov al, [esi+(PlayerFile.nationality+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    A2 = 25865;                             // mov A2, offset shortCountryNames
    eax = A2;                               // mov eax, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A2 = eax;                               // mov A2, eax
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, '(');               // mov byte ptr [esi], '('
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 41);                // mov byte ptr [esi], 29h
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_13109:;
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[483812];       // mov ax, teamSkillDiffAfterChange
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_131D2;                    // jns cseg_131D2

    ax = *(word *)&g_memByte[483822];       // mov ax, isNationalSquad
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_13204;                    // jnz cseg_13204

    ax = *(word *)&g_memByte[483798];       // mov ax, dseg_16F47C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_13204;                    // jnz cseg_13204

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 109, 1);    // mov al, [esi+6Dh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    al = (byte)readMemory(esi + 110, 1);    // mov al, [esi+6Eh]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 255;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFh
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    al = (byte)readMemory(esi + 111, 1);    // mov al, [esi+6Fh]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    al = (byte)readMemory(esi + 112, 1);    // mov al, [esi+70h]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    goto cseg_131E8;                        // jmp short cseg_131E8

cseg_131D2:;
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx + 109, 1); // mov al, [esi+ebx+6Dh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al

cseg_131E8:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_13204:;
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[483798];       // mov ax, dseg_16F47C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_13346;                    // jnz cseg_13346

    push(A0);                               // push A0
    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A1 = eax;                               // mov A1, eax
    IsTeamNational();                       // call IsTeamNational
    if (flags.zero)
        goto cseg_13291;                    // jz short cseg_13291

    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    cseg_3E04F();                           // call cseg_3E04F
    pop(A0);                                // pop A0
    goto cseg_132C9;                        // jmp short cseg_132C9

cseg_13291:;
    A1 = 316574;                            // mov A1, offset fundsBuffer
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    cseg_247C8();                           // call cseg_247C8
    pop(A0);                                // pop A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 316574);       // mov dword ptr [esi+26h], offset fundsBuffer
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_132C9:;
    *(word *)&D1 = 13;                      // mov word ptr D1, 0Dh
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_13311;                    // jz short cseg_13311

    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_13311;                    // jz short cseg_13311

    *(word *)&D1 = 2;                       // mov word ptr D1, 2
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+66h], 2
    if (flags.zero)
        goto cseg_13311;                    // jz short cseg_13311

    *(word *)&D1 = 15;                      // mov word ptr D1, 0Fh

cseg_13311:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+24h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+24h], ax

cseg_13346:;
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    ax = *(word *)&g_memByte[483822];       // mov ax, isNationalSquad
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_13422;                    // jz cseg_13422

    ax = *(word *)&g_memByte[483798];       // mov ax, dseg_16F47C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_13422;                    // jz cseg_13422

    push(A0);                               // push A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    A0 = 92426;                             // mov A0, offset dseg_D6F98
    ax = D4;                                // mov ax, word ptr D4
    bx = 17;                                // mov bx, 11h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)((byte *)&D4 + 2) = dx;        // mov word ptr D4+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 40);                // mov byte ptr [esi], 28h
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 1
    StringCopy();                           // call StringCopy
    pop(A0);                                // pop A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 41);                // mov byte ptr [esi], 29h
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_13422:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    ax = *(word *)&g_memByte[483822];       // mov ax, isNationalSquad
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_13445;                    // jz short cseg_13445

    ax = *(word *)&g_memByte[483798];       // mov ax, dseg_16F47C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_13508;                    // jz cseg_13508

    goto cseg_13454;                        // jmp short cseg_13454

cseg_13445:;
    ax = *(word *)&g_memByte[483798];       // mov ax, dseg_16F47C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_13508;                    // jnz cseg_13508

cseg_13454:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 38h
    goto cseg_13732;                        // jmp cseg_13732

cseg_13508:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    D0 = eax;                               // mov D0, eax
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    D0 |= eax;                              // or D0, eax
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    D0 |= eax;
    flags.carry = false;
    flags.sign = (D0 & 0x80000000) != 0;
    flags.zero = D0 == 0;                   // or D0, eax
    if (flags.zero)
        goto cseg_13582;                    // jz short cseg_13582

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 109, 1);    // mov al, [esi+6Dh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax

cseg_13582:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_135D8;                    // jz short cseg_135D8

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 110, 1);    // mov al, [esi+6Eh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax

cseg_135D8:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_1362E;                    // jz short cseg_1362E

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 111, 1);    // mov al, [esi+6Fh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax

cseg_1362E:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_13684;                    // jz short cseg_13684

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 112, 1);    // mov al, [esi+70h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax

cseg_13684:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 109, 1);    // mov al, [esi+6Dh]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 255;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFh
    al = (byte)readMemory(esi + 110, 1);    // mov al, [esi+6Eh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    al = (byte)readMemory(esi + 111, 1);    // mov al, [esi+6Fh]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    al = (byte)readMemory(esi + 112, 1);    // mov al, [esi+70h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 38h

cseg_13732:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 46;                                // mov D0, 2Eh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 18;                      // mov word ptr D0, 12h
    SWOS::DrawMultipleItems();              // jmp DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void cseg_1377B()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 28;                                // mov D0, 1Ch
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 11;                      // mov word ptr D0, 0Bh
    CallDrawMultipleItems();                // call CallDrawMultipleItems
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void SquadMenuSavePlayerPositions()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ax = *(word *)&g_memByte[378786];       // mov ax, oldPlayerSkill
    *(word *)&g_memByte[378788] = ax;       // mov newPlayerSkill, ax
    A0 = 378790;                            // mov A0, offset playerPositionsArray
    A1 = 378822;                            // mov A1, offset oldPlayerPositionsArray
    *(word *)&D0 = 31;                      // mov word ptr D0, 31

cseg_13888:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_13888;                    // jns short cseg_13888

    UpdateBigCheckMark();                   // call UpdateBigCheckMark
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_1390D()
{
    ax = *(word *)&g_memByte[378786];       // mov ax, oldPlayerSkill
    *(word *)&g_memByte[378788] = ax;       // mov newPlayerSkill, ax
    A0 = 378790;                            // mov A0, offset playerPositionsArray
    A1 = 378822;                            // mov A1, offset oldPlayerPositionsArray
    *(word *)&D0 = 31;                      // mov word ptr D0, 31

cseg_13936:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_13936;                    // jns short cseg_13936

    eax = *(dword *)&g_memByte[483808];     // mov eax, dseg_16F486
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 59, 1, 1);            // mov byte ptr [esi+3Bh], 1
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    SetupTeamSubstitutes();                           // call SetupTeamSubstitutes

    UpdateBigCheckMark();
}

// =============== S U B R O U T I N E =======================================
//
void UpdateBigCheckMark()
{
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = *(word *)&g_memByte[483812];       // mov ax, teamSkillDiffAfterChange
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        return;                             // jns short @@out

    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 57343;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0DFFFh
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    ax = *(word *)&g_memByte[378786];       // mov ax, oldPlayerSkill
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[378788];       // mov ax, newPlayerSkill
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry && !flags.zero)
        goto l_good_change;                 // ja short @@good_change

    ax = *(word *)&g_memByte[378788];       // mov ax, newPlayerSkill
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.carry)
        goto l_bad_change;                  // jb short @@bad_change

l_out:;
    return;                                 // retn

l_bad_change:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, 207);          // mov word ptr [esi+MenuEntry.fg], SPR_NOT_CHECK_BIG
    goto cseg_13A1F;                        // jmp short cseg_13A1F

l_good_change:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, 206);          // mov word ptr [esi+MenuEntry.fg], SPR_CHECK_BIG

cseg_13A1F:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D1 |= 8192;
    flags.carry = false;
    flags.sign = (*(word *)&D1 & 0x8000) != 0;
    flags.zero = *(word *)&D1 == 0;         // or word ptr D1, 2000h
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
}

// =============== S U B R O U T I N E =======================================

// in:
//     A6 -> player (file)
//
void cseg_13A55()
{
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_13C3E;                    // jnz cseg_13C3E

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 24;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 18h
    {
        word res = *(word *)&D1 >> 3;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 3
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        word res = *(word *)&D2 & 28;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 1Ch
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    {
        word res = *(word *)&D3 & 224;
        *(word *)&D3 = res;
    }                                       // and word ptr D3, 0E0h
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 0
    if (!flags.zero)
        goto cseg_13AD7;                    // jnz short cseg_13AD7

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 0
    if (flags.zero)
        goto cseg_13BDD;                    // jz cseg_13BDD

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 20h
    if (flags.zero)
        goto cseg_13B9C;                    // jz cseg_13B9C

    goto cseg_13B48;                        // jmp short cseg_13B48

cseg_13AD7:;
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 0
    if (flags.zero)
        goto cseg_13BB6;                    // jz cseg_13BB6

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 20h
    if (flags.zero)
        goto cseg_13BB6;                    // jz cseg_13BB6

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 4
    if (flags.zero)
        goto cseg_13B48;                    // jz short cseg_13B48

    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 8
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 64;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 40h
    {
        word res = *(word *)&D1 >> 5;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 5
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_13BB6;                    // jnb short cseg_13BB6

cseg_13B48:;
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset careerTeam
    if (flags.carry)
        goto cseg_13B75;                    // jb short cseg_13B75

    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 94090;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset careerNumPlayers
    if (!flags.carry)
        goto cseg_13B75;                    // jnb short cseg_13B75

    cseg_3E608();                           // call cseg_3E608
    if (!flags.zero)
        goto cseg_13B75;                    // jnz short cseg_13B75

    *(word *)&D0 = 152;                     // mov word ptr D0, 98h
    goto cseg_13BF4;                        // jmp cseg_13BF4

cseg_13B75:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 64;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 40h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 156;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9Ch
    goto cseg_13BF4;                        // jmp short cseg_13BF4

cseg_13B9C:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 153;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 99h
    goto cseg_13C2D;                        // jmp short cseg_13C2D

cseg_13BB6:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 4
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 145;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 91h
    goto cseg_13BF4;                        // jmp short cseg_13BF4

cseg_13BDD:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 186;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0BAh
    goto cseg_13C2D;                        // jmp short cseg_13C2D

cseg_13BF4:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0FFF0h
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    return;                                 // retn

cseg_13C2D:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    return;                                 // retn

cseg_13C3E:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 24;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 18h
    {
        word res = *(word *)&D1 >> 3;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 3
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        word res = *(word *)&D2 & 3;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 3
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    {
        word res = *(word *)&D3 & 224;
        *(word *)&D3 = res;
    }                                       // and word ptr D3, 0E0h
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 0
    if (!flags.zero)
        goto cseg_13CB1;                    // jnz short cseg_13CB1

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 0
    if (flags.zero)
        goto cseg_13D9A;                    // jz cseg_13D9A

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 20h
    if (flags.zero)
        goto cseg_13D64;                    // jz cseg_13D64

    goto cseg_13D10;                        // jmp short cseg_13D10

cseg_13CB1:;
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 0
    if (flags.zero)
        goto cseg_13D7B;                    // jz cseg_13D7B

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 20h
    if (flags.zero)
        goto cseg_13D7B;                    // jz cseg_13D7B

    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 64;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 40h
    {
        word res = *(word *)&D1 >> 5;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 5
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_13D7B;                    // jnb short cseg_13D7B

cseg_13D10:;
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset careerTeam
    if (flags.carry)
        goto cseg_13D3D;                    // jb short cseg_13D3D

    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 94090;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset careerNumPlayers
    if (!flags.carry)
        goto cseg_13D3D;                    // jnb short cseg_13D3D

    cseg_3E608();                           // call cseg_3E608
    if (!flags.zero)
        goto cseg_13D3D;                    // jnz short cseg_13D3D

    *(word *)&D0 = 152;                     // mov word ptr D0, 98h
    goto cseg_13DB1;                        // jmp short cseg_13DB1

cseg_13D3D:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 64;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 40h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 156;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9Ch
    goto cseg_13DB1;                        // jmp short cseg_13DB1

cseg_13D64:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 153;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 99h
    goto cseg_13DEA;                        // jmp short cseg_13DEA

cseg_13D7B:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 146;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 92h
    goto cseg_13DB1;                        // jmp short cseg_13DB1

cseg_13D9A:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 186;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0BAh
    goto cseg_13DEA;                        // jmp short cseg_13DEA

cseg_13DB1:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0FFF0h
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    return;                                 // retn

cseg_13DEA:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_13DFB()
{
    cseg_3E608();                           // call cseg_3E608
    if (!flags.zero)
        goto cseg_13E10;                    // jnz short cseg_13E10

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    { cseg_13A55(); return; }               // jmp cseg_13A55

cseg_13E10:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 24;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 18h
    {
        word res = *(word *)&D1 >> 3;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 3
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    {
        word res = *(word *)&D3 & 224;
        *(word *)&D3 = res;
    }                                       // and word ptr D3, 0E0h
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 0
    if (!flags.zero)
        goto cseg_13E69;                    // jnz short cseg_13E69

    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 186;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0BAh
    goto cseg_13EB2;                        // jmp short cseg_13EB2

cseg_13E69:;
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 20h
    if (!flags.zero)
        goto cseg_13E8A;                    // jnz short cseg_13E8A

    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 153;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 99h
    goto cseg_13EB2;                        // jmp short cseg_13EB2

cseg_13E8A:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 64;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 40h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 156;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9Ch

cseg_13EB2:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> menu entry to set sprite
//      A6 -> team header + player offset
//
void SetMenuEntryPlayerFace()
{
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 24;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 18h
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 186;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, SPR_PL_FACE_WHITE_GUY
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.sprite2], ax
}

// =============== S U B R O U T I N E =======================================
//
void SelTeamForTacticsInit()
{
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = *(dword *)&g_memByte[336828];     // mov eax, chooseTeamMenuName
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    {
        word src = *(word *)&g_memByte[337096];
        int16_t dstSigned = src;
        int16_t srcSigned = 66;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numTeamsCountryBuffer, 66
    if (flags.carry)
        goto l_less_than_66_teams;          // jb short @@less_than_66_teams

    *(word *)&g_memByte[337090] = 22;       // mov selTeamsColumn1, 22
    *(word *)&g_memByte[337092] = 21;       // mov selTeamsColumn2, 21
    *(word *)&g_memByte[337094] = 21;       // mov selTeamsColumn3, 21
    goto cseg_14573;                        // jmp cseg_14573

l_less_than_66_teams:;
    {
        word src = *(word *)&g_memByte[337096];
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numTeamsCountryBuffer, 8
    if (!flags.carry && !flags.zero)
        goto l_more_than_8_teams;           // ja short @@more_than_8_teams

    *(word *)&g_memByte[337090] = 0;        // mov selTeamsColumn1, 0
    ax = *(word *)&g_memByte[337096];       // mov ax, numTeamsCountryBuffer
    *(word *)&g_memByte[337092] = ax;       // mov selTeamsColumn2, ax
    *(word *)&g_memByte[337094] = 0;        // mov selTeamsColumn3, 0
    goto cseg_14573;                        // jmp cseg_14573

l_more_than_8_teams:;
    ax = *(word *)&g_memByte[337096];       // mov ax, numTeamsCountryBuffer
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 3;                                 // mov bx, 3
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[337090] = ax;       // mov selTeamsColumn1, ax
    *(word *)&g_memByte[337092] = ax;       // mov selTeamsColumn2, ax
    *(word *)&g_memByte[337094] = ax;       // mov selTeamsColumn3, ax
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_14559;                    // jnz short cseg_14559

    {
        word src = *(word *)&g_memByte[337096];
        int16_t dstSigned = src;
        int16_t srcSigned = 64;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numTeamsCountryBuffer, 64
    if (!flags.zero)
        goto l_one_more_team_to_middle_column; // jnz short @@one_more_team_to_middle_column

    {
        word src = *(word *)&g_memByte[337090];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[337090] = src;
    }                                       // add selTeamsColumn1, 1
    goto cseg_14573;                        // jmp short cseg_14573

l_one_more_team_to_middle_column:;
    {
        word src = *(word *)&g_memByte[337092];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[337092] = src;
    }                                       // add selTeamsColumn2, 1
    goto cseg_14573;                        // jmp short cseg_14573

cseg_14559:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (!flags.zero)
        goto cseg_14573;                    // jnz short cseg_14573

    {
        word src = *(word *)&g_memByte[337090];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[337090] = src;
    }                                       // add selTeamsColumn1, 1
    {
        word src = *(word *)&g_memByte[337092];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[337092] = src;
    }                                       // add selTeamsColumn2, 1

cseg_14573:;
    cseg_147AB();                           // call cseg_147AB
    A1 = 337102;                            // mov A1, offset b_index_countries
    A3 = 336834;                            // mov A3, offset dwArrayCountries
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    *(word *)&D6 = 0;                       // mov word ptr D6, 0

cseg_145D2:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[337096];       // mov ax, numTeamsCountryBuffer
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (!flags.carry)
        goto cseg_14711;                    // jnb cseg_14711

cseg_145F1:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 22;                                // mov bx, 22
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_14649;                    // jnz short cseg_14649

    ax = *(word *)&g_memByte[337090];       // mov ax, selTeamsColumn1
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    goto cseg_14679;                        // jmp short cseg_14679

cseg_14649:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_14661;                    // jnz short cseg_14661

    ax = *(word *)&g_memByte[337092];       // mov ax, selTeamsColumn2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    goto cseg_14679;                        // jmp short cseg_14679

cseg_14661:;
    ax = *(word *)&g_memByte[337094];       // mov ax, selTeamsColumn3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_14679:;
    ax = D0;                                // mov ax, word ptr D0
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto cseg_146C4;                    // jb short cseg_146C4

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 56
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 67;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2], 67
    if (flags.zero)
        return;                             // jz cseg_14732

    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    goto cseg_145F1;                        // jmp cseg_145F1

cseg_146C4:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax

cseg_14711:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 38h
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 67;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2], 43h
    if (flags.zero)
        return;                             // jz short cseg_14732

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    goto cseg_145D2;                        // jmp cseg_145D2
}

// =============== S U B R O U T I N E =======================================
//
void SelTeamForTacticsExit()
{
    *(word *)&g_memByte[336832] = -1;       // mov teamSelected, -1
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void SelTeamForTacticsCommon()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 22;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 22
    if (flags.carry)
        goto l_got_team;                    // jb short @@got_team

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 44;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 44
    if (flags.carry)
        goto cseg_14782;                    // jb short cseg_14782

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 22;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 22
    ax = *(word *)&g_memByte[337092];       // mov ax, selTeamsColumn2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax

cseg_14782:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 22;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 22
    ax = *(word *)&g_memByte[337090];       // mov ax, selTeamsColumn1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax

l_got_team:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[336832] = ax;       // mov teamSelected, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void cseg_147AB()
{
    ax = *(word *)&g_memByte[337090];       // mov ax, selTeamsColumn1
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[337092];       // mov ax, selTeamsColumn2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry && !flags.zero)
        goto cseg_147D2;                    // ja short cseg_147D2

    ax = *(word *)&g_memByte[337092];       // mov ax, selTeamsColumn2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_147D2:;
    ax = *(word *)&g_memByte[337094];       // mov ax, selTeamsColumn3
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry && !flags.zero)
        goto cseg_147ED;                    // ja short cseg_147ED

    ax = *(word *)&g_memByte[337094];       // mov ax, selTeamsColumn3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_147ED:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 18;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 18
    if (flags.carry || flags.zero)
        goto cseg_14859;                    // jbe short cseg_14859

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 20
    if (flags.carry || flags.zero)
        goto cseg_14832;                    // jbe short cseg_14832

    push(D0);                               // push D0
    D0 = 67;                                // mov D0, 67
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+MenuEntry.y], 7
    {
        word src = (word)readMemory(esi + 26, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 26, 2, src);
    }                                       // sub [esi+MenuEntry.dwHeight], 7

cseg_14832:;
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

cseg_14859:;
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+MenuEntry.isInvisible]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_148A4;                    // jnz short cseg_148A4

    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+MenuEntry.dwHeight]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax

cseg_148A4:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[337098] = ax;       // mov dseg_114E54, ax
    push(D0);                               // push D0
    D0 = 67;                                // mov D0, 67
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    *(word *)&g_memByte[337100] = ax;       // mov dseg_114E56, ax
    {
        word src = *(word *)&g_memByte[337096];
        int16_t dstSigned = src;
        int16_t srcSigned = 64;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numTeamsCountryBuffer, 64
    if (!flags.zero)
        goto cseg_14902;                    // jnz short cseg_14902

    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+MenuEntry.dwHeight]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word src = *(word *)&g_memByte[337100];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[337100] = src;
    }                                       // add dseg_114E56, ax

cseg_14902:;
    ax = D1;                                // mov ax, word ptr D1
    bx = 9;                                 // mov bx, 9
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    ax = *(word *)&g_memByte[337100];       // mov ax, dseg_114E56
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[337098];       // mov ax, dseg_114E54
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1
    ax = *(word *)&g_memByte[337098];       // mov ax, dseg_114E54
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D2 = 2;                       // mov word ptr D2, 2

cseg_14986:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D3 = 21;                      // mov word ptr D3, 21

cseg_1499B:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_1499B;                    // jns short cseg_1499B

    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_14986;                    // jns short cseg_14986
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> menu name
//      A1 -> buffer with country numbers for teams
//      D0 = number of teams in country buffer
// out:
//      A0 - succes boolean flag
//
// Also for view competition - view squads.
//
void ChooseTeamForEditTactics()
{
    eax = A1;                               // mov eax, A1
    A5 = eax;                               // mov A5, eax
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[336828] = eax;     // mov chooseTeamMenuName, eax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[337096] = ax;       // mov numTeamsCountryBuffer, ax
    A2 = 336834;                            // mov A2, offset dwArrayCountries
    A3 = 337102;                            // mov A3, offset b_index_countries
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

l_countries_loop:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(A5);                               // push A5
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    pop(A5);                                // pop A5
    al = D6;                                // mov al, byte ptr D6
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A3)++;                    // inc A3
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 4
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_countries_loop;              // jns short @@countries_loop

    ax = *(word *)&g_memByte[337096];       // mov ax, numTeamsCountryBuffer
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 2
    if (flags.sign)
        goto l_show_select_menu;            // js @@show_select_menu

    A3 = 336834;                            // mov A3, offset dwArrayCountries

cseg_14AAE:;
    A2 = 337102;                            // mov A2, offset b_index_countries
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_14ACD:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A1 = eax;                               // mov A1, eax

cseg_14B43:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_14B97;                    // jz short cseg_14B97

    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_14B97;                    // jb short cseg_14B97

    if (!flags.carry && !flags.zero)
        goto cseg_14B74;                    // ja short cseg_14B74

    goto cseg_14B43;                        // jmp short cseg_14B43

cseg_14B74:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    writeMemory(esi + -1, 1, al);           // mov [esi-1], al
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi, 1, al);                // mov [esi], al
    *(word *)&D3 = 1;                       // mov word ptr D3, 1

cseg_14B97:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_14ACD;                    // jns cseg_14ACD

    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_14AAE;                    // jnz cseg_14AAE

l_show_select_menu:;
    A6 = 262;                               // mov A6, offset selectTeamsForTacticsMenu
    push(A5);                               // push A5
    SWOS::ShowMenu();                       // call ShowMenu
    pop(A5);                                // pop A5
    ax = *(word *)&g_memByte[336832];       // mov ax, teamSelected
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_err_out;                     // js short @@err_out

    A0 = 337102;                            // mov A0, offset b_index_countries
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    return;                                 // retn

l_err_out:;
    A0 = 0;                                 // mov A0, 0
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - maximum number of substitutes
//
// Called from edit tactics and play match menu.
//
void RotatePlayersLeft()
{
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto l_not_a_career_team;           // jnz short @@not_a_career_team

    A0 = 92766;                             // mov A0, offset currentMatchPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    goto cseg_14C74;                        // jmp short cseg_14C74

l_not_a_career_team:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 60
    A0 = eax;                               // mov A0, eax
    *(word *)&D1 = 16;                      // mov word ptr D1, 16

cseg_14C74:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 11
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 2
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    push(ax);                               // push ax

l_move_players_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_move_players_loop;           // jns short @@move_players_loop

    {
        int32_t val = stack[stackTop++];
        ax = val;
    }                                       // pop ax
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
}

// =============== S U B R O U T I N E =======================================

// in:
//     A1 -> destination buffer
//     A6 -> player (file) + header
//
// Form that weird 3-letter string that comes after player name in play match menu.
//
void FormTopSkillsString()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 11100000b
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto l_out;                         // jz @@out

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A2 = 483586;                            // mov A2, offset dseg_16F3A8
    A3 = 483642;                            // mov A3, offset dseg_16F3E0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 80, 1);     // mov al, [esi+(PlayerFile.playerName+4Dh)]
    *(byte *)&D1 ^= al;                     // xor byte ptr D1, al
    al = (byte)readMemory(esi + 79, 1);     // mov al, [esi+(PlayerFile.playerName+4Ch)]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    *(byte *)&D1 ^= al;                     // xor byte ptr D1, al
    {
        byte res = *(byte *)&D1 & 1;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr D1, 1
    if (flags.zero)
        goto cseg_14DE1;                    // jz short cseg_14DE1

    A2 = 483614;                            // mov A2, offset dseg_16F3C4
    A3 = 483670;                            // mov A3, offset dseg_16F3FC

cseg_14DE1:;
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A2 = eax;                               // mov A2, eax
    esi = A3;                               // mov esi, A3
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A3 = eax;                               // mov A3, eax
    *(byte *)&D1 = 255;                     // mov byte ptr D1, 0FFh
    *(byte *)&D2 = 255;                     // mov byte ptr D2, 0FFh
    *(byte *)&D3 = 255;                     // mov byte ptr D3, 0FFh
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 104, 2);    // mov ax, word ptr [esi+(PlayerFile.passing+4Ch)]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)((byte *)&D7 + 2) = ax;        // mov word ptr D7+2, ax
    ax = (word)readMemory(esi + 106, 2);    // mov ax, word ptr [esi+(PlayerFile.tacklingBallControl+4Ch)]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        dword res = D7 << 4;
        D7 = res;
    }                                       // shl D7, 4
    *(word *)&D4 = 6;                       // mov word ptr D4, 6

l_loop:;
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A3)++;                    // inc A3
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    eax = D7;                               // mov eax, D7
    D0 = eax;                               // mov D0, eax
    cl = D5;                                // mov cl, byte ptr D5
    {
        byte rotationCount = ((D0) & 0x1f) % 32;
        if (rotationCount) {
            D0 = (D0 << rotationCount) | ((dword)D0 >> (32 - rotationCount));
        }
    }                                       // rol D0, cl
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    al = D0;                                // mov al, byte ptr D0
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.sign == flags.overflow)
        goto cseg_14EEB;                    // jge short cseg_14EEB

    eax = D2;                               // mov eax, D2
    D3 = eax;                               // mov D3, eax
    eax = D1;                               // mov eax, D1
    D2 = eax;                               // mov D2, eax
    al = D0;                                // mov al, byte ptr D0
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    goto l_next;                            // jmp @@next

cseg_14EEB:;
    al = D0;                                // mov al, byte ptr D0
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (flags.sign == flags.overflow)
        goto cseg_14F41;                    // jge short cseg_14F41

    eax = D2;                               // mov eax, D2
    D3 = eax;                               // mov D3, eax
    al = D0;                                // mov al, byte ptr D0
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    goto l_next;                            // jmp short @@next

cseg_14F41:;
    al = D0;                                // mov al, byte ptr D0
    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D3, al
    if (flags.sign == flags.overflow)
        goto l_next;                        // jge short @@next

    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax

l_next:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A2 = res;
    }                                       // add A2, 1
    (*(int16_t *)&D4)--;
    flags.overflow = (int16_t)(*(int16_t *)&D4) == INT16_MIN;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto l_loop;                        // jns @@loop

    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    al = D1;                                // mov al, byte ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    al = D2;                                // mov al, byte ptr D2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    al = D3;                                // mov al, byte ptr D3
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;
    flags.overflow = (int32_t)(*(int32_t *)&A1) == INT32_MAX;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1

l_out:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_15075()
{
    A2 = 6307;                              // mov A2, offset aFr
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, 0
    if (flags.zero)
        return;                             // jz @@exit

    A2 = 6307;                              // mov A2, offset aFr
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 108405;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset friendlyCopy
    if (flags.zero)
        return;                             // jz @@exit

    A2 = 6310;                              // mov A2, offset aWc
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 109079;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset worldCup2Copy
    if (flags.zero)
        return;                             // jz @@exit

    A2 = 6313;                              // mov A2, offset aWcq
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 109191;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset world_cup_qualifying_group_1_copy
    if (flags.carry)
        goto cseg_150E6;                    // jb short cseg_150E6

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 109867;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset oceaniaWorldCupQualificationCopy
    if (flags.carry || flags.zero)
        return;                             // jbe @@exit

cseg_150E6:;
    A2 = 6317;                              // mov A2, offset aEc
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 108445;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset europeanChampionships2Copy
    if (flags.zero)
        return;                             // jz @@exit

    A2 = 6320;                              // mov A2, offset aEcq
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 108523;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset e_c_qualifying_group_1_copy
    if (flags.carry)
        goto cseg_15126;                    // jb short cseg_15126

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 108803;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset e_c_qualifying_group_8_copy
    if (flags.carry || flags.zero)
        return;                             // jbe @@exit

cseg_15126:;
    A2 = 6324;                              // mov A2, offset aNac
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 108957;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset northAmericanCupCopy
    if (flags.zero)
        return;                             // jz @@exit

    A2 = 6328;                              // mov A2, offset aCa
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 108839;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset copaAmericaCopy
    if (flags.zero)
        return;                             // jz short @@exit

    A2 = 6331;                              // mov A2, offset aAnc
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 108909;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset africanNationsCupCopy
    if (flags.zero)
        return;                             // jz short @@exit

    A2 = 6335;                              // mov A2, offset aAc
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 109003;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset asianCupCopy
    if (flags.zero)
        return;                             // jz short @@exit

    A2 = 6338;                              // mov A2, offset aOc
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 109051;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset oceaniaCupCopy
    if (flags.zero)
        return;                             // jz short @@exit

    A2 = 6341;                              // mov A2, offset aTnm
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 108333;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset invitationTournamentCopy
    if (flags.zero)
        return;                             // jz short @@exit

    A2 = 6345;                              // mov A2, offset aTr
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 108369;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset tourCopy
    if (flags.zero)
        return;                             // jz short @@exit

    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0 - winning team number
//     D5 - number of goals to generate
//
// When player aborts the game they are punished with a loss, and this function will
// assign those fictive goals to other team scorers.
//
void AssignFakeGoalsToScorers()
{
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, 1
    if (flags.sign)
        return;                             // js @@out

    A3 = 332876;                            // mov A3, offset topTeamInGame
    ax = *(word *)&g_memByte[449298];       // mov ax, pl1Tactics
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto l_left_team;                   // jz short @@left_team

    A3 = 334580;                            // mov A3, offset bottomTeamInGame
    ax = *(word *)&g_memByte[449300];       // mov ax, pl2Tactics
    *(word *)&D6 = ax;                      // mov word ptr D6, ax

l_left_team:;
    {
        word res = *(word *)&D6 << 2;
        flags.carry = ((word)*(word *)&D6 >> 14) & 1;
        *(word *)&D6 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D6, 2
    A2 = 378446;                            // mov A2, offset playersPositionsByTactics
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A2 = eax;                               // mov A2, eax

l_goals_loop:;
    A4 = 486181;                            // mov A4, offset playerPositionsScoringChances
    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 248;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 248
    if (!flags.carry)
        goto l_own_goal;                    // jnb @@own_goal

    {
        word res = *(word *)&D0 & 127;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7Fh
    *(word *)&D6 = 10;                      // mov word ptr D6, 10
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_assign_goal_to_player;       // jb @@assign_goal_to_player

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_assign_goal_to_player;       // jb @@assign_goal_to_player

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_assign_goal_to_player;       // jb @@assign_goal_to_player

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_assign_goal_to_player;       // jb @@assign_goal_to_player

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_assign_goal_to_player;       // jb @@assign_goal_to_player

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_assign_goal_to_player;       // jb @@assign_goal_to_player

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_assign_goal_to_player;       // jb @@assign_goal_to_player

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_assign_goal_to_player;       // jb @@assign_goal_to_player

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_assign_goal_to_player;       // jb @@assign_goal_to_player

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_assign_goal_to_player;       // jb short @@assign_goal_to_player

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 127;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7Fh
    *(word *)&D6 = 1;                       // mov word ptr D6, 1
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto l_assign_goal_to_player;       // jb short @@assign_goal_to_player

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1

l_assign_goal_to_player:;
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    ax = D6;                                // mov ax, word ptr D6
    bx = 61;                                // mov bx, 61
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)((byte *)&D6 + 2) = dx;        // mov word ptr D6+2, dx
    eax = A3;                               // mov eax, A3
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 44, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        src = res;
        writeMemory(esi + 44, 1, src);
    }                                       // add [esi+PlayerGameHeader.goalsScored], 1

l_next_goal:;
    (*(int16_t *)&D5)--;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto l_goals_loop;                  // jns @@goals_loop

    return;                                 // retn

l_own_goal:;
    esi = A3;                               // mov esi, A3
    {
        byte src = (byte)readMemory(esi + 40, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 40, 1, src);
    }                                       // add [esi+TeamGame.numOwnGoals], 1
    goto l_next_goal;                       // jmp short @@next_goal
}

// =============== S U B R O U T I N E =======================================
//
void EnqueueCornerSample()
{
    *(word *)&g_memByte[485390] = 100;      // mov playingCornerSample, 100
}

// =============== S U B R O U T I N E =======================================
//
void EnqueueThrowInSample()
{
    *(word *)&g_memByte[485392] = 70;       // mov playingThrowInSample, 70
}

// =============== S U B R O U T I N E =======================================
//
void EnqueueDeletedSample()
{
}

// =============== S U B R O U T I N E =======================================
//
void StopGoodPassSample()
{
    *(word *)&g_memByte[485394] = -1;       // mov playingGoodPassTimer, -1
}

// =============== S U B R O U T I N E =======================================
//
void EnqueuPlayingGoodPassSample()
{
    *(word *)&g_memByte[485394] = -1;       // mov playingGoodPassTimer, -1
    {
        word src = *(word *)&g_memByte[485388];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[485388] = src;
    }                                       // add goodPassTimer, 1
    {
        word src = *(word *)&g_memByte[485388];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp goodPassTimer, 5
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&g_memByte[485388] = 0;        // mov goodPassTimer, 0
    *(word *)&g_memByte[485394] = 10;       // mov playingGoodPassTimer, 10
}

// =============== S U B R O U T I N E =======================================
//
void RingABell()
{
    push(ax);                               // push ax
    push(dx);                               // push dx
    ah = 2;                                 // mov ah, 2
    dl = 7;                                 // mov dl, 7
    {
        int32_t val = stack[stackTop++];
        dx = val;
    }                                       // pop dx
    {
        int32_t val = stack[stackTop++];
        ax = val;
    }                                       // pop ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      al - PIT mode control byte
//      cx - countdown
//
void ProgramPIT()
{
}

// =============== S U B R O U T I N E =======================================
//
void InitMenuMusic()
{
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 -  sprite number
//      A0 -> color conversion table
//
// Converts sprites to 8 colors.
//
void ConvertSpriteColors()
{
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - sprite index
//      D1 - x
//      D2 - y
//
// Destroys ebp.
//
void DrawSpriteCentered()
{
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - sprite number
//      D1 - x
//      D2 - y
//
// Draw sprite to vsPtr. Does clipping.
// Destroys D0, D2, D4, D5, D7, A0, A1,
//          eax, ebx, ecx, edx, esi, edi, ebp.
//
void DrawSprite()
{
}

// =============== S U B R O U T I N E =======================================
//
void SetExitMenuFlag()
{
    *(word *)&g_memByte[317586] = 1;        // mov g_exitMenu, 1
}

// =============== S U B R O U T I N E =======================================

// Read timer difference and update time of last drawn frame.
//
void ReadTimerDelta()
{
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[323902];       // mov ax, lastGameTick
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (!flags.zero)
        goto l_difference_not_zero;         // jnz short @@difference_not_zero

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1

l_difference_not_zero:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[323900] = ax;       // mov lastFrameTicks, ax
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&g_memByte[323902] = ax;       // mov lastGameTick, ax
}

// =============== S U B R O U T I N E =======================================
//
void SetDefaultNameAndSurname()
{
    *(word *)&g_memByte[91734] = 0;         // mov mrOrMs, MR
    ax = *(word *)&g_memByte[323904];       // mov ax, currentGameTick
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    bx = 5;                                 // mov bx, 5
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    A2 = 378314;                            // mov A2, offset defaultNamesTable
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    A1 = 91741;                             // mov A1, offset managerNameBuffer
    push(D0);                               // push D0
    StringCopy();                           // call StringCopy
    pop(D0);                                // pop D0
    A2 = 378334;                            // mov A2, offset defaultSurnamesTable
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    A1 = 91750;                             // mov A1, offset managerSurnameBuffer
    push(D0);                               // push D0
    StringCopy();                           // call StringCopy
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - menu item ordinal that we're converting
//
// returns:
//      D0 -  offset to menu entry
//      A0 -> pointer to menu entry
//
// destroys:
//      eax, ebx, edx, D0, A0
//      [ebp safe]
//
void CalcMenuEntryAddress()
{
    A0 = 347300;                            // mov A0, offset g_currentMenu
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 22;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, size Menu
    ax = D0;                                // mov ax, word ptr D0
    bx = 56;                                // mov bx, size MenuEntry
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, eax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - max. number of items to draw
//      A5 - pointer to first entry to draw
//
void CallDrawMultipleItems()
{
}

// =============== S U B R O U T I N E =======================================

// in:
//      A5 - ptr to item to draw
//
void CallDrawMenuItem()
{
    SWOS::DrawMenuItem();                   // call DrawMenuItem
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 = src sprite index
//      D1 = dest sprite index
//
void CopyWholeSprite()
{
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_5()
{
}

// =============== S U B R O U T I N E =======================================
//
void ZeroOutStars()
{
    A0 = 4201;                              // mov A0, offset aChairmanScenes

l_search_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_loop_2;                      // jz short @@loop_2

    (*(int32_t *)&A0)++;                    // inc A0
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '*';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], '*'
    if (!flags.zero)
        goto l_search_loop;                 // jnz short @@search_loop

    esi = A0;                               // mov esi, A0
    writeMemory(esi + -1, 1, 0);            // mov byte ptr [esi-1], 0

l_loop_2:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_loop_2;                      // jnz short @@loop_2

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 23355;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset albania
    if (!flags.zero)
        goto l_search_loop;                 // jnz short @@search_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - game type
//
void InitCareerVariables()
{
    ax = *(word *)&g_memByte[323906];       // mov ax, currentTick
    *(word *)&g_memByte[131718] = ax;       // mov randomSeed, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[129472] = ax;       // mov g_gameType, ax
    *(word *)&g_memByte[129474] = 0;        // mov contestStarted, 0
    *(word *)&g_memByte[323894] = 0;        // mov teamsLoaded, 0
    *(word *)&g_memByte[129476] = 0;        // mov dseg_E0052, 0
    *(word *)&g_memByte[91720] = -1;        // mov selTeamNumber, -1
    *(word *)&g_memByte[91330] = 0;         // mov currentSeasonShowing, 0
    g_memByte[129467] = 94;                 // mov seasonPlaying, 94
    g_memByte[316646] = 0;                  // mov competitionFilename, 0
    *(word *)&g_memByte[36606] = 0;         // mov careerFileBuffer, 0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> src
//      A1 -> dest
// out:
//      A1 -> ending zero
//
void StringCopy()
{
_l_start:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto _l_start;                      // jnz short StringCopy

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // sub A1, 1
}

// =============== S U B R O U T I N E =======================================
//
void Randomize2()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(A0);                               // push A0
    ax = *(word *)&g_memByte[131718];       // mov ax, randomSeed
    *(word *)&D0 ^= ax;                     // xor word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[131714] = ax;       // mov word ptr seed2, ax
    A0 = 379922;                            // mov A0, offset kRandomTable
    al = g_memByte[131715];                 // mov al, randXorIndex2
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0FFh
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    g_memByte[131716] = al;                 // mov randXorKey2, al
    pop(A0);                                // pop A0
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 - pointer to string
// out:
//      A0 -> end of string (one before zero, better don't send empty string //))
//      D0 -  string length
//
void GetStringLength()
{
    *(word *)&D0 = 0;                       // mov word ptr D0, 0

l_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_end_of_str;                  // jz short @@end_of_str

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    goto l_loop;                            // jmp short @@loop

l_end_of_str:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // sub A0, 1
}

// =============== S U B R O U T I N E =======================================

// in:
//     A0 -> format string
//     A1 -> converted string in the end (words)
//     D0 - number 0
//     D1 - number 1
//     D2 - number 2
//     D3 - number 3
//     D4 - number 4
//     D5 - number 5
//     D6 - number 6
//     A2 - string a
//     A3 - string b
//     A4 - string c
//
// Format string can contain simple commands that start with %.
// %a, %b and %c mark string insertation, where actual strings
// are in A2, A3 and A4. Ascii representation of 0, 1,
// 2, 3, 4, 5, or 6 after % means converting number in D0-D6
// to ascii and inserting in output string.
//
void PrintFormatted()
{
    push(D7);                               // push D7
    push(A5);                               // push A5

l_loop:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '%';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], '%'
    if (flags.zero)
        goto l_percent_found;               // jz short @@percent_found

    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_loop;                        // jnz short @@loop

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // sub A1, 1
    pop(A5);                                // pop A5
    pop(D7);                                // pop D7
    return;                                 // retn

l_percent_found:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    eax = A2;                               // mov eax, A2
    A5 = eax;                               // mov A5, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + -1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 'a';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi-1], 'a'
    if (flags.zero)
        goto l_string;                      // jz @@string

    eax = A3;                               // mov eax, A3
    A5 = eax;                               // mov A5, eax
    {
        byte src = (byte)readMemory(esi + -1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 'b';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi-1], 'b'
    if (flags.zero)
        goto l_string;                      // jz @@string

    eax = A4;                               // mov eax, A4
    A5 = eax;                               // mov A5, eax
    {
        byte src = (byte)readMemory(esi + -1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 'c';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi-1], 'c'
    if (flags.zero)
        goto l_string;                      // jz @@string

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        byte src = (byte)readMemory(esi + -1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '0';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi-1], '0'
    if (flags.zero)
        goto l_number;                      // jz @@number

    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        byte src = (byte)readMemory(esi + -1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '1';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi-1], '1'
    if (flags.zero)
        goto l_number;                      // jz @@number

    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        byte src = (byte)readMemory(esi + -1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '2';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi-1], '2'
    if (flags.zero)
        goto l_number;                      // jz short @@number

    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        byte src = (byte)readMemory(esi + -1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '3';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi-1], '3'
    if (flags.zero)
        goto l_number;                      // jz short @@number

    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        byte src = (byte)readMemory(esi + -1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '4';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi-1], '4'
    if (flags.zero)
        goto l_number;                      // jz short @@number

    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        byte src = (byte)readMemory(esi + -1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '5';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi-1], '5'
    if (flags.zero)
        goto l_number;                      // jz short @@number

    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        byte src = (byte)readMemory(esi + -1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '6';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi-1], '6'

l_number:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 10
    if (flags.carry)
        goto l_less_than_10;                // jb @@less_than_10

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 100
    if (flags.carry)
        goto l_10_100;                      // jb @@10_100

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1000;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 1000
    if (flags.carry)
        goto l_100_1000;                    // jb @@100_1000

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 10000;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 10000
    if (flags.carry)
        goto l_1000_10000;                  // jb short @@1000_10000

    {
        dword res = D7 & 65535;
        D7 = res;
    }                                       // and D7, 0FFFFh
    ax = D7;                                // mov ax, word ptr D7
    dx = *(word *)((byte *)&D7 + 2);        // mov dx, word ptr D7+2
    bx = 10000;                             // mov bx, 10000
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '0';
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi, 1, src);
    }                                       // add byte ptr [esi], '0'
    (*(int32_t *)&A1)++;                    // inc A1
    {
        word tmp = *(word *)((byte *)&D7 + 2);
        *(word *)((byte *)&D7 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D7+2
    *(word *)&D7 = ax;                      // mov word ptr D7, ax

l_1000_10000:;
    ax = D7;                                // mov ax, word ptr D7
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D7 = eax;                               // mov D7, eax
    dx = *(word *)((byte *)&D7 + 2);        // mov dx, word ptr D7+2
    bx = 1000;                              // mov bx, 1000
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '0';
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi, 1, src);
    }                                       // add byte ptr [esi], '0'
    (*(int32_t *)&A1)++;                    // inc A1
    {
        word tmp = *(word *)((byte *)&D7 + 2);
        *(word *)((byte *)&D7 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D7+2
    *(word *)&D7 = ax;                      // mov word ptr D7, ax

l_100_1000:;
    ax = D7;                                // mov ax, word ptr D7
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D7 = eax;                               // mov D7, eax
    dx = *(word *)((byte *)&D7 + 2);        // mov dx, word ptr D7+2
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '0';
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi, 1, src);
    }                                       // add byte ptr [esi], '0'
    (*(int32_t *)&A1)++;                    // inc A1
    {
        word tmp = *(word *)((byte *)&D7 + 2);
        *(word *)((byte *)&D7 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D7+2
    *(word *)&D7 = ax;                      // mov word ptr D7, ax

l_10_100:;
    ax = D7;                                // mov ax, word ptr D7
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D7 = eax;                               // mov D7, eax
    dx = *(word *)((byte *)&D7 + 2);        // mov dx, word ptr D7+2
    bx = 10;                                // mov bx, 10
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '0';
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi, 1, src);
    }                                       // add byte ptr [esi], '0'
    (*(int32_t *)&A1)++;                    // inc A1
    {
        word tmp = *(word *)((byte *)&D7 + 2);
        *(word *)((byte *)&D7 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D7+2
    *(word *)&D7 = ax;                      // mov word ptr D7, ax

l_less_than_10:;
    al = D7;                                // mov al, byte ptr D7
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '0';
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        src = res;
        writeMemory(esi, 1, src);
    }                                       // add byte ptr [esi], '0'
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    goto l_loop;                            // jmp @@loop

l_string:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_string;                      // jnz short @@string

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // sub A1, 1
    goto l_loop;                            // jmp @@loop
}

// =============== S U B R O U T I N E =======================================
//
void InitUserTactics()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    A0 = 369671;                            // mov A0, (offset tact_5_3_2+121h)
    A1 = 368543;                            // mov A1, (offset tact_4_4_2+121h)
    A2 = 371551;                            // mov A2, (offset tacticsSweep+121h)
    *(word *)&D0 = 69;                      // mov word ptr D0, 69

l_copy_attackers_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A2)++;                    // inc A2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_attackers_loop;         // jns short @@copy_attackers_loop

    A0 = 368254;                            // mov A0, offset tact_4_4_2
    A1 = 129478;                            // mov A1, offset USER_A
    *(word *)&D0 = 369;                     // mov word ptr D0, 369

l_init_user_A_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_init_user_A_loop;            // jns short @@init_user_A_loop

    A0 = 368254;                            // mov A0, offset tact_4_4_2
    A1 = 129848;                            // mov A1, offset USER_B
    *(word *)&D0 = 369;                     // mov word ptr D0, 369

l_init_user_B_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_init_user_B_loop;            // jns short @@init_user_B_loop

    A0 = 368254;                            // mov A0, offset tact_4_4_2
    A1 = 130218;                            // mov A1, offset USER_C
    *(word *)&D0 = 369;                     // mov word ptr D0, 369

l_init_user_C_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_init_user_C_loop;            // jns short @@init_user_C_loop

    A0 = 368254;                            // mov A0, offset tact_4_4_2
    A1 = 130588;                            // mov A1, offset USER_D
    *(word *)&D0 = 369;                     // mov word ptr D0, 369

l_init_user_D_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_init_user_D_loop;            // jns short @@init_user_D_loop

    A0 = 368254;                            // mov A0, offset tact_4_4_2
    A1 = 130958;                            // mov A1, offset USER_E
    *(word *)&D0 = 369;                     // mov word ptr D0, 369

l_init_user_E_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_init_user_E_loop;            // jns short @@init_user_E_loop

    A0 = 368254;                            // mov A0, offset tact_4_4_2
    A1 = 131328;                            // mov A1, offset USER_F
    *(word *)&D0 = 369;                     // mov word ptr D0, 369

l_init_user_F_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_init_user_F_loop;            // jns short @@init_user_F_loop

    A0 = 10761;                             // mov A0, offset aUSER_A
    A1 = 129478;                            // mov A1, offset USER_A
    StringCopy();                           // call StringCopy
    A0 = 10768;                             // mov A0, offset aUSER_B
    A1 = 129848;                            // mov A1, offset USER_B
    StringCopy();                           // call StringCopy
    A0 = 10775;                             // mov A0, offset aUSER_C
    A1 = 130218;                            // mov A1, offset USER_C
    StringCopy();                           // call StringCopy
    A0 = 10782;                             // mov A0, offset aUSER_D
    A1 = 130588;                            // mov A1, offset USER_D
    StringCopy();                           // call StringCopy
    A0 = 10789;                             // mov A0, offset aUSER_E
    A1 = 130958;                            // mov A1, offset USER_E
    StringCopy();                           // call StringCopy
    A0 = 10796;                             // mov A0, offset aUSER_F
    A1 = 131328;                            // mov A1, offset USER_F
    StringCopy();                           // call StringCopy
    InitializeTacticsPositions();           // call InitializeTacticsPositions
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// Fill position by defensiveness, decreasing. It represents sum of how far player is from his own goal
// at every position (measured by maximum distance from goal (by y) and vertical half (by x)).
// Also called at the very start of program.
//
void InitializeTacticsPositions()
{
    A6 = 378446;                            // mov A6, offset playersPositionsByTactics
    A5 = 372768;                            // mov A5, offset g_tacticsTable
    *(word *)&D7 = 17;                      // mov word ptr D7, 17

l_tactics_loop:;
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 4
    A4 = eax;                               // mov A4, eax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A3 = eax;                               // mov A3, eax
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    (*(int32_t *)&A3)++;                    // inc A3
    A2 = 378424;                            // mov A2, offset positionDefensiveness
    *(word *)&D6 = 1;                       // mov word ptr D6, 1

l_players_positions_loop:;
    al = D6;                                // mov al, byte ptr D6
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A3)++;                    // inc A3
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        word res = *(word *)&D3 << 1;
        *(word *)&D3 = res;
    }                                       // shl word ptr D3, 1
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    writeMemory(esi + ebx, 2, 0);           // mov word ptr [esi+ebx], 0
    *(word *)&D4 = 34;                      // mov word ptr D4, 34

l_players_loop:;
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    bx = 35;                                // mov bx, 35
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    esi = A4;                               // mov esi, A4
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx + 9, 1); // mov al, [esi+ebx+Tactics.playerPos.positions]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 255;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFh
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        word res = *(word *)&D1 >> 4;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 4
    {
        word res = *(word *)&D2 & 15;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 0Fh
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 7
    if (!flags.sign)
        goto l_left_side;                   // jns short @@left_side

    *(int16_t *)&D1 = -*(int16_t *)&D1;     // neg word ptr D1

l_left_side:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 15
    *(int16_t *)&D2 = -*(int16_t *)&D2;     // neg word ptr D2
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.carry || flags.zero)
        goto l_x_greater;                   // jbe short @@x_greater

    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_x_greater:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    {
        word src = (word)readMemory(esi + ebx, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + ebx, 2, src);
    }                                       // add [esi+ebx], ax
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 1
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 15
    if (!flags.carry)
        goto l_players_loop;                // jnb @@players_loop

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 11
    if (flags.carry)
        goto l_players_positions_loop;      // jb @@players_positions_loop

    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 4
    A4 = eax;                               // mov A4, eax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 1
    *(word *)&D5 = 8;                       // mov word ptr D5, 8

l_bubble_sort_positions:;
    eax = A4;                               // mov eax, A4
    A3 = eax;                               // mov A3, eax
    A2 = 378426;                            // mov A2, (offset positionDefensiveness+2)
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D4 = ax;                      // mov word ptr D4, ax

l_buble_position_loop:;
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 1
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto l_next_position;               // jnb short @@next_position

    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    writeMemory(esi + -2, 2, ax);           // mov [esi-2], ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    writeMemory(esi + -1, 1, al);           // mov [esi-1], al
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi, 1, al);                // mov [esi], al
    *(word *)&D3 = 1;                       // mov word ptr D3, 1

l_next_position:;
    (*(int16_t *)&D4)--;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto l_buble_position_loop;         // jns @@buble_position_loop

    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_bubble_sort_positions;       // jnz @@bubble_sort_positions

    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_tactics_loop;                // jns @@tactics_loop
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_17()
{
}

// =============== S U B R O U T I N E =======================================

// Copy string1 to string2 until char or end of string is encountered.
//
// in:  A0 -> src string
//      A1 -> dst string
//      D0 = char
//
void StringCopyUntilChar()
{
_l_start:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto l_char_end;                    // jz short @@char_end

    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto _l_start;                      // jnz short StringCopyUntilChar

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // sub A1, 1
    return;                                 // retn

l_char_end:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // sub A0, 1
}

// =============== S U B R O U T I N E =======================================
//
void ChangePitchType()
{
    {
        word src = *(word *)&g_memByte[131708];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[131708] = src;
    }                                       // add g_pitchType, 1
    {
        word src = *(word *)&g_memByte[131708];
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_pitchType, 7
    if (!flags.zero)
        goto l_out;                         // jnz short @@out

    *(word *)&g_memByte[131708] = 65534;    // mov g_pitchType, SEASONAL

l_out:;
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void ChangeGameLength()
{
    {
        word src = *(word *)&g_memByte[131698];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[131698] = src;
    }                                       // add g_gameLength, 1
    {
        word src = *(word *)&g_memByte[131698];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameLength, 4
    if (!flags.zero)
        goto l_out;                         // jnz short @@out

    *(word *)&g_memByte[131698] = 0;        // mov g_gameLength, 0

l_out:;
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void ChangeAutoReplays()
{
    {
        word src = *(word *)&g_memByte[131700];
        src ^= 1;
        *(word *)&g_memByte[131700] = src;
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor g_autoReplays, 1
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void ChangeAllPlTeamsEqual()
{
    {
        word src = *(word *)&g_memByte[131706];
        src ^= 1;
        *(word *)&g_memByte[131706] = src;
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor g_allPlayerTeamsEqual, 1
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void ChangeAutoSaveHighlights()
{
    {
        word src = *(word *)&g_memByte[131704];
        src ^= 1;
        *(word *)&g_memByte[131704] = src;
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor g_autoSaveHighlights, 1
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void SaveOptions()
{
    A0 = 131698;                            // mov A0, offset g_gameLength
    A1 = 252450;                            // mov A1, offset s_gameLength
    *(word *)&D0 = 7;                       // mov word ptr D0, 7

l_save_options_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_save_options_loop;           // jns short @@save_options_loop
}

// =============== S U B R O U T I N E =======================================
//
void RestoreOptions()
{
    A0 = 252450;                            // mov A0, offset s_gameLength
    A1 = 131698;                            // mov A1, offset g_gameLength
    *(word *)&D0 = 7;                       // mov word ptr D0, 7

l_restore_options_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_restore_options_loop;        // jns short @@restore_options_loop
}

// =============== S U B R O U T I N E =======================================
//
void CycleMenuMusic()
{
}

// =============== S U B R O U T I N E =======================================
//
void GlobalRetn()
{
}

// =============== S U B R O U T I N E =======================================

// Set text at CONTINUE... and SAVE... entries, depending
// on mode (career, season, diy) and name of the save file.
// Called when returning to main menu from various submenus.
//
void CommonMenuExit()
{
    ax = *(word *)&g_memByte[129472];       // mov ax, g_gameType
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, GAME_TYPE_DIY_COMPETITION
    if (flags.zero)
        goto l_diy_competition;             // jz @@diy_competition

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, GAME_TYPE_PRESET_COMPETITION
    if (flags.zero)
        goto l_preset_competition;          // jz @@preset_competition

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, GAME_TYPE_SEASON
    if (flags.zero)
        goto l_season;                      // jz @@season

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, GAME_TYPE_CAREER
    if (flags.zero)
        goto l_career;                      // jz @@career

    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    return;                                 // retn

l_diy_competition:;
    A2 = 126572;                            // mov A2, offset diyPresetNameOfCompetition
    ax = *(word *)&g_memByte[126570];       // mov ax, competitionOver
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto l_replay;                      // jnz short @@replay

    goto l_continue;                        // jmp short @@continue

l_preset_competition:;
    A2 = 126572;                            // mov A2, offset diyPresetNameOfCompetition
    ax = *(word *)&g_memByte[126570];       // mov ax, competitionOver
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto l_replay;                      // jnz short @@replay

    goto l_continue;                        // jmp short @@continue

l_season:;
    A2 = 18845;                             // mov A2, offset aSeason
    goto l_continue;                        // jmp short @@continue

l_career:;
    A2 = 18550;                             // mov A2, offset aCareer

l_continue:;
    A0 = 9204;                              // mov A0, offset aContinueA
    goto l_show_save_and_continue_entries;  // jmp short @@show_save_and_continue_entries

l_replay:;
    A0 = 9219;                              // mov A0, offset aReplayA

l_show_save_and_continue_entries:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    PrintFormatted();                       // call PrintFormatted
    A0 = 9234;                              // mov A0, offset aSaveA
    A1 = 378716;                            // mov A1, offset saveFileTitle
    PrintFormatted();                       // call PrintFormatted
    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
}

// =============== S U B R O U T I N E =======================================
//
void FriendlyMenu()
{
    ax = *(word *)&g_memByte[323906];       // mov ax, currentTick
    *(word *)&g_memByte[486180] = ax;       // mov word ptr seed, ax
    Friendly();                             // call Friendly
    CommonMenuExit();                       // jmp CommonMenuExit
}

// =============== S U B R O U T I N E =======================================
//
void DIYCompetitionMenu()
{
    ax = *(word *)&g_memByte[323906];       // mov ax, currentTick
    *(word *)&g_memByte[486180] = 0;        // mov word ptr seed, 0
    A0 = 17000;                             // mov A0, offset aDiyCompetition
    CheckContinueAbortPrompt();             // call CheckContinueAbortPrompt
    if (!flags.zero)
        goto l_continue_selected;           // jnz short @@continue_selected

    A6 = 508036;                            // mov A6, offset diyCompetitionMenu
    SWOS::ShowMenu();                       // call ShowMenu
    ax = *(word *)&g_memByte[336406];       // mov ax, diySelected
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_continue_selected;           // js short @@continue_selected

    ax = *(word *)&g_memByte[336406];       // mov ax, diySelected
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_diy_league;                  // jz short @@diy_league

    {
        word src = *(word *)&g_memByte[336406];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp diySelected, 1
    if (flags.zero)
        goto l_diy_cup;                     // jz short @@diy_cup

    ShowDesignDIYTournamentMenu();          // call ShowDesignDIYTournamentMenu
    goto l_exit_diy_tournament;             // jmp short @@exit_diy_tournament

l_diy_cup:;
    ShowDesignDIYCupMenu();                 // call ShowDesignDIYCupMenu
    goto l_exit_diy_tournament;             // jmp short @@exit_diy_tournament

l_diy_league:;
    ShowDesignDIYLeagueMenu();              // call ShowDesignDIYLeagueMenu

l_exit_diy_tournament:;
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_NO_GAME
    if (flags.zero)
        goto l_continue_selected;           // jz short @@continue_selected

    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

l_continue_selected:;
    CommonMenuExit();                       // jmp CommonMenuExit
}

// =============== S U B R O U T I N E =======================================
//
void PresetCompetitionMenu()
{
    ax = *(word *)&g_memByte[323906];       // mov ax, currentTick
    *(word *)&g_memByte[486180] = ax;       // mov word ptr seed, ax
    A0 = 18889;                             // mov A0, offset aPresetCompetit
    CheckContinueAbortPrompt();             // call CheckContinueAbortPrompt
    if (!flags.zero)
        goto cseg_224D3;                    // jnz short cseg_224D3

    SelectTeamsForPresetCompetition();      // call SelectTeamsForPresetCompetition
    ax = *(word *)&g_memByte[330694];       // mov ax, chooseTeamsResult
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_224D9;                    // jnz short cseg_224D9

cseg_224D3:;
    CommonMenuExit();                       // call CommonMenuExit

l_out:;
    return;                                 // retn

cseg_224D9:;
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CareerInitVars();                       // call CareerInitVars
    eax = *(dword *)&g_memByte[330194];     // mov eax, selectedContest
    A6 = eax;                               // mov A6, eax
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 0
    if (flags.zero)
        goto cseg_2250E;                    // jz short cseg_2250E

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 1
    if (flags.zero)
        goto cseg_22578;                    // jz short cseg_22578

    goto cseg_225D3;                        // jmp cseg_225D3

cseg_2250E:;
    A0 = 318944;                            // mov A0, offset dseg_10EFD6
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_87D60();                           // call cseg_87D60
    eax = *(dword *)&g_memByte[330194];     // mov eax, selectedContest
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[330198];       // mov ax, dseg_1132B9
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_8F1F2();                           // call cseg_8F1F2
    InitTeams();                            // call InitTeams
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    ShowDiyLeaguesTournamentMenu();         // call ShowDiyLeaguesTournamentMenu
    cseg_89AC8();                           // call cseg_89AC8
    CommonMenuExit();                       // call CommonMenuExit
    goto cseg_22627;                        // jmp cseg_22627

cseg_22578:;
    A0 = 319232;                            // mov A0, offset dseg_10F0F6
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_87D60();                           // call cseg_87D60
    eax = *(dword *)&g_memByte[330194];     // mov eax, selectedContest
    A0 = eax;                               // mov A0, eax
    cseg_87DA0();                           // call cseg_87DA0
    InitTeams();                            // call InitTeams
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_45B51();                           // call cseg_45B51
    cseg_89A34();                           // call cseg_89A34
    CommonMenuExit();                       // call CommonMenuExit
    goto cseg_22627;                        // jmp short cseg_22627

cseg_225D3:;
    A0 = 317741;                            // mov A0, offset dseg_10EB23
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_87D60();                           // call cseg_87D60
    eax = *(dword *)&g_memByte[330194];     // mov eax, selectedContest
    A0 = eax;                               // mov A0, eax
    cseg_24DFA();                           // call cseg_24DFA
    InitTeams();                            // call InitTeams
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_89B5C();                           // call cseg_89B5C
    cseg_899A0();                           // call cseg_899A0

cseg_22627:;
    CommonMenuExit();                       // call CommonMenuExit
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_NO_GAME
    if (flags.zero)
        return;                             // jz @@out

    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void SeasonMenu()
{
    ax = *(word *)&g_memByte[323906];       // mov ax, currentTick
    *(word *)&g_memByte[486180] = 0;        // mov word ptr seed, 0
    A0 = 18845;                             // mov A0, offset aSeason
    CheckContinueAbortPrompt();             // call CheckContinueAbortPrompt
    if (!flags.zero)
        goto l_out_exit_menu;               // jnz short @@out_exit_menu

    cseg_4C6EE();                           // call cseg_4C6EE
    ax = *(word *)&g_memByte[330694];       // mov ax, chooseTeamsResult
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_22685;                    // jnz short cseg_22685

l_out_exit_menu:;
    CommonMenuExit();                       // jmp CommonMenuExit

cseg_22684:;
    return;                                 // retn

cseg_22685:;
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CareerInitVars();                       // call CareerInitVars
    eax = *(dword *)&g_memByte[330194];     // mov eax, selectedContest
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[330198];       // mov ax, dseg_1132B9
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    InitNewSeason();                        // call InitNewSeason
    A6 = 489733;                            // mov A6, offset contestMenu
    SWOS::ShowMenu();                       // call ShowMenu
    CommonMenuExit();                       // call CommonMenuExit
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 0
    if (flags.zero)
        return;                             // jz short cseg_22684

    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void CareerMenu()
{
    ax = *(word *)&g_memByte[323906];       // mov ax, currentTick
    *(word *)&g_memByte[486180] = 0;        // mov word ptr seed, 0
    A0 = 18550;                             // mov A0, offset aCareer
    CheckContinueAbortPrompt();             // call CheckContinueAbortPrompt
    if (!flags.zero)
        goto l_out;                         // jnz short @@out

    A6 = 490853;                            // mov A6, offset careerMenu
    SWOS::ShowMenu();                       // call ShowMenu
    CommonMenuExit();                       // call CommonMenuExit
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_NO_GAME
    if (flags.zero)
        goto l_out;                         // jz short @@out

    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

l_out:;
    CommonMenuExit();                       // jmp CommonMenuExit
}

// =============== S U B R O U T I N E =======================================
//
void StartContest()
{
    *(word *)&g_memByte[129474] = 0;        // mov contestStarted, 0
    ax = *(word *)&g_memByte[129472];       // mov ax, g_gameType
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, GAME_TYPE_DIY_COMPETITION
    if (flags.zero)
        goto l_diy_competition;             // jz short @@diy_competition

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, GAME_TYPE_PRESET_COMPETITION
    if (flags.zero)
        goto l_preset_competition;          // jz short @@preset_competition

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, GAME_TYPE_SEASON
    if (flags.zero)
        goto l_season;                      // jz @@season

    goto l_career;                          // jmp @@career

l_diy_competition:;
    {
        word src = *(word *)&g_memByte[126570];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp competitionOver, 1
    if (flags.zero)
        goto l_diy_competition_over;        // jz short @@diy_competition_over

    goto l_diy_not_over;                    // jmp @@diy_not_over

l_preset_competition:;
    {
        word src = *(word *)&g_memByte[126570];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp competitionOver, 1
    if (flags.zero)
        goto l_preset_competition_over;     // jz @@preset_competition_over

    goto l_preset_not_over;                 // jmp @@preset_not_over

l_diy_competition_over:;
    ax = *(word *)&g_memByte[126568];       // mov ax, competitionFileBuffer
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_22812;                    // jz short cseg_22812

    {
        word src = *(word *)&g_memByte[126568];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp competitionFileBuffer, 1
    if (flags.zero)
        goto cseg_227DE;                    // jz short cseg_227DE

    SaveDIYTournament();                    // call SaveDIYTournament
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_89B5C();                           // call cseg_89B5C
    RestoreDIYTournament();                 // call RestoreDIYTournament
    CommonMenuExit();                       // call CommonMenuExit
    goto l_continue_contest;                // jmp @@continue_contest

cseg_227DE:;
    cseg_27FFF();                           // call cseg_27FFF
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_45B51();                           // call cseg_45B51
    cseg_28076();                           // call cseg_28076
    CommonMenuExit();                       // call CommonMenuExit
    goto l_continue_contest;                // jmp @@continue_contest

cseg_22812:;
    SaveDIYLeague();                        // call SaveDIYLeague
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    ShowDiyLeaguesTournamentMenu();         // call ShowDiyLeaguesTournamentMenu
    RestoreDIYLeague();                     // call RestoreDIYLeague
    CommonMenuExit();                       // call CommonMenuExit
    goto l_continue_contest;                // jmp @@continue_contest

l_preset_competition_over:;
    ax = *(word *)&g_memByte[126568];       // mov ax, competitionFileBuffer
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_228C9;                    // jz short cseg_228C9

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto cseg_22895;                    // jz short cseg_22895

    cseg_89956();                           // call cseg_89956
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_89B5C();                           // call cseg_89B5C
    cseg_899A0();                           // call cseg_899A0
    CommonMenuExit();                       // call CommonMenuExit
    goto l_continue_contest;                // jmp @@continue_contest

cseg_22895:;
    cseg_899EA();                           // call cseg_899EA
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_45B51();                           // call cseg_45B51
    cseg_89A34();                           // call cseg_89A34
    CommonMenuExit();                       // call CommonMenuExit
    goto l_continue_contest;                // jmp @@continue_contest

cseg_228C9:;
    cseg_89A7E();                           // call cseg_89A7E
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    ShowDiyLeaguesTournamentMenu();         // call ShowDiyLeaguesTournamentMenu
    cseg_89AC8();                           // call cseg_89AC8
    CommonMenuExit();                       // call CommonMenuExit
    goto l_continue_contest;                // jmp @@continue_contest

l_season:;
    A6 = 489733;                            // mov A6, offset contestMenu
    SWOS::ShowMenu();                       // call ShowMenu
    CommonMenuExit();                       // call CommonMenuExit
    goto l_continue_contest;                // jmp @@continue_contest

l_career:;
    A6 = 489733;                            // mov A6, offset contestMenu
    SWOS::ShowMenu();                       // call ShowMenu
    CommonMenuExit();                       // call CommonMenuExit
    goto l_continue_contest;                // jmp @@continue_contest

l_diy_not_over:;
    ax = *(word *)&g_memByte[126568];       // mov ax, competitionFileBuffer
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_diy_league;                  // jz @@diy_league

    {
        word src = *(word *)&g_memByte[126568];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp competitionFileBuffer, 1
    if (flags.zero)
        goto l_diy_cup;                     // jz short @@diy_cup

    SaveDIYTournament();                    // call SaveDIYTournament
    InitTeams();                            // call InitTeams
    cseg_8AC02();                           // call cseg_8AC02
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_89B5C();                           // call cseg_89B5C
    RestoreDIYTournament();                 // call RestoreDIYTournament
    CommonMenuExit();                       // call CommonMenuExit
    goto l_continue_contest;                // jmp @@continue_contest

l_diy_cup:;
    cseg_27FFF();                           // call cseg_27FFF
    InitTeams();                            // call InitTeams
    cseg_8AC90();                           // call cseg_8AC90
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_45B51();                           // call cseg_45B51
    cseg_28076();                           // call cseg_28076
    CommonMenuExit();                       // call CommonMenuExit
    goto l_continue_contest;                // jmp @@continue_contest

l_diy_league:;
    SaveDIYLeague();                        // call SaveDIYLeague
    InitTeams();                            // call InitTeams
    cseg_8AED0();                           // call cseg_8AED0
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    ShowDiyLeaguesTournamentMenu();         // call ShowDiyLeaguesTournamentMenu
    RestoreDIYLeague();                     // call RestoreDIYLeague
    CommonMenuExit();                       // call CommonMenuExit
    goto l_continue_contest;                // jmp @@continue_contest

l_preset_not_over:;
    ax = *(word *)&g_memByte[126568];       // mov ax, competitionFileBuffer
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_22A97;                    // jz cseg_22A97

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto cseg_22A5C;                    // jz short cseg_22A5C

    cseg_89956();                           // call cseg_89956
    InitTeams();                            // call InitTeams
    cseg_8AC02();                           // call cseg_8AC02
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_89B5C();                           // call cseg_89B5C
    cseg_899A0();                           // call cseg_899A0
    CommonMenuExit();                       // call CommonMenuExit
    goto l_continue_contest;                // jmp short @@continue_contest

cseg_22A5C:;
    cseg_899EA();                           // call cseg_899EA
    InitTeams();                            // call InitTeams
    cseg_8AC90();                           // call cseg_8AC90
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_45B51();                           // call cseg_45B51
    cseg_89A34();                           // call cseg_89A34
    CommonMenuExit();                       // call CommonMenuExit
    goto l_continue_contest;                // jmp short @@continue_contest

cseg_22A97:;
    cseg_89A7E();                           // call cseg_89A7E
    InitTeams();                            // call InitTeams
    cseg_8AED0();                           // call cseg_8AED0
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    ShowDiyLeaguesTournamentMenu();         // call ShowDiyLeaguesTournamentMenu
    cseg_89AC8();                           // call cseg_89AC8
    CommonMenuExit();                       // call CommonMenuExit

l_continue_contest:;
    CommonMenuExit();                       // call CommonMenuExit
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_NO_GAME
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&D0 = 12;                      // mov word ptr D0, 12
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void SaveContest()
{
    A0 = 378716;                            // mov A0, offset saveFileTitle
    SetZeroFlag();                          // call SetZeroFlag
    ax = *(word *)&g_memByte[129472];       // mov ax, g_gameType
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, GAME_TYPE_DIY_COMPETITION
    if (flags.zero)
        goto l_saving_diy_file;             // jz short @@saving_diy_file

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, GAME_TYPE_PRESET_COMPETITION
    if (flags.zero)
        goto l_saving_preset_file;          // jz short @@saving_preset_file

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, GAME_TYPE_SEASON
    if (flags.zero)
        goto l_saving_season;               // jz @@saving_season

    goto l_saving_career;                   // jmp @@saving_career

l_saving_diy_file:;
    D0 = 776227161;                         // mov D0, '.DIY'
    A0 = 316646;                            // mov A0, offset competitionFilename
    A1 = 378716;                            // mov A1, offset saveFileTitle
    SWOS::SelectFileToSaveDialog();         // call SelectFileToSaveDialog
    if (!flags.zero)
        goto l_canceled;                    // jnz @@canceled

    *(byte *)&D0 = 1;                       // mov byte ptr D0, 1
    push(A0);                               // push A0
    SaveDIYFile();                          // call SaveDIYFile
    pop(A0);                                // pop A0
    if (!flags.zero)
        goto l_canceled;                    // jnz @@canceled

    *(word *)&g_memByte[129474] = 1;        // mov contestStarted, 1
    A1 = 316646;                            // mov A1, offset competitionFilename
    StringCopy();                           // call StringCopy
    goto l_canceled;                        // jmp @@canceled

l_saving_preset_file:;
    D0 = 777015877;                         // mov D0, '.PRE'
    A0 = 316646;                            // mov A0, offset competitionFilename
    A1 = 378716;                            // mov A1, offset saveFileTitle
    SWOS::SelectFileToSaveDialog();         // call SelectFileToSaveDialog
    if (!flags.zero)
        goto l_canceled;                    // jnz @@canceled

    *(byte *)&D0 = 2;                       // mov byte ptr D0, 2
    push(A0);                               // push A0
    SavePresetCompetitionFile();            // call SavePresetCompetitionFile
    pop(A0);                                // pop A0
    if (!flags.zero)
        goto l_canceled;                    // jnz @@canceled

    *(word *)&g_memByte[129474] = 1;        // mov contestStarted, 1
    A1 = 316646;                            // mov A1, offset competitionFilename
    StringCopy();                           // call StringCopy
    goto l_canceled;                        // jmp @@canceled

    return;                                 // retn

l_saving_season:;
    A0 = 316646;                            // mov A0, offset competitionFilename
    D0 = 777209153;                         // mov D0, '.SEA'
    A1 = 378716;                            // mov A1, offset saveFileTitle
    SWOS::SelectFileToSaveDialog();         // call SelectFileToSaveDialog
    if (!flags.zero)
        goto l_canceled;                    // jnz @@canceled

    *(byte *)&D0 = 3;                       // mov byte ptr D0, 3
    push(A0);                               // push A0
    j_SaveCareerFile();                     // call j_SaveCareerFile
    pop(A0);                                // pop A0
    if (!flags.zero)
        goto l_canceled;                    // jnz short @@canceled

    *(word *)&g_memByte[129474] = 1;        // mov contestStarted, 1
    A1 = 316646;                            // mov A1, offset competitionFilename
    StringCopy();                           // call StringCopy
    goto l_canceled;                        // jmp short @@canceled

l_saving_career:;
    A0 = 316646;                            // mov A0, offset competitionFilename
    D0 = 776159570;                         // mov D0, '.CAR'
    A1 = 378716;                            // mov A1, offset saveFileTitle
    SWOS::SelectFileToSaveDialog();         // call SelectFileToSaveDialog
    if (!flags.zero)
        goto l_canceled;                    // jnz short @@canceled

    *(byte *)&D0 = 4;                       // mov byte ptr D0, 4
    push(A0);                               // push A0
    SaveCareerFile();                       // call SaveCareerFile
    pop(A0);                                // pop A0
    if (!flags.zero)
        goto l_canceled;                    // jnz short @@canceled

    *(word *)&g_memByte[129474] = 1;        // mov contestStarted, 1
    A1 = 316646;                            // mov A1, offset competitionFilename
    StringCopy();                           // call StringCopy

l_canceled:;
    A0 = 378716;                            // mov A0, offset saveFileTitle
    SetZeroFlag();                          // call SetZeroFlag
    CommonMenuExit();                       // jmp CommonMenuExit
}

// =============== S U B R O U T I N E =======================================
//
void LoadOldCompetitionMenu()
{
    A0 = 19629;                             // mov A0, offset aLoadOldCompeti
    CheckContinueAbortPrompt();             // call CheckContinueAbortPrompt
    if (!flags.zero)
        goto l_aborted;                     // jnz @@aborted

    A0 = 19629;                             // mov A0, offset aLoadOldCompeti
    D0 = 0;                                 // mov D0, 0
    A1 = 19629;                             // mov A1, offset aLoadOldCompeti
    *(word *)&g_memByte[456346] = -1;       // mov g_skipNonCompetitionFiles, -1
    SWOS::GetFilenameAndExtension();        // call GetFilenameAndExtension
    *(word *)&g_memByte[456346] = 0;        // mov g_skipNonCompetitionFiles, 0
    if (!flags.zero)
        goto l_out;                         // jnz @@out

    {
        int32_t dstSigned = D1;
        int32_t srcSigned = 776227161;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, '.DIY'
    if (flags.zero)
        goto l_diy;                         // jz short @@diy

    {
        int32_t dstSigned = D1;
        int32_t srcSigned = 777015877;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, '.PRE'
    if (flags.zero)
        goto l_preset;                      // jz short @@preset

    {
        int32_t dstSigned = D1;
        int32_t srcSigned = 777209153;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, '.SEA'
    if (flags.zero)
        goto l_season;                      // jz @@season

    {
        int32_t dstSigned = D1;
        int32_t srcSigned = 776159570;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, '.CAR'
    if (flags.zero)
        goto l_career;                      // jz @@career

    A0 = 8735;                              // mov A0, offset aNotACompetitio
    SWOS::ShowErrorMenu();                  // call ShowErrorMenu
    goto l_out;                             // jmp @@out

l_diy:;
    push(A0);                               // push A0
    LoadDIYFile();                          // call LoadDIYFile
    pop(A0);                                // pop A0
    if (!flags.zero)
        goto l_error_loading_file;          // jnz @@error_loading_file

    A1 = 316646;                            // mov A1, offset competitionFilename
    StringCopy();                           // call StringCopy
    goto l_start_contest;                   // jmp short @@start_contest

l_aborted:;
    CommonMenuExit();                       // call CommonMenuExit
    return;                                 // retn

l_preset:;
    push(A0);                               // push A0
    LoadPresetFile();                       // call LoadPresetFile
    pop(A0);                                // pop A0
    if (!flags.zero)
        goto l_error_loading_file;          // jnz short @@error_loading_file

    A1 = 316646;                            // mov A1, offset competitionFilename
    StringCopy();                           // call StringCopy
    goto l_start_contest;                   // jmp short @@start_contest

l_season:;
    push(A0);                               // push A0
    j_LoadCareerFile();                     // call j_LoadCareerFile
    pop(A0);                                // pop A0
    if (!flags.zero)
        goto l_error_loading_file;          // jnz short @@error_loading_file

    A1 = 316646;                            // mov A1, offset competitionFilename
    StringCopy();                           // call StringCopy
    goto l_start_contest;                   // jmp short @@start_contest

l_career:;
    push(A0);                               // push A0
    LoadCareerFile();                       // call LoadCareerFile
    pop(A0);                                // pop A0
    if (!flags.zero)
        goto l_error_loading_file;          // jnz short @@error_loading_file

    A1 = 316646;                            // mov A1, offset competitionFilename
    StringCopy();                           // call StringCopy

l_start_contest:;
    A0 = 19629;                             // mov A0, offset aLoadOldCompeti
    SetZeroFlag();                          // call SetZeroFlag
    CommonMenuExit();                       // call CommonMenuExit
    { StartContest(); return; }             // jmp StartContest

l_error_loading_file:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    CareerInitVars();                       // call CareerInitVars

l_out:;
    A0 = 19629;                             // mov A0, offset aLoadOldCompeti
    SetZeroFlag();                          // call SetZeroFlag
    CommonMenuExit();                       // jmp CommonMenuExit
}

// =============== S U B R O U T I N E =======================================
//
void EditCustomTeamMenu()
{
    *(word *)&g_memByte[456254] = -1;       // mov inTransferMarketMenu, -1
    EditCustomTeam();                       // call EditCustomTeam
    *(word *)&g_memByte[456254] = 0;        // mov inTransferMarketMenu, 0
    CommonMenuExit();                       // jmp CommonMenuExit
}

// =============== S U B R O U T I N E =======================================
//
void EditTacticsMenu()
{
    EditTactics();                          // call EditTactics
    CommonMenuExit();                       // jmp CommonMenuExit
}

// =============== S U B R O U T I N E =======================================
//
void SaveDiskFilingMenu()
{
    A6 = -408;                              // mov A6, offset nullsub_9
    SWOS::ShowMenu();                       // call ShowMenu
    CommonMenuExit();                       // jmp CommonMenuExit
}

// =============== S U B R O U T I N E =======================================
//
void FriendlyMenuInit()
{
    ax = *(word *)&g_memByte[486721];       // mov ax, friendlyOk
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_just_started;                // jz short @@just_started

    SetSelectTwoTeamsText();                // call SetSelectTwoTeamsText

l_just_started:;

    FriendlyMenuReinit();
}

// =============== S U B R O U T I N E =======================================
//
void FriendlyMenuReinit()
{
    {
        word src = *(word *)&g_memByte[131708];
        int16_t dstSigned = src;
        int16_t srcSigned = 65534;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_pitchType, SEASONAL
    if (flags.zero)
        goto l_draw_num_subs;               // jz @@draw_num_subs

    *(word *)&g_memByte[486724] = 0;        // mov pitchTypeOrSeason, 0
    ax = *(word *)&g_memByte[131708];       // mov ax, g_pitchType
    *(word *)&g_memByte[486726] = ax;       // mov friendlyPitchType, ax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1

l_draw_num_subs:;
    DrawNumbersOfSubstitutes();             // call DrawNumbersOfSubstitutes
    ax = *(word *)&g_memByte[486721];       // mov ax, friendlyOk
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_ok_selected;                 // jnz short @@ok_selected

    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    return;                                 // retn

l_ok_selected:;
    DisableEntries();                       // call DisableEntries
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    SWOS::SetCurrentEntry();                // jmp SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void DrawNumbersOfSubstitutes()
{
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[486730];       // mov ax, minSubstitutes
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SWOS::Int2Ascii();                      // call Int2Ascii
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[486732];       // mov ax, maxSubstitutes
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SWOS::Int2Ascii();                      // call Int2Ascii
    SetFriendlyPitchOrSeason();             // call SetFriendlyPitchOrSeason
}

// =============== S U B R O U T I N E =======================================
//
void DisableEntries()
{
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D1 = 5;                       // mov word ptr D1, 5

l_entries_loop:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 28, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+MenuEntry.background], ENTRY_FRAME_AND_BACK_COLOR
    if (!flags.zero)
        goto l_next;                        // jnz short @@next

    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Fh
    if (flags.zero)
        goto l_next;                        // jz short @@next

    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1

l_next:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_entries_loop;                // jns short @@entries_loop
}

// =============== S U B R O U T I N E =======================================
//
void FriendlyOK()
{
    *(word *)&g_memByte[486721] = 1;        // mov friendlyOk, 1
    A6 = 486259;                            // mov A6, offset friendlyGameMenu
    SWOS::ActivateMenu();                   // jmp ActivateMenu
}

// =============== S U B R O U T I N E =======================================
//
void jmpSetExitMenuFlag()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ChooseTeamsMenu()
{
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    A0 = 16775;                             // mov A0, offset aFriendly
    A1 = 16038;                             // mov A1, offset aPlayFriendly
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    *(word *)&D3 = 1;                       // mov word ptr D3, 1
    *(word *)&D4 = 1;                       // mov word ptr D4, 1
    GoGetTeamsForPlay();                    // call GoGetTeamsForPlay
    ax = *(word *)&g_memByte[330694];       // mov ax, chooseTeamsResult
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        { jmpSetExitMenuFlag(); return; }   // jz short jmpSetExitMenuFlag

    RandomlySwapTeams();                    // call RandomlySwapTeams
    InitTeams();                            // call InitTeams
    PlayFriendly();                         // call PlayFriendly
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void PitchTypeOrSeasonProc()
{
    {
        word src = *(word *)&g_memByte[486724];
        src ^= 1;
        *(word *)&g_memByte[486724] = src;
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor pitchTypeOrSeason, 1
    SetFriendlyPitchOrSeason();             // call SetFriendlyPitchOrSeason
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CallDrawMultipleItems();                // jmp CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void SetFriendlyPitchOrSeason()
{
    A0 = 486629;                            // mov A0, offset friendlyPitchTypeTable
    ax = *(word *)&g_memByte[486724];       // mov ax, pitchTypeOrSeason
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_pitch_type;                  // jz short @@pitch_type

    A0 = 486667;                            // mov A0, offset friendly_season_table

l_pitch_type:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax
}

// =============== S U B R O U T I N E =======================================
//
void FriendlyPitchTypeProc()
{
    ax = *(word *)&g_memByte[486724];       // mov ax, pitchTypeOrSeason
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_season;                      // jnz short @@season

    {
        word src = *(word *)&g_memByte[486726];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[486726] = src;
    }                                       // add friendlyPitchType, 1
    {
        word src = *(word *)&g_memByte[486726];
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp friendlyPitchType, 7
    if (!flags.zero)
        goto l_draw_item;                   // jnz short @@draw_item

    *(word *)&g_memByte[486726] = 65535;    // mov friendlyPitchType, RANDOM

l_draw_item:;
    { CallDrawMenuItem(); return; }         // jmp CallDrawMenuItem

l_season:;
    {
        word src = *(word *)&g_memByte[486728];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[486728] = src;
    }                                       // add friendlySeason, 1
    {
        word src = *(word *)&g_memByte[486728];
        int16_t dstSigned = src;
        int16_t srcSigned = 12;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp friendlySeason, 12
    if (flags.carry)
        goto l_draw_item;                   // jb short @@draw_item

    *(word *)&g_memByte[486728] = 0;        // mov friendlySeason, 0
    goto l_draw_item;                       // jmp short @@draw_item
}

// =============== S U B R O U T I N E =======================================
//
void MinSubstitutes()
{
    ax = *(word *)&g_memByte[486732];       // mov ax, maxSubstitutes
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        word src = *(word *)&g_memByte[486730];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[486730] = src;
    }                                       // add minSubstitutes, 1
    ax = *(word *)&g_memByte[486730];       // mov ax, minSubstitutes
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto l_no_overflow;                 // jnb short @@no_overflow

    *(word *)&g_memByte[486730] = 1;        // mov minSubstitutes, 1

l_no_overflow:;
    DrawNumbersOfSubstitutes();             // call DrawNumbersOfSubstitutes
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void MaxSubstitutes()
{
    {
        word src = *(word *)&g_memByte[486732];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[486732] = src;
    }                                       // add maxSubstitutes, 1
    {
        word src = *(word *)&g_memByte[486732];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp maxSubstitutes, 5
    if (flags.carry || flags.zero)
        goto l_in_range;                    // jbe short @@in_range

    *(word *)&g_memByte[486732] = 0;        // mov maxSubstitutes, 0
    *(word *)&g_memByte[486730] = 0;        // mov minSubstitutes, 0

l_in_range:;
    {
        word src = *(word *)&g_memByte[486732];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp maxSubstitutes, 1
    if (!flags.zero)
        goto l_not_one;                     // jnz short @@not_one

    *(word *)&g_memByte[486730] = 1;        // mov minSubstitutes, 1

l_not_one:;
    DrawNumbersOfSubstitutes();             // call DrawNumbersOfSubstitutes
    CallDrawMenuItem();                     // call CallDrawMenuItem
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================

// [friendly menu procedure]
//
void SetSelectTwoTeamsText()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    A0 = 16324;                             // mov A0, offset aSelect0Teams
    PrintFormatted();                       // call PrintFormatted
}

// =============== S U B R O U T I N E =======================================
//
void RandomlySwapTeams()
{
    SWOS::Rand2();                          // call Rand2
    {
        dword res = D0 & 1;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D0, 1
    if (flags.zero)
        return;                             // jz short @@out

    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, size TeamFile
    A1 = eax;                               // mov A1, eax
    *(word *)&D1 = 341;                     // mov word ptr D1, 341

l_copy_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_copy_loop;                   // jns short @@copy_loop
}

// =============== S U B R O U T I N E =======================================
//
void Friendly()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_NO_GAME
    if (!flags.zero)
        ContestInProgress();                // jnz short ContestInProgress

    ShowFriendlyMenu();
}

// =============== S U B R O U T I N E =======================================
//
void ShowFriendlyMenu()
{
    *(word *)&g_memByte[129468] = 1;        // mov inFriendlyMenu, 1
    *(word *)&g_memByte[486724] = 0;        // mov pitchTypeOrSeason, 0
    *(word *)&g_memByte[486726] = 65535;    // mov friendlyPitchType, RANDOM
    *(word *)&g_memByte[486728] = 8;        // mov friendlySeason, SEASON_SEP
    *(word *)&g_memByte[486730] = 2;        // mov minSubstitutes, 2
    *(word *)&g_memByte[486732] = 5;        // mov maxSubstitutes, 5
    *(word *)&g_memByte[486721] = 0;        // mov friendlyOk, 0
    A6 = 486259;                            // mov A6, offset friendlyGameMenu
    SWOS::ShowMenu();                       // call ShowMenu
    *(word *)&g_memByte[129468] = 0;        // mov inFriendlyMenu, 0
}

// =============== S U B R O U T I N E =======================================
//
void ContestInProgress()
{
    SaveSelectedTeams();                    // call SaveSelectedTeams
    push(*(dword *)&g_memByte[129472]);     // push small [g_gameType]
    push(*(dword *)&g_memByte[91720]);      // push small [selTeamNumber]
    *(word *)&g_memByte[91720] = -1;        // mov selTeamNumber, -1
    *(word *)&g_memByte[129472] = 0;        // mov g_gameType, GAME_TYPE_NO_GAME
    ShowFriendlyMenu();                     // call ShowFriendlyMenu
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[91720] = val;
    }                                       // pop small [selTeamNumber]
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[129472] = val;
    }                                       // pop small [g_gameType]
    RestoreSelectedTeams();                 // jmp RestoreSelectedTeams
}

// =============== S U B R O U T I N E =======================================
//
void cseg_234DF()
{
    *(word *)&g_memByte[129468] = 1;        // mov inFriendlyMenu, 1
    *(word *)&g_memByte[486724] = 0;        // mov pitchTypeOrSeason, 0
    *(word *)&g_memByte[486726] = 65535;    // mov friendlyPitchType, RANDOM
    *(word *)&g_memByte[486728] = 8;        // mov friendlySeason, 8
    *(word *)&g_memByte[486730] = 2;        // mov minSubstitutes, 2
    *(word *)&g_memByte[486732] = 5;        // mov maxSubstitutes, 5
    *(word *)&g_memByte[486721] = 0;        // mov friendlyOk, 0
    A6 = 486259;                            // mov A6, offset friendlyGameMenu
    SWOS::ActivateMenu();                   // jmp ActivateMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2352D()
{
    *(word *)&g_memByte[129468] = 0;        // mov inFriendlyMenu, 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_23538()
{
    *(word *)&g_memByte[36606] = 0;         // mov careerFileBuffer, 0
    push(D0);                               // push D0
    push(A0);                               // push A0
    LoadSomeEuroCup();                      // call LoadSomeEuroCup
    pop(A0);                                // pop A0
    pop(D0);                                // pop D0
    *(word *)&g_memByte[131757] = 0;        // mov g_numSelectedTeams, 0
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    push(D1);                               // push D1
    push(A0);                               // push A0
    cseg_31F79();                           // call cseg_31F79
    pop(A0);                                // pop A0
    pop(D1);                                // pop D1
    ax = D1;                                // mov ax, word ptr D1
    bx = 6;                                 // mov bx, 6
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    esi = A0;                               // mov esi, A0
    eax = D1;                               // mov eax, D1
    al = (byte)readMemory(esi + eax + 13, 1); // mov al, [esi+eax+13]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&g_memByte[330674] = ax;       // mov numNeededTeams, ax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_235E4()
{
    *(word *)&g_memByte[36606] = 0;         // mov careerFileBuffer, 0
    push(A0);                               // push A0
    LoadSomeEuroCup();                      // call LoadSomeEuroCup
    pop(A0);                                // pop A0
    *(word *)&g_memByte[131757] = 0;        // mov g_numSelectedTeams, 0
    push(A0);                               // push A0
    cseg_32024();                           // call cseg_32024
    pop(A0);                                // pop A0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 10, 1);     // mov al, [esi+10]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&g_memByte[330674] = ax;       // mov numNeededTeams, ax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> league
//
void cseg_2364C()
{
    *(word *)&g_memByte[36606] = 0;         // mov careerFileBuffer, 0
    push(A0);                               // push A0
    LoadSomeEuroCup();                      // call LoadSomeEuroCup
    pop(A0);                                // pop A0
    *(word *)&g_memByte[131757] = 0;        // mov g_numSelectedTeams, 0
    push(A0);                               // push A0
    cseg_320A3();                           // call cseg_320A3
    pop(A0);                                // pop A0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 15, 1);     // mov al, [esi+15]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&g_memByte[330674] = ax;       // mov numNeededTeams, ax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team number to search for
// out:
//      zero flag: set = found, clear = not found
//
void SearchTeamInTmdFile()
{
    ax = *(word *)&g_memByte[36606];        // mov ax, careerFileBuffer
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_found_out;               // jz short @@not_found_out

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    A0 = 36608;                             // mov A0, offset tmdFileBuffer

l_next_team:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, size TeamFile
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_next_team;                   // jns short @@next_team

l_not_found_out:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team number to search for
// out:
//      zero flag: set - found, clear - not found
//      D0 - index of team, if found
//      D1 - 0 if found in selected teams, 1 if not found
//      A0 -> team (file), if found
//
// See if we can find that team in already loaded teams.
//
void FindTeamInCache()
{
    ax = *(word *)&g_memByte[99544];        // mov ax, currentTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_not_current_team;            // jnz short @@not_current_team

    A0 = 98218;                             // mov A0, offset currentTeam
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

l_not_current_team:;
    ax = *(word *)&g_memByte[379876];       // mov ax, dseg_11F9CC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2374D;                    // jz short cseg_2374D

    ax = *(word *)&g_memByte[92798];        // mov ax, word ptr careerTeam
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_career_team;                 // jz short @@career_team

cseg_2374D:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_search_in_selected_teams;    // jnz short @@search_in_selected_teams

l_career_team:;
    A0 = 92798;                             // mov A0, offset careerTeam
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

l_search_in_selected_teams:;
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_found;                   // jz short @@not_found

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax

l_teams_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_found;                       // jz short @@found

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 684
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_teams_loop;                  // jns short @@teams_loop

l_not_found:;
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    return;                                 // retn

l_found:;
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    eax ^= eax;
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // xor eax, eax
}

// =============== S U B R O U T I N E =======================================
//
void InitTeams()
{
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

l_teams_loop:;
    *(word *)&D2 = 15;                      // mov word ptr D2, 15
    TeamInit();                             // call TeamInit
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, size TeamFile
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_teams_loop;                  // jns short @@teams_loop

    ax = *(word *)&g_memByte[129476];       // mov ax, dseg_E0052
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { RetnProc(); return; }             // jnz RetnProc

    {
        word src = *(word *)&g_memByte[91720];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp selTeamNumber, -1
    if (flags.zero)
        { RetnProc(); return; }             // jz RetnProc

    A0 = 92798;                             // mov A0, offset careerTeam
    *(word *)&D2 = 31;                      // mov word ptr D2, 31

    TeamInit();
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team (file)
//      D2 = number of players to init - 1
//
void TeamInit()
{
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 59, 1, 1);            // mov [esi+TeamFile.someFlag], 1
    writeMemory(esi + 22, 1, 0);            // mov [esi+TeamFile.writesZeroHere], 0
    {
        byte src = (byte)readMemory(esi + 23, 1);
        byte res = src & 254;
        src = res;
        writeMemory(esi + 23, 1, src);
    }                                       // and [esi+TeamFile.andWith0xFE], 0FEh
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax

l_players_loop:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 103, 1, 0);           // mov [esi+(PlayerFile.cardsInjuries+4Ch)], 0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto l_new_season;                  // jnz short @@new_season

    ax = *(word *)&g_memByte[91332];        // mov ax, stayingInOldClub
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_not_new_season;              // jnz short @@not_new_season

l_new_season:;
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 253;
        src = res;
        writeMemory(esi + 102, 1, src);
    }                                       // and [esi+(PlayerFile.positionAndFace+4Ch)], 0FDh
    writeMemory(esi + 113, 1, 0);           // mov [esi+(PlayerFile.someFlag+4Ch)], 0

l_not_new_season:;
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 251;
        src = res;
        writeMemory(esi + 102, 1, src);
    }                                       // and [esi+(PlayerFile.positionAndFace+4Ch)], 0FBh
    writeMemory(esi + 109, 1, 0);           // mov [esi+(PlayerFile.field_21+4Ch)], 0
    writeMemory(esi + 110, 1, 0);           // mov [esi+(PlayerFile.field_22+4Ch)], 0
    writeMemory(esi + 111, 1, 0);           // mov [esi+(PlayerFile.field_23+4Ch)], 0
    writeMemory(esi + 112, 1, 0);           // mov [esi+(PlayerFile.field_24+4Ch)], 0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 38;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, size PlayerFile
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto l_players_loop;                // jns short @@players_loop

    RetnProc();
}

// =============== S U B R O U T I N E =======================================
//
void RetnProc()
{
}

// =============== S U B R O U T I N E =======================================
//
void PlayFriendly()
{
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A1 = eax;                               // mov A1, eax
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, size TeamFile
    A2 = eax;                               // mov A2, eax
    InitAndPlayGame();                      // call InitAndPlayGame
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> team1 (file)
//      A2 -> team2
//
void InitAndPlayGame()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    ax = *(word *)&g_memByte[486732];       // mov ax, maxSubstitutes
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D6 = 1;                       // mov word ptr D6, 1
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    SetupPlayers();                         // call SetupPlayers
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[456648];       // mov ax, g_exitGameFlag
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_out;                         // jnz @@out

    push(A1);                               // push A1
    A0 = 6648;                              // mov A0, offset aTraining
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_not_training;                // jnz short @@not_training

    A0 = 16775;                             // mov A0, offset aFriendly

l_not_training:;
    A1 = 336284;                            // mov A1, offset gameName
    StringCopy();                           // call StringCopy
    g_memByte[336324] = 0;                  // mov gameRound, 0
    pop(A1);                                // pop A1
    ax = *(word *)&g_memByte[486724];       // mov ax, pitchTypeOrSeason
    *(word *)&g_memByte[449290] = ax;       // mov gamePitchTypeOrSeason, ax
    ax = *(word *)&g_memByte[486728];       // mov ax, friendlySeason
    *(word *)&g_memByte[449294] = ax;       // mov gameSeason, ax
    ax = *(word *)&g_memByte[486726];       // mov ax, friendlyPitchType
    *(word *)&g_memByte[449292] = ax;       // mov gamePitchType, ax
    *(word *)&g_memByte[449312] = 0;        // mov team1GoalsFirstLeg, 0
    *(word *)&g_memByte[449314] = 0;        // mov team2GoalsFirstLeg, 0
    *(word *)&g_memByte[449308] = 0;        // mov extraTimeState, 0
    *(word *)&g_memByte[449310] = 0;        // mov penaltiesState, 0
    *(word *)&g_memByte[449288] = 0;        // mov secondLeg, 0
    *(word *)&g_memByte[449286] = 0;        // mov playing2ndGame, 0
    *(word *)&g_memByte[449284] = 1;        // mov isGameFriendly, 1
    eax = A0;                               // mov eax, A0
    A4 = eax;                               // mov A4, eax
    A5 = 0;                                 // mov A5, 0
    *(word *)&D7 = -1;                      // mov word ptr D7, -1
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = *(word *)&g_memByte[486730];       // mov ax, minSubstitutes
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[486732];       // mov ax, maxSubstitutes
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    SWOS::InitializeInGameTeamsAndStartGame(); // call InitializeInGameTeamsAndStartGame

l_out:;
    *(word *)&g_memByte[91626] = 0;         // mov isCareer, 0
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// in:
//      D1 - max substitutes
//      D6 - allow squad changes
//      D7 -
//      A1 -> team1
//      A2 -> team2
//
// Shows play match menu for one or both players.
//
void SetupPlayers()
{
    *(word *)&g_memByte[456350] = 0;        // mov careerTeamCoachOnly, 0
    ax = *(word *)&g_memByte[91626];        // mov ax, isCareer
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_not_career;                  // jnz @@not_career

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto l_career_team;                 // jz short @@career_team

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (!flags.zero)
        goto l_not_career;                  // jnz @@not_career

l_career_team:;
    cseg_3E642();                           // call cseg_3E642
    if (!flags.zero)
        goto l_not_career;                  // jnz @@not_career

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    A0 = 92798;                             // mov A0, offset careerTeam
    A1 = 0;                                 // mov A1, 0
    cseg_2C9D9();                           // call cseg_2C9D9
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

l_not_career:;
    *(word *)&g_memByte[91626] = 0;         // mov isCareer, 0
    *(word *)&g_memByte[456648] = 0;        // mov g_exitGameFlag, 0
    *(word *)&g_memByte[378854] = -1;       // mov team1SelectedPlayerIndex, -1
    *(word *)&g_memByte[378856] = -1;       // mov team2SelectedPlayerIndex, -1
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        goto l_computer;                    // jz short @@computer

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        goto l_computer;                    // jz short @@computer

    *(word *)&g_memByte[316506] = 1;        // mov twoPlayers, 1

l_computer:;
    *(word *)&g_memByte[449270] = 0;        // mov pl1Coach, 0
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COACH
    g_memByte[449270] = 0;                  // mov byte ptr pl1Coach, 0
    if (!flags.zero)
        goto l_not_coach;                   // jnz short @@not_coach

    g_memByte[449270] = -1;                 // mov byte ptr pl1Coach, -1

l_not_coach:;
    *(word *)&g_memByte[449278] = 0;        // mov topTeamPlayerNo, 0
    *(word *)&g_memByte[449274] = 0;        // mov topTeamCoachNo, 0
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (!flags.zero)
        goto l_show_play_match_allow_both_players; // jnz short @@show_play_match_allow_both_players

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (!flags.zero)
        goto l_test_if_showing_team2_setup; // jnz @@test_if_showing_team2_setup

l_show_play_match_allow_both_players:;
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    *(word *)&D5 = 1;                       // mov word ptr D5, 1
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ShowPlayMatchMenu();                    // call ShowPlayMatchMenu
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    ax = *(word *)&g_memByte[456648];       // mov ax, g_exitGameFlag
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_no_game;                     // jnz @@no_game

    ax = *(word *)&g_memByte[456350];       // mov ax, careerTeamCoachOnly
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_check_if_top_team_cpu;       // jz short @@check_if_top_team_cpu

    *(word *)&g_memByte[449270] = 0;        // mov pl1Coach, 0
    *(word *)&g_memByte[449278] = 0;        // mov topTeamPlayerNo, 0
    *(word *)&g_memByte[449274] = 0;        // mov topTeamCoachNo, 0

l_check_if_top_team_cpu:;
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        goto l_test_if_showing_team2_setup; // jz short @@test_if_showing_team2_setup

    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_test_if_showing_team2_setup; // jnz short @@test_if_showing_team2_setup

    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COACH
    if (!flags.zero)
        goto l_team_player_controlled;      // jnz short @@team_player_controlled

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[449274] = ax;       // mov topTeamCoachNo, ax
    goto l_test_if_showing_team2_setup;     // jmp short @@test_if_showing_team2_setup

l_team_player_controlled:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[449278] = ax;       // mov topTeamPlayerNo, ax

l_test_if_showing_team2_setup:;
    *(word *)&g_memByte[449272] = 0;        // mov pl2Coach, 0
    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COACH
    {
        byte src = g_memByte[449272];
        src = flags.zero != 0;
        g_memByte[449272] = src;
    }                                       // setz byte ptr pl2Coach
    {
        int8_t src = g_memByte[449272];
        src = -src;
        g_memByte[449272] = src;
    }                                       // neg byte ptr pl2Coach
    *(word *)&g_memByte[449280] = 0;        // mov bottomTeamPlayerNo, 0
    *(word *)&g_memByte[449276] = 0;        // mov bottomTeamCoachNo, 0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        goto l_set_tactics;                 // jz @@set_tactics

    ax = *(word *)&g_memByte[456350];       // mov ax, careerTeamCoachOnly
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_skip_team2_setup;            // jnz @@skip_team2_setup

    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[449278];       // mov ax, topTeamPlayerNo
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[449274];       // mov ax, topTeamCoachNo
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    *(word *)&D0 ^= 3;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // xor word ptr D0, 3
    eax = A1;                               // mov eax, A1
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A1 = eax;                               // mov A1, eax
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ShowPlayMatchMenu();                    // call ShowPlayMatchMenu
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    ax = *(word *)&g_memByte[456648];       // mov ax, g_exitGameFlag
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_no_game;                     // jnz @@no_game

    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_set_tactics;                 // jnz short @@set_tactics

    eax = A1;                               // mov eax, A1
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A1 = eax;                               // mov A1, eax

l_skip_team2_setup:;
    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COACH
    if (!flags.zero)
        goto l_team_2_not_pl_coach;         // jnz short @@team_2_not_pl_coach

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[449276] = ax;       // mov bottomTeamCoachNo, ax
    goto l_set_tactics;                     // jmp short @@set_tactics

l_team_2_not_pl_coach:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[449280] = ax;       // mov bottomTeamPlayerNo, ax

l_set_tactics:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    al = D1;                                // mov al, byte ptr D1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&g_memByte[449298] = ax;       // mov pl1Tactics, ax
    al = D2;                                // mov al, byte ptr D2
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)&g_memByte[449300] = ax;       // mov pl2Tactics, ax
    return;                                 // retn

l_no_game:;
    *(word *)&g_memByte[449296] = 1;        // mov gameCanceled, 1
    *(word *)&g_memByte[91626] = 0;         // mov isCareer, 0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_24089;                    // jz short cseg_24089

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (!flags.zero)
        return;                             // jnz short @@out

cseg_24089:;
    *(word *)&g_memByte[91626] = 1;         // mov isCareer, 1
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team number
//      D1 - player index - must be < 16 (from menu)
// out:
//      D1 -  player position (index in team file)
//      A0 -> player pointer + header
//
// Return pointer to player (file) structure given ordinal (say when displayed in menu)
// and team number. Internal team player position translation table is used.
//
void GetPlayerAtIndex()
{
    ax = *(word *)&g_memByte[99544];        // mov ax, currentTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_not_current_team;            // jnz short @@not_current_team

    A0 = 99510;                             // mov A0, offset playerPositions
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    { GetPlayer(); return; }                // jmp GetPlayer

l_not_current_team:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_not_selected_team;           // jnz short @@not_selected_team

    A0 = 92766;                             // mov A0, offset currentMatchPlayers
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    { GetPlayer(); return; }                // jmp GetPlayer

l_not_selected_team:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 16
    if (!flags.carry)
        goto l_total_error;                 // jnb short @@total_error

    push(D0);                               // push D0
    GetTeamPointer();                       // call GetTeamPointer
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    al = (byte)readMemory(esi + eax + 60, 1); // mov al, [esi+eax+TeamFile.playerNumbers]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    { GetPlayer(); return; }                // jmp GetPlayer

l_total_error:;
    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_24132()
{
    push(D0);                               // push D0
    push(A0);                               // push A0
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_2419F;                    // jnz short cseg_2419F

    A0 = 92766;                             // mov A0, offset currentMatchPlayers
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

cseg_2416C:;
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto cseg_2418E;                    // jz short cseg_2418E

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    goto cseg_2416C;                        // jmp short cseg_2416C

cseg_2418E:;
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry)
        goto cseg_241FD;                    // jnb short cseg_241FD

    goto cseg_241F0;                        // jmp short cseg_241F0

cseg_2419F:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 10h
    if (!flags.carry)
        goto cseg_241FD;                    // jnb short cseg_241FD

    GetTeamPointer();                       // call GetTeamPointer
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

cseg_241C3:;
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    al = (byte)readMemory(esi + eax + 60, 1); // mov al, [esi+eax+3Ch]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto cseg_241E6;                    // jz short cseg_241E6

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    goto cseg_241C3;                        // jmp short cseg_241C3

cseg_241E6:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 10h
    if (!flags.carry)
        goto cseg_241FD;                    // jnb short cseg_241FD

cseg_241F0:;
    pop(A0);                                // pop A0
    pop(D0);                                // pop D0
    return;                                 // retn

cseg_241FD:;
    debugBreak();                           // int 3

cseg_241FE:;
    goto cseg_241FE;                        // jmp short cseg_241FE
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - number of team to search for
// out:
//      D0 - 0 = OK, 1 = error
//           zero flag set = OK, clear = error
//      A0 -> team with that number (file)
//
void GetTeamPointer()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D0);                               // push D0
    FindTeamInCache();                      // call FindTeamInCache
    pop(D0);                                // pop D0
    if (flags.zero)
        goto l_out;                         // jz @@out

    push(D0);                               // push D0
    SearchTeamInTmdFile();                  // call SearchTeamInTmdFile
    pop(D0);                                // pop D0
    if (flags.zero)
        goto l_out;                         // jz @@out

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    LoadTeamFile();                         // call LoadTeamFile
    A0 = 252468;                            // mov A0, (offset teamFileBuffer+2)

l_next_team:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto l_found;                       // jz short @@found

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, size TeamFile
    goto l_next_team;                       // jmp short @@next_team

l_found:;
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_243BD();                           // call cseg_243BD
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

l_out:;
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team number (country number << 8 + ordinal)
//      D1 - player index in team (file)
// out:
//      A0 -> player ptr (file) - header
//      D1 - value retained
//
// Return a pointer to player with given index into file team structure.
//
void GetPlayer()
{
    push(D1);                               // push D1
    ax = *(word *)&g_memByte[99544];        // mov ax, currentTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_not_current_team;            // jnz short @@not_current_team

    A0 = 98218;                             // mov A0, offset currentTeam
    goto l_get_player_offset;               // jmp short @@get_player_offset

l_not_current_team:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_look_up_team;                // jnz short @@look_up_team

    A0 = 92798;                             // mov A0, offset careerTeam
    goto l_get_player_offset;               // jmp short @@get_player_offset

l_look_up_team:;
    GetTeamPointer();                       // call GetTeamPointer

l_get_player_offset:;
    ax = D1;                                // mov ax, word ptr D1
    bx = 38;                                // mov bx, size PlayerFile
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    pop(D1);                                // pop D1
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team (file structure)
//
void cseg_243BD()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[92020];        // mov ax, numForeignMarketPlayers2
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    A6 = 111782;                            // mov A6, offset careerForeignMarketPlayers

l_loop:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D5;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D5, al
    if (!flags.zero)
        goto l_next;                        // jnz @@next

    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D4, al
    if (!flags.zero)
        goto l_next;                        // jnz @@next

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 38
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.players
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A4 = eax;                               // mov A4, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4
    A3 = eax;                               // mov A3, eax
    *(word *)&D0 = 18;                      // mov word ptr D0, 18

l_copy_player_loop:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 2
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A4 = res;
    }                                       // add A4, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_player_loop;            // jns short @@copy_player_loop

l_next:;
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 42;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 42
    A6 = eax;                               // mov A6, eax
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_loop;                        // jns @@loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> player name & surname
//      D0 = max surname length,
//           two highest bits are flags:
//           - if highest bit is set, start string with name initial (e.g. E. CHIESA)
//           - if second highest bit is set, copy only surname
// out:
//      A0 -> surname (in surnameBuf)
//
// Returns player surname. If neither of highest bits is set,
// copy name initial if there is enough room (or copy everything).
//
void ExtractSurname()
{
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    {
        word res = *(word *)&D0 & 49152;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0C000h
    if (flags.zero)
        goto l_no_flags;                    // jz short @@no_flags

    {
        word res = *(word *)&D7 & 32768;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 8000h
    if (!flags.zero)
        goto l_name_initial;                // jnz short @@name_initial

    {
        word res = *(word *)&D7 & 49151;
        *(word *)&D7 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D7, 0BFFFh
    *(word *)&D5 = -1;                      // mov word ptr D5, -1
    goto l_work_on_string;                  // jmp short @@work_on_string

l_name_initial:;
    {
        word res = *(word *)&D7 & 32767;
        *(word *)&D7 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D7, 7FFFh
    *(word *)&D5 = 1;                       // mov word ptr D5, 1
    goto l_work_on_string;                  // jmp short @@work_on_string

l_no_flags:;
    GetStringLength();                      // call GetStringLength
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry || flags.zero)
        return;                             // jbe @@out

l_work_on_string:;
    A0 = 316480;                            // mov A0, offset surnameBuf
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    eax = A6;                               // mov eax, A6
    A1 = eax;                               // mov A1, eax

l_skip_spaces:;
    esi = A1;                               // mov esi, A1
    (*(int32_t *)&A1)++;                    // inc A1
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = ' ';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], ' '
    if (flags.zero)
        goto l_skip_spaces;                 // jz short @@skip_spaces

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        A1 = res;
    }                                       // sub A1, 1
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_zero_terminate_out;          // jz @@zero_terminate_out

    eax = A1;                               // mov eax, A1
    A3 = eax;                               // mov A3, eax

l_skip_firstname:;
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_end_of_string;               // jz short @@end_of_string

    (*(int32_t *)&A3)++;                    // inc A3
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = ' ';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], ' '
    if (!flags.zero)
        goto l_skip_firstname;              // jnz short @@skip_firstname

    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        A3 = res;
    }                                       // sub A3, 1

l_end_of_string:;
    eax = A3;                               // mov eax, A3
    D1 = eax;                               // mov D1, eax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    A2 = eax;                               // mov A2, eax

l_next_char:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_next_char;                   // jnz short @@next_char

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        A2 = res;
    }                                       // sub A2, 1

l_skip_ending_spaces:;
    (*(int32_t *)&A2)--;                    // dec A2
    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = ' ';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], ' '
    if (flags.zero)
        goto l_skip_ending_spaces;          // jz short @@skip_ending_spaces

    eax = A2;                               // mov eax, A2
    D0 = eax;                               // mov D0, eax

l_find_start_of_surname:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, eax
    if (flags.zero)
        goto l_copy_surname_until_zero;     // jz @@copy_surname_until_zero

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        A2 = res;
    }                                       // sub A2, 1
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, eax
    if (!flags.zero)
        goto l_find_start_of_surname;       // jnz short @@find_start_of_surname

    eax = D0;                               // mov eax, D0
    D2 = eax;                               // mov D2, eax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = D2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D2 = res;
    }                                       // sub D2, eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 1
    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_copy_surname_until_zero;     // js @@copy_surname_until_zero

    if (!flags.zero)
        goto l_copy_name_initial;           // jnz @@copy_name_initial

    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        goto l_copy_name_initial;           // ja short @@copy_name_initial

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

l_copy_name_loop:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_copy_name_loop;              // jns short @@copy_name_loop

    esi = A2;                               // mov esi, A2
    (*(int32_t *)&A2)++;                    // inc A2
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

l_copy_surname_loop:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto l_copy_surname_loop;           // jns short @@copy_surname_loop

    goto l_zero_terminate;                  // jmp @@zero_terminate

l_copy_name_initial:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, '.');               // mov byte ptr [esi], '.'
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 3

l_copy_surname_until_zero:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_zero_terminate;              // jz short @@zero_terminate

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.zero)
        goto l_copy_surname_until_zero;     // jnz short @@copy_surname_until_zero

    esi = A0;                               // mov esi, A0
    writeMemory(esi + -1, 1, '.');          // mov byte ptr [esi-1], '.'

l_zero_terminate:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0

l_return:;
    A0 = 316480;                            // mov A0, offset surnameBuf

l_out:;
    return;                                 // retn

l_zero_terminate_out:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    goto l_return;                          // jmp short @@return
}

// =============== S U B R O U T I N E =======================================
//
void cseg_247C8()
{
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (!flags.zero)
        goto cseg_247E3;                    // jnz short cseg_247E3

    A0 = 6661;                              // mov A0, offset aTrial
    { StringCopy(); return; }               // jmp StringCopy

cseg_247E3:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (!flags.zero)
        goto cseg_247FE;                    // jnz short cseg_247FE

    A0 = 6657;                              // mov A0, offset aRes
    { StringCopy(); return; }               // jmp StringCopy

cseg_247FE:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+66h], 2
    if (flags.zero)
        goto cseg_24819;                    // jz short cseg_24819

    A0 = 9199;                              // mov A0, offset aLoan
    { StringCopy(); return; }               // jmp StringCopy

cseg_24819:;
    cseg_2484B();                           // call cseg_2484B
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    A0 = 332160;                            // mov A0, offset avgTeamValueBases
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_24AB6();                           // jmp cseg_24AB6
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2484B()
{
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset currentTeam
    if (flags.carry)
        goto cseg_24863;                    // jb short cseg_24863

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 99510;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset playerPositions
    if (flags.carry)
        goto cseg_24885;                    // jb short cseg_24885

cseg_24863:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (flags.carry)
        goto cseg_24905;                    // jb cseg_24905

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 94090;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerNumPlayers
    if (!flags.carry)
        goto cseg_24905;                    // jnb cseg_24905

cseg_24885:;
    cseg_94C7E();                           // call cseg_94C7E
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 332362;                            // mov A0, offset avgTeamValues
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.sign == flags.overflow)
        goto cseg_248F1;                    // jge short cseg_248F1

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    return;                                 // retn

cseg_248F1:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 80;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 50h
    if (flags.carry || flags.zero)
        return;                             // jbe short cseg_24904

    *(word *)&D0 = 80;                      // mov word ptr D0, 50h

cseg_24904:;
    return;                                 // retn

cseg_24905:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    GetPlayerRandomNum();                   // call GetPlayerRandomNum
    al = g_memByte[129466];                 // mov al, dseg_E0048
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = D2;                                // mov al, byte ptr D2
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    A0 = 332362;                            // mov A0, offset avgTeamValues
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.sign == flags.overflow)
        goto cseg_249A2;                    // jge short cseg_249A2

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    return;                                 // retn

cseg_249A2:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 80;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 50h
    if (flags.carry || flags.zero)
        return;                             // jbe short cseg_249B5

    *(word *)&D0 = 80;                      // mov word ptr D0, 50h
}

// =============== S U B R O U T I N E =======================================
//
void cseg_24AB6()
{
    ax = D0;                                // mov ax, word ptr D0
    bx = 1000;                              // mov bx, 1000
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    nullsub_12();                           // call nullsub_12
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 1000;                              // mov bx, 1000
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        dword res = D1 & 65535;
        D1 = res;
    }                                       // and D1, 0FFFFh
    ax = D1;                                // mov ax, word ptr D1
    dx = *(word *)((byte *)&D1 + 2);        // mov dx, word ptr D1+2
    bx = 1000;                              // mov bx, 1000
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_24C19;                    // jz cseg_24C19

    eax = D1;                               // mov eax, D1
    D0 = eax;                               // mov D0, eax
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_24C0D;                    // jz cseg_24C0D

    {
        dword res = D1 & 65535;
        D1 = res;
    }                                       // and D1, 0FFFFh
    ax = D1;                                // mov ax, word ptr D1
    dx = *(word *)((byte *)&D1 + 2);        // mov dx, word ptr D1+2
    bx = 10;                                // mov bx, 10
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        dword res = D2 & 65535;
        D2 = res;
    }                                       // and D2, 0FFFFh
    ax = D2;                                // mov ax, word ptr D2
    dx = *(word *)((byte *)&D2 + 2);        // mov dx, word ptr D2+2
    bx = 10;                                // mov bx, 10
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_24C01;                    // jnz short cseg_24C01

    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_24C01:;
    A0 = 9351;                              // mov A0, offset a0_1m
    goto cseg_24C36;                        // jmp short cseg_24C36

cseg_24C0D:;
    A0 = 9338;                              // mov A0, offset a0m
    goto cseg_24C36;                        // jmp short cseg_24C36

cseg_24C19:;
    ax = D1;                                // mov ax, word ptr D1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    A0 = 9325;                              // mov A0, offset a1k

cseg_24C36:;
    PrintFormatted();                       // jmp PrintFormatted
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team (file struct)
// out:
//      D0 - random number
//
// Get random number bound to player.
//
void GetPlayerRandomNum()
{
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 ^= al;                     // xor byte ptr D0, al
    al = (byte)readMemory(esi + 79, 1);     // mov al, [esi+(PlayerFile.playerName+4Ch)]
    *(byte *)&D0 ^= al;                     // xor byte ptr D0, al
    al = (byte)readMemory(esi + 89, 1);     // mov al, [esi+(PlayerFile.playerName+56h)]
    *(byte *)&D0 ^= al;                     // xor byte ptr D0, al
    ax = *(word *)&g_memByte[91330];        // mov ax, currentSeasonShowing
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(byte *)&D0 ^= al;                     // xor byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0FFh
    A0 = 379922;                            // mov A0, offset kRandomTable
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> header string
// out:
//      zero flag - 0 - continue (D0 = 0)
//                  1 - abort (D0 = 1)
//
// Depending on the value of gameType shows continue/abort prompt.
//
void CheckContinueAbortPrompt()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_NO_GAME
    if (flags.zero)
        goto l_not_showing;                 // jz short @@not_showing

    A1 = 14801;                             // mov A1, offset diyCompetitionPrompt
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_DIY_COMPETITION
    if (flags.zero)
        goto l_show_prompt;                 // jz short @@show_prompt

    A1 = 14870;                             // mov A1, offset presetCompetitionPrompt
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_PRESET_COMPETITION
    if (flags.zero)
        goto l_show_prompt;                 // jz short @@show_prompt

    A1 = 14939;                             // mov A1, offset seasonPrompt
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_SEASON
    if (flags.zero)
        goto l_show_prompt;                 // jz short @@show_prompt

    A1 = 15008;                             // mov A1, offset careerPrompt

l_show_prompt:;
    A2 = 16899;                             // mov A2, offset aContinue
    A3 = 17196;                             // mov A3, offset aAbort
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    SWOS::DoContinueAbortMenu();            // call DoContinueAbortMenu
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    CareerInitVars();                       // call CareerInitVars

l_not_showing:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - game type
//
void CareerInitVars()
{
    ax = *(word *)&g_memByte[323906];       // mov ax, currentTick
    *(word *)&g_memByte[131718] = ax;       // mov randomSeed, ax
    g_memByte[131717] = al;                 // mov newRandomSeedCopy, al
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[129472] = ax;       // mov g_gameType, ax
    *(word *)&g_memByte[129474] = 0;        // mov contestStarted, 0
    *(word *)&g_memByte[323894] = 0;        // mov teamsLoaded, 0
    *(word *)&g_memByte[379876] = 0;        // mov dseg_11F9CC, 0
    *(word *)&g_memByte[129476] = 0;        // mov dseg_E0052, 0
    *(word *)&g_memByte[91720] = -1;        // mov selTeamNumber, -1
    *(word *)&g_memByte[99544] = -1;        // mov currentTeamNumber, -1
    *(word *)&g_memByte[91330] = 0;         // mov currentSeasonShowing, 0
    g_memByte[129467] = 96;                 // mov seasonPlaying, 96
    g_memByte[316646] = 0;                  // mov competitionFilename, 0
    g_memByte[317158] = 0;                  // mov hilFilename, 0
    *(word *)&g_memByte[36606] = 0;         // mov careerFileBuffer, 0
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    Randomize2();                           // call Randomize2
    InitUserTactics();                      // call InitUserTactics
}

// =============== S U B R O U T I N E =======================================
//
void cseg_24DFA()
{
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    push(A5);                               // push A5
    cseg_254F8();                           // call cseg_254F8
    pop(A5);                                // pop A5
    A6 = 317588;                            // mov A6, offset diyFileBufferCopy
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 59, 2, 1);            // mov word ptr [esi+3Bh], 1
    A1 = 27119;                             // mov A1, offset dseg_C707E

cseg_24E35:;
    esi = A1;                               // mov esi, A1
    {
        dword src = readMemory(esi, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi], 0FFFFFFFFh
    if (flags.zero)
        goto cseg_24E63;                    // jz short cseg_24E63

    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A5, eax
    if (!flags.zero)
        goto cseg_24E35;                    // jnz short cseg_24E35

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 59, 2, 0);            // mov word ptr [esi+3Bh], 0

cseg_24E63:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 45, 1, al);           // mov [esi+2Dh], al
    writeMemory(esi + 79, 2, 0);            // mov word ptr [esi+4Fh], 0
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 8, 1);      // mov al, [esi+8]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_24FE7;                    // jz cseg_24FE7

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 79, 2, 1);            // mov word ptr [esi+4Fh], 1
    eax = A5;                               // mov eax, A5
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_254F5;                    // jz cseg_254F5

    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A3 = eax;                               // mov A3, eax
    al = (byte)readMemory(esi + 15, 1);     // mov al, [esi+0Fh]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_24F0C:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 153;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 99h
    A0 = eax;                               // mov A0, eax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

cseg_24F3A:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_24F70;                    // jz short cseg_24F70

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto cseg_24F3A;                    // jnz short cseg_24F3A

    goto cseg_24FD3;                        // jmp short cseg_24FD3

cseg_24F70:;
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto cseg_24FD3;                    // jz short cseg_24FD3

    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax

cseg_24F8D:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_24F8D;                    // jnz short cseg_24F8D

    (*(int32_t *)&A0)--;                    // dec A0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    al = D0;                                // mov al, byte ptr D0
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 1, al);                // mov [esi], al

cseg_24FD3:;
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A3 = res;
    }                                       // add A3, 1
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_24F0C;                    // jns cseg_24F0C

cseg_24FE7:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 3, 1);      // mov al, [esi+3]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 55, 1, al);           // mov [esi+37h], al
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 4, 1);      // mov al, [esi+4]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 56, 1, al);           // mov [esi+38h], al
    writeMemory(esi + 51, 2, 1);            // mov word ptr [esi+33h], 1
    {
        word src = *(word *)&g_memByte[131708];
        int16_t dstSigned = src;
        int16_t srcSigned = 65534;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_pitchType, SEASONAL
    if (flags.zero)
        goto cseg_2503D;                    // jz short cseg_2503D

    writeMemory(esi + 51, 2, 0);            // mov word ptr [esi+33h], 0
    ax = *(word *)&g_memByte[131708];       // mov ax, g_pitchType
    writeMemory(esi + 53, 2, ax);           // mov [esi+35h], ax

cseg_2503D:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 15, 1);     // mov al, [esi+0Fh]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 49, 2, ax);           // mov [esi+31h], ax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4
    A1 = eax;                               // mov A1, eax
    cseg_95C18();                           // call cseg_95C18
    if (flags.zero)
        goto cseg_250F0;                    // jz short cseg_250F0

    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 24755;                             // mov A0, offset countriesTable
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 1
    A0 = eax;                               // mov A0, eax

cseg_250C9:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_250C9;                    // jnz short cseg_250C9

    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 32);                // mov byte ptr [esi], 20h
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 1

cseg_250F0:;
    A0 = 18143;                             // mov A0, offset aLeague
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_25141;                    // jz short cseg_25141

    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, offset aChairmanScenes
    A0 = eax;                               // mov A0, eax

cseg_25141:;
    eax = A0;                               // mov eax, A0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 39, 4, eax);          // mov [esi+27h], eax
    StringCopy();                           // call StringCopy
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 10, 1);     // mov al, [esi+0Ah]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 73, 2, ax);           // mov [esi+49h], ax
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 13, 1);     // mov al, [esi+0Dh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 240;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0F0h
    {
        word res = *(word *)&D0 >> 4;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 4
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 75, 2, ax);           // mov [esi+4Bh], ax
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 13, 1);     // mov al, [esi+0Dh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0Fh
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 77, 2, ax);           // mov [esi+4Dh], ax
    writeMemory(esi + 345, 2, 0);           // mov word ptr [esi+159h], 0
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 12, 1);     // mov al, [esi+0Ch]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    al = (byte)readMemory(esi + 11, 1);     // mov al, [esi+0Bh]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 34;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 22h
    A2 = eax;                               // mov A2, eax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 14;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0Eh
    A1 = eax;                               // mov A1, eax
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 81, 2, ax);           // mov [esi+51h], ax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 49, 2, ax);           // mov [esi+31h], ax
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_252AF:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 9, 1);      // mov al, [esi+9]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 351, 2, ax);          // mov [esi+15Fh], ax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 359, 2, ax);          // mov [esi+167h], ax
    ax = D6;                                // mov ax, word ptr D6
    writeMemory(esi + 357, 2, ax);          // mov [esi+165h], ax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 353, 2, ax);          // mov [esi+161h], ax
    writeMemory(esi + 347, 2, 0);           // mov word ptr [esi+15Bh], 0
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.sign)
        goto cseg_25377;                    // jns short cseg_25377

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 345, 2, 1);           // mov word ptr [esi+159h], 1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 347, 2, 1);           // mov word ptr [esi+15Bh], 1
    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0

cseg_25377:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 349, 2, ax);          // mov [esi+15Dh], ax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 361, 2, ax);          // mov [esi+169h], ax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 363, 2, ax);          // mov [esi+16Bh], ax
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_253F7;                    // jz short cseg_253F7

    {
        dword res = D0 & 1;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D0, 1
    if (flags.zero)
        goto cseg_253F7;                    // jz short cseg_253F7

    debugBreak();                           // int 3

cseg_253F5:;
    goto cseg_253F5;                        // jmp short cseg_253F5

cseg_253F7:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 355, 2, ax);          // mov [esi+163h], ax
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 192;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0C0h
    {
        word res = *(word *)&D0 >> 6;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 6
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 365, 2, ax);          // mov [esi+16Dh], ax
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 48;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 30h
    {
        word res = *(word *)&D0 >> 4;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 4
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 367, 2, ax);          // mov [esi+16Fh], ax
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 12;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0Ch
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 369, 2, ax);          // mov [esi+171h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 118;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 76h
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_252AF;                    // jns cseg_252AF

    {
        word src = *(word *)&g_memByte[317669];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10EADB, 6
    if (flags.zero)
        goto cseg_254EA;                    // jz short cseg_254EA

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 237, 2);    // mov ax, [esi+0EDh]
    writeMemory(esi + 353, 2, ax);          // mov [esi+161h], ax

cseg_254EA:;
    cseg_2573C();                           // call cseg_2573C
    cseg_258E4();                           // call cseg_258E4
    return;                                 // retn

cseg_254F5:;
    debugBreak();                           // int 3

cseg_254F6:;
    goto cseg_254F6;                        // jmp short cseg_254F6
}

// =============== S U B R O U T I N E =======================================
//
void cseg_254F8()
{
    A2 = 317588;                            // mov A2, offset diyFileBufferCopy
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, 2);                 // mov word ptr [esi], 2
    writeMemory(esi + 43, 2, 2);            // mov word ptr [esi+2Bh], 2
    writeMemory(esi + 2, 2, 0);             // mov word ptr [esi+2], 0
    writeMemory(esi + 67, 2, 0);            // mov word ptr [esi+43h], 0
    writeMemory(esi + 69, 2, 0);            // mov word ptr [esi+45h], 0
    writeMemory(esi + 57, 2, 65535);        // mov word ptr [esi+39h], 0FFFFh
    writeMemory(esi + 59, 2, 1);            // mov word ptr [esi+3Bh], 1
    writeMemory(esi + 61, 2, 3);            // mov word ptr [esi+3Dh], 3
    writeMemory(esi + 63, 2, 2);            // mov word ptr [esi+3Fh], 2
    writeMemory(esi + 65, 2, 8);            // mov word ptr [esi+41h], 8
    writeMemory(esi + 45, 1, 255);          // mov byte ptr [esi+2Dh], 0FFh
    writeMemory(esi + 79, 2, 0);            // mov word ptr [esi+4Fh], 0
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4
    A1 = eax;                               // mov A1, eax
    A0 = 17105;                             // mov A0, offset aDiyTournament
    StringCopy();                           // call StringCopy
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 55, 1, 56);           // mov byte ptr [esi+37h], 38h
    writeMemory(esi + 56, 1, 32);           // mov byte ptr [esi+38h], 20h
    writeMemory(esi + 51, 2, 1);            // mov word ptr [esi+33h], 1
    writeMemory(esi + 53, 2, 65535);        // mov word ptr [esi+35h], 0FFFFh
    writeMemory(esi + 75, 2, 3);            // mov word ptr [esi+4Bh], 3
    writeMemory(esi + 77, 2, 5);            // mov word ptr [esi+4Dh], 5
    writeMemory(esi + 73, 2, 0);            // mov word ptr [esi+49h], 0
    writeMemory(esi + 345, 2, 0);           // mov word ptr [esi+159h], 0
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    A1 = 1868;                              // mov A1, offset cseg_25714
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 81, 2, ax);           // mov [esi+51h], ax
    writeMemory(esi + 83, 2, 0);            // mov word ptr [esi+53h], 0
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 49, 2, ax);           // mov [esi+31h], ax
    *(word *)&D0 = 5;                       // mov word ptr D0, 5

cseg_255FA:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 353, 2, ax);          // mov [esi+161h], ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 349, 2, ax);          // mov [esi+15Dh], ax
    writeMemory(esi + 351, 2, 0);           // mov word ptr [esi+15Fh], 0
    writeMemory(esi + 347, 2, 0);           // mov word ptr [esi+15Bh], 0
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 361, 2, ax);          // mov [esi+169h], ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 363, 2, ax);          // mov [esi+16Bh], ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 355, 2, ax);          // mov [esi+163h], ax
    writeMemory(esi + 365, 2, 1);           // mov word ptr [esi+16Dh], 1
    writeMemory(esi + 367, 2, 1);           // mov word ptr [esi+16Fh], 1
    writeMemory(esi + 369, 2, 1);           // mov word ptr [esi+171h], 1
    writeMemory(esi + 359, 2, 2);           // mov word ptr [esi+167h], 2
    writeMemory(esi + 357, 2, 1);           // mov word ptr [esi+165h], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 118;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 76h
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_255FA;                    // jns cseg_255FA

    A0 = 317677;                            // mov A0, offset dseg_10EAE3
    *(byte *)&D1 = 0;                       // mov byte ptr D1, 0
    *(word *)&D0 = 63;                      // mov word ptr D0, 3Fh

cseg_256F0:;
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_256F0;                    // jns short cseg_256F0
}

// DATA XREF: cseg_254F8+B6o

// =============== S U B R O U T I N E =======================================
//
void cseg_2573C()
{
    *(word *)&g_memByte[317590] = 1;        // mov dseg_10EA8C, 1
    nullsub_13();                           // call nullsub_13
    *(word *)&g_memByte[317675] = 0;        // mov dseg_10EAE1, 0
    *(word *)&g_memByte[317671] = 0;        // mov dseg_10EADD, 0
    *(word *)&g_memByte[318645] = 0;        // mov dseg_10EEAB, 0
    A0 = 317588;                            // mov A0, offset diyFileBufferCopy
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_25787:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2585B;                    // jz cseg_2585B

    ax = (word)readMemory(esi + 363, 2);    // mov ax, [esi+16Bh]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        word res = *(word *)&D2 >> 1;
        *(word *)&D2 = res;
    }                                       // shr word ptr D2, 1
    ax = (word)readMemory(esi + 363, 2);    // mov ax, [esi+16Bh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 363, 2);
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul word ptr [esi+16Bh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D2);
        word rem = (word)(dividend % *(word *)&D2);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D2
    {
        word src = (word)readMemory(esi + 357, 2);
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
        flags.carry = dx != 0 != 0;
    }                                       // mul word ptr [esi+165h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    writeMemory(esi + 371, 2, ax);          // mov [esi+173h], ax
    goto cseg_25899;                        // jmp short cseg_25899

cseg_2585B:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 371, 2, 2);           // mov word ptr [esi+173h], 2
    {
        word src = (word)readMemory(esi + 365, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+16Dh], 2
    if (flags.zero)
        goto cseg_25899;                    // jz short cseg_25899

    {
        word src = (word)readMemory(esi + 369, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+171h], 1
    if (!flags.zero)
        goto cseg_25899;                    // jnz short cseg_25899

    writeMemory(esi + 371, 2, 1);           // mov word ptr [esi+173h], 1

cseg_25899:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 118;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 76h
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_25787;                    // jns cseg_25787

    cseg_260A9();                           // call cseg_260A9
    ax = *(word *)&g_memByte[317637];       // mov ax, dseg_10EABB
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 317741;                            // mov A0, offset dseg_10EB23
    cseg_26280();                           // call cseg_26280
    al = D0;                                // mov al, byte ptr D0
    g_memByte[317635] = al;                 // mov dseg_10EAB9, al
    al = D1;                                // mov al, byte ptr D1
    g_memByte[317636] = al;                 // mov dseg_10EABA, al
}

// =============== S U B R O U T I N E =======================================
//
void cseg_258E4()
{
    A2 = 317588;                            // mov A2, offset diyFileBufferCopy
    eax = A2;                               // mov eax, A2
    A3 = eax;                               // mov A3, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+83]
    bx = 118;                               // mov bx, 118
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, eax
    A4 = 318643;                            // mov A4, offset DIY_competitionStart
    A5 = 318643;                            // mov A5, offset DIY_competitionStart
    writeMemory(esi + 85, 2, 0);            // mov word ptr [esi+85], 0
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+349]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_25D36;                    // jz cseg_25D36

    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_26395();                           // call cseg_26395
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 71, 2, 1);            // mov word ptr [esi+71], 1
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 67, 2);     // mov ax, [esi+67]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 67, 2, ax);           // mov [esi+67], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 69, 2);     // mov ax, [esi+69]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 69, 2, ax);           // mov [esi+69], ax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4
    A0 = eax;                               // mov A0, eax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+83]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 73, 2, ax);           // mov [esi+73], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+81]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 75, 2, ax);           // mov [esi+75], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+43]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 43, 2, ax);           // mov [esi+43], ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+353]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 49, 2, ax);           // mov [esi+49], ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 361, 2);    // mov ax, [esi+361]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 79, 2, ax);           // mov [esi+79], ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 355, 2);    // mov ax, [esi+355]
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    {
        word src = (word)readMemory(esi + 361, 2);
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / src);
        word rem = (word)(dividend % src);
        ax = quot;
        dx = rem;
    }                                       // div word ptr [esi+361]
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 83, 2, ax);           // mov [esi+83], ax
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_25AE1;                    // jz short cseg_25AE1

    writeMemory(esi + 85, 2, 1);            // mov word ptr [esi+85], 1

cseg_25AE1:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 153;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 153
    A0 = eax;                               // mov A0, eax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 301;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 301
    A1 = eax;                               // mov A1, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+49]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_25B17:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_25B17;                    // jns short cseg_25B17

    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_26DFC();                           // call cseg_26DFC
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 357, 2);    // mov ax, [esi+357]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 93, 2, ax);           // mov [esi+93], ax
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 373, 1);    // mov al, [esi+373]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 55, 1, al);           // mov [esi+55], al
    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_2653B();                           // call cseg_2653B
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 47, 1);     // mov al, [esi+47]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 47, 1, al);           // mov [esi+47], al
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 48, 1);     // mov al, [esi+48]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 48, 1, al);           // mov [esi+48], al
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 51, 2);     // mov ax, [esi+51]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 51, 2, ax);           // mov [esi+51], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 53, 2);     // mov ax, [esi+53]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 53, 2, ax);           // mov [esi+53], ax
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 55, 1);     // mov al, [esi+55]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 55, 1, al);           // mov [esi+55], al
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 56, 1);     // mov al, [esi+56]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 56, 1, al);           // mov [esi+56], al
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 59, 2);     // mov ax, [esi+59]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 59, 2, ax);           // mov [esi+59], ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 359, 2);    // mov ax, [esi+359]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 97, 2, ax);           // mov [esi+97], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 75, 2);     // mov ax, [esi+75]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 99, 2, ax);           // mov [esi+99], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 77, 2);     // mov ax, [esi+77]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 101, 2, ax);          // mov [esi+101], ax
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 373;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 373
    A0 = eax;                               // mov A0, eax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 461;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 461
    A1 = eax;                               // mov A1, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 371, 2);    // mov ax, [esi+371]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_25CEA:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_25CEA;                    // jns short cseg_25CEA

    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 45, 1);     // mov al, [esi+45]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 45, 1, al);           // mov [esi+45], al
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+49]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 77, 2, ax);           // mov [esi+77], ax
    return;                                 // retn

cseg_25D36:;
    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    InitDIYCup();                           // call InitDIYCup
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 71, 2, 1);            // mov word ptr [esi+71], 1
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 67, 2);     // mov ax, [esi+67]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 67, 2, ax);           // mov [esi+67], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 69, 2);     // mov ax, [esi+69]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 69, 2, ax);           // mov [esi+69], ax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4
    A0 = eax;                               // mov A0, eax
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 89, 2, 1);            // mov word ptr [esi+89], 1
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+43]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 43, 2, ax);           // mov [esi+43], ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+353]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 49, 2, ax);           // mov [esi+49], ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 365, 2);    // mov ax, [esi+365]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 101, 2, ax);          // mov [esi+101], ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 367, 2);    // mov ax, [esi+367]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 113, 2, ax);          // mov [esi+113], ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 369, 2);    // mov ax, [esi+369]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 125, 2, ax);          // mov [esi+125], ax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 153;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 153
    A0 = eax;                               // mov A0, eax
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 589
    A1 = eax;                               // mov A1, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+49]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_25E7C:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_25E7C;                    // jns short cseg_25E7C

    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_26A78();                           // call cseg_26A78
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 373, 1);    // mov al, [esi+373]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 55, 1, al);           // mov [esi+55], al
    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_268C6();                           // call cseg_268C6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 75, 2, ax);           // mov [esi+4Bh], ax
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 47, 1);     // mov al, [esi+2Fh]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 47, 1, al);           // mov [esi+2Fh], al
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 48, 1);     // mov al, [esi+30h]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 48, 1, al);           // mov [esi+30h], al
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 51, 2);     // mov ax, [esi+33h]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 51, 2, ax);           // mov [esi+33h], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 53, 2);     // mov ax, [esi+35h]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 53, 2, ax);           // mov [esi+35h], ax
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 55, 1);     // mov al, [esi+37h]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 55, 1, al);           // mov [esi+37h], al
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 56, 1);     // mov al, [esi+38h]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 56, 1, al);           // mov [esi+38h], al
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 59, 2);     // mov ax, [esi+3Bh]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 59, 2, ax);           // mov [esi+3Bh], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 73, 2);     // mov ax, [esi+49h]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 93, 2, ax);           // mov [esi+5Dh], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 75, 2);     // mov ax, [esi+4Bh]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 95, 2, ax);           // mov [esi+5Fh], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 77, 2);     // mov ax, [esi+4Dh]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 97, 2, ax);           // mov [esi+61h], ax
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 373;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 175h
    A0 = eax;                               // mov A0, eax
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 823;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 337h
    A1 = eax;                               // mov A1, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 371, 2);    // mov ax, [esi+173h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 819, 2, ax);          // mov [esi+333h], ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_2605C:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_2605C;                    // jns short cseg_2605C

    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 45, 1);     // mov al, [esi+2Dh]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 45, 1, al);           // mov [esi+2Dh], al
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 77, 2, ax);           // mov [esi+4Dh], ax
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_13()
{
}

// =============== S U B R O U T I N E =======================================
//
void cseg_260A9()
{
    A1 = 317588;                            // mov A1, offset diyFileBufferCopy
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_260DE:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 371, 2);    // mov ax, [esi+173h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 118;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 76h
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_260DE;                    // jns short cseg_260DE

    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 55, 1);     // mov al, [esi+37h]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 56, 1);     // mov al, [esi+38h]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 373;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 175h
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_26145;                    // jnz short cseg_26145

    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    return;                                 // retn

cseg_26145:;
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.carry)
        goto cseg_26159;                    // jnb short cseg_26159

    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = 96;
        byte res = dstSigned + srcSigned;
        *(byte *)&D2 = res;
    }                                       // add byte ptr D2, 60h

cseg_26159:;
    al = D2;                                // mov al, byte ptr D2
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D3 = res;
    }                                       // sub byte ptr D3, al
    {
        word res = *(word *)&D3 & 255;
        *(word *)&D3 = res;
    }                                       // and word ptr D3, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, 1
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = -118;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0FFFFFF8Ah
    A1 = eax;                               // mov A1, eax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = -118;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0FFFFFF8Ah
    A0 = eax;                               // mov A0, eax
    A2 = eax;                               // mov A2, eax
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    *(word *)&D4 = 0;                       // mov word ptr D4, 0

cseg_261C1:;
    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_261F7;                    // jnz short cseg_261F7

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 118;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 76h
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 371, 2);    // mov ax, [esi+173h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 118;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 76h
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax

cseg_261F7:;
    ax = D4;                                // mov ax, word ptr D4
    tmp = ax * *(word *)&D3;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D3
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D5);
        word rem = (word)(dividend % *(word *)&D5);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, al
    al = D0;                                // mov al, byte ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 1
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (flags.carry || flags.zero)
        goto cseg_261C1;                    // jbe cseg_261C1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_26280()
{
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    ax = D0;                                // mov ax, word ptr D0
    bx = 16;                                // mov bx, 16
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)((byte *)&D6 + 2) = dx;        // mov word ptr D6+2, dx
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, 1
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_262D6:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    *(word *)&D2 = 15;                      // mov word ptr D2, 0Fh

cseg_262FA:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+108]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, ax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 38;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 38
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_262FA;                    // jns short cseg_262FA

    (*(int16_t *)&D5)--;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto cseg_262D6;                    // jns short cseg_262D6

    ax = D4;                                // mov ax, word ptr D4
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D6);
        word rem = (word)(dividend % *(word *)&D6);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 >> 2;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 7
    if (flags.carry || flags.zero)
        return;                             // jbe short cseg_26394

    *(word *)&D1 = 7;                       // mov word ptr D1, 7
}

// =============== S U B R O U T I N E =======================================
//
void cseg_26395()
{
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, 0);                 // mov word ptr [esi], 0
    writeMemory(esi + 43, 2, 0);            // mov word ptr [esi+43], 0
    writeMemory(esi + 2, 2, 0);             // mov word ptr [esi+2], 0
    writeMemory(esi + 67, 2, 0);            // mov word ptr [esi+67], 0
    writeMemory(esi + 69, 2, 0);            // mov word ptr [esi+69], 0
    writeMemory(esi + 57, 2, -1);           // mov word ptr [esi+57], -1
    writeMemory(esi + 59, 2, 1);            // mov word ptr [esi+59], 1
    writeMemory(esi + 103, 2, 0);           // mov word ptr [esi+103], 0
    writeMemory(esi + 61, 2, 3);            // mov word ptr [esi+61], 3
    writeMemory(esi + 63, 2, 2);            // mov word ptr [esi+63], 2
    writeMemory(esi + 65, 2, 8);            // mov word ptr [esi+65], 8
    writeMemory(esi + 45, 1, -1);           // mov byte ptr [esi+45], -1
    writeMemory(esi + 71, 2, 0);            // mov word ptr [esi+71], 0
    A0 = 17055;                             // mov A0, offset aDiyLeague
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 55, 1, 56);           // mov byte ptr [esi+55], 38h
    writeMemory(esi + 56, 1, 32);           // mov byte ptr [esi+56], 20h
    writeMemory(esi + 51, 2, 1);            // mov word ptr [esi+51], 1
    writeMemory(esi + 53, 2, -1);           // mov word ptr [esi+53], -1
    writeMemory(esi + 49, 2, 2);            // mov word ptr [esi+49], 2
    writeMemory(esi + 93, 2, 1);            // mov word ptr [esi+93], 1
    writeMemory(esi + 97, 2, 2);            // mov word ptr [esi+97], 2
    writeMemory(esi + 99, 2, 3);            // mov word ptr [esi+99], 3
    writeMemory(esi + 101, 2, 5);           // mov word ptr [esi+101], 5
    writeMemory(esi + 79, 2, 1);            // mov word ptr [esi+79], 1
    writeMemory(esi + 91, 2, 0);            // mov word ptr [esi+91], 0
    writeMemory(esi + 83, 2, 0);            // mov word ptr [esi+83], 0
    writeMemory(esi + 85, 2, 0);            // mov word ptr [esi+85], 0
    writeMemory(esi + 87, 2, 0);            // mov word ptr [esi+87], 0
    writeMemory(esi + 89, 2, 0);            // mov word ptr [esi+89], 0
    *(word *)&D0 = 63;                      // mov word ptr D0, 3Fh

cseg_26477:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 695, 2, 0);           // mov word ptr [esi+695], 0
    writeMemory(esi + 697, 2, 0);           // mov word ptr [esi+697], 0
    writeMemory(esi + 699, 2, 0);           // mov word ptr [esi+699], 0
    writeMemory(esi + 701, 2, 0);           // mov word ptr [esi+701], 0
    writeMemory(esi + 703, 2, 0);           // mov word ptr [esi+703], 0
    writeMemory(esi + 705, 2, 0);           // mov word ptr [esi+705], 0
    writeMemory(esi + 707, 2, 0);           // mov word ptr [esi+707], 0
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 18;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A2 = res;
    }                                       // add A2, 18
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_26477;                    // jns short cseg_26477

    A0 = 318880;                            // mov A0, offset dseg_10EF96
    A1 = 318752;                            // mov A1, offset dseg_10EF16
    *(byte *)&D1 = 0;                       // mov byte ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    *(word *)&D0 = 63;                      // mov word ptr D0, 3Fh

cseg_264F9:;
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    ax = D2;                                // mov ax, word ptr D2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 18;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 12h
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_264F9;                    // jns short cseg_264F9
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2653B()
{
    cseg_27227();                           // call cseg_27227
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+49]
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    {
        word src = (word)readMemory(esi + 79, 2);
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / src);
        word rem = (word)(dividend % src);
        ax = quot;
        dx = rem;
    }                                       // div word ptr [esi+79]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    writeMemory(esi + 81, 2, ax);           // mov [esi+81], ax
    writeMemory(esi + 459, 2, 0);           // mov word ptr [esi+459], 0
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 453, 2, ax);          // mov [esi+453], ax
    {
        word src = (word)readMemory(esi + 79, 2);
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul word ptr [esi+79]
    writeMemory(esi + 455, 2, ax);          // mov [esi+455], ax
    writeMemory(esi + 457, 2, 0);           // mov word ptr [esi+457], 0
    writeMemory(esi + 449, 2, 0);           // mov word ptr [esi+449], 0
    writeMemory(esi + 447, 2, 0);           // mov word ptr [esi+447], 0
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+81]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 81, 2);
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul word ptr [esi+81]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 105, 2, ax);          // mov [esi+105], ax
    ax = (word)readMemory(esi + 105, 2);    // mov ax, [esi+105]
    writeMemory(esi + 107, 2, ax);          // mov [esi+107], ax
    ax = (word)readMemory(esi + 105, 2);    // mov ax, [esi+105]
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    {
        word src = (word)readMemory(esi + 453, 2);
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / src);
        word rem = (word)(dividend % src);
        ax = quot;
        dx = rem;
    }                                       // div word ptr [esi+453]
    {
        word src = (word)readMemory(esi + 93, 2);
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
        flags.carry = dx != 0 != 0;
    }                                       // mul word ptr [esi+93]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    writeMemory(esi + 451, 2, ax);          // mov [esi+451], ax
    ax = (word)readMemory(esi + 93, 2);     // mov ax, [esi+93]
    writeMemory(esi + 95, 2, ax);           // mov [esi+95], ax
    writeMemory(esi + 445, 2, 0);           // mov word ptr [esi+445], 0
    writeMemory(esi + 2, 2, 1);             // mov word ptr [esi+2], 1
    al = (byte)readMemory(esi + 55, 1);     // mov al, [esi+55]
    writeMemory(esi + 46, 1, al);           // mov [esi+46], al
    g_memByte[129466] = al;                 // mov dseg_E0048, al
    cseg_2730A();                           // call cseg_2730A
    ax = *(word *)&g_memByte[318692];       // mov ax, diyLeagueNumTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 318944;                            // mov A0, offset dseg_10EFD6
    cseg_26280();                           // call cseg_26280
    al = D0;                                // mov al, byte ptr D0
    g_memByte[318690] = al;                 // mov dseg_10EED8, al
    al = D1;                                // mov al, byte ptr D1
    g_memByte[318691] = al;                 // mov dseg_10EED9, al
}

// =============== S U B R O U T I N E =======================================
//
void InitDIYCup()
{
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, 1);                 // mov [esi+DIY_Competition.competitionType], DIY_CUP
    writeMemory(esi + 43, 2, 1);            // mov word ptr [esi+43], 1
    writeMemory(esi + 73, 2, 0);            // mov word ptr [esi+73], 0
    writeMemory(esi + 91, 2, 1);            // mov word ptr [esi+91], 1
    writeMemory(esi + 2, 2, 0);             // mov word ptr [esi+2], 0
    writeMemory(esi + 67, 2, 0);            // mov word ptr [esi+67], 0
    writeMemory(esi + 69, 2, 0);            // mov word ptr [esi+69], 0
    writeMemory(esi + 57, 2, 65535);        // mov word ptr [esi+57], 0FFFFh
    writeMemory(esi + 59, 2, 1);            // mov word ptr [esi+59], 1
    writeMemory(esi + 61, 2, 3);            // mov word ptr [esi+61], 3
    writeMemory(esi + 63, 2, 2);            // mov word ptr [esi+63], 2
    writeMemory(esi + 65, 2, 8);            // mov word ptr [esi+65], 8
    writeMemory(esi + 45, 1, 255);          // mov byte ptr [esi+45], 0FFh
    writeMemory(esi + 71, 2, 0);            // mov word ptr [esi+71], 0
    A0 = 17080;                             // mov A0, offset aDiyCup
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 55, 1, 56);           // mov [esi+DIY_Competition.startMonth], 56
    writeMemory(esi + 56, 1, 32);           // mov [esi+DIY_Competition.endMonth], 32
    writeMemory(esi + 51, 2, 1);            // mov [esi+DIY_Competition.pitchTypeOrSeason], 1
    writeMemory(esi + 53, 2, -1);           // mov [esi+DIY_Competition.pitchType], -1
    writeMemory(esi + 49, 2, 16);           // mov [esi+DIY_Competition.numTeams], 16
    writeMemory(esi + 89, 2, 4);            // mov word ptr [esi+89], 4
    writeMemory(esi + 93, 2, 0);            // mov [esi+DIY_Competition.playEachTeam], 0
    writeMemory(esi + 95, 2, 3);            // mov word ptr [esi+95], 3
    writeMemory(esi + 97, 2, 5);            // mov word ptr [esi+97], 5
    writeMemory(esi + 99, 2, 0);            // mov word ptr [esi+99], 0
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 5;                       // mov word ptr D0, 5

cseg_2685B:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 101, 2, 1);           // mov word ptr [esi+101], 1
    writeMemory(esi + 113, 2, 1);           // mov word ptr [esi+113], 1
    writeMemory(esi + 125, 2, 1);           // mov word ptr [esi+125], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_2685B;                    // jns short cseg_2685B

    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 717
    A0 = eax;                               // mov A0, eax
    *(byte *)&D1 = 0;                       // mov byte ptr D1, 0
    *(word *)&D0 = 63;                      // mov word ptr D0, 63

cseg_268A2:;
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_268A2;                    // jns short cseg_268A2
}

// =============== S U B R O U T I N E =======================================
//
void cseg_268C6()
{
    cseg_27436();                           // call cseg_27436
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 79, 2, ax);           // mov [esi+4Fh], ax
    writeMemory(esi + 81, 2, ax);           // mov [esi+51h], ax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1

cseg_2692C:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    {
        word res = *(word *)&D0 >> 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 1
    if (!flags.zero)
        goto cseg_2692C;                    // jnz short cseg_2692C

    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 89, 2, ax);           // mov [esi+59h], ax
    writeMemory(esi + 83, 2, 0);            // mov word ptr [esi+53h], 0
    writeMemory(esi + 87, 2, 0);            // mov word ptr [esi+57h], 0
    writeMemory(esi + 2, 2, 1);             // mov word ptr [esi+2], 1
    writeMemory(esi + 85, 2, 0);            // mov word ptr [esi+55h], 0
    writeMemory(esi + 329, 2, 0);           // mov word ptr [esi+149h], 0
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx + 101, 2); // mov ax, [esi+ebx+65h]
    writeMemory(esi + 331, 2, ax);          // mov [esi+14Bh], ax
    {
        word src = (word)readMemory(esi + 79, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+4Fh], 1
    if (!flags.zero)
        goto cseg_269CA;                    // jnz short cseg_269CA

    {
        word src = (word)readMemory(esi + 331, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+14Bh], 2
    if (flags.zero)
        goto cseg_269CA;                    // jz short cseg_269CA

    writeMemory(esi + 331, 2, 0);           // mov word ptr [esi+14Bh], 0

cseg_269CA:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 815, 2, 0);           // mov word ptr [esi+32Fh], 0
    writeMemory(esi + 813, 2, 0);           // mov word ptr [esi+32Dh], 0
    writeMemory(esi + 821, 2, 0);           // mov word ptr [esi+335h], 0
    writeMemory(esi + 817, 2, 0);           // mov word ptr [esi+331h], 0
    *(byte *)&D1 = 0;                       // mov byte ptr D1, 0
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 137;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 89h
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 31;                      // mov word ptr D0, 1Fh

cseg_26A13:;
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_26A13;                    // jns short cseg_26A13

    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 55, 1);     // mov al, [esi+37h]
    writeMemory(esi + 46, 1, al);           // mov [esi+2Eh], al
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    g_memByte[129466] = al;                 // mov dseg_E0048, al
    cseg_275C4();                           // call cseg_275C4
    ax = *(word *)&g_memByte[318692];       // mov ax, diyLeagueNumTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 319232;                            // mov A0, offset dseg_10F0F6
    cseg_26280();                           // call cseg_26280
    al = D0;                                // mov al, byte ptr D0
    g_memByte[318690] = al;                 // mov dseg_10EED8, al
    al = D1;                                // mov al, byte ptr D1
    g_memByte[318691] = al;                 // mov dseg_10EED9, al
}

// =============== S U B R O U T I N E =======================================
//
void cseg_26A78()
{
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 45, 1);     // mov al, [esi+45]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = g_memByte[28229];                  // mov al, worldCup
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto cseg_26ACD;                    // jnz short cseg_26ACD

    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_277E5();                           // call cseg_277E5
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    goto cseg_26C72;                        // jmp cseg_26C72

cseg_26ACD:;
    al = g_memByte[29227];                  // mov al, byte ptr europeanChampionships
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto cseg_26AE7;                    // jz short cseg_26AE7

    al = g_memByte[29149];                  // mov al, european_championships2
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto cseg_26B21;                    // jnz short cseg_26B21

cseg_26AE7:;
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_31CFE();                           // call cseg_31CFE
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    goto cseg_26C72;                        // jmp cseg_26C72

cseg_26B21:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_26B43;                    // jnz short cseg_26B43

    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_26CC9;                    // jnz cseg_26CC9

cseg_26B43:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 351, 2);    // mov ax, [esi+15Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_26B5F;                    // jnz short cseg_26B5F

    cseg_27F08();                           // call cseg_27F08
    goto cseg_26CC9;                        // jmp cseg_26CC9

cseg_26B5F:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_26B92;                    // jz short cseg_26B92

    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 231, 2);    // mov ax, [esi+0E7h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_26B97;                    // jnz short cseg_26B97

    ax = (word)readMemory(esi + 233, 2);    // mov ax, [esi+0E9h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_26B97;                    // jnz short cseg_26B97

cseg_26B92:;
    cseg_27B4B();                           // call cseg_27B4B

cseg_26B97:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    A6 = 336554;                            // mov A6, offset dseg_114C2C
    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_26BE3:;
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D0, 1
    if (flags.zero)
        goto cseg_26C2D;                    // jz short cseg_26C2D

    (*(int32_t *)&A1)--;                    // dec A1
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    esi = A6;                               // mov esi, A6
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A6)++;                    // inc A6
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A6;                               // mov esi, A6
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A6)++;
    flags.sign = (*(int32_t *)&A6 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A6 == 0;      // inc A6
    goto cseg_26C65;                        // jmp short cseg_26C65

cseg_26C2D:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A6;                               // mov esi, A6
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A6)++;                    // inc A6
    (*(int32_t *)&A1)--;                    // dec A1
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    esi = A6;                               // mov esi, A6
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A6)++;                    // inc A6

cseg_26C65:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_26BE3;                    // jns cseg_26BE3

cseg_26C72:;
    A0 = 336554;                            // mov A0, offset dseg_114C2C
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A1 = eax;                               // mov A1, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_26CA4:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_26CA4;                    // jns short cseg_26CA4

cseg_26CC9:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A1 = eax;                               // mov A1, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 347, 2);    // mov ax, [esi+15Bh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_26D11;                    // jz short cseg_26D11

    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1

cseg_26D11:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_26D19:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_26D19;                    // jns short cseg_26D19

    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 347, 2);    // mov ax, [esi+15Bh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_26D6A;                    // jz short cseg_26D6A

    {
        word res = *(word *)&D2 << 1;
        *(word *)&D2 = res;
    }                                       // shl word ptr D2, 1

cseg_26D6A:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 71, 2, 0);            // mov word ptr [esi+47h], 0
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A1 = eax;                               // mov A1, eax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 153;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 99h
    A3 = eax;                               // mov A3, eax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_26D9A:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_26DF2;                    // jz short cseg_26DF2

    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 71, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        src = res;
        writeMemory(esi + 71, 2, src);
    }                                       // add word ptr [esi+47h], 1

cseg_26DF2:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_26D9A;                    // jns short cseg_26D9A
}

// =============== S U B R O U T I N E =======================================
//
void cseg_26DFC()
{
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 45, 1);     // mov al, [esi+45]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = g_memByte[28229];                  // mov al, worldCup
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto cseg_26E51;                    // jnz short cseg_26E51

    push(A5);                               // push A5
    push(A4);                               // push A4
    push(A3);                               // push A3
    push(A2);                               // push A2
    cseg_277E5();                           // call cseg_277E5
    pop(A2);                                // pop A2
    pop(A3);                                // pop A3
    pop(A4);                                // pop A4
    pop(A5);                                // pop A5
    goto cseg_27070;                        // jmp cseg_27070

cseg_26E51:;
    al = g_memByte[29227];                  // mov al, byte ptr europeanChampionships
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto cseg_26E6B;                    // jz short cseg_26E6B

    al = g_memByte[29149];                  // mov al, european_championships2
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto cseg_26EA5;                    // jnz short cseg_26EA5

cseg_26E6B:;
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_31CFE();                           // call cseg_31CFE
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    goto cseg_27070;                        // jmp cseg_27070

cseg_26EA5:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_26EC7;                    // jnz short cseg_26EC7

    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_270C7;                    // jnz cseg_270C7

cseg_26EC7:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 351, 2);    // mov ax, [esi+15Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_26EE3;                    // jnz short cseg_26EE3

    cseg_27F08();                           // call cseg_27F08
    goto cseg_270C7;                        // jmp cseg_270C7

cseg_26EE3:;
    *(word *)&D5 = 65535;                   // mov word ptr D5, 0FFFFh
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_26F18;                    // jz short cseg_26F18

    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 231, 2);    // mov ax, [esi+0E7h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_26F18;                    // jz short cseg_26F18

    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    goto cseg_26F29;                        // jmp short cseg_26F29

cseg_26F18:;
    push(D5);                               // push D5
    cseg_27B4B();                           // call cseg_27B4B
    pop(D5);                                // pop D5

cseg_26F29:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax
    A1 = 336554;                            // mov A1, offset dseg_114C2C
    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_26F5E;                    // js short cseg_26F5E

    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 243, 2);    // mov ax, [esi+0F3h]
    *(word *)&D5 = ax;                      // mov word ptr D5, ax

cseg_26F5E:;
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 363, 2);    // mov ax, [esi+16Bh]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D3 = res;
    }                                       // sub word ptr D3, 1
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

cseg_26F8B:;
    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_26FB5;                    // js short cseg_26FB5

    ax = D4;                                // mov ax, word ptr D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_26FB5;                    // jnz short cseg_26FB5

    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 363, 2);    // mov ax, [esi+16Bh]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax

cseg_26FB5:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 361, 2);    // mov ax, [esi+169h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_26FD0:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.carry)
        goto cseg_26FFC;                    // jb short cseg_26FFC

    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    goto cseg_26FD0;                        // jmp short cseg_26FD0

cseg_26FFC:;
    esi = A0;                               // mov esi, A0
    bl = (byte)readMemory(esi, 1);          // mov bl, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    writeMemory(esi + eax, 1, bl);          // mov [esi+eax], bl
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 1
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (!flags.zero)
        goto cseg_2703A;                    // jnz short cseg_2703A

    *(word *)&D4 = 0;                       // mov word ptr D4, 0

cseg_2703A:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 363, 2);    // mov ax, [esi+16Bh]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_26FD0;                    // jns cseg_26FD0

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_26F8B;                    // jns cseg_26F8B

cseg_27070:;
    A0 = 336554;                            // mov A0, offset dseg_114C2C
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A1 = eax;                               // mov A1, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_270A2:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_270A2;                    // jns short cseg_270A2

cseg_270C7:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 89
    A0 = eax;                               // mov A0, eax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 237;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 237
    A1 = eax;                               // mov A1, eax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 109;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 109
    A4 = eax;                               // mov A4, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+353]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_2710B:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 18;                                // mov bx, 18
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A4 = res;
    }                                       // add A4, 2
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_2710B;                    // jns short cseg_2710B

    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 89
    A0 = eax;                               // mov A0, eax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 281;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 281
    A1 = eax;                               // mov A1, eax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

cseg_2719C:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 363, 2);    // mov ax, [esi+363]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_271B7:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
        flags.carry = false;
    }                                       // and word ptr D0, 0FFh
    bl = D1;                                // mov bl, byte ptr D1
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    writeMemory(esi + eax, 1, bl);          // mov [esi+eax], bl
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_271B7;                    // jns short cseg_271B7

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 361, 2);    // mov ax, [esi+361]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto cseg_2719C;                    // jnz short cseg_2719C
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team number
// out:
//      A0 -> ptr to team (file)
//
// Crashes program if team could not be found in memory.
//
void VerifyTeamLoaded()
{
    FindTeamInCache();                      // call FindTeamInCache
    if (!flags.zero)
        goto l_horrible_error;              // jnz short @@horrible_error

    return;                                 // retn

l_horrible_error:;
    debugBreak();                           // int 3
    RingABell();                            // call RingABell
    SWOS::EndProgram();                     // call EndProgram
    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_27227()
{
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 237;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 237
    A3 = eax;                               // mov A3, eax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 301;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 301
    A6 = eax;                               // mov A6, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+49]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_27267:;
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A3)++;                    // inc A3
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        word res = *(word *)&D6 << 1;
        flags.carry = ((word)*(word *)&D6 >> 15) & 1;
        *(word *)&D6 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D6, 1
    esi = A6;                               // mov esi, A6
    eax = *(word *)&D6;                     // movzx eax, word ptr D6
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    {
        word res = *(word *)&D6 >> 1;
        *(word *)&D6 = res;
    }                                       // shr word ptr D6, 1
    ax = D6;                                // mov ax, word ptr D6
    bx = 18;                                // mov bx, 18
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)((byte *)&D6 + 2) = dx;        // mov word ptr D6+2, dx
    eax = A2;                               // mov eax, A2
    A1 = eax;                               // mov A1, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        A0 = res;
    }                                       // sub A0, eax
    eax = A0;                               // mov eax, A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 691, 4, eax);         // mov [esi+691], eax
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_27267;                    // jns cseg_27267
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2730A()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 451, 2);    // mov ax, [esi+451]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = (byte)readMemory(esi + 55, 1);     // mov al, [esi+55]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 56, 1);     // mov al, [esi+56]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 461;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 461
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_2736A;                    // jnz short cseg_2736A

    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    return;                                 // retn

cseg_2736A:;
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.carry)
        goto cseg_2737E;                    // jnb short cseg_2737E

    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = 96;
        byte res = dstSigned + srcSigned;
        *(byte *)&D2 = res;
    }                                       // add byte ptr D2, 96

cseg_2737E:;
    al = D2;                                // mov al, byte ptr D2
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D3 = res;
    }                                       // sub byte ptr D3, al
    {
        word res = *(word *)&D3 & 255;
        *(word *)&D3 = res;
    }                                       // and word ptr D3, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, 1
    *(word *)&D4 = 0;                       // mov word ptr D4, 0

cseg_273B9:;
    ax = D4;                                // mov ax, word ptr D4
    tmp = ax * *(word *)&D3;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D3
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D5);
        word rem = (word)(dividend % *(word *)&D5);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, al
    al = D0;                                // mov al, byte ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 1
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (flags.carry || flags.zero)
        goto cseg_273B9;                    // jbe short cseg_273B9
}

// =============== S U B R O U T I N E =======================================
//
void cseg_27436()
{
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 717
    A3 = eax;                               // mov A3, eax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 589
    A6 = eax;                               // mov A6, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+49]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_27476:;
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A3)++;                    // inc A3
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        word res = *(word *)&D6 << 1;
        flags.carry = ((word)*(word *)&D6 >> 15) & 1;
        *(word *)&D6 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D6, 1
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    {
        word res = *(word *)&D6 >> 1;
        *(word *)&D6 = res;
    }                                       // shr word ptr D6, 1
    ax = D6;                                // mov ax, word ptr D6
    bx = 4;                                 // mov bx, 4
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)((byte *)&D6 + 2) = dx;        // mov word ptr D6+2, dx
    eax = A2;                               // mov eax, A2
    A1 = eax;                               // mov A1, eax
    eax = D6;                               // mov eax, D6
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        A0 = res;
    }                                       // sub A0, eax
    eax = A0;                               // mov eax, A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 835, 4, eax);         // mov [esi+343h], eax
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_27476;                    // jns cseg_27476

    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 75, 2, 0);            // mov word ptr [esi+4Bh], 0
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A1 = eax;                               // mov A1, eax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 589
    A3 = eax;                               // mov A3, eax
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_27564:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_275BA;                    // jz short cseg_275BA

    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 75, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        src = res;
        writeMemory(esi + 75, 2, src);
    }                                       // add word ptr [esi+4Bh], 1

cseg_275BA:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_27564;                    // jns short cseg_27564
}

// =============== S U B R O U T I N E =======================================
//
void cseg_275C4()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 101;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 65h
    A1 = eax;                               // mov A1, eax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 125;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7Dh
    A2 = eax;                               // mov A2, eax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_27609:;
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 2
    esi = A1;                               // mov esi, A1
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 2
    if (flags.zero)
        goto cseg_27653;                    // jz short cseg_27653

    *(word *)&D6 = 1;                       // mov word ptr D6, 1
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (!flags.zero)
        goto cseg_27653;                    // jnz short cseg_27653

    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_27653:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A2 = res;
    }                                       // add A2, 2
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_27609;                    // jns short cseg_27609

    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 819, 2, ax);          // mov [esi+333h], ax
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    al = (byte)readMemory(esi + 55, 1);     // mov al, [esi+37h]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 56, 1);     // mov al, [esi+38h]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 101;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 65h
    A1 = eax;                               // mov A1, eax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 125;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7Dh
    A2 = eax;                               // mov A2, eax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 823;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 337h
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_276F4;                    // jnz short cseg_276F4

    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;
    flags.sign = (*(int32_t *)&A0 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A0 == 0;      // inc A0
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    goto cseg_277BF;                        // jmp cseg_277BF

cseg_276F4:;
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.carry)
        goto cseg_27708;                    // jnb short cseg_27708

    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = 96;
        byte res = dstSigned + srcSigned;
        *(byte *)&D2 = res;
    }                                       // add byte ptr D2, 60h

cseg_27708:;
    al = D2;                                // mov al, byte ptr D2
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D3 = res;
    }                                       // sub byte ptr D3, al
    {
        word res = *(word *)&D3 & 255;
        *(word *)&D3 = res;
    }                                       // and word ptr D3, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, 1
    *(word *)&D4 = 0;                       // mov word ptr D4, 0

cseg_27743:;
    ax = D4;                                // mov ax, word ptr D4
    tmp = ax * *(word *)&D3;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D3
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D5);
        word rem = (word)(dividend % *(word *)&D5);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, al
    al = D0;                                // mov al, byte ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 1
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (flags.carry || flags.zero)
        goto cseg_27743;                    // jbe short cseg_27743

cseg_277BF:;
    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_277E4

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 2;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 2
    al = D0;                                // mov al, byte ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;
    flags.sign = (*(int32_t *)&A0 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A0 == 0;      // inc A0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_277E5()
{
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+83]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2783D;                    // jz short cseg_2783D

    {
        word src = (word)readMemory(esi + 83, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+83], 1
    if (flags.zero)
        goto cseg_27883;                    // jz cseg_27883

    {
        word src = (word)readMemory(esi + 83, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+83], 2
    if (flags.zero)
        goto cseg_279D3;                    // jz cseg_279D3

    {
        word src = (word)readMemory(esi + 83, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+83], 3
    if (flags.zero)
        goto cseg_27A41;                    // jz cseg_27A41

    {
        word src = (word)readMemory(esi + 83, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+83], 4
    if (flags.zero)
        goto cseg_27AB6;                    // jz cseg_27AB6

    goto cseg_27AB6;                        // jmp cseg_27AB6

cseg_2783D:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 89
    A0 = eax;                               // mov A0, eax
    A1 = 336554;                            // mov A1, offset dseg_114C2C
    *(word *)&D1 = 23;                      // mov word ptr D1, 23

cseg_2785D:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_2785D;                    // jns short cseg_2785D

    return;                                 // retn

cseg_27883:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 281;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 281
    A1 = eax;                               // mov A1, eax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 101;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 101
    A0 = eax;                               // mov A0, eax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 3;                       // mov word ptr D2, 3

cseg_278B1:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = 1;                                // mov eax, 1
    cl = D0;                                // mov cl, byte ptr D0
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D1 |= eax;
    flags.carry = false;                    // or D1, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_278B1;                    // jns short cseg_278B1

    A0 = 1924;                              // mov A0, offset cseg_27AF0

cseg_27915:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.sign)
        goto cseg_27924;                    // jns short cseg_27924

    debugBreak();                           // int 3

cseg_27922:;
    goto cseg_27922;                        // jmp short cseg_27922

cseg_27924:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto cseg_27943;                    // jz short cseg_27943

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 4
    goto cseg_27915;                        // jmp short cseg_27915

cseg_27943:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 89
    A1 = eax;                               // mov A1, eax
    A2 = 336554;                            // mov A2, offset dseg_114C2C
    A3 = 1908;                              // mov A3, offset cseg_27AE0
    *(word *)&D1 = 15;                      // mov word ptr D1, 15

cseg_2796D:;
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A3)++;                    // inc A3
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.sign)
        goto cseg_2799E;                    // jns short cseg_2799E

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 12;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 12

cseg_2799E:;
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A2)++;                    // inc A2
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_2796D;                    // jns short cseg_2796D

    return;                                 // retn

cseg_279D3:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 89
    A0 = eax;                               // mov A0, eax
    A1 = 336554;                            // mov A1, offset dseg_114C2C
    A2 = 2000;                              // mov A2, offset cseg_27B3C
    *(word *)&D1 = 7;                       // mov word ptr D1, 7

cseg_279FD:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
        flags.carry = false;
    }                                       // and word ptr D0, 0FFh
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_279FD;                    // jns short cseg_279FD

    return;                                 // retn

cseg_27A41:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax
    A1 = 336554;                            // mov A1, offset dseg_114C2C
    A2 = 2008;                              // mov A2, offset cseg_27B44
    *(word *)&D1 = 3;                       // mov word ptr D1, 3
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    flags.carry = false;                    // or al, al
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_279FD;                    // jns cseg_279FD

cseg_27AB6:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax
    A1 = 336554;                            // mov A1, offset dseg_114C2C
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_27B4B()
{
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 153;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 99h
    A1 = eax;                               // mov A1, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 2

cseg_27B75:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A6 = eax;                               // mov A6, eax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D6 = ax;                      // mov word ptr D6, ax

cseg_27B8E:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A6)++;                    // inc A6
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.carry)
        goto cseg_27DB1;                    // jnb short cseg_27DB1

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    writeMemory(esi + -1, 1, al);           // mov [esi-1], al
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi, 1, al);                // mov [esi], al

cseg_27DB1:;
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto cseg_27B8E;                    // jns cseg_27B8E

    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_27B75;                    // jns cseg_27B75

    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_27E12;                    // jz short cseg_27E12

    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax
    ax = (word)readMemory(esi + 363, 2);    // mov ax, [esi+16Bh]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = (word)readMemory(esi + 361, 2);    // mov ax, [esi+169h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    goto cseg_27E44;                        // jmp short cseg_27E44

cseg_27E12:;
    *(word *)&D4 = 4;                       // mov word ptr D4, 4
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        word res = *(word *)&D2 >> 2;
        *(word *)&D2 = res;
    }                                       // shr word ptr D2, 2
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 2
    if (flags.carry || flags.zero)
        return;                             // jbe cseg_27F07

cseg_27E44:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 1

cseg_27E59:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D3 = res;
    }                                       // sub word ptr D3, 1

cseg_27E6D:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D2;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        flags.carry = ((word)*(word *)&D0 >> 8) & 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    al = D1;                                // mov al, byte ptr D1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_27E6D;                    // jns short cseg_27E6D

    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D4)--;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto cseg_27E59;                    // jns cseg_27E59
}

// =============== S U B R O U T I N E =======================================
//
void cseg_27F08()
{
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_27F3C:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D6;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        flags.carry = ((word)*(word *)&D0 >> 8) & 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    bl = (byte)readMemory(esi + eax, 1);    // mov bl, [esi+eax]
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    writeMemory(esi + eax, 1, bl);          // mov [esi+eax], bl
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    bl = D1;                                // mov bl, byte ptr D1
    writeMemory(esi + eax, 1, bl);          // mov [esi+eax], bl
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_27F3C;                    // jns short cseg_27F3C
}

// =============== S U B R O U T I N E =======================================
//
void SaveDIYTournament()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    A1 = 317588;                            // mov A1, offset diyFileBufferCopy
    *(word *)&D0 = 1448;                    // mov word ptr D0, 1448

l_copy_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_loop;                   // jns short @@copy_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_27FFF()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    *(word *)&D0 = 1448;                    // mov word ptr D0, 1448

l_copy_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    flags.carry = false;                    // or ax, ax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_loop;                   // jns short @@copy_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_28049()
{
    cseg_280C0();                           // call cseg_280C0
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    A0 = 331912;                            // mov A0, offset rounds_str_table
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    A0 = eax;                               // mov A0, eax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_28076()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    *(word *)&D0 = 544;                     // mov word ptr D0, 544

cseg_28093:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    flags.carry = false;                    // or ax, ax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_28093;                    // jns short cseg_28093
}

// =============== S U B R O U T I N E =======================================
//
void cseg_280C0()
{
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        goto cseg_2812F;                    // jz short cseg_2812F

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        goto cseg_28125;                    // jz short cseg_28125

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        goto cseg_2811B;                    // jz short cseg_2811B

    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    return;                                 // retn

cseg_2811B:;
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    return;                                 // retn

cseg_28125:;
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    return;                                 // retn

cseg_2812F:;
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
}

// =============== S U B R O U T I N E =======================================
//
void cseg_28139()
{
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        word res = *(word *)&D7 << 1;
        *(word *)&D7 = res;
    }                                       // shl word ptr D7, 1
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_2817D:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D6;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        flags.carry = ((word)*(word *)&D0 >> 8) & 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    bl = (byte)readMemory(esi + eax, 1);    // mov bl, [esi+eax]
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    writeMemory(esi + eax, 1, bl);          // mov [esi+eax], bl
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    bl = D1;                                // mov bl, byte ptr D1
    writeMemory(esi + eax, 1, bl);          // mov [esi+eax], bl
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_2817D;                    // jns short cseg_2817D
}

// =============== S U B R O U T I N E =======================================
//
void RestoreDIYLeague()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    *(word *)&D0 = 920;                     // mov word ptr D0, 920

cseg_28216:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    flags.carry = false;                    // or ax, ax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_28216;                    // jns short cseg_28216
}

// =============== S U B R O U T I N E =======================================
//
void cseg_28243()
{
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 237;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 237
    A0 = eax;                               // mov A0, eax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 109;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 109
    A1 = eax;                               // mov A1, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+49]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_2828D:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D6;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    bl = (byte)readMemory(esi + eax, 1);    // mov bl, [esi+eax]
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    writeMemory(esi + eax, 1, bl);          // mov [esi+eax], bl
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    bl = D1;                                // mov bl, byte ptr D1
    writeMemory(esi + eax, 1, bl);          // mov [esi+eax], bl
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    {
        word res = *(word *)&D7 << 1;
        *(word *)&D7 = res;
    }                                       // shl word ptr D7, 1
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    bx = (word)readMemory(esi + eax, 2);    // mov bx, [esi+eax]
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    writeMemory(esi + eax, 2, bx);          // mov [esi+eax], bx
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    bx = D1;                                // mov bx, word ptr D1
    writeMemory(esi + eax, 2, bx);          // mov [esi+eax], bx
    {
        word res = *(word *)&D7 >> 1;
        flags.carry = ((word)*(word *)&D7 >> 15) & 1;
        *(word *)&D7 = res;
    }                                       // shr word ptr D7, 1
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_2828D;                    // jns cseg_2828D
}

// =============== S U B R O U T I N E =======================================
//
void SaveDIYLeague()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    *(word *)&D0 = 920;                     // mov word ptr D0, 920

cseg_28390:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    flags.carry = false;                    // or ax, ax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_28390;                    // jns short cseg_28390
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 -
//      D1 -
//      D2 -
//      D3 -
//      D4 -
// out:
//      D0 - index
//
void cseg_283BD()
{
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_283F3;                    // jz short cseg_283F3

    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1
    if (flags.zero)
        goto l_final_group;                 // jz @@final_group

    goto l_final_groups;                    // jmp @@final_groups

l_out:;
    return;                                 // retn

cseg_283F3:;
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto l_final;                       // jz @@final

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1
    ax = D4;                                // mov ax, word ptr D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_28430;                    // jz short cseg_28430

    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto l_third_place_play_off;        // jz short @@third_place_play_off

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_28430:;
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto cseg_2846B;                    // jz short cseg_2846B

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto cseg_28457;                    // jz short cseg_28457

    return;                                 // retn

cseg_28457:;
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 8
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    return;                                 // retn

cseg_2846B:;
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 4
    if (!flags.zero)
        return;                             // jnz @@out

    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    return;                                 // retn

l_final:;
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    return;                                 // retn

l_final_group:;
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    return;                                 // retn

l_third_place_play_off:;
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    return;                                 // retn

l_final_groups:;
    *(word *)&D0 = 11;                      // mov word ptr D0, 11
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 -
//      D1 -
//      D2 -
//      D3 -
//      D4 -
// out:
//      A0 - which round string
//
void cseg_284AB()
{
    cseg_283BD();                           // call cseg_283BD
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    A0 = 331912;                            // mov A0, offset rounds_str_table
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    A0 = eax;                               // mov A0, eax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_284D8()
{
    ax = *(word *)&g_memByte[318728];       // mov ax, dseg_10EEFE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_288E1

    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 329, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+149h], 1
    if (flags.zero)
        goto cseg_28515;                    // jz short cseg_28515

    {
        word src = (word)readMemory(esi + 331, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+14Bh], 2
    if (flags.zero)
        goto cseg_2869A;                    // jz cseg_2869A

cseg_28515:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 813, 2);    // mov ax, [esi+32Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2878E;                    // jnz cseg_2878E

    cseg_29659();                           // call cseg_29659
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 331, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+14Bh], 2
    if (flags.zero)
        goto cseg_285A1;                    // jz short cseg_285A1

    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_285A1;                    // jnz short cseg_285A1

    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 125, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+7Dh], 1
    if (flags.zero)
        goto cseg_285A1;                    // jz short cseg_285A1

    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 821, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 821, 2, src);
    }                                       // add word ptr [esi+335h], 1

cseg_285A1:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 821, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 821, 2, src);
    }                                       // add word ptr [esi+335h], 1
    {
        word src = (word)readMemory(esi + 87, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 87, 2, src);
    }                                       // add word ptr [esi+57h], 1
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 79, 2, ax);           // mov [esi+4Fh], ax
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    writeMemory(esi + 81, 2, ax);           // mov [esi+51h], ax
    writeMemory(esi + 99, 2, 0);            // mov word ptr [esi+63h], 0
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ax = (word)readMemory(esi + eax + 101, 2); // mov ax, [esi+eax+65h]
    writeMemory(esi + 331, 2, ax);          // mov [esi+14Bh], ax
    {
        word src = (word)readMemory(esi + 79, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+4Fh], 1
    if (!flags.zero)
        goto cseg_28633;                    // jnz short cseg_28633

    {
        word src = (word)readMemory(esi + 331, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+14Bh], 2
    if (flags.zero)
        goto cseg_28633;                    // jz short cseg_28633

    writeMemory(esi + 331, 2, 0);           // mov word ptr [esi+14Bh], 0

cseg_28633:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 815, 2, 0);           // mov word ptr [esi+32Fh], 0
    writeMemory(esi + 813, 2, 0);           // mov word ptr [esi+32Dh], 0
    writeMemory(esi + 83, 2, 0);            // mov word ptr [esi+53h], 0
    writeMemory(esi + 329, 2, 0);           // mov word ptr [esi+149h], 0
    *(byte *)&D1 = 0;                       // mov byte ptr D1, 0
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 137;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 89h
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 31;                      // mov word ptr D0, 1Fh

cseg_28679:;
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_28679;                    // jns short cseg_28679

    goto cseg_288BA;                        // jmp cseg_288BA

cseg_2869A:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 821, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 821, 2, src);
    }                                       // add word ptr [esi+335h], 1
    {
        word src = (word)readMemory(esi + 329, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 329, 2, src);
    }                                       // add word ptr [esi+149h], 1
    writeMemory(esi + 99, 2, 0);            // mov word ptr [esi+63h], 0
    writeMemory(esi + 83, 2, 0);            // mov word ptr [esi+53h], 0
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 201;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0C9h
    A1 = eax;                               // mov A1, eax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 333;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 14Dh
    A2 = eax;                               // mov A2, eax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A3 = eax;                               // mov A3, eax
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 137;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 89h
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_28710:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 32);                // mov byte ptr [esi], 20h
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        *(word *)&D0 = ((word)*(word *)&D0 >> 8) | (*(word *)&D0 << 8);
    }                                       // ror word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 2
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        *(word *)&D0 = ((word)*(word *)&D0 >> 8) | (*(word *)&D0 << 8);
    }                                       // ror word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A2 = res;
    }                                       // add A2, 2
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_28710;                    // jns short cseg_28710

    goto cseg_288BA;                        // jmp cseg_288BA

cseg_2878E:;
    cseg_29858();                           // call cseg_29858
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_287CD;                    // jnz short cseg_287CD

    {
        word src = (word)readMemory(esi + 331, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+14Bh], 2
    if (flags.zero)
        goto cseg_287CD;                    // jz short cseg_287CD

    {
        word src = (word)readMemory(esi + 821, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 821, 2, src);
    }                                       // add word ptr [esi+335h], 1

cseg_287CD:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 813, 2);    // mov ax, [esi+32Dh]
    writeMemory(esi + 81, 2, ax);           // mov [esi+51h], ax
    {
        word src = (word)readMemory(esi + 331, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+14Bh], 2
    if (!flags.zero)
        goto cseg_287F7;                    // jnz short cseg_287F7

    writeMemory(esi + 331, 2, 0);           // mov word ptr [esi+14Bh], 0

cseg_287F7:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 329, 2, 0);           // mov word ptr [esi+149h], 0
    {
        word src = (word)readMemory(esi + 815, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 815, 2, src);
    }                                       // add word ptr [esi+32Fh], 1
    writeMemory(esi + 99, 2, 0);            // mov word ptr [esi+63h], 0
    writeMemory(esi + 83, 2, 0);            // mov word ptr [esi+53h], 0
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A3 = eax;                               // mov A3, eax
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(byte *)&D1 = 0;                       // mov byte ptr D1, 0
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2885A;                    // jz short cseg_2885A

    *(word *)&D1 |= 64;                     // or word ptr D1, 40h

cseg_2885A:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 137;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 89h
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_28871:;
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        *(word *)&D0 = ((word)*(word *)&D0 >> 8) | (*(word *)&D0 << 8);
    }                                       // ror word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A3 = res;
    }                                       // add A3, 2
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_28871;                    // jns short cseg_28871

cseg_288BA:;
    ax = *(word *)&g_memByte[129476];       // mov ax, dseg_E0052
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short cseg_288E1

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (flags.zero)
        { cseg_29B4A(); return; }           // jz cseg_29B4A

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 3
    if (flags.zero)
        cseg_29B4A();                       // jz cseg_29B4A
}

// =============== S U B R O U T I N E =======================================
//
void cseg_288E2()
{
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    eax = A1;                               // mov eax, A1
    A2 = eax;                               // mov A2, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 99, 2);     // mov ax, [esi+63h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 4;                                 // mov bx, 4
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    eax = D1;                               // mov eax, D1
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax + 1, 1); // mov al, [esi+eax+1]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    eax = D1;                               // mov eax, D1
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A2 = res;
    }                                       // add A2, eax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - do nothing if set
// out:
//      A0 -> formated string
//
void cseg_289AC()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[336618] = ax;       // mov dseg_114C6C, ax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    eax = A1;                               // mov eax, A1
    A3 = eax;                               // mov A3, eax
    eax = A2;                               // mov eax, A2
    A4 = eax;                               // mov A4, eax
    {
        word res = *(word *)&D7 & 32;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 20h
    if (flags.zero)
        goto cseg_28BA8;                    // jz cseg_28BA8

    {
        word res = *(word *)&D7 & 128;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 80h
    if (!flags.zero)
        goto cseg_28A4E;                    // jnz short cseg_28A4E

    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 255;
        *(word *)&D1 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D1, 0FFh
    A0 = 22814;                             // mov A0, offset a1stLeg01
    goto cseg_28D56;                        // jmp cseg_28D56

cseg_28A4E:;
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    {
        word res = *(word *)&D2 >> 8;
        *(word *)&D2 = res;
    }                                       // shr word ptr D2, 8
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, ax
    {
        word res = *(word *)&D3 & 255;
        *(word *)&D3 = res;
    }                                       // and word ptr D3, 0FFh
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 255;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFh
    eax = A3;                               // mov eax, A3
    A2 = eax;                               // mov A2, eax
    {
        word res = *(word *)&D7 & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 1
    if (flags.zero)
        goto cseg_28AF9;                    // jz short cseg_28AF9

    eax = A4;                               // mov eax, A4
    A2 = eax;                               // mov A2, eax
    eax = D0;                               // mov eax, D0
    {
        dword tmp = D1;
        D1 = eax;
        eax = tmp;
    }                                       // xchg eax, D1
    D0 = eax;                               // mov D0, eax
    eax = D2;                               // mov eax, D2
    {
        dword tmp = D3;
        D3 = eax;
        eax = tmp;
    }                                       // xchg eax, D3
    D2 = eax;                               // mov D2, eax

cseg_28AF9:;
    {
        word res = *(word *)&D7 & 2;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 2
    if (flags.zero)
        goto cseg_28B99;                    // jz cseg_28B99

    {
        word res = *(word *)&D7 & 4;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 4
    if (!flags.zero)
        goto cseg_28B38;                    // jnz short cseg_28B38

    {
        word res = *(word *)&D7 & 8;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 8
    if (!flags.zero)
        goto cseg_28B7B;                    // jnz short cseg_28B7B

    {
        word res = *(word *)&D7 & 16;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 10h
    if (!flags.zero)
        goto cseg_28B6C;                    // jnz short cseg_28B6C

    A0 = 22868;                             // mov A0, offset aAWin23OnAgg_
    goto cseg_28D56;                        // jmp cseg_28D56

cseg_28B38:;
    {
        word res = *(word *)&D7 & 16;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 10h
    if (!flags.zero)
        goto cseg_28B5D;                    // jnz short cseg_28B5D

    {
        word res = *(word *)&D7 & 8;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 8
    if (!flags.zero)
        goto cseg_28B8A;                    // jnz short cseg_28B8A

    A0 = 22932;                             // mov A0, offset aAWin23OnAgg_A_
    goto cseg_28D56;                        // jmp cseg_28D56

cseg_28B5D:;
    A0 = 23061;                             // mov A0, offset a23OnAgg_AWinOn
    goto cseg_28D56;                        // jmp cseg_28D56

cseg_28B6C:;
    A0 = 22997;                             // mov A0, offset a23OnAgg_AWin_0
    goto cseg_28D56;                        // jmp cseg_28D56

cseg_28B7B:;
    A0 = 23131;                             // mov A0, offset a23OnAgg_AWin01
    goto cseg_28D56;                        // jmp cseg_28D56

cseg_28B8A:;
    A0 = 23195;                             // mov A0, offset a23OnAgg_AWin_1
    goto cseg_28D56;                        // jmp cseg_28D56

cseg_28B99:;
    A0 = 23265;                             // mov A0, offset a23OnAgg_
    goto cseg_28D56;                        // jmp cseg_28D56

cseg_28BA8:;
    {
        word res = *(word *)&D7 & 128;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 80h
    if (flags.zero)
        goto cseg_28D84;                    // jz cseg_28D84

    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        word res = *(word *)&D2 >> 8;
        *(word *)&D2 = res;
    }                                       // shr word ptr D2, 8
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        word res = *(word *)&D3 & 255;
        *(word *)&D3 = res;
    }                                       // and word ptr D3, 0FFh
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 255;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFh
    eax = A3;                               // mov eax, A3
    A2 = eax;                               // mov A2, eax
    {
        word res = *(word *)&D7 & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 1
    if (flags.zero)
        goto cseg_28C38;                    // jz short cseg_28C38

    eax = A4;                               // mov eax, A4
    A2 = eax;                               // mov A2, eax
    eax = D0;                               // mov eax, D0
    {
        dword tmp = D1;
        D1 = eax;
        eax = tmp;
    }                                       // xchg eax, D1
    D0 = eax;                               // mov D0, eax

cseg_28C38:;
    {
        word res = *(word *)&D7 & 4;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 4
    if (!flags.zero)
        goto cseg_28C70;                    // jnz short cseg_28C70

    {
        word res = *(word *)&D7 & 8;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 8
    if (!flags.zero)
        goto cseg_28D33;                    // jnz cseg_28D33

    {
        word res = *(word *)&D7 & 64;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 40h
    if (flags.zero)
        goto cseg_28D84;                    // jz cseg_28D84

    A0 = 22093;                             // mov A0, offset aReplay_0
    goto cseg_28D56;                        // jmp cseg_28D56

cseg_28C70:;
    {
        word res = *(word *)&D7 & 8;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 8
    if (!flags.zero)
        goto cseg_28CDE;                    // jnz short cseg_28CDE

    {
        word res = *(word *)&D7 & 64;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 40h
    if (!flags.zero)
        goto cseg_28CB2;                    // jnz short cseg_28CB2

    A0 = 22157;                             // mov A0, offset aA_e_t_
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (flags.zero)
        goto cseg_28D56;                    // jz cseg_28D56

    A0 = 22221;                             // mov A0, offset aA_e_t_90Mins23
    goto cseg_28D56;                        // jmp cseg_28D56

cseg_28CB2:;
    A0 = 22484;                             // mov A0, offset aA_e_t_Replay
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (flags.zero)
        goto cseg_28D56;                    // jz cseg_28D56

    A0 = 22548;                             // mov A0, offset aA_e_t_90Mins_0
    goto cseg_28D56;                        // jmp short cseg_28D56

cseg_28CDE:;
    {
        word res = *(word *)&D7 & 64;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 40h
    if (!flags.zero)
        goto cseg_28D0E;                    // jnz short cseg_28D0E

    A0 = 22349;                             // mov A0, offset aAWin01OnPensA_
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (flags.zero)
        goto cseg_28D56;                    // jz short cseg_28D56

    A0 = 22414;                             // mov A0, offset aAWin01OnPens_0
    goto cseg_28D56;                        // jmp short cseg_28D56

cseg_28D0E:;
    A0 = 22679;                             // mov A0, offset aAWin01OnPens_1
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (flags.zero)
        goto cseg_28D56;                    // jz short cseg_28D56

    A0 = 22744;                             // mov A0, offset aAWin01OnPens_2
    goto cseg_28D56;                        // jmp short cseg_28D56

cseg_28D33:;
    {
        word res = *(word *)&D7 & 64;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 40h
    if (!flags.zero)
        goto cseg_28D4A;                    // jnz short cseg_28D4A

    A0 = 22285;                             // mov A0, offset aAWin01OnPens
    goto cseg_28D56;                        // jmp short cseg_28D56

cseg_28D4A:;
    A0 = 22615;                             // mov A0, offset aAWin01OnPensRe

cseg_28D56:;
    ax = *(word *)&g_memByte[336618];       // mov ax, dseg_114C6C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_do_printf;                   // jz short @@do_printf

l_skip_it_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_skip_it_loop;                // jnz short @@skip_it_loop

l_do_printf:;
    A1 = 316575;                            // mov A1, offset resultString
    PrintFormatted();                       // call PrintFormatted
    goto l_return;                          // jmp short @@return

cseg_28D84:;
    g_memByte[316575] = 0;                  // mov resultString, 0

l_return:;
    A0 = 316575;                            // mov A0, offset resultString
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_28DC6()
{
    cseg_288E2();                           // call cseg_288E2
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 835, 4);         // mov eax, [esi+343h]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 4, 1);      // mov al, [esi+4]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 835, 4);         // mov eax, [esi+343h]
    A2 = eax;                               // mov A2, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, eax
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 4, 1);      // mov al, [esi+4]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = D1;                                // mov al, byte ptr D1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        return;                             // jz short cseg_28E75

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1
    if (flags.zero)
        return;                             // jz short cseg_28E75

    eax = D0;                               // mov eax, D0
    {
        dword tmp = D1;
        D1 = eax;
        eax = tmp;
    }                                       // xchg eax, D1
    D0 = eax;                               // mov D0, eax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1
    if (flags.zero)
        return;                             // jz short cseg_28E75

    *(word *)&D0 = 2;                       // mov word ptr D0, 2
}

// =============== S U B R O U T I N E =======================================
//
void cseg_28E76()
{
    *(word *)&g_memByte[318710] = 1;        // mov dseg_10EEEC, 1
    cseg_29635();                           // call cseg_29635
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&g_memByte[487132] = ax;       // mov dseg_172A35, ax
    cseg_288E2();                           // call cseg_288E2
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 835, 4);         // mov eax, [esi+343h]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 835, 4);         // mov eax, [esi+343h]
    A2 = eax;                               // mov A2, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, eax
    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_28F37;                    // jz short cseg_28F37

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 1
    if (flags.zero)
        goto cseg_28F1E;                    // jz short cseg_28F1E

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 3
    if (flags.zero)
        goto cseg_28F05;                    // jz short cseg_28F05

    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    cseg_29E79();                           // call cseg_29E79
    if (!flags.zero)
        return;                             // jnz cseg_29634

    goto cseg_28FA3;                        // jmp cseg_28FA3

cseg_28F05:;
    *(word *)&D7 = 1;                       // mov word ptr D7, 1
    cseg_29E79();                           // call cseg_29E79
    if (!flags.zero)
        return;                             // jnz cseg_29634

    goto cseg_28FA3;                        // jmp cseg_28FA3

cseg_28F1E:;
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    cseg_29E79();                           // call cseg_29E79
    if (!flags.zero)
        return;                             // jnz cseg_29634

    goto cseg_28FA3;                        // jmp short cseg_28FA3

cseg_28F37:;
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 2
    if (flags.zero)
        goto cseg_28F67;                    // jz short cseg_28F67

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 2
    if (flags.zero)
        goto cseg_28F67;                    // jz short cseg_28F67

    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 3
    if (flags.zero)
        goto cseg_28F67;                    // jz short cseg_28F67

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 3
    if (!flags.zero)
        goto cseg_28F9C;                    // jnz short cseg_28F9C

cseg_28F67:;
    ax = *(word *)&g_memByte[318740];       // mov ax, diyPointsForAWin
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[318702];       // mov ax, dseg_10EEE4
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    SetupPlayers();                         // call SetupPlayers
    ax = *(word *)&g_memByte[456648];       // mov ax, g_exitGameFlag
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_29634

cseg_28F9C:;
    cseg_2D64E();                           // call cseg_2D64E

cseg_28FA3:;
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 329, 2);    // mov ax, [esi+149h]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_29022;                    // jz short cseg_29022

    ax = (word)readMemory(esi + 99, 2);     // mov ax, [esi+63h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 333;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 14Dh
    A0 = eax;                               // mov A0, eax
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx + 1, 1); // mov al, [esi+ebx+1]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al

cseg_29022:;
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_2AE97();                           // call cseg_2AE97
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 >> 8;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 8
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        word res = *(word *)&D2 & 255;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 0FFh
    A3 = 318643;                            // mov A3, offset DIY_competitionStart
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 137;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 89h
    A0 = eax;                               // mov A0, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 99, 2);     // mov ax, [esi+63h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    al = D7;                                // mov al, byte ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 201;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0C9h
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    ax = D4;                                // mov ax, word ptr D4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 329, 2);    // mov ax, [esi+149h]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_29148;                    // jnz short cseg_29148

    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 333;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 14Dh
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    ax = D5;                                // mov ax, word ptr D5
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax

cseg_29148:;
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 461;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 1CDh
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    ax = D6;                                // mov ax, word ptr D6
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 >> 8;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 8
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        word res = *(word *)&D2 & 255;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 0FFh
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 817, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 817, 2, src);
    }                                       // add word ptr [esi+331h], 1
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_291C8;                    // jz short cseg_291C8

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (!flags.zero)
        goto cseg_291DD;                    // jnz short cseg_291DD

cseg_291C8:;
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 69, 2, 1);            // mov word ptr [esi+45h], 1
    *(word *)&g_memByte[91628] = 1;         // mov dseg_D6C7A, 1

cseg_291DD:;
    cseg_29635();                           // call cseg_29635
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 99, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 99, 2, src);
    }                                       // add word ptr [esi+63h], 1
    writeMemory(esi + 83, 2, 0);            // mov word ptr [esi+53h], 0
    ax = (word)readMemory(esi + 99, 2);     // mov ax, [esi+63h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_2929F;                    // jnz cseg_2929F

    writeMemory(esi + 83, 2, 1);            // mov word ptr [esi+53h], 1
    writeMemory(esi + 99, 2, 0);            // mov word ptr [esi+63h], 0
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 823;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 337h
    A0 = eax;                               // mov A0, eax
    ax = (word)readMemory(esi + 821, 2);    // mov ax, [esi+335h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = (word)readMemory(esi + 819, 2);    // mov ax, [esi+333h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_2929F;                    // jz short cseg_2929F

    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 46, 1, al);           // mov [esi+2Eh], al
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+46]
    g_memByte[129466] = al;                 // mov dseg_E0048, al

cseg_2929F:;
    ax = *(word *)&g_memByte[129476];       // mov ax, dseg_E0052
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_29324;                    // jnz short cseg_29324

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (flags.zero)
        goto cseg_292C2;                    // jz short cseg_292C2

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 3
    if (!flags.zero)
        goto cseg_29324;                    // jnz short cseg_29324

cseg_292C2:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_2A71E();                           // call cseg_2A71E
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1

cseg_29324:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_29628;                    // jz cseg_29628

    {
        word src = (word)readMemory(esi + 331, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+14Bh], 2
    if (!flags.zero)
        goto cseg_2935B;                    // jnz short cseg_2935B

    {
        word src = (word)readMemory(esi + 329, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+149h], 1
    if (!flags.zero)
        goto cseg_29628;                    // jnz cseg_29628

cseg_2935B:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2947B;                    // jnz cseg_2947B

    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_2947B;                    // jz cseg_2947B

    push(D1);                               // push D1
    push(D2);                               // push D2
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    cseg_2AA86();                           // call cseg_2AA86
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    cseg_2AC34();                           // call cseg_2AC34
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_29628;                    // jnz cseg_29628

    push(D1);                               // push D1
    push(D2);                               // push D2
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    cseg_2974C();                           // call cseg_2974C
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    goto cseg_29628;                        // jmp cseg_29628

cseg_2947B:;
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    cseg_2AA86();                           // call cseg_2AA86
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    cseg_2AC34();                           // call cseg_2AC34
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    if (!flags.zero)
        goto cseg_29628;                    // jnz cseg_29628

    esi = A3;                               // mov esi, A3
    writeMemory(esi + 85, 2, 1);            // mov word ptr [esi+55h], 1
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_29541;                    // jz short cseg_29541

    ax = *(word *)&g_memByte[317671];       // mov ax, dseg_10EADD
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = *(word *)&g_memByte[317669];       // mov ax, dseg_10EADB
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_295B0;                    // jnz short cseg_295B0

cseg_29541:;
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 717, 1);    // mov al, [esi+2CDh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        byte src = (byte)readMemory(esi + 137, 1);
        byte res = src & 1;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+89h], 1
    if (flags.zero)
        goto cseg_29572;                    // jz short cseg_29572

    al = (byte)readMemory(esi + 718, 1);    // mov al, [esi+2CEh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al

cseg_29572:;
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 24Dh
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 57, 2, ax);           // mov [esi+39h], ax

cseg_295B0:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_295D0;                    // jz short cseg_295D0

    {
        word src = (word)readMemory(esi + 71, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+47h], 2
    if (!flags.zero)
        goto cseg_29628;                    // jnz short cseg_29628

cseg_295D0:;
    {
        word src = *(word *)&g_memByte[91720];
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp selTeamNumber, 0FFFFh
    if (flags.zero)
        goto cseg_29628;                    // jz short cseg_29628

    ax = *(word *)&g_memByte[487132];       // mov ax, dseg_172A35
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_29628;                    // jz short cseg_29628

    {
        word src = *(word *)&g_memByte[317174];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10E848, 1
    if (flags.zero)
        goto cseg_29628;                    // jz short cseg_29628

    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto cseg_29628;                    // jz short cseg_29628

    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_2960E;                    // jg short cseg_2960E

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_2961C;                    // jz short cseg_2961C

    goto cseg_29623;                        // jmp short cseg_29623

cseg_2960E:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (flags.zero)
        goto cseg_2961C;                    // jz short cseg_2961C

    goto cseg_29623;                        // jmp short cseg_29623

cseg_2961C:;
    FadeAndPlayWinCupAnimation();           // call FadeAndPlayWinCupAnimation
    goto cseg_29628;                        // jmp short cseg_29628

cseg_29623:;
    FadeAndPlayLoseCupAnimation();          // call FadeAndPlayLoseCupAnimation

cseg_29628:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_29635()
{
    ax = *(word *)&g_memByte[318714];       // mov ax, dseg_10EEF0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    ax = *(word *)&g_memByte[318710];       // mov ax, dseg_10EEEC
    *(word *)&g_memByte[317655] = ax;       // mov dseg_10EACD, ax
    ax = *(word *)&g_memByte[318712];       // mov ax, dseg_10EEEE
    *(word *)&g_memByte[317657] = ax;       // mov dseg_10EACF, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_29659()
{
    cseg_2ACAE();                           // call cseg_2ACAE
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A3 = eax;                               // mov A3, eax
    A4 = 486758;                            // mov A4, offset dseg_1728B6
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_29699:;
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A3)++;                    // inc A3
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A4)++;                    // inc A4
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_29699;                    // jns short cseg_29699

    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A2 = eax;                               // mov A2, eax
    A3 = 486758;                            // mov A3, offset dseg_1728B6
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 781;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 30Dh
    A5 = eax;                               // mov A5, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_29708:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
        flags.carry = false;
    }                                       // and word ptr D0, 0FFh
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A2)++;                    // inc A2
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_29708;                    // jns short cseg_29708
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2974C()
{
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 781;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 30Dh
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_29786:;
    al = D0;                                // mov al, byte ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 1
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_29786;                    // jns short cseg_29786

    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 781;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 30Dh
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_297DC:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D6;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        flags.carry = ((word)*(word *)&D0 >> 8) & 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    bl = (byte)readMemory(esi + eax, 1);    // mov bl, [esi+eax]
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    writeMemory(esi + eax, 1, bl);          // mov [esi+eax], bl
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    bl = D1;                                // mov bl, byte ptr D1
    writeMemory(esi + eax, 1, bl);          // mov [esi+eax], bl
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_297DC;                    // jns short cseg_297DC
}

// =============== S U B R O U T I N E =======================================
//
void cseg_29858()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A3 = eax;                               // mov A3, eax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 137;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 89h
    A2 = eax;                               // mov A2, eax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 201;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0C9h
    A1 = eax;                               // mov A1, eax
    D1 = 0;                                 // mov D1, 0
    D2 = 0;                                 // mov D2, 0

cseg_298A3:;
    esi = A2;                               // mov esi, A2
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    {
        byte src = (byte)readMemory(esi + eax, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+eax], 2
    if (!flags.zero)
        goto cseg_29B2A;                    // jnz cseg_29B2A

    {
        word res = *(word *)&D1 << 1;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 1
    {
        word res = *(word *)&D2 << 1;
        *(word *)&D2 = res;
    }                                       // shl word ptr D2, 1
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(word *)&D2;                     // movzx eax, word ptr D2
    bx = (word)readMemory(esi + eax, 2);    // mov bx, [esi+eax]
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    writeMemory(esi + eax, 2, bx);          // mov [esi+eax], bx
    bx = D0;                                // mov bx, word ptr D0
    eax = *(word *)&D2;                     // movzx eax, word ptr D2
    writeMemory(esi + eax, 2, bx);          // mov [esi+eax], bx
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(word *)&D2;                     // movzx eax, word ptr D2
    bx = (word)readMemory(esi + eax, 2);    // mov bx, [esi+eax]
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    writeMemory(esi + eax, 2, bx);          // mov [esi+eax], bx
    bx = D0;                                // mov bx, word ptr D0
    eax = *(word *)&D2;                     // movzx eax, word ptr D2
    writeMemory(esi + eax, 2, bx);          // mov [esi+eax], bx
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 132;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 84h
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 132;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 84h
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(word *)&D2;                     // movzx eax, word ptr D2
    bx = (word)readMemory(esi + eax, 2);    // mov bx, [esi+eax]
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    writeMemory(esi + eax, 2, bx);          // mov [esi+eax], bx
    bx = D0;                                // mov bx, word ptr D0
    eax = *(word *)&D2;                     // movzx eax, word ptr D2
    writeMemory(esi + eax, 2, bx);          // mov [esi+eax], bx
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 132;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 84h
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 132;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 84h
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 260;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 104h
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 260;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 104h
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(word *)&D2;                     // movzx eax, word ptr D2
    bx = (word)readMemory(esi + eax, 2);    // mov bx, [esi+eax]
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    writeMemory(esi + eax, 2, bx);          // mov [esi+eax], bx
    bx = D0;                                // mov bx, word ptr D0
    eax = *(word *)&D2;                     // movzx eax, word ptr D2
    writeMemory(esi + eax, 2, bx);          // mov [esi+eax], bx
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 260;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 104h
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 260;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 104h
    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1
    {
        word res = *(word *)&D2 >> 1;
        *(word *)&D2 = res;
    }                                       // shr word ptr D2, 1
    esi = A2;                               // mov esi, A2
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    eax = *(word *)&D2;                     // movzx eax, word ptr D2
    bl = (byte)readMemory(esi + eax, 1);    // mov bl, [esi+eax]
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    writeMemory(esi + eax, 1, bl);          // mov [esi+eax], bl
    bl = D0;                                // mov bl, byte ptr D0
    eax = *(word *)&D2;                     // movzx eax, word ptr D2
    writeMemory(esi + eax, 1, bl);          // mov [esi+eax], bl
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_29B22;                    // jnz short cseg_29B22

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 781;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 30Dh
    A4 = eax;                               // mov A4, eax

cseg_29ACB:;
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_29ACB;                    // jnz short cseg_29ACB

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 781;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 30Dh
    A5 = eax;                               // mov A5, eax

cseg_29AF0:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.zero)
        goto cseg_29AF0;                    // jnz short cseg_29AF0

    al = D1;                                // mov al, byte ptr D1
    esi = A5;                               // mov esi, A5
    writeMemory(esi + -1, 1, al);           // mov [esi-1], al
    al = D2;                                // mov al, byte ptr D2
    esi = A4;                               // mov esi, A4
    writeMemory(esi + -1, 1, al);           // mov [esi-1], al

cseg_29B22:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1

cseg_29B2A:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto cseg_298A3;                    // jnz cseg_298A3
}

// =============== S U B R O U T I N E =======================================
//
void cseg_29B4A()
{
    *(word *)&D7 = 0;                       // mov word ptr D7, 0

cseg_29B53:;
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+55h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_29DFF

    {
        word src = (word)readMemory(esi + 329, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+149h], 1
    if (flags.zero)
        return;                             // jz cseg_29DFF

    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_29BAF;                    // jz short cseg_29BAF

    ax = *(word *)&g_memByte[317671];       // mov ax, dseg_10EADD
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_29BAF:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+2Bh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A6 = 109912;                            // mov A6, offset dseg_DB3E6
    ax = *(word *)&g_memByte[109908];       // mov ax, dseg_DB3E2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_29BDD:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto cseg_29BFE;                    // jnz short cseg_29BFE

    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto cseg_29C1A;                    // jz short cseg_29C1A

cseg_29BFE:;
    esi = A6;                               // mov esi, A6
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A6 = res;
    }                                       // add A6, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_29BDD;                    // jns short cseg_29BDD

    debugBreak();                           // int 3

cseg_29C18:;
    goto cseg_29C18;                        // jmp short cseg_29C18

cseg_29C1A:;
    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_29C33;                    // jz short cseg_29C33

    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 2
    if (!flags.zero)
        goto cseg_29BFE;                    // jnz short cseg_29BFE

    goto cseg_29C75;                        // jmp short cseg_29C75

cseg_29C33:;
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 1
    if (flags.zero)
        goto cseg_29C75;                    // jz short cseg_29C75

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_29C5F;                    // jnz short cseg_29C5F

    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 3
    if (flags.zero)
        goto cseg_29BFE;                    // jz short cseg_29BFE

    goto cseg_29C75;                        // jmp short cseg_29C75

cseg_29C5F:;
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 3
    if (!flags.zero)
        goto cseg_29BFE;                    // jnz short cseg_29BFE

    writeMemory(esi + 4, 1, 0);             // mov byte ptr [esi+4], 0

cseg_29C75:;
    eax = A6;                               // mov eax, A6
    A5 = eax;                               // mov A5, eax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 5, 1, 0);             // mov byte ptr [esi+5], 0
    writeMemory(esi + 6, 1, 0);             // mov byte ptr [esi+6], 0
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A1 = eax;                               // mov A1, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_29CBA:;
    cseg_29E00();                           // call cseg_29E00
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    eax = A0;                               // mov eax, A0
    A3 = eax;                               // mov A3, eax
    cseg_29E00();                           // call cseg_29E00
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 2
    if (!flags.zero)
        goto cseg_29D06;                    // jnz short cseg_29D06

    eax = D0;                               // mov eax, D0
    {
        dword tmp = D3;
        D3 = eax;
        eax = tmp;
    }                                       // xchg eax, D3
    D0 = eax;                               // mov D0, eax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax

cseg_29D06:;
    esi = A3;                               // mov esi, A3
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (!flags.zero)
        goto cseg_29D40;                    // jnz short cseg_29D40

    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_29DB3;                    // jz cseg_29DB3

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 331, 2);    // mov ax, [esi+14Bh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_29D5E;                    // jz short cseg_29D5E

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 10, 1, 2);            // mov byte ptr [esi+0Ah], 2
    goto cseg_29D68;                        // jmp short cseg_29D68

cseg_29D40:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 331, 2);    // mov ax, [esi+14Bh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_29D5E;                    // jz short cseg_29D5E

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 10, 1, 1);            // mov byte ptr [esi+0Ah], 1
    goto cseg_29D68;                        // jmp short cseg_29D68

cseg_29D5E:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 10, 1, 0);            // mov byte ptr [esi+0Ah], 0

cseg_29D68:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 14, 2, ax);           // mov [esi+0Eh], ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 12, 2, ax);           // mov [esi+0Ch], ax
    writeMemory(esi + 11, 1, 0);            // mov byte ptr [esi+0Bh], 0
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 5, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 5, 1, src);
    }                                       // add byte ptr [esi+5], 1
    {
        byte src = (byte)readMemory(esi + 6, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 6, 1, src);
    }                                       // add byte ptr [esi+6], 1
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 12;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A5 = res;
    }                                       // add A5, 0Ch

cseg_29DB3:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_29CBA;                    // jns cseg_29CBA

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_29DE6;                    // jnz short cseg_29DE6

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 75, 2);     // mov ax, [esi+4Bh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_29DE6;                    // jz short cseg_29DE6

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 6, 1, 255);           // mov byte ptr [esi+6], 0FFh

cseg_29DE6:;
    *(word *)&D7 = 1;                       // mov word ptr D7, 1
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 1
    if (flags.zero)
        goto cseg_29B53;                    // jz cseg_29B53
}

// =============== S U B R O U T I N E =======================================
//
void cseg_29E00()
{
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 4;                                 // mov bx, 4
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 835;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 343h
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_29E79()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ax = *(word *)&g_memByte[318740];       // mov ax, diyPointsForAWin
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[318702];       // mov ax, dseg_10EEE4
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    SetupPlayers();                         // call SetupPlayers
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[456648];       // mov ax, g_exitGameFlag
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_out;                         // jnz @@out

    *(word *)&g_memByte[91626] = 0;         // mov isCareer, 0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_29FD4;                    // jz short cseg_29FD4

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (!flags.zero)
        goto cseg_29FDD;                    // jnz short cseg_29FDD

cseg_29FD4:;
    *(word *)&g_memByte[91626] = 1;         // mov isCareer, 1

cseg_29FDD:;
    A6 = 318643;                            // mov A6, offset DIY_competitionStart
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A6;                               // mov eax, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    push(D7);                               // push D7
    push(A1);                               // push A1
    push(A2);                               // push A2
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    A1 = 336284;                            // mov A1, offset gameName
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4
    A0 = eax;                               // mov A0, eax
    StringCopy();                           // call StringCopy
    A1 = 336324;                            // mov A1, offset gameRound
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2A0CB;                    // jz short cseg_2A0CB

    A0 = 317588;                            // mov A0, offset diyFileBufferCopy
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        word res = *(word *)&D3 << 1;
        flags.carry = ((word)*(word *)&D3 >> 15) & 1;
        *(word *)&D3 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D3, 1
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 345, 2);    // mov ax, [esi+159h]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    cseg_284AB();                           // call cseg_284AB
    StringCopy();                           // call StringCopy
    goto cseg_2A105;                        // jmp short cseg_2A105

cseg_2A0CB:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 91, 2);     // mov ax, [esi+5Bh]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    cseg_28049();                           // call cseg_28049
    StringCopy();                           // call StringCopy

cseg_2A105:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2A179;                    // jz short cseg_2A179

    A0 = 16239;                             // mov A0, offset aReplay
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 3
    if (flags.carry || flags.zero)
        goto cseg_2A133;                    // jbe short cseg_2A133

    goto cseg_2A162;                        // jmp short cseg_2A162

cseg_2A133:;
    A0 = 332056;                            // mov A0, offset dseg_1139FA
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax

cseg_2A162:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 32);                // mov byte ptr [esi], 20h
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 1
    StringCopy();                           // call StringCopy
    goto cseg_2A1C2;                        // jmp short cseg_2A1C2

cseg_2A179:;
    A0 = 17793;                             // mov A0, offset a2ndLeg
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 329, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+149h], 1
    if (flags.zero)
        goto cseg_2A1AD;                    // jz short cseg_2A1AD

    {
        word src = (word)readMemory(esi + 331, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+14Bh], 2
    if (!flags.zero)
        goto cseg_2A1C2;                    // jnz short cseg_2A1C2

    A0 = 17785;                             // mov A0, offset a1stLeg

cseg_2A1AD:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 32);                // mov byte ptr [esi], 20h
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 1
    StringCopy();                           // call StringCopy

cseg_2A1C2:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 51, 2);     // mov ax, [esi+33h]
    *(word *)&g_memByte[449290] = ax;       // mov gamePitchTypeOrSeason, ax
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 60h
    if (flags.carry)
        goto cseg_2A20B;                    // jb short cseg_2A20B

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 60h

cseg_2A20B:;
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 8;                                 // mov bx, 8
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[449294] = ax;       // mov gameSeason, ax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 53, 2);     // mov ax, [esi+35h]
    *(word *)&g_memByte[449292] = ax;       // mov gamePitchType, ax
    *(word *)&g_memByte[449312] = 0;        // mov team1GoalsFirstLeg, 0
    *(word *)&g_memByte[449314] = 0;        // mov team2GoalsFirstLeg, 0
    *(word *)&g_memByte[449308] = 0;        // mov extraTimeState, 0
    *(word *)&g_memByte[449310] = 0;        // mov penaltiesState, 0
    *(word *)&g_memByte[449288] = 0;        // mov secondLeg, 0
    *(word *)&g_memByte[449286] = 0;        // mov playing2ndGame, 0
    *(word *)&g_memByte[449284] = 0;        // mov isGameFriendly, 0
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[336654] = ax;       // mov dseg_114C98, ax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 101, 2);    // mov ax, [esi+65h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2A53D;                    // jz cseg_2A53D

    {
        word src = (word)readMemory(esi + 101, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+65h], 1
    if (flags.zero)
        goto cseg_2A53D;                    // jz cseg_2A53D

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2A53D;                    // jnz cseg_2A53D

    ax = (word)readMemory(esi + 329, 2);    // mov ax, [esi+149h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2A362;                    // jnz short cseg_2A362

    eax = A0;                               // mov eax, A0
    A4 = eax;                               // mov A4, eax
    A5 = 0;                                 // mov A5, 0
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+43]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax = *(word *)&g_memByte[318738];       // mov ax, diyMinSubstitutes
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[318740];       // mov ax, diyPointsForAWin
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[318702];       // mov ax, dseg_10EEE4
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    SWOS::InitializeInGameTeamsAndStartGame(); // call InitializeInGameTeamsAndStartGame
    if (!flags.zero)
        goto l_out;                         // jnz @@out

    ax = *(word *)&g_memByte[336632];       // mov ax, statsTeam1GoalsCopy
    *(word *)&g_memByte[336652] = ax;       // mov dseg_114C96, ax
    ax = *(word *)&g_memByte[336634];       // mov ax, statsTeam2GoalsCopy
    *(word *)&g_memByte[336654] = ax;       // mov dseg_114C98, ax
    goto cseg_2A6AE;                        // jmp cseg_2A6AE

cseg_2A362:;
    *(word *)&g_memByte[449288] = 1;        // mov secondLeg, 1
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 113, 2);    // mov ax, [esi+71h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2A3A2;                    // jz short cseg_2A3A2

    {
        word src = (word)readMemory(esi + 113, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+71h], 1
    if (flags.zero)
        goto cseg_2A399;                    // jz short cseg_2A399

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2A3A2;                    // jz short cseg_2A3A2

cseg_2A399:;
    *(word *)&g_memByte[449308] = 1;        // mov extraTimeState, 1

cseg_2A3A2:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 125, 2);    // mov ax, [esi+7Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2A3D9;                    // jz short cseg_2A3D9

    {
        word src = (word)readMemory(esi + 125, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+7Dh], 1
    if (flags.zero)
        goto cseg_2A3D0;                    // jz short cseg_2A3D0

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2A3D9;                    // jz short cseg_2A3D9

cseg_2A3D0:;
    *(word *)&g_memByte[449310] = 1;        // mov penaltiesState, 1

cseg_2A3D9:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 99, 2);     // mov ax, [esi+99]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 333;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 14Dh
    A3 = eax;                               // mov A3, eax
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax + 1, 1); // mov al, [esi+eax+1]
    g_memByte[449312] = al;                 // mov byte ptr team1GoalsFirstLeg, al
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    g_memByte[449314] = al;                 // mov byte ptr team2GoalsFirstLeg, al
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 93, 2);     // mov ax, [esi+93]
    *(word *)&g_memByte[449286] = ax;       // mov playing2ndGame, ax
    eax = A0;                               // mov eax, A0
    A4 = eax;                               // mov A4, eax
    A5 = 0;                                 // mov A5, 0
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+43]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax = *(word *)&g_memByte[318738];       // mov ax, diyMinSubstitutes
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[318740];       // mov ax, diyPointsForAWin
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[318702];       // mov ax, dseg_10EEE4
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    SWOS::InitializeInGameTeamsAndStartGame(); // call InitializeInGameTeamsAndStartGame
    if (!flags.zero)
        goto l_out;                         // jnz @@out

    ax = *(word *)&g_memByte[336632];       // mov ax, statsTeam1GoalsCopy
    *(word *)&g_memByte[336652] = ax;       // mov dseg_114C96, ax
    ax = *(word *)&g_memByte[336634];       // mov ax, statsTeam2GoalsCopy
    *(word *)&g_memByte[336654] = ax;       // mov dseg_114C98, ax
    ax = *(word *)&g_memByte[449308];       // mov ax, extraTimeState
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_2A515;                    // jns short cseg_2A515

    ax = *(word *)&g_memByte[336636];       // mov ax, statsTeam1Goals
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[336632];       // mov ax, statsTeam1GoalsCopy
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[336656] = ax;       // mov dseg_114C9A, ax
    ax = *(word *)&g_memByte[336638];       // mov ax, statsTeam2Goals
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[336634];       // mov ax, statsTeam2GoalsCopy
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[336658] = ax;       // mov dseg_114C9C, ax

cseg_2A515:;
    ax = *(word *)&g_memByte[449310];       // mov ax, penaltiesState
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_2A538;                    // jns short cseg_2A538

    ax = *(word *)&g_memByte[449316];       // mov ax, team1PenaltyGoals
    *(word *)&g_memByte[336660] = ax;       // mov dseg_114C9E, ax
    ax = *(word *)&g_memByte[449318];       // mov ax, team2PenaltyGoals
    *(word *)&g_memByte[336662] = ax;       // mov dseg_114CA0, ax

cseg_2A538:;
    goto cseg_2A6AE;                        // jmp cseg_2A6AE

cseg_2A53D:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 113, 2);    // mov ax, [esi+71h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2A574;                    // jz short cseg_2A574

    {
        word src = (word)readMemory(esi + 113, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+71h], 1
    if (flags.zero)
        goto cseg_2A56B;                    // jz short cseg_2A56B

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2A574;                    // jz short cseg_2A574

cseg_2A56B:;
    *(word *)&g_memByte[449308] = 1;        // mov extraTimeState, 1

cseg_2A574:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 125, 2);    // mov ax, [esi+7Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2A5AB;                    // jz short cseg_2A5AB

    {
        word src = (word)readMemory(esi + 125, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+7Dh], 1
    if (flags.zero)
        goto cseg_2A5A2;                    // jz short cseg_2A5A2

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2A5AB;                    // jz short cseg_2A5AB

cseg_2A5A2:;
    *(word *)&g_memByte[449310] = 1;        // mov penaltiesState, 1

cseg_2A5AB:;
    eax = A0;                               // mov eax, A0
    A4 = eax;                               // mov A4, eax
    A5 = 0;                                 // mov A5, 0
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+2Bh]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0
    ax = (word)readMemory(esi + 331, 2);    // mov ax, [esi+14Bh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2A5EF;                    // jnz short cseg_2A5EF

    *(byte *)&D0 = 255;                     // mov byte ptr D0, 0FFh

cseg_2A5EF:;
    ax = *(word *)&g_memByte[318738];       // mov ax, diyMinSubstitutes
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[318740];       // mov ax, diyPointsForAWin
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[318702];       // mov ax, dseg_10EEE4
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    SWOS::InitializeInGameTeamsAndStartGame(); // call InitializeInGameTeamsAndStartGame
    if (!flags.zero)
        goto l_out;                         // jnz @@out

    ax = *(word *)&g_memByte[336632];       // mov ax, statsTeam1GoalsCopy
    *(word *)&g_memByte[336652] = ax;       // mov dseg_114C96, ax
    ax = *(word *)&g_memByte[336634];       // mov ax, statsTeam2GoalsCopy
    *(word *)&g_memByte[336654] = ax;       // mov dseg_114C98, ax
    ax = *(word *)&g_memByte[449308];       // mov ax, extraTimeState
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_2A68B;                    // jns short cseg_2A68B

    ax = *(word *)&g_memByte[336636];       // mov ax, statsTeam1Goals
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[336632];       // mov ax, statsTeam1GoalsCopy
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[336656] = ax;       // mov dseg_114C9A, ax
    ax = *(word *)&g_memByte[336638];       // mov ax, statsTeam2Goals
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[336634];       // mov ax, statsTeam2GoalsCopy
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[336658] = ax;       // mov dseg_114C9C, ax

cseg_2A68B:;
    ax = *(word *)&g_memByte[449310];       // mov ax, penaltiesState
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_2A6AE;                    // jns short cseg_2A6AE

    ax = *(word *)&g_memByte[449316];       // mov ax, team1PenaltyGoals
    *(word *)&g_memByte[336660] = ax;       // mov dseg_114C9E, ax
    ax = *(word *)&g_memByte[449318];       // mov ax, team2PenaltyGoals
    *(word *)&g_memByte[336662] = ax;       // mov dseg_114CA0, ax

cseg_2A6AE:;
    *(word *)&g_memByte[91626] = 0;         // mov isCareer, 0
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax

l_out:;
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2A71E()
{
    *(word *)&g_memByte[126566] = 1;        // mov dseg_DF4F4, 1
    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2A9F0;                    // jnz cseg_2A9F0

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_2A87E;                    // jz cseg_2A87E

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (!flags.zero)
        goto cseg_2A9F0;                    // jnz cseg_2A9F0

    {
        word src = *(word *)&g_memByte[91642];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91642] = src;
    }                                       // add dseg_D6C88, 1
    {
        word src = *(word *)&g_memByte[91630];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91630] = src;
    }                                       // add gamesPlayed, 1
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 >> 8;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 8
    ax = D1;                                // mov ax, word ptr D1
    {
        word src = *(word *)&g_memByte[91652];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91652] = src;
    }                                       // add dseg_D6C92, ax
    {
        word src = *(word *)&g_memByte[91640];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91640] = src;
    }                                       // add goalsTaken, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 255;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFh
    ax = D1;                                // mov ax, word ptr D1
    {
        word src = *(word *)&g_memByte[91650];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91650] = src;
    }                                       // add dseg_D6C90, ax
    {
        word src = *(word *)&g_memByte[91638];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91638] = src;
    }                                       // add goalsScored, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 >> 8;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 8
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.carry)
        goto cseg_2A81E;                    // jb short cseg_2A81E

    if (!flags.carry && !flags.zero)
        goto cseg_2A946;                    // ja cseg_2A946

    {
        word res = *(word *)&D7 & 8;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 8
    if (flags.zero)
        goto cseg_2A9A0;                    // jz cseg_2A9A0

    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 >> 8;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 8
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.carry && !flags.zero)
        goto cseg_2A946;                    // ja cseg_2A946

cseg_2A81E:;
    {
        word src = *(word *)&g_memByte[91644];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91644] = src;
    }                                       // add dseg_D6C8A, 1
    {
        word src = *(word *)&g_memByte[91632];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91632] = src;
    }                                       // add numWins, 1
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2A9F0;                    // jnz cseg_2A9F0

    {
        dword src = *(dword *)&g_memByte[318682];
        int32_t dstSigned = src;
        int32_t srcSigned = 7067;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10EED0, offset aEuropeanTour
    if (flags.carry)
        goto cseg_2A855;                    // jb short cseg_2A855

    {
        dword src = *(dword *)&g_memByte[318682];
        int32_t dstSigned = src;
        int32_t srcSigned = 7145;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10EED0, offset aOceaniaTour
    if (flags.carry || flags.zero)
        goto cseg_2A871;                    // jbe short cseg_2A871

cseg_2A855:;
    ax = *(word *)&g_memByte[318746];       // mov ax, dseg_10EF10
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2A9F0;                    // jz cseg_2A9F0

    {
        word src = *(word *)&g_memByte[91654];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91654] = src;
    }                                       // add dseg_D6C94, 1
    goto cseg_2A9F0;                        // jmp cseg_2A9F0

cseg_2A871:;
    {
        word src = *(word *)&g_memByte[91660];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91660] = src;
    }                                       // add dseg_D6C9A, 1
    goto cseg_2A9F0;                        // jmp cseg_2A9F0

cseg_2A87E:;
    {
        word src = *(word *)&g_memByte[91642];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91642] = src;
    }                                       // add dseg_D6C88, 1
    {
        word src = *(word *)&g_memByte[91630];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91630] = src;
    }                                       // add gamesPlayed, 1
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 >> 8;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 8
    ax = D1;                                // mov ax, word ptr D1
    {
        word src = *(word *)&g_memByte[91650];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91650] = src;
    }                                       // add dseg_D6C90, ax
    {
        word src = *(word *)&g_memByte[91638];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91638] = src;
    }                                       // add goalsScored, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 255;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFh
    ax = D1;                                // mov ax, word ptr D1
    {
        word src = *(word *)&g_memByte[91652];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91652] = src;
    }                                       // add dseg_D6C92, ax
    {
        word src = *(word *)&g_memByte[91640];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91640] = src;
    }                                       // add goalsTaken, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 >> 8;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 8
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.carry)
        goto cseg_2A946;                    // jb short cseg_2A946

    if (!flags.carry && !flags.zero)
        goto cseg_2A81E;                    // ja cseg_2A81E

    {
        word res = *(word *)&D7 & 8;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 8
    if (flags.zero)
        goto cseg_2A9A0;                    // jz cseg_2A9A0

    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 >> 8;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 8
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.carry && !flags.zero)
        goto cseg_2A81E;                    // ja cseg_2A81E

cseg_2A946:;
    {
        word src = *(word *)&g_memByte[91648];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91648] = src;
    }                                       // add dseg_D6C8E, 1
    {
        word src = *(word *)&g_memByte[91636];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91636] = src;
    }                                       // add numLost, 1
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2A9F0;                    // jnz cseg_2A9F0

    {
        dword src = *(dword *)&g_memByte[318682];
        int32_t dstSigned = src;
        int32_t srcSigned = 7067;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10EED0, offset aEuropeanTour
    if (flags.carry)
        goto cseg_2A97D;                    // jb short cseg_2A97D

    {
        dword src = *(dword *)&g_memByte[318682];
        int32_t dstSigned = src;
        int32_t srcSigned = 7145;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10EED0, offset aOceaniaTour
    if (flags.carry || flags.zero)
        goto cseg_2A996;                    // jbe short cseg_2A996

cseg_2A97D:;
    ax = *(word *)&g_memByte[318746];       // mov ax, dseg_10EF10
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2A9F0;                    // jz short cseg_2A9F0

    {
        word src = *(word *)&g_memByte[91658];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91658] = src;
    }                                       // add dseg_D6C98, 1
    goto cseg_2A9F0;                        // jmp short cseg_2A9F0

cseg_2A996:;
    {
        word src = *(word *)&g_memByte[91664];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91664] = src;
    }                                       // add dseg_D6C9E, 1
    goto cseg_2A9F0;                        // jmp short cseg_2A9F0

cseg_2A9A0:;
    {
        word src = *(word *)&g_memByte[91646];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91646] = src;
    }                                       // add dseg_D6C8C, 1
    {
        word src = *(word *)&g_memByte[91634];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91634] = src;
    }                                       // add numDrawn, 1
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2A9F0;                    // jnz short cseg_2A9F0

    {
        dword src = *(dword *)&g_memByte[318682];
        int32_t dstSigned = src;
        int32_t srcSigned = 7067;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10EED0, offset aEuropeanTour
    if (flags.carry)
        goto cseg_2A9D3;                    // jb short cseg_2A9D3

    {
        dword src = *(dword *)&g_memByte[318682];
        int32_t dstSigned = src;
        int32_t srcSigned = 7145;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10EED0, offset aOceaniaTour
    if (flags.carry || flags.zero)
        goto cseg_2A9E8;                    // jbe short cseg_2A9E8

cseg_2A9D3:;
    ax = *(word *)&g_memByte[318746];       // mov ax, dseg_10EF10
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2A9F0;                    // jz short cseg_2A9F0

    {
        word src = *(word *)&g_memByte[91656];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91656] = src;
    }                                       // add dseg_D6C96, 1
    goto cseg_2A9F0;                        // jmp short cseg_2A9F0

cseg_2A9E8:;
    {
        word src = *(word *)&g_memByte[91662];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91662] = src;
    }                                       // add dseg_D6C9C, 1

cseg_2A9F0:;
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (!flags.zero)
        goto cseg_2AA08;                    // jnz short cseg_2AA08

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_2AA61;                    // jz short cseg_2AA61

cseg_2AA08:;
    push(D0);                               // push D0
    cseg_2AE07();                           // call cseg_2AE07
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 6, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 6, 1, src);
    }                                       // sub byte ptr [esi+6], 1
    al = D7;                                // mov al, byte ptr D7
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 11, 1, al);           // mov [esi+0Bh], al
    ax = D4;                                // mov ax, word ptr D4
    writeMemory(esi + 16, 2, ax);           // mov [esi+10h], ax
    ax = D5;                                // mov ax, word ptr D5
    writeMemory(esi + 18, 2, ax);           // mov [esi+12h], ax
    ax = D6;                                // mov ax, word ptr D6
    writeMemory(esi + 20, 2, ax);           // mov [esi+14h], ax

cseg_2AA61:;
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2AA79;                    // jnz short cseg_2AA79

    ax = *(word *)&g_memByte[319090];       // mov ax, dseg_10F068
    *(word *)&g_memByte[109910] = ax;       // mov dseg_DB3E4, ax
    return;                                 // retn

cseg_2AA79:;
    ax = *(word *)&g_memByte[318726];       // mov ax, dseg_10EEFC
    *(word *)&g_memByte[109910] = ax;       // mov dseg_DB3E4, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2AA86()
{
    A6 = 318643;                            // mov A6, offset DIY_competitionStart
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 589
    A5 = eax;                               // mov A5, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A3 = eax;                               // mov A3, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 137;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 89h
    A2 = eax;                               // mov A2, eax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2AB7B;                    // jz cseg_2AB7B

    A0 = 317588;                            // mov A0, offset diyFileBufferCopy
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    bx = 118;                               // mov bx, 76h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 347, 2);    // mov ax, [esi+15Bh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2AB45;                    // jnz short cseg_2AB45

    {
        word src = (word)readMemory(esi + 355, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+163h], 1
    if (flags.zero)
        goto cseg_2AB7B;                    // jz short cseg_2AB7B

    ax = (word)readMemory(esi + 465, 2);    // mov ax, [esi+1D1h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2AB7B;                    // jz short cseg_2AB7B

    return;                                 // jmp short cseg_2AB7A

cseg_2AB45:;
    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi], 2
    if (flags.zero)
        return;                             // jz short cseg_2AB7A

    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A3)++;
    flags.sign = (*(int32_t *)&A3 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A3 == 0;      // inc A3
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_2ABF0();                           // call cseg_2ABF0
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_2ABF0();                           // call cseg_2ABF0

cseg_2AB7A:;
    return;                                 // retn

cseg_2AB7B:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_2AB93:;
    esi = A2;                               // mov esi, A2
    (*(int32_t *)&A2)++;                    // inc A2
    {
        byte src = (byte)readMemory(esi, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi], 2
    if (flags.zero)
        goto cseg_2ABD9;                    // jz short cseg_2ABD9

    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + -1, 1);
        byte res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi-1], 1
    if (!flags.zero)
        goto cseg_2ABCB;                    // jnz short cseg_2ABCB

    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al

cseg_2ABCB:;
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0FFh
    cseg_2ABF0();                           // call cseg_2ABF0

cseg_2ABD9:;
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 2
    A3 = eax;                               // mov A3, eax
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_2AB93;                    // jns short cseg_2AB93
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2ABF0()
{
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    esi = A5;                               // mov esi, A5
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        return;                             // jz short cseg_2AC33

    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 75, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 75, 2, src);
    }                                       // sub word ptr [esi+4Bh], 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2AC34()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 813, 2, 0);           // mov word ptr [esi+32Dh], 0
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 137;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 89h
    A1 = eax;                               // mov A1, eax
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_2AC74:;
    esi = A1;                               // mov esi, A1
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 1
    {
        byte src = (byte)readMemory(esi, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi], 2
    if (!flags.zero)
        goto cseg_2AC94;                    // jnz short cseg_2AC94

    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 813, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        src = res;
        writeMemory(esi + 813, 2, src);
    }                                       // add word ptr [esi+32Dh], 1

cseg_2AC94:;
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_2AC74;                    // jns short cseg_2AC74

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 813, 2);    // mov ax, [esi+32Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2ACAE()
{
    A6 = 318643;                            // mov A6, offset DIY_competitionStart
    A4 = 336664;                            // mov A4, offset dseg_114CA2
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A4;                               // mov eax, A4
    {
        int16_t dstSigned = ax;
        int16_t srcSigned = D0;
        word res = dstSigned + srcSigned;
        ax = res;
    }                                       // add ax, word ptr D0
    A5 = eax;                               // mov A5, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A3 = eax;                               // mov A3, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 137;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 89h
    A2 = eax;                               // mov A2, eax
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_2AD19:;
    esi = A2;                               // mov esi, A2
    (*(int32_t *)&A2)++;                    // inc A2
    {
        byte src = (byte)readMemory(esi, 1);
        byte res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi], 1
    if (!flags.zero)
        goto cseg_2AD64;                    // jnz short cseg_2AD64

    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A3)++;                    // inc A3
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A4)++;                    // inc A4
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A3)++;                    // inc A3
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A5)++;
    flags.sign = (*(int32_t *)&A5 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A5 == 0;      // inc A5
    goto cseg_2AD9C;                        // jmp short cseg_2AD9C

cseg_2AD64:;
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A3)++;                    // inc A3
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A5)++;                    // inc A5
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A3)++;                    // inc A3
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A4)++;                    // inc A4

cseg_2AD9C:;
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_2AD19;                    // jns cseg_2AD19

    A2 = 336664;                            // mov A2, offset dseg_114CA2
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A3 = eax;                               // mov A3, eax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_2ADE1:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A3)++;                    // inc A3
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_2ADE1;                    // jns short cseg_2ADE1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2AE07()
{
    A0 = 109912;                            // mov A0, offset dseg_DB3E6
    ax = *(word *)&g_memByte[109906];       // mov ax, dseg_DB3E0
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        dword res = D0 & 65535;
        D0 = res;
    }                                       // and D0, 0FFFFh
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 6, 1);      // mov al, [esi+6]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        return;                             // js short cseg_2AE96

    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 6, 1);      // mov al, [esi+6]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    if (flags.zero)
        return;                             // jz short cseg_2AE96

    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    bx = 12;                                // mov bx, 12
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, eax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2AE97()
{
    A6 = 318643;                            // mov A6, offset DIY_competitionStart
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A6;                               // mov eax, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2B285;                    // jnz cseg_2B285

    {
        word src = (word)readMemory(esi + 331, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+14Bh], 2
    if (!flags.zero)
        goto cseg_2B28C;                    // jnz cseg_2B28C

    ax = (word)readMemory(esi + 329, 2);    // mov ax, [esi+149h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2AFCF;                    // jnz cseg_2AFCF

    {
        byte res = *(byte *)&D7 & 223;
        *(byte *)&D7 = res;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and byte ptr D7, 0DFh
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+5Fh]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 97, 2);     // mov ax, [esi+61h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+2Bh]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2B7D8();                           // call cseg_2B7D8
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto cseg_2B52F;                    // jz cseg_2B52F

    goto cseg_2B53F;                        // jmp cseg_2B53F

cseg_2AFCF:;
    *(byte *)&D7 |= 32;
    flags.carry = false;
    flags.sign = (*(byte *)&D7 & 0x80) != 0;
    flags.zero = *(byte *)&D7 == 0;         // or byte ptr D7, 20h
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+5Fh]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 97, 2);     // mov ax, [esi+61h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+2Bh]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2B7D8();                           // call cseg_2B7D8
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, ax
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (!flags.zero)
        goto cseg_2B23E;                    // jnz cseg_2B23E

    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 93, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+5Dh], 1
    if (!flags.zero)
        goto cseg_2B0F4;                    // jnz short cseg_2B0F4

    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto cseg_2B0F4;                    // jz short cseg_2B0F4

    *(byte *)&D7 |= 16;                     // or byte ptr D7, 10h
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto cseg_2B0F4;                    // jz short cseg_2B0F4

    if (!flags.carry && !flags.zero)
        goto cseg_2B268;                    // ja cseg_2B268

    goto cseg_2B24B;                        // jmp cseg_2B24B

cseg_2B0F4:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 113, 2);    // mov ax, [esi+71h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2B472;                    // jz cseg_2B472

    {
        word src = (word)readMemory(esi + 113, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+71h], 1
    if (!flags.zero)
        goto cseg_2B472;                    // jnz cseg_2B472

    *(byte *)&D7 |= 4;
    flags.carry = false;
    flags.sign = (*(byte *)&D7 & 0x80) != 0;
    flags.zero = *(byte *)&D7 == 0;         // or byte ptr D7, 4
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2B81B();                           // call cseg_2B81B
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, ax
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (!flags.zero)
        goto cseg_2B23E;                    // jnz short cseg_2B23E

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 93, 2);     // mov ax, [esi+5Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2B221;                    // jz short cseg_2B221

    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto cseg_2B221;                    // jz short cseg_2B221

    *(byte *)&D7 |= 16;                     // or byte ptr D7, 10h
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.carry && !flags.zero)
        goto cseg_2B268;                    // ja short cseg_2B268

    goto cseg_2B24B;                        // jmp short cseg_2B24B

cseg_2B221:;
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    goto cseg_2B472;                        // jmp cseg_2B472

cseg_2B23E:;
    al = D3;                                // mov al, byte ptr D3
    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D4, al
    if (!flags.carry && !flags.zero)
        goto cseg_2B268;                    // ja short cseg_2B268

cseg_2B24B:;
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    goto cseg_2B54C;                        // jmp cseg_2B54C

cseg_2B268:;
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    goto cseg_2B555;                        // jmp cseg_2B555

cseg_2B285:;
    *(byte *)&D7 |= 64;                     // or byte ptr D7, 40h

cseg_2B28C:;
    {
        byte res = *(byte *)&D7 & 223;
        *(byte *)&D7 = res;
    }                                       // and byte ptr D7, 0DFh
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 331, 2);    // mov ax, [esi+14Bh]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 0
    if (!flags.zero)
        goto cseg_2B2B9;                    // jnz short cseg_2B2B9

    *(byte *)&D0 = 255;                     // mov byte ptr D0, 0FFh

cseg_2B2B9:;
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+5Fh]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 97, 2);     // mov ax, [esi+61h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+2Bh]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2B7D8();                           // call cseg_2B7D8
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_2B53F;                    // jnz cseg_2B53F

    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 113, 2);    // mov ax, [esi+71h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2B472;                    // jz cseg_2B472

    {
        word src = (word)readMemory(esi + 113, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+71h], 1
    if (flags.zero)
        goto cseg_2B3AD;                    // jz short cseg_2B3AD

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2B472;                    // jz cseg_2B472

cseg_2B3AD:;
    *(byte *)&D7 |= 4;
    flags.carry = false;
    flags.sign = (*(byte *)&D7 & 0x80) != 0;
    flags.zero = *(byte *)&D7 == 0;         // or byte ptr D7, 4
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2B81B();                           // call cseg_2B81B
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    eax = D1;                               // mov eax, D1
    {
        dword tmp = D3;
        D3 = eax;
        eax = tmp;
    }                                       // xchg eax, D3
    D1 = eax;                               // mov D1, eax
    eax = D2;                               // mov eax, D2
    {
        dword tmp = D4;
        D4 = eax;
        eax = tmp;
    }                                       // xchg eax, D4
    D2 = eax;                               // mov D2, eax
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_2B53F;                    // jnz cseg_2B53F

cseg_2B472:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 125, 2);    // mov ax, [esi+7Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2B52F;                    // jz cseg_2B52F

    {
        word src = (word)readMemory(esi + 125, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+7Dh], 1
    if (flags.zero)
        goto cseg_2B4A8;                    // jz short cseg_2B4A8

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_2B52F;                    // jz cseg_2B52F

cseg_2B4A8:;
    *(byte *)&D7 |= 8;
    flags.carry = false;
    flags.sign = (*(byte *)&D7 & 0x80) != 0;
    flags.zero = *(byte *)&D7 == 0;         // or byte ptr D7, 8
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D7);                               // push D7
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2B84D();                           // call cseg_2B84D
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    al = D5;                                // mov al, byte ptr D5
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D6, al
    if (!flags.carry && !flags.zero)
        goto cseg_2B555;                    // ja short cseg_2B555

    goto cseg_2B54C;                        // jmp short cseg_2B54C

cseg_2B52F:;
    *(byte *)&D7 |= 128;                    // or byte ptr D7, 80h
    {
        byte res = *(byte *)&D7 & 253;
        *(byte *)&D7 = res;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and byte ptr D7, 0FDh
    goto cseg_2B56A;                        // jmp short cseg_2B56A

cseg_2B53F:;
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.carry && !flags.zero)
        goto cseg_2B555;                    // ja short cseg_2B555

cseg_2B54C:;
    {
        byte res = *(byte *)&D7 & 254;
        *(byte *)&D7 = res;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and byte ptr D7, 0FEh
    goto cseg_2B55C;                        // jmp short cseg_2B55C

cseg_2B555:;
    *(byte *)&D7 |= 1;                      // or byte ptr D7, 1

cseg_2B55C:;
    *(byte *)&D7 |= 128;                    // or byte ptr D7, 80h
    *(byte *)&D7 |= 2;                      // or byte ptr D7, 2

cseg_2B56A:;
    ax = *(word *)&g_memByte[379876];       // mov ax, dseg_11F9CC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2B780;                    // jnz cseg_2B780

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_2B595;                    // jz short cseg_2B595

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (!flags.zero)
        goto cseg_2B780;                    // jnz cseg_2B780

cseg_2B595:;
    *(word *)&g_memByte[529332] = 0;        // mov dseg_180584, 0
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_2B5B6;                    // jnz short cseg_2B5B6

    *(word *)&g_memByte[529332] = 65535;    // mov dseg_180584, 0FFFFh

cseg_2B5B6:;
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_908B4();                           // call cseg_908B4
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2D553();                           // call cseg_2D553
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    *(word *)&g_memByte[91350] = 0;         // mov dseg_D6B64, 0
    {
        byte res = *(byte *)&D7 & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr D7, 2
    if (flags.zero)
        goto cseg_2B780;                    // jz short cseg_2B780

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_2B765;                    // jz short cseg_2B765

    {
        byte res = *(byte *)&D7 & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr D7, 1
    if (!flags.zero)
        goto cseg_2B76E;                    // jnz short cseg_2B76E

    goto cseg_2B780;                        // jmp short cseg_2B780

cseg_2B765:;
    {
        byte res = *(byte *)&D7 & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr D7, 1
    if (!flags.zero)
        goto cseg_2B780;                    // jnz short cseg_2B780

cseg_2B76E:;
    *(word *)&g_memByte[91350] = 1;         // mov dseg_D6B64, 1
    *(word *)&g_memByte[529332] = 65535;    // mov dseg_180584, 0FFFFh

cseg_2B780:;
    {
        word res = *(word *)&D5 << 8;
        *(word *)&D5 = res;
    }                                       // shl word ptr D5, 8
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax
    {
        word res = *(word *)&D3 << 8;
        *(word *)&D3 = res;
    }                                       // shl word ptr D3, 8
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    {
        word res = *(word *)&D1 << 8;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 8
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2B7D8()
{
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 23, 1);
        byte res = src & 254;
        src = res;
        writeMemory(esi + 23, 1, src);
    }                                       // and byte ptr [esi+17h], 0FEh
    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 23, 1);
        byte res = src & 254;
        src = res;
        writeMemory(esi + 23, 1, src);
    }                                       // and byte ptr [esi+17h], 0FEh
    ax = *(word *)&g_memByte[336652];       // mov ax, dseg_114C96
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_2B819;                    // js short cseg_2B819

    ax = *(word *)&g_memByte[336652];       // mov ax, dseg_114C96
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[336654];       // mov ax, dseg_114C98
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)&g_memByte[336652] = -1;       // mov dseg_114C96, -1
    return;                                 // retn

cseg_2B819:;
    CalculateViewResult();                  // jmp short CalculateViewResult
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2B81B()
{
    ax = *(word *)&g_memByte[336656];       // mov ax, dseg_114C9A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_2B848;                    // js short cseg_2B848

    ax = *(word *)&g_memByte[336656];       // mov ax, dseg_114C9A
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = *(word *)&g_memByte[336658];       // mov ax, dseg_114C9C
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)&g_memByte[336656] = 65535;    // mov dseg_114C9A, 0FFFFh
    return;                                 // retn

cseg_2B848:;
    cseg_2C0D3();                           // jmp cseg_2C0D3
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2B84D()
{
    ax = *(word *)&g_memByte[336660];       // mov ax, dseg_114C9E
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_2B880;                    // js short cseg_2B880

    ax = *(word *)&g_memByte[336660];       // mov ax, dseg_114C9E
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    ax = *(word *)&g_memByte[336662];       // mov ax, dseg_114CA0
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    *(word *)&g_memByte[336660] = 65535;    // mov dseg_114C9E, 0FFFFh
    return;                                 // retn

cseg_2B880:;
    cseg_2C3CC();                           // jmp cseg_2C3CC
}

// =============== S U B R O U T I N E =======================================

// out:
//      D1 - team1 num. goals
//      D2 - team2 num, goals
//
//
void CalculateViewResult()
{
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[379616] = eax;     // mov dseg_11F8C8, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 59, 2);     // mov ax, [esi+3Bh]
    *(word *)&g_memByte[131753] = ax;       // mov inEditTactics, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[379620] = ax;       // mov dseg_11F8CC, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[379624] = ax;       // mov dseg_11F8D0, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[379626] = ax;       // mov dseg_11F8D2, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[379622] = ax;       // mov dseg_11F8CE, ax
    eax = A1;                               // mov eax, A1
    *(dword *)&g_memByte[379628] = eax;     // mov dseg_11F8D4, eax
    eax = A2;                               // mov eax, A2
    *(dword *)&g_memByte[379632] = eax;     // mov dseg_11F8D8, eax
    D0 = 0;                                 // mov D0, 0
    A0 = 379734;                            // mov A0, offset dseg_11F93E
    eax = D0;                               // mov eax, D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    A0 = 379766;                            // mov A0, offset dseg_11F95E
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, eax);               // mov [esi], eax
    eax = *(dword *)&g_memByte[379628];     // mov eax, dseg_11F8D4
    A0 = eax;                               // mov A0, eax
    A2 = 379658;                            // mov A2, offset dseg_11F8F2
    cseg_2CFD5();                           // call cseg_2CFD5
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&g_memByte[379730] = ax;       // mov dseg_11F93A, ax
    eax = D7;                               // mov eax, D7
    *(dword *)&g_memByte[379722] = eax;     // mov dseg_11F932, eax
    eax = *(dword *)&g_memByte[379632];     // mov eax, dseg_11F8D8
    A0 = eax;                               // mov A0, eax
    A2 = 379690;                            // mov A2, offset dseg_11F912
    cseg_2CFD5();                           // call cseg_2CFD5
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&g_memByte[379732] = ax;       // mov dseg_11F93C, ax
    eax = D7;                               // mov eax, D7
    *(dword *)&g_memByte[379726] = eax;     // mov dseg_11F936, eax
    eax = *(dword *)&g_memByte[379628];     // mov eax, dseg_11F8D4
    A0 = eax;                               // mov A0, eax
    A1 = 379658;                            // mov A1, offset dseg_11F8F2
    cseg_2C9D9();                           // call cseg_2C9D9
    eax = *(dword *)&g_memByte[379632];     // mov eax, dseg_11F8D8
    A0 = eax;                               // mov A0, eax
    A1 = 379690;                            // mov A1, offset dseg_11F912
    cseg_2C9D9();                           // call cseg_2C9D9
    eax = *(dword *)&g_memByte[379628];     // mov eax, dseg_11F8D4
    A0 = eax;                               // mov A0, eax
    A1 = 379658;                            // mov A1, offset dseg_11F8F2
    cseg_64D5A();                           // call cseg_64D5A
    eax = *(dword *)&g_memByte[379632];     // mov eax, dseg_11F8D8
    A0 = eax;                               // mov A0, eax
    A1 = 379690;                            // mov A1, offset dseg_11F912
    cseg_64D5A();                           // call cseg_64D5A
    eax = *(dword *)&g_memByte[379628];     // mov eax, dseg_11F8D4
    A0 = eax;                               // mov A0, eax
    A1 = 379658;                            // mov A1, offset dseg_11F8F2
    cseg_903B1();                           // call cseg_903B1
    eax = *(dword *)&g_memByte[379632];     // mov eax, dseg_11F8D8
    A0 = eax;                               // mov A0, eax
    A1 = 379690;                            // mov A1, offset dseg_11F912
    cseg_903B1();                           // call cseg_903B1
    eax = *(dword *)&g_memByte[379628];     // mov eax, dseg_11F8D4
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[379626];       // mov ax, dseg_11F8D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SetupTeamSubstitutes();                           // call SetupTeamSubstitutes
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[379636] = ax;       // mov dseg_11F8DC, ax
    eax = *(dword *)&g_memByte[379632];     // mov eax, dseg_11F8D8
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[379626];       // mov ax, dseg_11F8D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SetupTeamSubstitutes();                           // call SetupTeamSubstitutes
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[379638] = ax;       // mov dseg_11F8DE, ax
    eax = *(dword *)&g_memByte[379628];     // mov eax, dseg_11F8D4
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[379632];     // mov eax, dseg_11F8D8
    A2 = eax;                               // mov A2, eax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (!flags.zero)
        goto cseg_2BBAF;                    // jnz short cseg_2BBAF

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_2BBF3;                    // jz short cseg_2BBF3

cseg_2BBAF:;
    ax = *(word *)&g_memByte[379636];       // mov ax, dseg_11F8DC
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    cseg_2C05E();                           // call cseg_2C05E
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&g_memByte[379636] = ax;       // mov dseg_11F8DC, ax
    eax = A2;                               // mov eax, A2
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[379638];       // mov ax, dseg_11F8DE
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    cseg_2C05E();                           // call cseg_2C05E
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&g_memByte[379638] = ax;       // mov dseg_11F8DE, ax

cseg_2BBF3:;
    eax = *(dword *)&g_memByte[379628];     // mov eax, dseg_11F8D4
    A0 = eax;                               // mov A0, eax
    cseg_2C88E();                           // call cseg_2C88E
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[379646] = ax;       // mov dseg_11F8E6, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[379650] = ax;       // mov dseg_11F8EA, ax
    {
        dword src = *(dword *)&g_memByte[379628];
        int32_t dstSigned = src;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_11F8D4, offset careerTeam
    if (!flags.zero)
        goto cseg_2BC32;                    // jnz short cseg_2BC32

    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[379830] = ax;       // mov dseg_11F99E, ax

cseg_2BC32:;
    eax = *(dword *)&g_memByte[379632];     // mov eax, dseg_11F8D8
    A0 = eax;                               // mov A0, eax
    cseg_2C88E();                           // call cseg_2C88E
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[379648] = ax;       // mov dseg_11F8E8, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[379652] = ax;       // mov dseg_11F8EC, ax
    {
        dword src = *(dword *)&g_memByte[379632];
        int32_t dstSigned = src;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_11F8D8, offset careerTeam
    if (!flags.zero)
        goto cseg_2BC71;                    // jnz short cseg_2BC71

    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[379830] = ax;       // mov dseg_11F99E, ax

cseg_2BC71:;
    ax = *(word *)&g_memByte[379636];       // mov ax, dseg_11F8DC
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = *(word *)&g_memByte[379646];       // mov ax, dseg_11F8E6
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_2BCA4;                    // jns short cseg_2BCA4

    *(word *)&D0 = 0;                       // mov word ptr D0, 0

cseg_2BCA4:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 31
    if (flags.carry || flags.zero)
        goto cseg_2BCB7;                    // jbe short cseg_2BCB7

    *(word *)&D0 = 31;                      // mov word ptr D0, 31

cseg_2BCB7:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[379640] = ax;       // mov dseg_11F8E0, ax
    ax = *(word *)&g_memByte[379638];       // mov ax, dseg_11F8DE
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = *(word *)&g_memByte[379648];       // mov ax, dseg_11F8E8
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_2BCF6;                    // jns short cseg_2BCF6

    *(word *)&D0 = 0;                       // mov word ptr D0, 0

cseg_2BCF6:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1Fh
    if (flags.carry || flags.zero)
        goto cseg_2BD09;                    // jbe short cseg_2BD09

    *(word *)&D0 = 31;                      // mov word ptr D0, 1Fh

cseg_2BD09:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[379642] = ax;       // mov dseg_11F8E2, ax
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D3 = res;
    }                                       // sub word ptr D3, ax
    ax = *(word *)&g_memByte[379620];       // mov ax, dseg_11F8CC
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2BD35;                    // jnz short cseg_2BD35

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 2

cseg_2BD35:;
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 23;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 23
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_2BD4A;                    // jle short cseg_2BD4A

    *(word *)&D3 = 23;                      // mov word ptr D3, 23
    goto cseg_2BD5D;                        // jmp short cseg_2BD5D

cseg_2BD4A:;
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 65513;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 0FFE9h
    if (flags.sign == flags.overflow)
        goto cseg_2BD5D;                    // jge short cseg_2BD5D

    *(word *)&D3 = 65513;                   // mov word ptr D3, 0FFE9h

cseg_2BD5D:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[379644] = ax;       // mov dseg_11F8E4, ax
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_2BD81;                    // jns short cseg_2BD81

    *(int16_t *)&D0 = -*(int16_t *)&D0;     // neg word ptr D0

cseg_2BD81:;
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 486822;                            // mov A0, offset dseg_1728FF
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 3
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.sign)
        goto cseg_2BE12;                    // jns short cseg_2BE12

    A0 = 486950;                            // mov A0, offset dseg_17297F
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 6;                                 // mov bx, 6
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al

cseg_2BE12:;
    al = D1;                                // mov al, byte ptr D1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    A0 = 486956;                            // mov A0, offset dseg_172985
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    SWOS::Rand2();                          // call Rand2
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2BFBF;                    // jb cseg_2BFBF

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2BFBF;                    // jb cseg_2BFBF

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2BFBF;                    // jb cseg_2BFBF

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2BFBF;                    // jb cseg_2BFBF

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    A0 = 487028;                            // mov A0, offset dseg_1729CD
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    SWOS::Rand2();                          // call Rand2
    *(word *)&D2 = 3;                       // mov word ptr D2, 3
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2BFBF;                    // jb short cseg_2BFBF

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2BFBF;                    // jb short cseg_2BFBF

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1

cseg_2BFBF:;
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_2BFE7;                    // jns short cseg_2BFE7

    eax = D1;                               // mov eax, D1
    {
        dword tmp = D2;
        D2 = eax;
        eax = tmp;
    }                                       // xchg eax, D2
    D1 = eax;                               // mov D1, eax

cseg_2BFE7:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[379654] = ax;       // mov lastTeam1ViewResultGoals, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[379656] = ax;       // mov lastTeam2ViewResultGoals, ax
    eax = *(dword *)&g_memByte[379628];     // mov eax, dseg_11F8D4
    A0 = eax;                               // mov A0, eax
    A2 = 379658;                            // mov A2, offset dseg_11F8F2
    A3 = 379734;                            // mov A3, offset dseg_11F93E
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    cseg_2C47D();                           // call cseg_2C47D
    eax = *(dword *)&g_memByte[379632];     // mov eax, dseg_11F8D8
    A0 = eax;                               // mov A0, eax
    A2 = 379690;                            // mov A2, offset dseg_11F912
    A3 = 379766;                            // mov A3, offset dseg_11F95E
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    cseg_2C47D();                           // call cseg_2C47D
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2C05E()
{
    eax = *(dword *)&g_memByte[379616];     // mov eax, dseg_11F8C8
    A0 = eax;                               // mov A0, eax
    cseg_94A16();                           // call cseg_94A16
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 100;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 64h
    ax = D7;                                // mov ax, word ptr D7
    tmp = ax * *(word *)&D0;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D0
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_2C0BF;                    // jns short cseg_2C0BF

    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    return;                                 // retn

cseg_2C0BF:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 1Fh
    if (flags.carry || flags.zero)
        return;                             // jbe short cseg_2C0D2

    *(word *)&D7 = 31;                      // mov word ptr D7, 1Fh
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2C0D3()
{
    ax = *(word *)&g_memByte[379636];       // mov ax, dseg_11F8DC
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[379650];       // mov ax, dseg_11F8EA
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    if (!flags.sign)
        goto cseg_2C0F7;                    // jns short cseg_2C0F7

    *(word *)&D1 = 0;                       // mov word ptr D1, 0

cseg_2C0F7:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1Fh
    if (flags.carry || flags.zero)
        goto cseg_2C10A;                    // jbe short cseg_2C10A

    *(word *)&D1 = 31;                      // mov word ptr D1, 1Fh

cseg_2C10A:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[379640] = ax;       // mov dseg_11F8E0, ax
    ax = *(word *)&g_memByte[379638];       // mov ax, dseg_11F8DE
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[379652];       // mov ax, dseg_11F8EC
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    if (!flags.sign)
        goto cseg_2C13A;                    // jns short cseg_2C13A

    *(word *)&D2 = 0;                       // mov word ptr D2, 0

cseg_2C13A:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 1Fh
    if (flags.carry || flags.zero)
        goto cseg_2C14D;                    // jbe short cseg_2C14D

    *(word *)&D2 = 31;                      // mov word ptr D2, 1Fh

cseg_2C14D:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[379642] = ax;       // mov dseg_11F8E2, ax
    ax = *(word *)&g_memByte[379640];       // mov ax, dseg_11F8E0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (!flags.sign)
        goto cseg_2C193;                    // jns short cseg_2C193

    *(int16_t *)&D0 = -*(int16_t *)&D0;     // neg word ptr D0

cseg_2C193:;
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 2015;                              // mov A0, offset cseg_2C347
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 3
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    A0 = 2143;                              // mov A0, offset cseg_2C3C7
    SWOS::Rand2();                          // call Rand2
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2C2A2;                    // jb cseg_2C2A2

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2C2A2;                    // jb short cseg_2C2A2

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 1
    A0 = 2146;                              // mov A0, offset cseg_2C3CA
    SWOS::Rand2();                          // call Rand2
    *(word *)&D4 = 1;                       // mov word ptr D4, 1
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2C2A2;                    // jb short cseg_2C2A2

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 1

cseg_2C2A2:;
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry && !flags.zero)
        goto cseg_2C2CE;                    // ja short cseg_2C2CE

    eax = D3;                               // mov eax, D3
    {
        dword tmp = D4;
        D4 = eax;
        eax = tmp;
    }                                       // xchg eax, D4
    D3 = eax;                               // mov D3, eax

cseg_2C2CE:;
    ax = D3;                                // mov ax, word ptr D3
    {
        word src = *(word *)&g_memByte[379654];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[379654] = src;
    }                                       // add lastTeam1ViewResultGoals, ax
    ax = D4;                                // mov ax, word ptr D4
    {
        word src = *(word *)&g_memByte[379656];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[379656] = src;
    }                                       // add lastTeam2ViewResultGoals, ax
    eax = *(dword *)&g_memByte[379628];     // mov eax, dseg_11F8D4
    A0 = eax;                               // mov A0, eax
    A2 = 379658;                            // mov A2, offset dseg_11F8F2
    A3 = 379734;                            // mov A3, offset dseg_11F93E
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    cseg_2C47D();                           // call cseg_2C47D
    eax = *(dword *)&g_memByte[379632];     // mov eax, dseg_11F8D8
    A0 = eax;                               // mov A0, eax
    A2 = 379690;                            // mov A2, offset dseg_11F912
    A3 = 379766;                            // mov A3, offset dseg_11F95E
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    cseg_2C47D();                           // call cseg_2C47D
}

