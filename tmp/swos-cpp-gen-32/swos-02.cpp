// automatically generated by ida2asm, do not edit!

#include "vm.h"
#include "defs.h"

#ifdef _MSC_VER
# pragma warning(disable: 4309 4146 4333 4805 4102)
#endif

using namespace SwosVM;

extern void cseg_5E2E0();
extern void cseg_5A8DE();
extern void cseg_5C3CB();
extern void cseg_64E3E();
extern void GetPlayer();
extern void GetPlayerRandomNum();
extern void GetPlayerPrice();
extern void FixTwoCPUsGameCrash();
extern void cseg_94A16();
extern void Rand2();
extern void ShowErrorMenu();
extern void FindTeamInCache();
extern void SearchTeamInTmdFile();
extern void nullsub_9();
extern void InitUserTactics();
extern void SaveOptions();
extern void LoadFile();
extern void SetZeroFlag2();
extern void CycleMenuMusic();
extern void RestoreOptions();
extern void WriteFile();
extern void cseg_66A98();
extern void GetAveragePlayerPrice();
extern void dseg_1733C6();
extern void SetDefaultNameAndSurname();
extern void InitCareer();
extern void cseg_8E3DA();
extern void cseg_8E469();
extern void cseg_8EA56();
extern void cseg_10520();
extern void cseg_1053F();
extern void SelectAndShowSquadToView();
extern void ShowClubBussinesMenu();
extern void CareerInitVars();
extern void ShowSelectRepresentationMenu();
extern void cseg_8E98E();
extern void CheckForTransferOffers();
extern void cseg_8E94F();
extern void PrintFormatted();
extern void ContinueCareerNextSeason();
extern void SetZeroFlag();
extern void SelectFileToSaveDialog();
extern void cseg_89B5C();
extern void cseg_8B7EA();
extern void dseg_17343E();
extern void DrawMultipleItems();
extern void Randomize2();
extern void cseg_8F1F2();
extern void cseg_87DA0();
extern void cseg_8C623();
extern void cseg_24DFA();
extern void cseg_88A12();
extern void cseg_28E76();
extern void cseg_5353F();
extern void cseg_883DD();
extern void cseg_8A147();
extern void AddCareerTeamPlayer();
extern void CheckPlayersLeavingComing();
extern void cseg_8E841();
extern void cseg_8EA82();
extern void cseg_60E1C();
extern void cseg_5B705();
extern void cseg_8B71C();
extern void GetMoreExpensiveTeamsCount();
extern void cseg_5E535();
extern void cseg_9111F();
extern void VerifyTeamLoaded();
extern void cseg_2484B();
extern void Rand();
extern void ShowChairmanMessage();
extern void DeselectTeam();
extern void cseg_52588();
extern void CheckIsTeamNational();
extern void GetPlayerGameBreakPosition();
extern void DrawMenu();
extern void GetPlayerAtIndex();
extern void ShowStandardChooseTacticsMenu();
extern void RecalculateReachableEntries();
extern void RotatePlayersLeft();
extern void nullsub_17();
extern void DrawMenuItem();
extern void GetPlayerPosition();
extern void ExtractSurname();
extern void cseg_13A55();
extern void FormTopSkillsString();
extern void cseg_247C8();
extern void SetupTeamSubstitutes();
extern void cseg_63E05();
extern void cseg_6481C();
extern void cseg_63EC4();
extern void SetBenchPlayersNumbers();
extern void cseg_64161();
extern void CheckIfTeamIsChanged();
extern void ActivateMenu();
extern void InputText();
extern void cseg_87D60();
extern void nullsub_13();
extern void cseg_2573C();
extern void cseg_258E4();
extern void RestoreDIYTournament();
extern void StringCopy();
extern void CallDrawMultipleItems();
extern void SaveDIYTournament();
extern void cseg_254F8();
extern void CalcMenuEntryAddress();
extern void cseg_268C6();
extern void cseg_28139();
extern void cseg_28076();
extern void cseg_27FFF();
extern void InitDIYCup();
extern void MenuCheckControls();
extern void cseg_284AB();
extern void cseg_28049();
extern void cseg_284D8();
extern void cseg_288E2();
extern void cseg_289AC();
extern void cseg_28DC6();
extern void cseg_2653B();
extern void cseg_28243();
extern void InitTeams();
extern void RestoreDIYLeague();
extern void CallDrawMenuItem();
extern void Int2Ascii();
extern void SaveDIYLeague();
extern void cseg_26395();
extern void cseg_89758();
extern void cseg_88961();
extern void SetCurrentEntry();
extern void GetStringLength();
extern void SetExitMenuFlag();
extern void cseg_23538();
extern void cseg_2364C();
extern void cseg_235E4();
extern void ShowMenu();

// first pass forward declarations
void cseg_2C3CC();
void cseg_2C47D();
void cseg_2C88E();
void cseg_2C9D9();
void cseg_2CDC6();
void cseg_2CED3();
void cseg_2CFD5();
void cseg_2D553();
void cseg_2D64E();
void cseg_2D7B7();
void SaveSelectedTeams();
void RestoreSelectedTeams();
void SaveRand2State();
void RestoreRand2State();
void GetBankBalance();
void Int2Pounds();
void Int2PoundsSigned();
void WriteAccountBalance();
void nullsub_12();
void Int2StrWithCommas();
void Int2AsciiLessThan100Check();
void Int2AsciiSaveD0();
void UpdateCareerTeamPlayers();
void UpdatePlayerCareerStats();
void UpdatePlayerInjuries();
void UpdatePlayerGoalStats();
void InitInGameTeamStructure();
void SetPlayerNameAndFace();
void InitInGamePlayer();
void SetInGameTeamsPrimaryColors();
void IsSingleColorKitSimilar();
void ConvertTeamKitColorsWithFixedColors();
void ResolveTeamKitColorConflict();
void SetInGameTeamColors();
void ConvertTeamKitColors();
void SetTeamSecondaryColors();
void ConvertTeamColor();
void MeasureTeamKitsSimilarity();
void GetTeamKitsSimilarityFactor();
void AreBasicColorsConflicting();
void AreShortsAndStripeColorsConflicting();
void ProcessPostGameStats();
void ApplyTeamTactics();
void AdjustPlayerSkills();
void GetPlayerPricePercentageChange();
void ScaleSkill();
void cseg_31A2B();
void cseg_31B94();
void cseg_31C4C();
void cseg_31CFE();
void LoadSomeEuroCup();
void cseg_31F58();
void cseg_31F79();
void cseg_32024();
void cseg_320A3();
void cseg_32128();
void cseg_323DE();
void cseg_324F2();
void cseg_3252E();
void cseg_327E0();
void cseg_3283C();
void LoadTeamFile();
void SetLoadedTeamsGlobalNumbers();
void SetLeagueNumbers();
void FatalError();
void cseg_32E15();
void LoadCareerFile();
void SaveCareerFile();
void j_LoadCareerFile();
void j_SaveCareerFile();
void LoadPresetFile();
void SavePresetCompetitionFile();
void LoadDIYFile();
void SaveDIYFile();
void SetTeamGlobalNumbers();
void ProcessCareerFile();
void cseg_33A1A();
void cseg_33E38();
void StatsHighestScorerList();
void CompetitionInfo();
void StatsViewSquads();
void StatsExit();
void NullMenuInit();
void CareerMenuInit();
void CareerMenuFinish();
void SetPlayerCoachFieldColor();
void ChooseTeamAndStartCareer();
void LoadLiverpool();
void ChangeSex();
void CheckSex();
void SetName();
void SetSurname();
void CoachOrPlayerCoach();
void j_SetExitMenuFlag2();
void ContestMenuInit();
void ContestMenuOnReturn();
void PlayMatchMenu();
void NextMatch();
void ViewCompetitionsMenu();
void SquadMenu();
void ClubBussinesMenu();
void JobOffersMenu();
void SeasonFinished();
void TransfersMenu();
void ViewWorldMenu();
void jmp_SetExitMenuFlag();
void ContestMenuScrollUp();
void cseg_34C08();
void ContestMenuScrollDown();
void cseg_34CCA();
void cseg_34D5A();
void cseg_34DA3();
void CheckClubBusiness();
void CheckJobOffers();
void cseg_350AE();
void ContestSetButtons();
void SeasonLowerButtons();
void CheckTransfers();
void cseg_3563E();
void PrintNameAndSeason();
void nullsub_15();
void SetNationalSelectorButtons();
void CareerGameListCommon();
void CareerOverInit();
void CareerOverFinish();
void CareerOverUpdateJobOffersEntry();
void ViewCompetitionsMenuRetired();
void JobOffersMenuRetired();
void ContinueCareer();
void SaveCareer();
void ExitCareerMenu();
void SelectTeamToManage();
void cseg_375C2();
void cseg_3760C();
void cseg_37B44();
void cseg_37B50();
void cseg_37B5C();
void cseg_37B68();
void cseg_37B74();
void TopGoalScorersMenu();
void ManagementRecordMenu();
void jmp_SetExitMenuFlag_2();
void ShowRetirementMessage();
void ManagementRecordInit();
void jmp_SetExitMenuFlag_3();
void ManagementArrowUpSelect();
void ManagementArrowDownSelect();
void FillManagementRecordInfo();
void cseg_3892C();
void SetTrophySprites();
void SetTrophySprite();
void SetNationalityField();
void ChangeNationality();
void GetCurrentSeasonPointer();
void cseg_3934F();
void cseg_39392();
void nullsub_33();
void cseg_39916();
void GetNumberOfSubstitutes();
void cseg_39E7E();
void GetNumberOfAvailablePlayers();
void cseg_3A110();
void cseg_3A2CE();
void IsPlayerInjured();
void cseg_3AA17();
void cseg_3ABB2();
void cseg_3ACAB();
void cseg_3ADAE();
void cseg_3AE87();
void cseg_3B122();
void cseg_3B18F();
void cseg_3B4F7();
void cseg_3B56F();
void cseg_3B7F8();
void cseg_3B842();
void cseg_3B860();
void FindTeamInDIY();
void GetMoreExpensiveTeamsCountWrapper();
void EndlessLoop();
void CareerPlayMatch();
void cseg_3BEA0();
void cseg_3C07C();
void cseg_3C09F();
void ShowChairmanOpinionAboutTheSeason();
void GetAveragePlayerPriceInSelectedTeams();
void cseg_3C4CE();
void cseg_3CB05();
void cseg_3CB08();
void cseg_3CBFE();
void cseg_3CCF0();
void cseg_3D18C();
void cseg_3D1C8();
void cseg_3D204();
void cseg_3D597();
void cseg_3D5A7();
void cseg_3D5E1();
void cseg_3D6A2();
void cseg_3D6D8();
void cseg_3D7CB();
void cseg_3DCC8();
void cseg_3DFCB();
void cseg_3DFEE();
void IsTeamNational();
void cseg_3E04F();
void ShowSeasonOpinion();
void cseg_3E11C();
void cseg_3E26B();
void cseg_3E3B0();
void cseg_3E55C();
void cseg_3E608();
void cseg_3E642();
void cseg_3E67C();
void cseg_3E69D();
void cseg_3E6BE();
void ChooseTeamsFriendlyInit();
void SetTeamEntriesStringsAndColors();
void ChangeTeams();
void AbortChooseTeamsFriendly();
void ChooseTeamsFriendlyOnSelect76();
void ChooseTeamsFriendlyCommon();
void cseg_3F011();
void SetChooseChangeTeamsEntries();
void nullsub_6();
void ViewSelTeamsSetColumns();
void DeselectAllTeams();
void ShowPlayMatchMenu();
void PlayMatchMenuInit();
void PlayMatchMenuReinit();
void SetCurrentSelectedPlayerIndexPointer();
void OnSwapPlayer();
void PlayMatchMenuSwapPlayers();
void cseg_3FEC4();
void out_0();
void ReturnFalseCode();
void PlayMatchChangeTactics();
void ExitPlayMatch();
void EditTacticsInPlayMatchMenu();
void ViewOpponentsSelect();
void ReturnFromViewOpponent();
void PlayMatchOnSelect30();
void PlayMatch30AfterDraw();
void UpdateTeamCheckmark();
void SetGameStartButtonText();
void ShowOrHidePlayMatchButton();
void SetUpTacticsButtons();
void SetPlayerSurnamesOnSidePitch();
void SetVariableButtons();
void DrawPlayerEntries();
void RedrawPlayerNames();
void UpdateLittleCheckmark();
void SavePositionsAndUpdateLittleCheckmark();
void UpdateCheckMarkSprite();
void UseMatchTeamSelect();
void TogglePlayerCoach();
void ShowUseMatchTeamIfTraining();
void DesignDIYTournamentInit();
void DesignDIYTournamentReinit();
void cseg_42CF0();
void cseg_42D98();
void DesignDIYTournamentOK();
void DesignDIYTournamentOnSelect91();
void DesignDIYTournamentOnSelect2();
void DesignDIYTournamentOnSelect89();
void cseg_42F6F();
void DesignDIYTournamentOnSelect3();
void DesignDIYTournamentOnSelect4();
void DesignDIYTournamentOnSelect5();
void DesignDIYTournamentOnSelect7();
void DesignDIYTournamentOnSelect9();
void DesignDIYTournamentOnSelect11();
void DesignDIYTournamentOnSelect13();
void DesignDIYTournamentOnSelect21();
void DesignDIYTournamentOnSelect23();
void DesignDIYTournamentOnSelect24();
void DesignDIYTournamentOnSelect25();
void DesignDIYTournamentOnSelect26();
void DesignDIYTournamentOnSelect28();
void cseg_433DE();
void cseg_4346F();
void DesignDIYTournamentOnDraw();
void cseg_43EC2();
void cseg_43F3E();
void cseg_443C7();
void cseg_44459();
void DesignDIYTournamentOnSelect20();
void cseg_445A7();
void cseg_4477D();
void ShowDesignDIYTournamentMenu();
void ShowTournamentInfo();
void cseg_44C68();
void DesignDIYCupInit();
void DesignDIYCupReinit();
void cseg_44F40();
void cseg_44FE8();
void DesignDIYCupOK();
void jmp_SetExitMenuFlag_4();
void DesignDIYCupOnSelect2();
void DesignDIYCupOnSelect48();
void cseg_451B5();
void DesignDIYCupOnSelect3();
void DesignDIYCupOnSelect4();
void DesignDIYCupOnSelect5();
void DesignDIYCupOnSelect7();
void DesignDIYCupOnSelect9();
void DesignDIYCupOnSelect11();
void cseg_4549A();
void DesignDIYCupOnSelect13();
void DesignDIYCupOnSelect15();
void DesignDIYCupOnSelect20();
void DesignDIYCupOnSelect21();
void DesignDIYCupOnSelect22();
void cseg_456C9();
void cseg_4572C();
void DesignDIYCupOnDraw();
void ShowDesignDIYCupMenu();
void ShowCupInfo();
void cseg_45B51();
void DIYCupInit();
void DIYCupFinish();
void jmp_SetExitMenuFlag_5();
void cseg_45D00();
void cseg_45D92();
void DIYCupOnSelect10();
void DIYCupOnSelect9();
void DIYCupOnSelect16();
void DIYCupOnSelect17();
void DIYCupOnSelect1();
void cseg_46269();
void cseg_462F7();
void cseg_463D9();
void cseg_463E6();
void cseg_46515();
void cseg_46589();
void cseg_46DAE();
void cseg_46DCD();
void cseg_46DDB();
void cseg_46E4D();
void cseg_46E9B();
void DIYCupOnSelect3();
void DIYCupOnSelect4();
void DIYCupOnSelect5();
void DIYCupOnSelect6();
void DIYCupOnSelect7();
void DIYCupOnSelect8();
void DIYCupOnSelectCommon();
void cseg_4766F();
void DesignDIYLeagueInit();
void DesignDIYLeagueFinish();
void cseg_47981();
void DIYLeagueSetVariousFields();
void DIYLeagueOKSelected();
void DesignDIYLeagueOK();
void jmp_SetExitMenuFlag_6();
void DesignDIYLeagueSetName();
void DesignDIYLeagueChooseTeams();
void DIYSetMonthsOrPitchTypeEntries();
void DIYLeagueChangePitchTypeOrSeason();
void DesignDIYLeagueChangePitchType();
void DesignDIYLeagueChangeStartMonth();
void DesignDIYLeagueChangeEndMonth();
void DesignDIYLeagueChangeNumberOfTeams();
void DesignDIYLeagueChangePlayEachTeam();
void SetPlayEachTeamString();
void DesignDIYLeagueChangeNumPointsForWin();
void ConvertMinMaxSubstitutesNumbers();
void DesignDIYLeagueChangeMinSubstitutes();
void DesignDIYLeagueChangeMaxSubstitutes();
void SetNumberOfTeamsToSelect();
void ShowDesignDIYLeagueMenu();
void ShowLeagueInfo();
void ShowDiyLeaguesTournamentMenu();
void DIYLeagueTournamentInit();
void DIYLeagueTournamentOnRestore();
void jmp_SetExitMenuFlag_7();
void DIYLeagueTournamentStats();
void DIYLeagueTournamentExit();
void cseg_48CA1();
void DIYLeagueTournamentMatch();
void DIYLeagueTournamentOnSelect4();
void DIYLeagueTournamentResult();
void DIYLeagueTournamentViewMatch();
void DIYLeagueTournamentViewHighlights();
void DIYLeagueTournamentViewResult();
void DIYLeagueTournamentMatchCommon();
void DIYSetTeamNamesAndResults();
void DIYLeagueTournamentNextMatch();
void cseg_490E6();
void cseg_49181();
void cseg_49261();
void cseg_492AF();
void DIYLeagueTournament16BeforeDraw();
void DIYLeagueTournamentScrollUp();
void DIYLeagueTournamentScrollDown();
void nullsub_14();
void cseg_49EF4();
void cseg_49F01();
void GoGetTeamsForPlay();
void ChooseTeamsInit();
void ClubTeams();
void NationalTeams();
void OriginalCustomTeams();
void EditedCustomTeams();
void ExitChooseTeams();
void SelectTeamsInit();
void SelectTeamsReinit();
void SetLeagueNames();
void SetCountryNames();
void ViewSelectedTeams();
void ChooseTeamsPlayGame();
void ExitSelectTeams();
void SelectTeamsCommon();
void SelectLeaguesCommon();
void SetTeamsCoordinates();
void CheckNumberOfTeams();
void SelectTeamsFinalMenu();
void GetCountryName();
void PushContinent();
void PopContinent();
void SetSelectedTeamsStackTop();
void PushLastSelectedTeam();
void GetSelectedTeamsStackTop();
void MarkSelectedTeamsStackLocation();
void IsContestContinentalCup();
void cseg_4C599();
void cseg_4C5BD();
void ChooseCompetitionMenu();
void SelectTeamsForPresetCompetition();
void cseg_4C6EE();
void ChooseTeamsDialog();

// =============== S U B R O U T I N E =======================================
//
void cseg_2C3CC()
{
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    A0 = 2148;                              // mov A0, offset cseg_2C43D
    {
        word res = *(word *)&D0 & 63;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 3Fh
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    {
        word res = *(word *)&D6 & 128;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D6, 80h
    if (flags.zero)
        goto cseg_2C416;                    // jz short cseg_2C416

    {
        *(byte *)&D5 = ((byte)*(byte *)&D5 >> 4) | (*(byte *)&D5 << 4);
    }                                       // ror byte ptr D5, 4

cseg_2C416:;
    al = D5;                                // mov al, byte ptr D5
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    {
        byte res = *(byte *)&D5 >> 4;
        *(byte *)&D5 = res;
    }                                       // shr byte ptr D5, 4
    al = D5;                                // mov al, byte ptr D5
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    {
        word res = *(word *)&D6 & 15;
        *(word *)&D6 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D6, 0Fh
}

// =============== S U B R O U T I N E =======================================

// in:
//     A0 -> team (file)
//     D5 -  number of players
//
void cseg_2C47D()
{
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, 1
    if (flags.sign)
        return;                             // js @@out

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.playerNumbers
    A5 = eax;                               // mov A5, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto cseg_2C4AE;                    // jnz short cseg_2C4AE

    A5 = 92766;                             // mov A5, offset currentMatchPlayers

cseg_2C4AE:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A1 = 372768;                            // mov A1, offset g_tacticsTable
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 369, 1);    // mov al, [esi+Tactics.ballOutOfPlayTactics]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    A1 = 331628;                            // mov A1, offset positionsTable
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A1 = eax;                               // mov A1, eax
    A4 = 456010;                            // mov A4, offset dseg_16878C
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    *(dword *)&g_memByte[456226] = eax;     // mov dseg_168864, eax

l_players_loop:;
    eax = *(dword *)&g_memByte[456226];     // mov eax, dseg_168864
    A4 = eax;                               // mov A4, eax
    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 248;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 248
    if (!flags.carry)
        goto cseg_2C881;                    // jnb cseg_2C881

    {
        word res = *(word *)&D0 & 127;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7Fh
    *(word *)&D6 = 10;                      // mov word ptr D6, 10
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2C7AC;                    // jb cseg_2C7AC

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2C7AC;                    // jb cseg_2C7AC

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2C7AC;                    // jb cseg_2C7AC

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2C7AC;                    // jb cseg_2C7AC

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2C7AC;                    // jb cseg_2C7AC

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2C7AC;                    // jb cseg_2C7AC

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2C7AC;                    // jb cseg_2C7AC

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2C7AC;                    // jb cseg_2C7AC

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2C7AC;                    // jb cseg_2C7AC

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2C7AC;                    // jb short cseg_2C7AC

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 127;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7Fh
    *(word *)&D6 = 1;                       // mov word ptr D6, 1
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2C7AC;                    // jb short cseg_2C7AC

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1

cseg_2C7AC:;
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        *(byte *)&D6 = res;
    }                                       // sub byte ptr D6, 1
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_2C817;                    // js short cseg_2C817

    SWOS::Rand2();                          // call Rand2
    {
        dword res = D0 & 1;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D0, 1
    if (!flags.zero)
        goto cseg_2C817;                    // jnz short cseg_2C817

    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al

cseg_2C817:;
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    {
        byte src = (byte)readMemory(esi + ebx, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + ebx, 1, src);
    }                                       // add byte ptr [esi+ebx], 1
    ax = D6;                                // mov ax, word ptr D6
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)((byte *)&D6 + 2) = dx;        // mov word ptr D6+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A4 = eax;                               // mov A4, eax
    ax = *(word *)&g_memByte[379622];       // mov ax, dseg_11F8CE
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A4;                               // mov esi, A4
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        byte src = (byte)readMemory(esi + ebx + 109, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        src = res;
        writeMemory(esi + ebx + 109, 1, src);
    }                                       // add byte ptr [esi+ebx+6Dh], 1

l_next_player:;
    (*(int16_t *)&D5)--;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto l_players_loop;                // jns @@players_loop

    return;                                 // retn

cseg_2C881:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 22, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 1, src);
    }                                       // add [esi+TeamFile.writesZeroHere], 1
    goto l_next_player;                     // jmp short @@next_player
}

// =============== S U B R O U T I N E =======================================

// in:
//     A0 -> team (file)
// out:
//     D1 -
//     D2 -
//
// Might be returning some x, y offsets.. but for what
//
void cseg_2C88E()
{
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 2, 1);      // mov al, byte ptr [esi+TeamFile.globalTeamNumber]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = *(word *)&g_memByte[91330];        // mov ax, currentSeasonShowing
    *(byte *)&D0 ^= al;                     // xor byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    A1 = 379922;                            // mov A1, offset kRandomTable
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = g_memByte[129466];                 // mov al, dseg_E0048
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, al
    {
        word res = *(word *)&D0 & 127;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7Fh
    A1 = 2212;                              // mov A1, offset cseg_2C959
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 7;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 7
    {
        word res = *(word *)&D2 & 127;
        *(word *)&D2 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D2, 7Fh
    eax = *(word *)&D2;                     // movzx eax, word ptr D2
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team
//      A1 -
//
void cseg_2C9D9()
{
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        return;                             // jz @@out

    *(word *)&D0 = -1;                      // mov word ptr D0, -1
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    push(A1);                               // push A1
    GetNumberOfAvailablePlayers();          // call GetNumberOfAvailablePlayers
    pop(A1);                                // pop A1
    *(word *)&D5 = 4;                       // mov word ptr D5, 4
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (flags.zero)
        goto l_game_career;                 // jz short @@game_career

    *(word *)&D5 = 2;                       // mov word ptr D5, 2

l_game_career:;
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, ax
    if (flags.zero || flags.sign != flags.overflow)
        return;                             // jle @@out

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 60
    A5 = eax;                               // mov A5, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto l_not_a_career;                // jnz short @@not_a_career

    A5 = 92766;                             // mov A5, offset currentMatchPlayers
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, 0
    if (!flags.zero)
        goto l_not_a_career;                // jnz short @@not_a_career

    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1
    goto cseg_2CA86;                        // jmp short cseg_2CA86

l_not_a_career:;
    *(word *)&D7 = 10;                      // mov word ptr D7, 10

cseg_2CA86:;
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    SWOS::Rand2();                          // call Rand2
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, 0
    if (flags.zero)
        goto cseg_2CAEB;                    // jz short cseg_2CAEB

    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_2CAEB;                    // js short cseg_2CAEB

    {
        dword res = D0 & 1;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D0, 1
    if (!flags.zero)
        goto cseg_2CAEB;                    // jnz short cseg_2CAEB

    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al

cseg_2CAEB:;
    ax = D6;                                // mov ax, word ptr D6
    bx = 38;                                // mov bx, 38
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A6 = eax;                               // mov A6, eax
    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2CB3D;                    // jnz short cseg_2CB3D

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (!flags.carry)
        goto cseg_2CDB8;                    // jnb cseg_2CDB8

cseg_2CB3D:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 224;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0E0h
    {
        word res = *(word *)&D1 >> 5;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 5
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, 0
    if (!flags.zero)
        goto cseg_2CBBB;                    // jnz short cseg_2CBBB

    push(D0);                               // push D0
    push(D7);                               // push D7
    push(A1);                               // push A1
    *(word *)&D0 = 65535;                   // mov word ptr D0, 0FFFFh
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    push(D5);                               // push D5
    cseg_3A110();                           // call cseg_3A110
    pop(D5);                                // pop D5
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    pop(D0);                                // pop D0
    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2CDB8;                    // jnz cseg_2CDB8

cseg_2CBBB:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 224;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0E0h
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0
    if (flags.zero)
        goto cseg_2CBFA;                    // jz short cseg_2CBFA

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 20h
    if (!flags.zero)
        goto cseg_2CDB8;                    // jnz cseg_2CDB8

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 64;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 40h
    if (!flags.carry)
        goto cseg_2CDB8;                    // jnb cseg_2CDB8

    goto cseg_2CC08;                        // jmp short cseg_2CC08

cseg_2CBFA:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 5
    if (!flags.carry)
        goto cseg_2CDB8;                    // jnb cseg_2CDB8

cseg_2CC08:;
    A2 = 486736;                            // mov A2, offset dseg_1728A0
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 63;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 3Fh
    *(word *)&D1 = 32;                      // mov word ptr D1, 32
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2CD73;                    // jb cseg_2CD73

    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 20h
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2CD73;                    // jb cseg_2CD73

    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 20h
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2CD73;                    // jb cseg_2CD73

    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 20h
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2CD73;                    // jb cseg_2CD73

    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 20h
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2CD73;                    // jb short cseg_2CD73

    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 20h
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2CD73;                    // jb short cseg_2CD73

    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 20h
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_2CD73;                    // jb short cseg_2CD73

    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 20h

cseg_2CD73:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 65311;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FF1Fh
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 103, 1, al);          // mov [esi+67h], al
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, 1
    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

cseg_2CDB8:;
    (*(int16_t *)&D7)--;
    flags.overflow = (int16_t)(*(int16_t *)&D7) == INT16_MIN;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_2CA86;                    // jns cseg_2CA86
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team (file)
//
void cseg_2CDC6()
{
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        return;                             // jz @@out

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto l_not_a_career_team;           // jnz @@not_a_career_team

    A5 = 92766;                             // mov A5, offset currentMatchPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_2CE04:;
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 224;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0E0h
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0
    if (flags.zero)
        goto cseg_2CE79;                    // jz short cseg_2CE79

    cseg_2CED3();                           // call cseg_2CED3

cseg_2CE79:;
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_2CE04;                    // jns short cseg_2CE04

l_out:;
    return;                                 // retn

l_not_a_career_team:;
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    *(word *)&D7 = 15;                      // mov word ptr D7, 15

l_players_loop:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 224;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0E0h
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0
    if (flags.zero)
        goto l_next_player;                 // jz short @@next_player

    cseg_2CED3();                           // call cseg_2CED3

l_next_player:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 38;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 38
    A1 = eax;                               // mov A1, eax
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_players_loop;                // jns short @@players_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      D1 -
//      A1 -> team (file)
//
void cseg_2CED3()
{
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 20h
    if (flags.zero)
        goto cseg_2CF2D;                    // jz short cseg_2CF2D

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 192;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0C0h
    if (flags.zero)
        goto cseg_2CF4D;                    // jz short cseg_2CF4D

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 224;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0E0h
    if (flags.zero)
        return;                             // jz @@out

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 20h
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 20h
    if (!flags.zero)
        goto cseg_2CFA2;                    // jnz cseg_2CFA2

    SWOS::Rand2();                          // call Rand2
    {
        dword res = D0 & 1;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D0, 1
    if (!flags.zero)
        goto cseg_2CFA2;                    // jnz cseg_2CFA2

    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    goto cseg_2CFA2;                        // jmp short cseg_2CFA2

cseg_2CF2D:;
    SWOS::Rand2();                          // call Rand2
    {
        dword res = D0 & 1;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test D0, 1
    if (!flags.zero)
        return;                             // jnz @@out

    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    goto cseg_2CFA2;                        // jmp short cseg_2CFA2

cseg_2CF4D:;
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 7
    if (!flags.zero)
        return;                             // jnz short @@out

    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 5;                                 // mov bx, 5
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 << 5;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 5
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 20h

cseg_2CFA2:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        word res = *(word *)&D2 & 65311;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 0FF1Fh
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D2 |= ax;
    flags.carry = false;
    flags.sign = (*(word *)&D2 & 0x8000) != 0;
    flags.zero = *(word *)&D2 == 0;         // or word ptr D2, ax
    al = D2;                                // mov al, byte ptr D2
    writeMemory(esi + 103, 1, al);          // mov [esi+(PlayerFile.cardsInjuries+4Ch)], al
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2CFD5()
{
    D7 = 0;                                 // mov D7, 0
    D0 = -1;                                // mov D0, 0FFFFFFFFh
    eax = A2;                               // mov eax, A2
    A1 = eax;                               // mov A1, eax
    eax = D0;                               // mov eax, D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 3Ch
    A4 = eax;                               // mov A4, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto cseg_2D0B6;                    // jnz short cseg_2D0B6

    A4 = 92766;                             // mov A4, offset currentMatchPlayers

cseg_2D0B6:;
    A3 = 2340;                              // mov A3, offset cseg_2D443
    ax = *(word *)&g_memByte[379624];       // mov ax, dseg_11F8D0
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 3;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 3
    eax = A3;                               // mov eax, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A3 = eax;                               // mov A3, eax
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_2D436;                    // jz cseg_2D436

    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    A3 = 2452;                              // mov A3, offset cseg_2D4B3
    ax = *(word *)&g_memByte[379626];       // mov ax, dseg_11F8D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        word res = *(word *)&D0 << 5;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 5
    eax = A3;                               // mov eax, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A3 = eax;                               // mov A3, eax
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 24;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 18h
    eax = A3;                               // mov eax, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A3 = eax;                               // mov A3, eax
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 1

cseg_2D188:;
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A3)++;                    // inc A3
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        return;                             // jz cseg_2D435

    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A4;                               // mov esi, A4
    eax = *(word *)&D2;                     // movzx eax, word ptr D2
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0E0h
    if (!flags.zero)
        goto cseg_2D188;                    // jnz cseg_2D188

    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 28;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1Ch
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 8
    if (!flags.carry)
        goto cseg_2D188;                    // jnb cseg_2D188

    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 224;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0E0h
    {
        word res = *(word *)&D1 >> 5;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 5
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, 0
    if (!flags.zero)
        goto cseg_2D27A;                    // jnz short cseg_2D27A

    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (!flags.carry)
        goto cseg_2D188;                    // jnb cseg_2D188

cseg_2D27A:;
    A1 = 2388;                              // mov A1, offset cseg_2D473
    al = D1;                                // mov al, byte ptr D1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 << 3;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 3
    eax = A1;                               // mov eax, A1
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 << 2;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 2
    A1 = 378446;                            // mov A1, offset playersPositionsByTactics
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    esi = A2;                               // mov esi, A2
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_2D3F6;                    // js cseg_2D3F6

    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+18h]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 << 2;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 2
    A1 = 378446;                            // mov A1, offset playersPositionsByTactics
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    esi = A2;                               // mov esi, A2
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_2D3F6;                    // js short cseg_2D3F6

    goto cseg_2D428;                        // jmp short cseg_2D428

cseg_2D3F6:;
    bl = D2;                                // mov bl, byte ptr D2
    esi = A2;                               // mov esi, A2
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    writeMemory(esi + eax, 1, bl);          // mov [esi+eax], bl
    cx = D2;                                // mov cx, word ptr D2
    eax = 1;                                // mov eax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            dword res = eax << shiftCount;
            eax = res;
        }
    }                                       // shl eax, cl
    D7 |= eax;                              // or D7, eax
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1

cseg_2D428:;
    (*(int16_t *)&D4)--;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto cseg_2D188;                    // jns cseg_2D188

cseg_2D435:;
    return;                                 // retn

cseg_2D436:;
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2D553()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    *(word *)&g_memByte[91666] = 1;         // mov dseg_D6CA0, 1
    *(word *)&g_memByte[92298] = 2;         // mov timeToNegotiate, 2
    *(word *)&g_memByte[92312] = 65535;     // mov dseg_D6F26, 0FFFFh
    *(word *)&g_memByte[92320] = 0;         // mov dseg_D6F2E, 0
    cseg_5E2E0();                           // call cseg_5E2E0
    *(word *)&g_memByte[91398] = 1;         // mov dseg_D6B94, 1
    cseg_3C4CE();                           // call cseg_3C4CE
    cseg_5A8DE();                           // call cseg_5A8DE
    cseg_5C3CB();                           // call cseg_5C3CB
    cseg_5B705();                           // call cseg_5B705
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_2D64E()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_2CDC6();                           // call cseg_2CDC6
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_2CDC6();                           // call cseg_2CDC6
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[318702];       // mov ax, dseg_10EEE4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_2D7B7();                           // call cseg_2D7B7
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[318702];       // mov ax, dseg_10EEE4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_2D7B7();                           // call cseg_2D7B7
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team (file)
//
void cseg_2D7B7()
{
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        return;                             // jz @@out

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (flags.zero)
        goto l_career_team;                 // jz short @@career_team

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 60
    A5 = eax;                               // mov A5, eax
    *(word *)&D7 = 15;                      // mov word ptr D7, 15
    goto l_players_loop;                    // jmp short @@players_loop

l_career_team:;
    A5 = 92766;                             // mov A5, offset currentMatchPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

l_players_loop:;
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 38
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2D91B;                    // jnz cseg_2D91B

    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 28;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 1Ch
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0
    if (flags.zero)
        goto l_next_player;                 // jz @@next_player

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 8
    if (flags.zero)
        goto cseg_2D8DF;                    // jz short cseg_2D8DF

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 12;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0Ch
    if (flags.zero)
        goto cseg_2D8D4;                    // jz short cseg_2D8D4

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 10h
    if (flags.zero)
        goto cseg_2D8C9;                    // jz short cseg_2D8C9

    goto l_next_player;                     // jmp @@next_player

cseg_2D8C9:;
    *(word *)&D1 = 12;                      // mov word ptr D1, 0Ch
    goto cseg_2D8E8;                        // jmp short cseg_2D8E8

cseg_2D8D4:;
    *(word *)&D1 = 8;                       // mov word ptr D1, 8
    goto cseg_2D8E8;                        // jmp short cseg_2D8E8

cseg_2D8DF:;
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

cseg_2D8E8:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 65507;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFE3h
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // or word ptr D0, ax
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 103, 1, al);          // mov [esi+67h], al
    goto l_next_player;                     // jmp short @@next_player

cseg_2D91B:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 3;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 3
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0
    if (flags.zero)
        goto l_next_player;                 // jz short @@next_player

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 2
    if (flags.zero)
        goto cseg_2D950;                    // jz short cseg_2D950

    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    goto cseg_2D959;                        // jmp short cseg_2D959

cseg_2D950:;
    *(word *)&D1 = 1;                       // mov word ptr D1, 1

cseg_2D959:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 65532;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFFCh
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;
    flags.carry = false;                    // or word ptr D0, ax
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 103, 1, al);          // mov [esi+67h], al

l_next_player:;
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_players_loop;                // jns @@players_loop
}

// =============== S U B R O U T I N E =======================================
//
void SaveSelectedTeams()
{
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[200160];     // mov eax, dosMemOfs60c00h
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    D0 = 21888;                             // mov D0, 21888

l_copy_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 2;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D0 = res;
    }                                       // sub D0, 2
    if (!flags.zero)
        goto l_copy_loop;                   // jnz short @@copy_loop

    *(word *)&g_memByte[131757] = 0;        // mov g_numSelectedTeams, 0
}

// =============== S U B R O U T I N E =======================================
//
void RestoreSelectedTeams()
{
    {
        word src = *(word *)&g_memByte[131757];
        int16_t dstSigned = src;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_numSelectedTeams, 32
    eax = *(dword *)&g_memByte[200160];     // mov eax, dosMemOfs60c00h
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A1 = eax;                               // mov A1, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&g_memByte[131757] = ax;       // mov g_numSelectedTeams, ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    D0 = 21888;                             // mov D0, 21888

l_copy_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 2;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D0 = res;
    }                                       // sub D0, 2
    if (!flags.zero)
        goto l_copy_loop;                   // jnz short @@copy_loop
}

// =============== S U B R O U T I N E =======================================

// Save Rand state, but in process overwrite big_S_Sprite team number.
// That field isn't used so not sure if it's accidental or not.
//
void SaveRand2State()
{
    push(A0);                               // push A0
    eax = *(dword *)&g_memByte[325959];     // mov eax, savedRandStatePtr
    A0 = eax;                               // mov A0, eax
    al = g_memByte[131714];                 // mov al, seed2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    al = g_memByte[131715];                 // mov al, randXorIndex2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    al = g_memByte[131716];                 // mov al, randXorKey2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[325959] = eax;     // mov savedRandStatePtr, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 379922;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset kRandomTable
    pop(A0);                                // pop A0
}

// =============== S U B R O U T I N E =======================================
//
void RestoreRand2State()
{
    push(A0);                               // push A0
    eax = *(dword *)&g_memByte[325959];     // mov eax, savedRandStatePtr
    A0 = eax;                               // mov A0, eax
    (*(int32_t *)&A0)--;                    // dec A0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    g_memByte[131716] = al;                 // mov randXorKey2, al
    (*(int32_t *)&A0)--;                    // dec A0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    g_memByte[131715] = al;                 // mov randXorIndex2, al
    (*(int32_t *)&A0)--;
    flags.sign = (*(int32_t *)&A0 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A0 == 0;      // dec A0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    g_memByte[131714] = al;                 // mov seed2, al
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[325959] = eax;     // mov savedRandStatePtr, eax
    pop(A0);                                // pop A0
}

// $no-break{

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> buffer to get bank balance
//
void GetBankBalance()
{
    A0 = 18944;                             // mov A0, offset aBank
    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;                    // inc A1
    eax = *(dword *)&g_memByte[91354];      // mov eax, newBalance
    D0 = eax;                               // mov D0, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    Int2PoundsSigned();                     // jmp short Int2PoundsSigned
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - pounds quantity
//      A1 -> buffer for string
//
// Accepts only positive values.
//
void Int2Pounds()
{
    nullsub_12();                           // call nullsub_12
    A0 = 9322;                              // mov A0, offset pound
    StringCopy();                           // call StringCopy
    Int2StrWithCommas();                    // call Int2StrWithCommas
    A0 = 9324;                              // mov A0, offset nullString_0
    StringCopy();                           // jmp StringCopy
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - pounds quantity
//      A1 -> buffer for string
//
// Accepts both positive and negative values.
//
void Int2PoundsSigned()
{
    eax = D0;                               // mov eax, D0
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.sign)
        { Int2Pounds(); return; }           // jns short Int2Pounds

    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, '-');               // mov byte ptr [esi], '-'
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;                    // inc A1
    flags.carry = *(int32_t *)&D0 != 0;
    *(int32_t *)&D0 = -*(int32_t *)&D0;
    flags.sign = (*(int32_t *)&D0 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&D0 == 0;      // neg D0
    Int2Pounds();                           // jmp short Int2Pounds
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - account state
//      A1 -> output buffer
//
void WriteAccountBalance()
{
    eax = D0;                               // mov eax, D0
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.sign)
        goto l_negative;                    // js short @@negative

    if (flags.zero)
        { Int2Pounds(); return; }           // jz short Int2Pounds

    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, '+');               // mov byte ptr [esi], '+'
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    { Int2Pounds(); return; }               // jmp Int2Pounds

l_negative:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, '-');               // mov byte ptr [esi], '-'
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;                    // inc A1
    flags.carry = *(int32_t *)&D0 != 0;
    *(int32_t *)&D0 = -*(int32_t *)&D0;
    flags.sign = (*(int32_t *)&D0 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&D0 == 0;      // neg D0
    Int2Pounds();                           // jmp Int2Pounds
}

// $no-break}

// =============== S U B R O U T I N E =======================================
//
void nullsub_12()
{
}

// =============== S U B R O U T I N E =======================================
//
void Int2StrWithCommas()
{
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 1000;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 1000
    if (flags.carry)
        { Int2AsciiSaveD0(); return; }      // jb Int2AsciiSaveD0

    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 1000000;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D0, 1000000
    if (flags.carry)
        goto l_less_than_million;           // jb @@less_than_million

    eax = D0;                               // mov eax, D0
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        { Int2AsciiSaveD0(); return; }      // jz Int2AsciiSaveD0

    D1 = eax;                               // mov D1, eax
    {
        dword res = D0 >> 4;
        D0 = res;
    }                                       // shr D0, 4
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 62500;                             // mov bx, 62500
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    Int2AsciiSaveD0();                      // call Int2AsciiSaveD0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ',');               // mov byte ptr [esi], ','
    (*(int32_t *)&A1)++;                    // inc A1
    ax = D0;                                // mov ax, word ptr D0
    bx = 62500;                             // mov bx, 62500
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        dword res = D0 << 4;
        D0 = res;
    }                                       // shl D0, 4
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    eax = D1;                               // mov eax, D1
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 1000;                              // mov bx, 1000
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    Int2AsciiLessThan100Check();            // call Int2AsciiLessThan100Check
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ',');               // mov byte ptr [esi], ','
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    ax = D0;                                // mov ax, word ptr D0
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    { Int2AsciiLessThan100Check(); return; } // jmp short Int2AsciiLessThan100Check

l_less_than_million:;
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 1000;                              // mov bx, 1000
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    Int2AsciiSaveD0();                      // call Int2AsciiSaveD0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ',');               // mov byte ptr [esi], ','
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    ax = D0;                                // mov ax, word ptr D0
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

    Int2AsciiLessThan100Check();
}

// =============== S U B R O U T I N E =======================================
//
void Int2AsciiLessThan100Check()
{
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 100
    if (!flags.carry)
        { Int2AsciiSaveD0(); return; }      // jnb short Int2AsciiSaveD0

    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, '0');               // mov byte ptr [esi], '0'
    (*(int32_t *)&A1)++;                    // inc A1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 10
    if (!flags.carry)
        { Int2AsciiSaveD0(); return; }      // jnb short Int2AsciiSaveD0

    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, '0');               // mov byte ptr [esi], '0'
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1

    Int2AsciiSaveD0();
}

// =============== S U B R O U T I N E =======================================
//
void Int2AsciiSaveD0()
{
    push(D0);                               // push D0
    SWOS::Int2Ascii();                      // call Int2Ascii
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> team (game)
//      A2 -> team (file)
//
void UpdateCareerTeamPlayers()
{
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_2F193

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (!flags.zero)
        return;                             // jnz cseg_2F193

    *(word *)&D2 = 15;                      // mov word ptr D2, 0Fh

cseg_2F10A:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 42, 1);     // mov al, [esi+2Ah]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_2F179;                    // jnz short cseg_2F179

    {
        byte src = (byte)readMemory(esi + 78, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4Eh], 2
    if (!flags.zero)
        goto cseg_2F179;                    // jnz short cseg_2F179

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 43, 1);     // mov al, [esi+2Bh]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    push(A1);                               // push A1
    push(D2);                               // push D2
    cseg_64E3E();                           // call cseg_64E3E
    pop(D2);                                // pop D2
    pop(A1);                                // pop A1

cseg_2F179:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 61;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 3Dh
    A1 = eax;                               // mov A1, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_2F10A;                    // jns cseg_2F10A
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> team (game)
//      A2 -> team (file)
//
void UpdatePlayerCareerStats()
{
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        return;                             // jz @@out

    *(word *)&D2 = 15;                      // mov word ptr D2, 0Fh

cseg_2F1BC:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 42, 1);     // mov al, [esi+2Ah]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_2F2CF;                    // jnz cseg_2F2CF

    al = (byte)readMemory(esi + 52, 1);     // mov al, [esi+34h]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_2F2CF;                    // jz cseg_2F2CF

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 43, 1);     // mov al, [esi+2Bh]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 52, 1);     // mov al, [esi+34h]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    ax = *(word *)&g_memByte[449320];       // mov ax, plg_D3_param
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2F286;                    // jnz short cseg_2F286

    {
        byte res = *(byte *)&D1 << 2;
        *(byte *)&D1 = res;
    }                                       // shl byte ptr D1, 2
    {
        word res = *(word *)&D1 & 28;
        *(word *)&D1 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D1, 1Ch
    cseg_3E608();                           // call cseg_3E608
    if (!flags.zero)
        goto cseg_2F253;                    // jnz short cseg_2F253

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 4
    if (flags.zero)
        goto cseg_2F2CF;                    // jz cseg_2F2CF

    *(word *)&D1 = 8;                       // mov word ptr D1, 8

cseg_2F253:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 65507;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFE3h
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // or word ptr D0, ax
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 103, 1, al);          // mov [esi+67h], al
    goto cseg_2F2CF;                        // jmp short cseg_2F2CF

cseg_2F286:;
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, 1
    if (flags.zero)
        goto cseg_2F2CF;                    // jz short cseg_2F2CF

    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        *(byte *)&D1 = res;
    }                                       // sub byte ptr D1, 1
    {
        word res = *(word *)&D1 & 3;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 3
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 65532;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFFCh
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 103, 1, al);          // mov [esi+67h], al

cseg_2F2CF:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 61;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 3Dh
    A1 = eax;                               // mov A1, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_2F1BC;                    // jns cseg_2F1BC
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> team (game)
//      A2 -> team (file)
//
void UpdatePlayerInjuries()
{
    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        return;                             // jz @@out

    *(word *)&D2 = 15;                      // mov word ptr D2, 15

l_players_loop:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 42, 1);     // mov al, [esi+PlayerGameHeader.substituted]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_next_player;                 // jnz @@next_player

    al = (byte)readMemory(esi + 48, 1);     // mov al, [esi+PlayerGameHeader.isInjured]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_next_player;                 // jz short @@next_player

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 43, 1);     // mov al, [esi+PlayerGameHeader.playerIndex]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 77, 1);     // mov al, [esi+PlayerGameHeader.injuriesBitfield]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 65311;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FF1Fh
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 103, 1, al);          // mov [esi+(PlayerFile.cardsInjuries+4Ch)], al

l_next_player:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 61;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, size PlayerGame
    A1 = eax;                               // mov A1, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto l_players_loop;                // jns @@players_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      A1 -> team (game)
//      A2 -> team (file)
//      D7 -  some offset
//
void UpdatePlayerGoalStats()
{
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 40, 1);     // mov al, [esi+TeamGame.numOwnGoals]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 22, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 1, src);
    }                                       // add [esi+TeamFile.writesZeroHere], al
    *(word *)&D2 = 15;                      // mov word ptr D2, 15

l_loop:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 44, 1);     // mov al, [esi+PlayerGameHeader.goalsScored]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_next_player;                 // jz short @@next_player

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 43, 1);     // mov al, [esi+PlayerGameHeader.playerIndex]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayer();                            // call GetPlayer
    al = D3;                                // mov al, byte ptr D3
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    {
        byte src = (byte)readMemory(esi + ebx + 109, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + ebx + 109, 1, src);
    }                                       // add [esi+ebx+109], al

l_next_player:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 61;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, size PlayerGame
    A1 = eax;                               // mov A1, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto l_loop;                        // jns short @@loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      A2 -> this team (file)
//      A4 -> team (in game) - to fill
//      A6 -> selected teams average player price in percents
//            compared to this team average player price
//
void InitInGameTeamStructure()
{
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 20, 2, -1);           // mov [esi+TeamGame.markedPlayer], -1
    esi = A6;                               // mov esi, A6
    writeMemory(esi, 2, 100);               // mov word ptr [esi], 100
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (flags.zero)
        goto l_init_players_loop;           // jz @@init_players_loop

    ax = *(word *)&g_memByte[131706];       // mov ax, g_allPlayerTeamsEqual
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_init_players_loop;           // jz @@init_players_loop

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (!flags.zero)
        goto l_init_players_loop;           // jnz @@init_players_loop

    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    ax = *(word *)&g_memByte[455994];       // mov ax, averagePlayerPrice
    bx = 100;                               // mov bx, 100
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D0);
        word rem = (word)(dividend % *(word *)&D0);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 6;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 6
    ax = D2;                                // mov ax, word ptr D2
    esi = A6;                               // mov esi, A6
    writeMemory(esi, 2, ax);                // mov [esi], ax

l_init_players_loop:;
    eax = A4;                               // mov eax, A4
    A6 = eax;                               // mov A6, eax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 40, 1, 0);            // mov byte ptr [esi+TeamGeneralInfo.playerHasBall], 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0

l_players_loop:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_get_player;                  // jz short @@get_player

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset currentTeam
    if (!flags.zero)
        goto l_get_player;                  // jnz short @@get_player

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 13
    if (flags.carry)
        goto l_get_player;                  // jb short @@get_player

    *(word *)&D1 = 0;                       // mov word ptr D1, 0

l_get_player:;
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    push(D2);                               // push D2
    InitInGamePlayer();                     // call InitInGamePlayer
    pop(D2);                                // pop D2
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_get_player_by_ordinal;       // jz short @@get_player_by_ordinal

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset currentTeam
    if (!flags.zero)
        goto l_get_player_by_ordinal;       // jnz short @@get_player_by_ordinal

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 13
    if (flags.carry)
        goto l_get_player_by_ordinal;       // jb short @@get_player_by_ordinal

    *(word *)&D1 = 0;                       // mov word ptr D1, 0

l_get_player_by_ordinal:;
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    ax = *(word *)&g_memByte[378854];       // mov ax, team1SelectedPlayerIndex
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 332876;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, offset topTeamInGame
    if (flags.zero)
        goto cseg_2F682;                    // jz short cseg_2F682

    ax = *(word *)&g_memByte[378856];       // mov ax, team2SelectedPlayerIndex
    *(word *)&D3 = ax;                      // mov word ptr D3, ax

cseg_2F682:;
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (!flags.zero)
        goto cseg_2F6A1;                    // jnz short cseg_2F6A1

    ax = D0;                                // mov ax, word ptr D0
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 20, 2, ax);           // mov [esi+TeamGame.markedPlayer], ax

cseg_2F6A1:;
    ax = *(word *)&g_memByte[94092];        // mov ax, dseg_D761A
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (flags.zero)
        goto cseg_2F6D1;                    // jz short cseg_2F6D1

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset currentTeam
    if (!flags.zero)
        goto cseg_2F6F0;                    // jnz short cseg_2F6F0

    ax = *(word *)&g_memByte[99546];        // mov ax, dseg_D8B68
    *(word *)&D3 = ax;                      // mov word ptr D3, ax

cseg_2F6D1:;
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (!flags.zero)
        goto cseg_2F6F0;                    // jnz short cseg_2F6F0

    ax = D0;                                // mov ax, word ptr D0
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 20, 2, ax);           // mov [esi+TeamGame.markedPlayer], ax

cseg_2F6F0:;
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    push(D2);                               // push D2
    SetPlayerNameAndFace();                 // call SetPlayerNameAndFace
    pop(D2);                                // pop D2
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 69, 1, 0);            // mov [esi+PlayerGameHeader.passing], 0
    writeMemory(esi + 70, 1, 0);            // mov [esi+PlayerGameHeader.shooting], 0
    writeMemory(esi + 71, 1, 0);            // mov [esi+PlayerGameHeader.heading], 0
    writeMemory(esi + 72, 1, 0);            // mov [esi+PlayerGameHeader.tackling], 0
    writeMemory(esi + 73, 1, 0);            // mov [esi+PlayerGameHeader.ballControl], 0
    writeMemory(esi + 74, 1, 0);            // mov [esi+PlayerGameHeader.speed], 0
    writeMemory(esi + 75, 1, 0);            // mov [esi+PlayerGameHeader.finishing], 0
    writeMemory(esi + 76, 1, 0);            // mov [esi+PlayerGameHeader.goalieSkill], 0
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 61;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, size PlayerGame
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 16
    if (!flags.zero)
        goto l_players_loop;                // jnz @@players_loop

    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A0 = eax;                               // mov A0, eax
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 22;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamGame.teamName
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_a_training3;             // jz short @@not_a_training3

    A0 = 456352;                            // mov A0, offset team_A_name
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 332876;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, offset topTeamInGame
    if (flags.zero)
        goto l_not_a_training3;             // jz short @@not_a_training3

    A0 = 456369;                            // mov A0, offset team_B_name

l_not_a_training3:;
    StringCopy();                           // call StringCopy
}

// =============== S U B R O U T I N E =======================================

// in:
//      A5 -> player + header (file)
//      A6 -> player + header (game)
//
void SetPlayerNameAndFace()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, PlayerFile.playerName+4Ch
    A0 = eax;                               // mov A0, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 80;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, PlayerGameHeader.fullName
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 24;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 18h
    {
        word res = *(word *)&D0 >> 3;
        flags.carry = ((word)*(word *)&D0 >> 13) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 3
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 79, 1, al);           // mov [esi+PlayerGameHeader.face2], al
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// in:
//      D1 - player index
//      A5 -> player (file) + header
//      A6 -> player (game) + header
//
// Generates player short name used for displaying in top left corner when they have the ball.
// Initializes other fields. Full name isn't copied here.
//
void InitInGamePlayer()
{
    al = D1;                                // mov al, byte ptr D1
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 43, 1, al);           // mov [esi+PlayerGameHeader.playerIndex], al
    writeMemory(esi + 44, 1, 0);            // mov [esi+PlayerGameHeader.goalsScored], 0
    writeMemory(esi + 78, 2, 0);            // mov word ptr [esi+PlayerGameHeader.halfPlayed], 0
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, PlayerFile.playerName+4Ch
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 32782;                   // mov word ptr D0, 800Eh
    push(D2);                               // push D2
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ExtractSurname();                       // call ExtractSurname
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D2);                                // pop D2
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 54;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, PlayerGameHeader.shortName
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 24;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 18h
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 47, 1, al);           // mov [esi+PlayerGameHeader.face], al
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 46, 1, al);           // mov [esi+PlayerGameHeader.position], al
    writeMemory(esi + 42, 1, 0);            // mov [esi+PlayerGameHeader.substituted], 0
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 11
    if (flags.carry)
        goto l_first_team_players;          // jb @@first_team_players

    eax = A5;                               // mov eax, A5
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[449320];       // mov ax, plg_D3_param
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    IsPlayerInjured();                      // call IsPlayerInjured
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    if (!flags.zero)
        goto l_player_injured;              // jnz short @@player_injured

    ax = *(word *)&g_memByte[336366];       // mov ax, gameMaxSubstitutes
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 11
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.carry)
        goto l_first_team_players;          // jb short @@first_team_players

l_player_injured:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 46, 1, -1);           // mov [esi+PlayerGameHeader.position], -1
    writeMemory(esi + 42, 1, 1);            // mov [esi+PlayerGameHeader.substituted], 1

l_first_team_players:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 52, 1, 0);            // mov [esi+PlayerGameHeader.cards], 0
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = *(word *)&g_memByte[449320];       // mov ax, plg_D3_param
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_2FAE8;                    // jnz short cseg_2FAE8

    {
        word res = *(word *)&D0 & 28;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1Ch
    {
        word res = *(word *)&D0 >> 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 2
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 52, 1, al);           // mov [esi+PlayerGameHeader.cards], al
    goto cseg_2FB04;                        // jmp short cseg_2FB04

cseg_2FAE8:;
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.carry)
        goto cseg_2FB04;                    // jb short cseg_2FB04

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 52, 1, 2);            // mov [esi+PlayerGameHeader.cards], 2

cseg_2FB04:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 52, 1);     // mov al, [esi+PlayerGameHeader.cards]
    writeMemory(esi + 51, 1, al);           // mov [esi+PlayerGameHeader.previousCards], al
    writeMemory(esi + 48, 1, 0);            // mov [esi+PlayerGameHeader.isInjured], 0
    writeMemory(esi + 53, 1, 0);            // mov [esi+PlayerGameHeader.disallowSubs], 0
    writeMemory(esi + 77, 1, 0);            // mov [esi+PlayerGameHeader.injuriesBitfield], 0
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0E0h
    al = D0;                                // mov al, byte ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 77, 1, al);           // mov [esi+PlayerGameHeader.injuriesBitfield], al
    writeMemory(esi + 50, 1, 0);            // mov [esi+PlayerGameHeader.fasterTackle], 0
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+(PlayerFile.shirtNumber+4Ch)]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 45, 1, al);           // mov [esi+PlayerGameHeader.shirtNumber], al
}

// =============== S U B R O U T I N E =======================================

// in:
//      A2 -> team1 (file)
//      A3 -> team2 (file)
//
void SetInGameTeamsPrimaryColors()
{
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    eax = A3;                               // mov eax, A3
    A1 = eax;                               // mov A1, eax
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    MeasureTeamKitsSimilarity();            // call MeasureTeamKitsSimilarity
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 11;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
    }                                       // cmp byte ptr [esi], 11
    (*(int32_t *)&A6)++;
    flags.sign = (*(int32_t *)&A6 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A6 == 0;      // inc A6
    if (flags.carry)
        { SetInGameTeamColors(); return; }  // jb SetInGameTeamColors

    *(word *)&D7 = 1;                       // mov word ptr D7, 1
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 11;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
    }                                       // cmp byte ptr [esi], 11
    (*(int32_t *)&A6)++;
    flags.sign = (*(int32_t *)&A6 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A6 == 0;      // inc A6
    if (flags.carry)
        { SetInGameTeamColors(); return; }  // jb SetInGameTeamColors

    *(word *)&D7 = 2;                       // mov word ptr D7, 2
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 11;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
    }                                       // cmp byte ptr [esi], 11
    (*(int32_t *)&A6)++;
    flags.sign = (*(int32_t *)&A6 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A6 == 0;      // inc A6
    if (flags.carry)
        { SetInGameTeamColors(); return; }  // jb SetInGameTeamColors

    *(word *)&D7 = 3;                       // mov word ptr D7, 3
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 11;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 11
    if (flags.carry)
        { SetInGameTeamColors(); return; }  // jb SetInGameTeamColors

    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    IsSingleColorKitSimilar();              // call IsSingleColorKitSimilar
    if (flags.carry)
        { ConvertTeamKitColorsWithFixedColors(); return; } // jb ConvertTeamKitColorsWithFixedColors

    esi = A3;                               // mov esi, A3
    {
        byte src = (byte)readMemory(esi + 27, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.prStripesColor], 0
    if (flags.zero)
        goto l_try_primary_shorts_color;    // jz short @@try_primary_shorts_color

    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    IsSingleColorKitSimilar();              // call IsSingleColorKitSimilar
    if (flags.carry)
        { ConvertTeamKitColorsWithFixedColors(); return; } // jb ConvertTeamKitColorsWithFixedColors

l_try_primary_shorts_color:;
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 29, 1);     // mov al, [esi+TeamFile.prShortsColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    IsSingleColorKitSimilar();              // call IsSingleColorKitSimilar
    if (flags.carry)
        { ConvertTeamKitColorsWithFixedColors(); return; } // jb ConvertTeamKitColorsWithFixedColors

    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 32, 1);     // mov al, [esi+TeamFile.secStripesColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    IsSingleColorKitSimilar();              // call IsSingleColorKitSimilar
    if (flags.carry)
        { ConvertTeamKitColorsWithFixedColors(); return; } // jb ConvertTeamKitColorsWithFixedColors

    esi = A3;                               // mov esi, A3
    {
        byte src = (byte)readMemory(esi + 32, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.secStripesColor], 0
    if (flags.zero)
        goto l_try_secondary_shorts_color;  // jz short @@try_secondary_shorts_color

    al = (byte)readMemory(esi + 33, 1);     // mov al, [esi+TeamFile.secBasicColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    IsSingleColorKitSimilar();              // call IsSingleColorKitSimilar
    if (flags.carry)
        { ConvertTeamKitColorsWithFixedColors(); return; } // jb ConvertTeamKitColorsWithFixedColors

l_try_secondary_shorts_color:;
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 34, 1);     // mov al, [esi+TeamFile.secShortsColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    IsSingleColorKitSimilar();              // call IsSingleColorKitSimilar
    if (flags.carry)
        { ConvertTeamKitColorsWithFixedColors(); return; } // jb ConvertTeamKitColorsWithFixedColors

    ResolveTeamKitColorConflict();          // jmp ResolveTeamKitColorConflict
}

// =============== S U B R O U T I N E =======================================

// in:
//     D1  - color of the single color kit
//     A2 -> team (file)
// out:
//     carry flag: set = not similar, clear = similar
//
void IsSingleColorKitSimilar()
{
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 26, 1);     // mov al, [esi+TeamFile.prShirtType]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    al = (byte)readMemory(esi + 29, 1);     // mov al, [esi+TeamFile.prShortsColor]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    *(byte *)&D0 = 0;                       // mov byte ptr D0, SHIRT_ORDINARY
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(A2);                               // push A2
    push(A6);                               // push A6
    GetTeamKitsSimilarityFactor();          // call GetTeamKitsSimilarityFactor
    pop(A6);                                // pop A6
    pop(A2);                                // pop A2
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = 11;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, 11
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0  - bottom team shirt type
//     D1  - bottom team stripes color
//     D2  - bottom team basic color
//     D3  - bottom team shorts color
//     A2 -> top team (file)
//
void ConvertTeamKitColorsWithFixedColors()
{
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    A1 = 334580;                            // mov A1, offset bottomTeamInGame
    ConvertTeamKitColors();                 // call ConvertTeamKitColors
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 26, 1);     // mov al, [esi+TeamFile.prShirtType]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    al = (byte)readMemory(esi + 29, 1);     // mov al, [esi+TeamFile.prShortsColor]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    al = (byte)readMemory(esi + 30, 1);     // mov al, [esi+TeamFile.prSocksColor]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    A1 = 332876;                            // mov A1, offset topTeamInGame
    ConvertTeamKitColors();                 // call ConvertTeamKitColors
}

// =============== S U B R O U T I N E =======================================

// in:
//     A2 -> team (file)
//
void ResolveTeamKitColorConflict()
{
    A6 = 449452;                            // mov A6, offset teamKitTieBreakColors

l_try_next_color:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A6)++;                    // inc A6
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto l_set_fixed_colors;            // js @@set_fixed_colors

    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    *(byte *)&D0 = 0;                       // mov byte ptr D0, SHIRT_ORDINARY
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 26, 1);     // mov al, [esi+TeamFile.prShirtType]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    al = (byte)readMemory(esi + 29, 1);     // mov al, [esi+TeamFile.prShortsColor]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(A2);                               // push A2
    push(A6);                               // push A6
    GetTeamKitsSimilarityFactor();          // call GetTeamKitsSimilarityFactor
    pop(A6);                                // pop A6
    pop(A2);                                // pop A2
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = 11;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, 11
    if (!flags.carry)
        goto l_try_next_color;              // jnb @@try_next_color

    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    A1 = 334580;                            // mov A1, offset bottomTeamInGame
    ConvertTeamKitColors();                 // call ConvertTeamKitColors
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 26, 1);     // mov al, [esi+TeamFile.prShirtType]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    al = (byte)readMemory(esi + 29, 1);     // mov al, [esi+TeamFile.prShortsColor]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    al = (byte)readMemory(esi + 30, 1);     // mov al, [esi+TeamFile.prSocksColor]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    A1 = 332876;                            // mov A1, offset topTeamInGame
    ConvertTeamKitColors();                 // call ConvertTeamKitColors
    return;                                 // retn

l_set_fixed_colors:;
    *(byte *)&D0 = 0;                       // mov byte ptr D0, SHIRT_ORDINARY
    *(byte *)&D1 = 4;                       // mov byte ptr D1, 4
    *(byte *)&D2 = 4;                       // mov byte ptr D2, 4
    *(byte *)&D3 = 1;                       // mov byte ptr D3, 1
    *(byte *)&D4 = 4;                       // mov byte ptr D4, 4
    A1 = 332876;                            // mov A1, offset topTeamInGame
    ConvertTeamKitColors();                 // call ConvertTeamKitColors
    *(byte *)&D0 = 0;                       // mov byte ptr D0, SHIRT_ORDINARY
    *(byte *)&D1 = 5;                       // mov byte ptr D1, 5
    *(byte *)&D2 = 5;                       // mov byte ptr D2, 5
    *(byte *)&D3 = 1;                       // mov byte ptr D3, 1
    *(byte *)&D4 = 5;                       // mov byte ptr D4, 5
    A1 = 334580;                            // mov A1, offset bottomTeamInGame
    ConvertTeamKitColors();                 // call ConvertTeamKitColors
}

// =============== S U B R O U T I N E =======================================

// in:
//      D7  - secondary kit flags:
//            bit 0 set = use secondary kit for top team
//            bit 1 set = use secondary kit for bottom team
//      A2 -> team1 (file)
//      A3 -> team2 (file)
//
void SetInGameTeamColors()
{
    {
        word res = *(word *)&D7 & 2;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 2
    if (!flags.zero)
        goto l_use_secondary_kit_top_team;  // jnz short @@use_secondary_kit_top_team

    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 26, 1);     // mov al, [esi+TeamFile.prShirtType]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    al = (byte)readMemory(esi + 29, 1);     // mov al, [esi+TeamFile.prShortsColor]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    al = (byte)readMemory(esi + 30, 1);     // mov al, [esi+TeamFile.prSocksColor]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    goto l_set_top_team_colors;             // jmp short @@set_top_team_colors

l_use_secondary_kit_top_team:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 31, 1);     // mov al, [esi+TeamFile.secShirtTpe]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 32, 1);     // mov al, [esi+TeamFile.secStripesColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 33, 1);     // mov al, [esi+TeamFile.secBasicColor]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    al = (byte)readMemory(esi + 34, 1);     // mov al, [esi+TeamFile.secShortsColor]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    al = (byte)readMemory(esi + 35, 1);     // mov al, [esi+TeamFile.secSocksColor]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al

l_set_top_team_colors:;
    A1 = 332876;                            // mov A1, offset topTeamInGame
    ConvertTeamKitColors();                 // call ConvertTeamKitColors
    {
        word res = *(word *)&D7 & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, 1
    if (!flags.zero)
        goto l_use_secondary_kit_bottom_team; // jnz short @@use_secondary_kit_bottom_team

    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 26, 1);     // mov al, [esi+TeamFile.prShirtType]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    al = (byte)readMemory(esi + 29, 1);     // mov al, [esi+TeamFile.prShortsColor]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    al = (byte)readMemory(esi + 30, 1);     // mov al, [esi+TeamFile.prSocksColor]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    goto l_set_bottom_team_colors;          // jmp short @@set_bottom_team_colors

l_use_secondary_kit_bottom_team:;
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + 31, 1);     // mov al, [esi+TeamFile.secShirtTpe]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 32, 1);     // mov al, [esi+TeamFile.secStripesColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 33, 1);     // mov al, [esi+TeamFile.secBasicColor]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    al = (byte)readMemory(esi + 34, 1);     // mov al, [esi+TeamFile.secShortsColor]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    al = (byte)readMemory(esi + 35, 1);     // mov al, [esi+TeamFile.secSocksColor]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al

l_set_bottom_team_colors:;
    A1 = 334580;                            // mov A1, offset bottomTeamInGame
    ConvertTeamKitColors();                 // call ConvertTeamKitColors
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0 -  primary shirt type
//     D1 -  primary shirt stripes color
//     D2 -  primary basic shirt color
//     D3 -  primary shorts color
//     D4 -  primary socks color
//     A1 -> team (game)
//
void ConvertTeamKitColors()
{
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi+TeamGame.prShirtType], ax
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ConvertTeamColor();                     // call ConvertTeamColor
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 2, 2, ax);            // mov [esi+TeamGame.prShirtCol], ax
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGame.prShirtType], SHIRT_ORDINARY
    if (flags.zero)
        goto l_set_stripes_color;           // jz short @@set_stripes_color

    al = D2;                                // mov al, byte ptr D2
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ConvertTeamColor();                     // call ConvertTeamColor

l_set_stripes_color:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 4, 2, ax);            // mov [esi+TeamGame.prStripesCol], ax
    al = D3;                                // mov al, byte ptr D3
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ConvertTeamColor();                     // call ConvertTeamColor
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 6, 2, ax);            // mov [esi+TeamGame.prShortsCol], ax
    al = D4;                                // mov al, byte ptr D4
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ConvertTeamColor();                     // call ConvertTeamColor
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 8, 2, ax);            // mov [esi+TeamGame.prSocksCol], ax
}

// =============== S U B R O U T I N E =======================================

// in
//      D0 = shirt type
//      D1 = stripes color
//      D2 = shirt color
//      D3 = short color
//      D4 = socks color
//      A1 -> in game team struct
//
void SetTeamSecondaryColors()
{
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 10, 2, ax);           // mov [esi+TeamGame.secShirtType], ax
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ConvertTeamColor();                     // call ConvertTeamColor
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 12, 2, ax);           // mov [esi+TeamGame.secShirtCol], ax
    {
        word src = (word)readMemory(esi + 10, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamGame.secShirtType], SHIRT_ORDINARY
    if (flags.zero)
        goto l_basic_shirt;                 // jz short @@basic_shirt

    al = D2;                                // mov al, byte ptr D2
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ConvertTeamColor();                     // call ConvertTeamColor

l_basic_shirt:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 14, 2, ax);           // mov [esi+TeamGame.secStripesCol], ax
    al = D3;                                // mov al, byte ptr D3
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ConvertTeamColor();                     // call ConvertTeamColor
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 16, 2, ax);           // mov [esi+TeamGame.secShortsCol], ax
    al = D4;                                // mov al, byte ptr D4
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ConvertTeamColor();                     // call ConvertTeamColor
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 18, 2, ax);           // mov [esi+TeamGame.secSocksCol], ax
}

// =============== S U B R O U T I N E =======================================

// Receives a team color in D0 (range 0..9), and converts it to
// normal game color for drawing players
//
void ConvertTeamColor()
{
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 252402;                            // mov A0, offset shirtColorTable
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0FFh
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team1 (file)
//      A1 -> team2 (file)
// out:
//      A6 -> team kits similarity factors
//
void MeasureTeamKitsSimilarity()
{
    A2 = 449463;                            // mov A2, offset teamKitsSimilarity
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 26, 1);     // mov al, [esi+TeamFile.prShirtType]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    al = (byte)readMemory(esi + 29, 1);     // mov al, [esi+TeamFile.prShortsColor]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 26, 1);     // mov al, [esi+TeamFile.prShirtType]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    al = (byte)readMemory(esi + 29, 1);     // mov al, [esi+TeamFile.prShortsColor]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    GetTeamKitsSimilarityFactor();          // call GetTeamKitsSimilarityFactor
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    al = D7;                                // mov al, byte ptr D7
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A2)++;
    flags.sign = (*(int32_t *)&A2 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A2 == 0;      // inc A2
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 26, 1);     // mov al, [esi+TeamFile.prShirtType]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    al = (byte)readMemory(esi + 29, 1);     // mov al, [esi+TeamFile.prShortsColor]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 31, 1);     // mov al, [esi+TeamFile.secShirtTpe]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    al = (byte)readMemory(esi + 32, 1);     // mov al, [esi+TeamFile.secStripesColor]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    al = (byte)readMemory(esi + 33, 1);     // mov al, [esi+TeamFile.secBasicColor]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    al = (byte)readMemory(esi + 34, 1);     // mov al, [esi+TeamFile.secShortsColor]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    GetTeamKitsSimilarityFactor();          // call GetTeamKitsSimilarityFactor
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    al = D7;                                // mov al, byte ptr D7
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A2)++;
    flags.sign = (*(int32_t *)&A2 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A2 == 0;      // inc A2
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 31, 1);     // mov al, [esi+TeamFile.secShirtTpe]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 32, 1);     // mov al, [esi+TeamFile.secStripesColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 33, 1);     // mov al, [esi+TeamFile.secBasicColor]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    al = (byte)readMemory(esi + 34, 1);     // mov al, [esi+TeamFile.secShortsColor]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 26, 1);     // mov al, [esi+TeamFile.prShirtType]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    al = (byte)readMemory(esi + 27, 1);     // mov al, [esi+TeamFile.prStripesColor]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    al = (byte)readMemory(esi + 28, 1);     // mov al, [esi+TeamFile.prBasicColor]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    al = (byte)readMemory(esi + 29, 1);     // mov al, [esi+TeamFile.prShortsColor]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    GetTeamKitsSimilarityFactor();          // call GetTeamKitsSimilarityFactor
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    al = D7;                                // mov al, byte ptr D7
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A2)++;
    flags.sign = (*(int32_t *)&A2 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A2 == 0;      // inc A2
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 31, 1);     // mov al, [esi+TeamFile.secShirtTpe]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 32, 1);     // mov al, [esi+TeamFile.secStripesColor]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 33, 1);     // mov al, [esi+TeamFile.secBasicColor]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    al = (byte)readMemory(esi + 34, 1);     // mov al, [esi+TeamFile.secShortsColor]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 31, 1);     // mov al, [esi+TeamFile.secShirtTpe]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    al = (byte)readMemory(esi + 32, 1);     // mov al, [esi+TeamFile.secStripesColor]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    al = (byte)readMemory(esi + 33, 1);     // mov al, [esi+TeamFile.secBasicColor]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    al = (byte)readMemory(esi + 34, 1);     // mov al, [esi+TeamFile.secShortsColor]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    GetTeamKitsSimilarityFactor();          // call GetTeamKitsSimilarityFactor
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    al = D7;                                // mov al, byte ptr D7
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 1, al);                // mov [esi], al
    A6 = 449463;                            // mov A6, offset teamKitsSimilarity
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team1 shirt type
//      D1 - team1 stripes color
//      D2 - team1 basic color
//      D3 - team1 shorts color
//      D4 - team2 shirt type
//      D5 - team2 stripes color
//      D6 - team2 basic color
//      D7 - team2 shorts color
// out:
//      D7 - team kit colors similarity factor
//
void GetTeamKitsSimilarityFactor()
{
    al = D0;                                // mov al, byte ptr D0
    g_memByte[449412] = al;                 // mov shirtType1, al
    al = D4;                                // mov al, byte ptr D4
    g_memByte[449413] = al;                 // mov shirtType2, al

l_colors_check_loop:;
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, SHIRT_ORDINARY
    if (!flags.zero)
        goto l_check_if_team2_single_color_shirts; // jnz short @@check_if_team2_single_color_shirts

    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D2 = al;                      // mov byte ptr D2, al

l_check_if_team2_single_color_shirts:;
    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D4, SHIRT_ORDINARY
    if (!flags.zero)
        goto l_check_stripe_colors;         // jnz short @@check_stripe_colors

    al = D5;                                // mov al, byte ptr D5
    *(byte *)&D6 = al;                      // mov byte ptr D6, al

l_check_stripe_colors:;
    *(word *)&g_memByte[449414] = 99;       // mov similarityFactor, 99
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D5;                                // mov al, byte ptr D5
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (flags.zero)
        goto l_check_stripes1_vs_basic2;    // jz short @@check_stripes1_vs_basic2

    al = D2;                                // mov al, byte ptr D2
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D6;                                // mov al, byte ptr D6
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (!flags.zero)
        goto l_got_conflict;                // jnz @@got_conflict

l_check_stripes1_vs_basic2:;
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D6;                                // mov al, byte ptr D6
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (flags.zero)
        goto l_compare_shirt_types;         // jz short @@compare_shirt_types

    al = D2;                                // mov al, byte ptr D2
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D5;                                // mov al, byte ptr D5
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (!flags.zero)
        goto l_got_conflict;                // jnz @@got_conflict

l_compare_shirt_types:;
    {
        byte src = g_memByte[449412];
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType1, SHIRT_COLORED_SLEEVES
    if (flags.zero)
        goto cseg_30655;                    // jz short cseg_30655

    {
        byte src = g_memByte[449412];
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType1, SHIRT_ORDINARY
    if (!flags.zero)
        goto cseg_306A2;                    // jnz short cseg_306A2

    {
        byte src = g_memByte[449413];
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType2, SHIRT_COLORED_SLEEVES
    if (!flags.zero)
        goto cseg_306A2;                    // jnz short cseg_306A2

    goto l_check_stripes1_vs_shorts2;       // jmp short @@check_stripes1_vs_shorts2

cseg_30655:;
    {
        byte src = g_memByte[449413];
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType2, SHIRT_ORDINARY
    if (!flags.zero)
        goto cseg_306A2;                    // jnz short cseg_306A2

l_check_stripes1_vs_shorts2:;
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D7;                                // mov al, byte ptr D7
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreShortsAndStripeColorsConflicting();  // call AreShortsAndStripeColorsConflicting
    if (flags.zero)
        goto cseg_306A2;                    // jz short cseg_306A2

    al = D3;                                // mov al, byte ptr D3
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D5;                                // mov al, byte ptr D5
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreShortsAndStripeColorsConflicting();  // call AreShortsAndStripeColorsConflicting
    if (flags.zero)
        goto cseg_306A2;                    // jz short cseg_306A2

    *(word *)&g_memByte[449414] = 88;       // mov similarityFactor, 88
    goto l_got_conflict;                    // jmp @@got_conflict

cseg_306A2:;
    {
        byte src = g_memByte[449412];
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType1, SHIRT_VERTICAL_STRIPES
    if (flags.zero)
        goto cseg_306B8;                    // jz short cseg_306B8

    {
        byte src = g_memByte[449412];
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType1, SHIRT_HORIZONTAL_STRIPES
    if (!flags.zero)
        goto cseg_30748;                    // jnz cseg_30748

cseg_306B8:;
    {
        byte src = g_memByte[449413];
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType2, SHIRT_VERTICAL_STRIPES
    if (flags.zero)
        goto l_both_team_have_stripes;      // jz short @@both_team_have_stripes

    {
        byte src = g_memByte[449413];
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType2, SHIRT_HORIZONTAL_STRIPES
    if (!flags.zero)
        goto cseg_30748;                    // jnz short cseg_30748

l_both_team_have_stripes:;
    al = D3;                                // mov al, byte ptr D3
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D5;                                // mov al, byte ptr D5
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (!flags.zero)
        goto l_check_shorts_vs_strips_or_basic; // jnz short @@check_shorts_vs_strips_or_basic

    al = D3;                                // mov al, byte ptr D3
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D6;                                // mov al, byte ptr D6
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (flags.zero)
        goto cseg_30748;                    // jz short cseg_30748

l_check_shorts_vs_strips_or_basic:;
    al = D7;                                // mov al, byte ptr D7
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (!flags.zero)
        goto l_stripes_basic_shorts_conflict; // jnz short @@stripes_basic_shorts_conflict

    al = D7;                                // mov al, byte ptr D7
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D2;                                // mov al, byte ptr D2
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (flags.zero)
        goto cseg_30748;                    // jz short cseg_30748

l_stripes_basic_shorts_conflict:;
    *(word *)&g_memByte[449414] = 77;       // mov similarityFactor, 77
    goto l_got_conflict;                    // jmp @@got_conflict

cseg_30748:;
    {
        byte src = g_memByte[449412];
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType1, SHIRT_COLORED_SLEEVES
    if (!flags.zero)
        goto l_no_conflict;                 // jnz short @@no_conflict

    {
        byte src = g_memByte[449413];
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType2, SHIRT_COLORED_SLEEVES
    if (!flags.zero)
        goto l_no_conflict;                 // jnz short @@no_conflict

    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D5;                                // mov al, byte ptr D5
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (flags.zero)
        goto l_no_conflict;                 // jz short @@no_conflict

    *(word *)&g_memByte[449414] = 66;       // mov similarityFactor, 66
    goto l_got_conflict;                    // jmp @@got_conflict

l_no_conflict:;
    *(word *)&g_memByte[449414] = 0;        // mov similarityFactor, 0
    al = g_memByte[449412];                 // mov al, shirtType1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = g_memByte[449413];                 // mov al, shirtType2
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto cseg_307AB;                    // jz short cseg_307AB

    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // sub similarityFactor, 4

cseg_307AB:;
    {
        byte src = g_memByte[449412];
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType1, SHIRT_ORDINARY
    if (!flags.zero)
        goto cseg_307E7;                    // jnz short cseg_307E7

    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // sub similarityFactor, 2
    {
        byte src = g_memByte[449413];
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType2, SHIRT_COLORED_SLEEVES
    if (!flags.zero)
        goto cseg_307E7;                    // jnz short cseg_307E7

    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.zero)
        goto cseg_307E7;                    // jnz short cseg_307E7

    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D3, al
    if (!flags.zero)
        goto cseg_307E7;                    // jnz short cseg_307E7

    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // sub similarityFactor, 6

cseg_307E7:;
    {
        byte src = g_memByte[449413];
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType2, SHIRT_ORDINARY
    if (!flags.zero)
        goto cseg_30823;                    // jnz short cseg_30823

    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // sub similarityFactor, 2
    {
        byte src = g_memByte[449412];
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType1, SHIRT_COLORED_SLEEVES
    if (!flags.zero)
        goto cseg_30823;                    // jnz short cseg_30823

    al = D5;                                // mov al, byte ptr D5
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D6, al
    if (!flags.zero)
        goto cseg_30823;                    // jnz short cseg_30823

    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, al
    if (!flags.zero)
        goto cseg_30823;                    // jnz short cseg_30823

    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // sub similarityFactor, 6

cseg_30823:;
    {
        byte src = g_memByte[449412];
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType1, SHIRT_ORDINARY
    if (flags.zero)
        goto cseg_30840;                    // jz short cseg_30840

    {
        byte src = g_memByte[449412];
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType1, SHIRT_COLORED_SLEEVES
    if (!flags.zero)
        goto cseg_30851;                    // jnz short cseg_30851

    {
        byte src = g_memByte[449413];
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType2, SHIRT_ORDINARY
    if (!flags.zero)
        goto cseg_30851;                    // jnz short cseg_30851

    goto cseg_30849;                        // jmp short cseg_30849

cseg_30840:;
    {
        byte src = g_memByte[449413];
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType2, SHIRT_COLORED_SLEEVES
    if (!flags.zero)
        goto cseg_30851;                    // jnz short cseg_30851

cseg_30849:;
    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // add similarityFactor, 1

cseg_30851:;
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D5;                                // mov al, byte ptr D5
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (flags.zero)
        goto cseg_30874;                    // jz short cseg_30874

    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // add similarityFactor, 5

cseg_30874:;
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D6;                                // mov al, byte ptr D6
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (flags.zero)
        goto cseg_30897;                    // jz short cseg_30897

    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // add similarityFactor, 5

cseg_30897:;
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D7;                                // mov al, byte ptr D7
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (flags.zero)
        goto cseg_308BA;                    // jz short cseg_308BA

    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // add similarityFactor, 2

cseg_308BA:;
    al = D2;                                // mov al, byte ptr D2
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D5;                                // mov al, byte ptr D5
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (flags.zero)
        goto cseg_308DD;                    // jz short cseg_308DD

    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // add similarityFactor, 5

cseg_308DD:;
    al = D2;                                // mov al, byte ptr D2
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D6;                                // mov al, byte ptr D6
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (flags.zero)
        goto cseg_30900;                    // jz short cseg_30900

    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // add similarityFactor, 5

cseg_30900:;
    al = D2;                                // mov al, byte ptr D2
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D7;                                // mov al, byte ptr D7
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (flags.zero)
        goto cseg_30923;                    // jz short cseg_30923

    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // add similarityFactor, 2

cseg_30923:;
    al = D3;                                // mov al, byte ptr D3
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D5;                                // mov al, byte ptr D5
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (flags.zero)
        goto cseg_30946;                    // jz short cseg_30946

    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // add similarityFactor, 2

cseg_30946:;
    al = D3;                                // mov al, byte ptr D3
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D6;                                // mov al, byte ptr D6
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (flags.zero)
        goto cseg_30969;                    // jz short cseg_30969

    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // add similarityFactor, 2

cseg_30969:;
    al = D3;                                // mov al, byte ptr D3
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D7;                                // mov al, byte ptr D7
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    AreBasicColorsConflicting();            // call AreBasicColorsConflicting
    if (flags.zero)
        goto l_got_conflict;                // jz short @@got_conflict

    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[449414] = src;
    }                                       // add similarityFactor, 5

l_got_conflict:;
    {
        word src = *(word *)&g_memByte[449414];
        int16_t dstSigned = src;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp similarityFactor, 11
    if (!flags.carry)
        goto l_return_value;                // jnb @@return_value

    A0 = 449366;                            // mov A0, offset dseg_130942
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D4 = 0;                       // mov word ptr D4, 0

cseg_309B6:;
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_30A49;                    // jnz cseg_30A49

    {
        byte src = g_memByte[449412];
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType1, SHIRT_VERTICAL_STRIPES
    if (flags.zero)
        goto cseg_309DB;                    // jz short cseg_309DB

    {
        byte src = g_memByte[449412];
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType1, SHIRT_HORIZONTAL_STRIPES
    if (!flags.zero)
        goto cseg_30A49;                    // jnz short cseg_30A49

cseg_309DB:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_309FC;                    // jnz short cseg_309FC

    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (flags.zero)
        goto cseg_30A1D;                    // jz short cseg_30A1D

cseg_309FC:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_30A49;                    // jnz short cseg_30A49

    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.zero)
        goto cseg_30A49;                    // jnz short cseg_30A49

cseg_30A1D:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    g_memByte[449412] = 0;                  // mov shirtType1, SHIRT_ORDINARY
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al

cseg_30A49:;
    ax = D4;                                // mov ax, word ptr D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_30ADC;                    // jnz cseg_30ADC

    {
        byte src = g_memByte[449413];
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType2, SHIRT_VERTICAL_STRIPES
    if (flags.zero)
        goto cseg_30A6E;                    // jz short cseg_30A6E

    {
        byte src = g_memByte[449413];
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp shirtType2, SHIRT_HORIZONTAL_STRIPES
    if (!flags.zero)
        goto cseg_30ADC;                    // jnz short cseg_30ADC

cseg_30A6E:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D5;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D5, al
    if (!flags.zero)
        goto cseg_30A8F;                    // jnz short cseg_30A8F

    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D6, al
    if (flags.zero)
        goto cseg_30AB0;                    // jz short cseg_30AB0

cseg_30A8F:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    {
        int8_t dstSigned = *(byte *)&D5;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D5, al
    if (!flags.zero)
        goto cseg_30ADC;                    // jnz short cseg_30ADC

    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D6, al
    if (!flags.zero)
        goto cseg_30ADC;                    // jnz short cseg_30ADC

cseg_30AB0:;
    *(word *)&D4 = 1;                       // mov word ptr D4, 1
    g_memByte[449413] = 0;                  // mov shirtType2, SHIRT_ORDINARY
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al

cseg_30ADC:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 3;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 3
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = -1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], -1
    if (!flags.zero)
        goto cseg_309B6;                    // jnz cseg_309B6

    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_colors_check_loop;           // jnz @@colors_check_loop

    ax = D4;                                // mov ax, word ptr D4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_colors_check_loop;           // jnz @@colors_check_loop

l_return_value:;
    ax = *(word *)&g_memByte[449414];       // mov ax, similarityFactor
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        return;                             // jns short @@out

    *(word *)&D7 = 0;                       // mov word ptr D7, 0
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team color 1 (0..9)
//      D4 - team color 2 (0..9)
// out:
//      zero flag: set = OK, clear = conflict
//
void AreBasicColorsConflicting()
{
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D4 & 255;
        *(word *)&D4 = res;
    }                                       // and word ptr D4, 0FFh
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    A0 = 449326;                            // mov A0, offset conflictingBasicTeamColorsTable
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cx = D4;                                // mov cx, word ptr D4
    ax = 1;                                 // mov ax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            word res = ax << shiftCount;
            ax = res;
        }
    }                                       // shl ax, cl
    {
        word res = *(word *)&D0 & ax;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D0, ax
}

// =============== S U B R O U T I N E =======================================
//
void AreShortsAndStripeColorsConflicting()
{
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D4 & 255;
        *(word *)&D4 = res;
    }                                       // and word ptr D4, 0FFh
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    A0 = 449346;                            // mov A0, offset conflictingShortsTeamColorsTable
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cx = D4;                                // mov cx, word ptr D4
    ax = 1;                                 // mov ax, 1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            word res = ax << shiftCount;
            ax = res;
        }
    }                                       // shl ax, cl
    {
        word res = *(word *)&D0 & ax;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D0, ax
}

// =============== S U B R O U T I N E =======================================
//
void ProcessPostGameStats()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_2CDC6();                           // call cseg_2CDC6
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D0);                                // pop D0
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_2CDC6();                           // call cseg_2CDC6
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D0);                                // pop D0
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_2D7B7();                           // call cseg_2D7B7
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D0);                                // pop D0
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_2D7B7();                           // call cseg_2D7B7
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D0);                                // pop D0
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A4 -> team data (in-game)
//
// Get current tactic from pl1 or pl2Tactics and apply it to a given team data.
// Adjust player skills based on tactics.
//
void ApplyTeamTactics()
{
    ax = *(word *)&g_memByte[449298];       // mov ax, pl1Tactics
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(dword *)&g_memByte[455996];     // mov eax, gameTeam1
    A2 = eax;                               // mov A2, eax
    eax = *(dword *)&g_memByte[456000];     // mov eax, gameTeam2
    A3 = eax;                               // mov A3, eax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 332876;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, offset topTeamInGame
    if (flags.zero)
        goto l_dont_swap;                   // jz short @@dont_swap

    ax = *(word *)&g_memByte[449300];       // mov ax, pl2Tactics
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A2;                               // mov eax, A2
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A2 = eax;                               // mov A2, eax

l_dont_swap:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    push(ax);                               // push ax
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 24, 1, al);           // mov [esi+TeamFile.tactics], al
    eax = A4;                               // mov eax, A4
    A6 = eax;                               // mov A6, eax
    *(word *)&D2 = 0;                       // mov word ptr D2, 0

l_starting_players_loop:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 43, 1);     // mov al, [esi+PlayerGameHeader.playerIndex]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    GetPlayer();                            // call GetPlayer
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    SaveRand2State();                       // call SaveRand2State
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    GetPlayerRandomNum();                   // call GetPlayerRandomNum
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    ax = *(word *)&g_memByte[456004];       // mov ax, gameRandValue
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D0 ^= ax;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // xor word ptr D0, ax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    Randomize2();                           // call Randomize2
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    AdjustPlayerSkills();                   // call AdjustPlayerSkills
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    RestoreRand2State();                    // call RestoreRand2State
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 61;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, size PlayerGame
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 11
    if (!flags.zero)
        goto l_starting_players_loop;       // jnz @@starting_players_loop

    {
        int32_t val = stack[stackTop++];
        ax = val;
    }                                       // pop ax
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 24, 1, al);           // mov [esi+TeamFile.tactics], al
}

// =============== S U B R O U T I N E =======================================

// in:
//      D2  - current player index
//      A2 -> team (file)
//      A3 -> opponent team (file)
//      A4 -> team (game)
//      A5 -> player (file) + header
//      A6 -> player (game) + header
//
void AdjustPlayerSkills()
{
    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_player;                      // jnz short @@player

    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    goto l_check_price;                     // jmp @@check_price

l_player:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    eax = A5;                               // mov eax, A5
    A1 = eax;                               // mov A1, eax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    GetPlayerPrice();                       // call GetPlayerPrice
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D4 = ax;                      // mov word ptr D4, ax

l_check_price:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_price_non_zero;              // jnz short @@price_non_zero

    *(word *)&D3 = 1;                       // mov word ptr D3, 1

l_price_non_zero:;
    ax = D4;                                // mov ax, word ptr D4
    bx = 100;                               // mov bx, 100
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D3);
        word rem = (word)(dividend % *(word *)&D3);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D3
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)((byte *)&D4 + 2) = dx;        // mov word ptr D4+2, dx
    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (!flags.zero)
        goto cseg_313F7;                    // jnz short cseg_313F7

    *(word *)&D4 = 100;                     // mov word ptr D4, 100

cseg_313F7:;
    ax = *(word *)&g_memByte[449282];       // mov ax, plg_D0_param
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_get_player_price_percentage_change; // jnz short @@get_player_price_percentage_change

    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 334580;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, offset bottomTeamInGame
    if (!flags.zero)
        goto l_get_player_price_percentage_change; // jnz short @@get_player_price_percentage_change

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (!flags.zero)
        goto cseg_31426;                    // jnz short cseg_31426

    esi = A3;                               // mov esi, A3
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (flags.zero)
        goto l_get_player_price_percentage_change; // jz short @@get_player_price_percentage_change

cseg_31426:;
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 12;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 12
    if (!flags.sign)
        goto l_get_player_price_percentage_change; // jns short @@get_player_price_percentage_change

    *(word *)&D4 = 0;                       // mov word ptr D4, 0

l_get_player_price_percentage_change:;
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    GetPlayerPricePercentageChange();       // call GetPlayerPricePercentageChange
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 104, 2);    // mov ax, word ptr [esi+(PlayerFile.passing+4Ch)]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)((byte *)&D1 + 2) = ax;        // mov word ptr D1+2, ax
    ax = (word)readMemory(esi + 106, 2);    // mov ax, word ptr [esi+(PlayerFile.tacklingBallControl+4Ch)]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        dword res = D1 & 125269879;
        D1 = res;
    }                                       // and D1, 7777777h
    {
        dword res = D1 << 4;
        D1 = res;
    }                                       // shl D1, 4
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 69;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, PlayerGameHeader.passing
    A0 = eax;                               // mov A0, eax
    *(word *)&D3 = 6;                       // mov word ptr D3, 6

l_player_skills_loop:;
    {
        D1 = (D1 << 4) | ((dword)D1 >> 28);
    }                                       // rol D1, 4
    al = D1;                                // mov al, byte ptr D1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Fh
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ScaleSkill();                           // call ScaleSkill
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 7
    if (flags.carry || flags.zero)
        goto l_update_scaled_skill;         // jbe short @@update_scaled_skill

    *(byte *)&D0 = 7;                       // mov byte ptr D0, 7

l_update_scaled_skill:;
    al = D0;                                // mov al, byte ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D3)--;
    flags.overflow = (int16_t)(*(int16_t *)&D3) == INT16_MIN;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto l_player_skills_loop;          // jns short @@player_skills_loop

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 76, 1, 0);            // mov [esi+PlayerGameHeader.goalieSkill], 0
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (!flags.zero)
        return;                             // jnz @@out

    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 3
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 7;                                 // mov bx, 7
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    ax = *(word *)&g_memByte[456004];       // mov ax, gameRandValue
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 1;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 332876;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, offset topTeamInGame
    if (flags.zero)
        goto l_check_controls;              // jz short @@check_controls

    ax = *(word *)&g_memByte[456004];       // mov ax, gameRandValue
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 2;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 2
    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1

l_check_controls:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    esi = A3;                               // mov esi, A3
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (!flags.zero)
        goto cseg_3167D;                    // jnz short cseg_3167D

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    goto l_limit_max_skill_to_7;            // jmp short @@limit_max_skill_to_7

cseg_3167D:;
    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (!flags.zero)
        goto l_check_if_this_team_cpu;      // jnz short @@check_if_this_team_cpu

    esi = A3;                               // mov esi, A3
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (!flags.zero)
        goto l_check_if_this_team_cpu;      // jnz short @@check_if_this_team_cpu

    goto l_limit_max_skill_to_7;            // jmp short @@limit_max_skill_to_7

l_check_if_this_team_cpu:;
    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (!flags.zero)
        goto l_set_goalie_skill;            // jnz short @@set_goalie_skill

    esi = A3;                               // mov esi, A3
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (!flags.zero)
        goto l_set_goalie_skill;            // jnz short @@set_goalie_skill

l_limit_max_skill_to_7:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 7
    if (flags.zero || flags.sign != flags.overflow)
        goto l_eliminate_negative_values;   // jle short @@eliminate_negative_values

    *(word *)&D0 = 7;                       // mov word ptr D0, 7

l_eliminate_negative_values:;
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_set_goalie_skill;            // jns short @@set_goalie_skill

    *(word *)&D0 = 0;                       // mov word ptr D0, 0

l_set_goalie_skill:;
    al = D0;                                // mov al, byte ptr D0
    SWOS::FixTwoCPUsGameCrash();            // call FixTwoCPUsGameCrash
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 76, 1, al);           // mov [esi+PlayerGameHeader.goalieSkill], al
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0 -
//     D4 - player price change factor
//     A2 -> team (file)
// out:
//     D4 - player price percentage of increase/decrease
//
void GetPlayerPricePercentageChange()
{
    ax = *(word *)&g_memByte[449284];       // mov ax, isGameFriendly
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_add_random_part;             // jnz @@add_random_part

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (flags.zero)
        goto l_add_random_part;             // jz @@add_random_part

    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2C88E();                           // call cseg_2C88E
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D0);                                // pop D0
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, ax
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    eax = A2;                               // mov eax, A2
    A1 = eax;                               // mov A1, eax
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_94A16();                           // call cseg_94A16
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, ax

l_add_random_part:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 24;                                // mov bx, 24
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 12;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 12
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0 - skill
//     D4 - percantage increase/decrease (* 100)
// out:
//     D0 - scaled skill
//
// Multiply skill with percentage change of player skill compared to original value in file,
// as well as percentage of team average value compared to average value of all teams selected.
//
void ScaleSkill()
{
    push(D2);                               // push D2
    push(D3);                               // push D3
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 75;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 75
    if (flags.sign == flags.overflow)
        goto l_check_max_percentage;        // jge short @@check_max_percentage

    *(word *)&D2 = 75;                      // mov word ptr D2, 75

l_check_max_percentage:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 125;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 125
    if (flags.zero || flags.sign != flags.overflow)
        goto l_get_team_app;                // jle short @@get_team_app

    *(word *)&D2 = 125;                     // mov word ptr D2, 125

l_get_team_app:;
    ax = *(word *)&g_memByte[456006];       // mov ax, team1AppPercent
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 332876;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, offset topTeamInGame
    if (flags.zero)
        goto cseg_31935;                    // jz short cseg_31935

    ax = *(word *)&g_memByte[456008];       // mov ax, team2AppPercent
    *(word *)&D3 = ax;                      // mov word ptr D3, ax

cseg_31935:;
    ax = D2;                                // mov ax, word ptr D2
    tmp = ax * *(word *)&D3;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D3
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D2;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D2
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    eax = D0;                               // mov eax, D0
    D2 = eax;                               // mov D2, eax
    {
        word tmp = *(word *)((byte *)&D2 + 2);
        *(word *)((byte *)&D2 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D2+2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 100;                               // mov bx, 100
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto l_return;                      // jnb short @@return

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 1

l_return:;
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
}

// =============== S U B R O U T I N E =======================================
//
void cseg_31A2B()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_2CDC6();                           // call cseg_2CDC6
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_2CDC6();                           // call cseg_2CDC6
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[318702];       // mov ax, dseg_10EEE4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_2D7B7();                           // call cseg_2D7B7
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[318702];       // mov ax, dseg_10EEE4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_2D7B7();                           // call cseg_2D7B7
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_31B94()
{
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 55, 1);     // mov al, [esi+37h]
    writeMemory(esi + 46, 1, al);           // mov [esi+2Eh], al
    writeMemory(esi + 445, 2, 0);           // mov word ptr [esi+1BDh], 0
    writeMemory(esi + 91, 2, 0);            // mov word ptr [esi+5Bh], 0
    writeMemory(esi + 459, 2, 0);           // mov word ptr [esi+1CBh], 0
    writeMemory(esi + 457, 2, 0);           // mov word ptr [esi+1C9h], 0
    writeMemory(esi + 449, 2, 0);           // mov word ptr [esi+1C1h], 0
    writeMemory(esi + 447, 2, 0);           // mov word ptr [esi+1BFh], 0
    ax = (word)readMemory(esi + 105, 2);    // mov ax, [esi+69h]
    writeMemory(esi + 107, 2, ax);          // mov [esi+6Bh], ax
    ax = (word)readMemory(esi + 93, 2);     // mov ax, [esi+5Dh]
    writeMemory(esi + 95, 2, ax);           // mov [esi+5Fh], ax
    *(word *)&D0 = 63;                      // mov word ptr D0, 3Fh

cseg_31BF6:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 695, 2, 0);           // mov word ptr [esi+2B7h], 0
    writeMemory(esi + 697, 2, 0);           // mov word ptr [esi+2B9h], 0
    writeMemory(esi + 699, 2, 0);           // mov word ptr [esi+2BBh], 0
    writeMemory(esi + 701, 2, 0);           // mov word ptr [esi+2BDh], 0
    writeMemory(esi + 703, 2, 0);           // mov word ptr [esi+2BFh], 0
    writeMemory(esi + 705, 2, 0);           // mov word ptr [esi+2C1h], 0
    writeMemory(esi + 707, 2, 0);           // mov word ptr [esi+2C3h], 0
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 18;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A2 = res;
    }                                       // add A2, 12h
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_31BF6;                    // jns short cseg_31BF6
}

// =============== S U B R O U T I N E =======================================
//
void cseg_31C4C()
{
    A0 = 92798;                             // mov A0, offset careerTeam
    A5 = 92766;                             // mov A5, offset currentMatchPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_31C74:;
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 38
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 65311;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FF1Fh
    *(word *)&D0 |= 0;
    flags.carry = false;                    // or word ptr D0, 0
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 103, 1, al);          // mov [esi+67h], al
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_31C74;                    // jns cseg_31C74
}

// =============== S U B R O U T I N E =======================================
//
void cseg_31CFE()
{
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_31D30;                    // jz short cseg_31D30

    {
        word src = (word)readMemory(esi + 83, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+53h], 1
    if (flags.zero)
        goto cseg_31D76;                    // jz short cseg_31D76

    {
        word src = (word)readMemory(esi + 83, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+53h], 2
    if (flags.zero)
        goto cseg_31DE4;                    // jz cseg_31DE4

    goto cseg_31E56;                        // jmp cseg_31E56

cseg_31D30:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax
    A1 = 336554;                            // mov A1, offset dseg_114C2C
    *(word *)&D1 = 15;                      // mov word ptr D1, 0Fh

cseg_31D50:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_31D50;                    // jns short cseg_31D50

    return;                                 // retn

cseg_31D76:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax
    A1 = 336554;                            // mov A1, offset dseg_114C2C
    A2 = 486744;                            // mov A2, offset dseg_1728A8
    *(word *)&D1 = 7;                       // mov word ptr D1, 7

cseg_31DA0:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
        flags.carry = false;
    }                                       // and word ptr D0, 0FFh
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_31DA0;                    // jns short cseg_31DA0

    return;                                 // retn

cseg_31DE4:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax
    A1 = 336554;                            // mov A1, offset dseg_114C2C
    A2 = 486752;                            // mov A2, offset dseg_1728B0
    *(word *)&D1 = 3;                       // mov word ptr D1, 3
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
        flags.carry = false;
    }                                       // and word ptr D0, 0FFh
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_31DA0;                    // jns cseg_31DA0

    return;                                 // retn

cseg_31E56:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax
    A1 = 336554;                            // mov A1, offset dseg_114C2C
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> contest
//
void LoadSomeEuroCup()
{
    A1 = 27803;                             // mov A1, offset aDataEurocup_tm
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 27854;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset euroCup
    if (flags.zero)
        goto l_known_contest;               // jz short @@known_contest

    A1 = 27820;                             // mov A1, offset aDataEurocwc_tm
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 27933;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset cupWinnersCup
    if (flags.zero)
        goto l_known_contest;               // jz short @@known_contest

    A1 = 27837;                             // mov A1, offset aDataUefacup_tm
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 28025;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset uefaCup
    if (!flags.zero)
        return;                             // jnz @@out

l_known_contest:;
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    A1 = 36608;                             // mov A1, offset tmdFileBuffer
    ax = *(word *)&g_memByte[36606];        // mov ax, careerFileBuffer
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, eax
    SWOS::LoadFile();                       // call LoadFile
    ax = D1;                                // mov ax, word ptr D1
    dx = *(word *)((byte *)&D1 + 2);        // mov dx, word ptr D1+2
    bx = 684;                               // mov bx, 684
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    {
        word src = *(word *)&g_memByte[36606];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[36606] = src;
    }                                       // add careerFileBuffer, ax
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    eax = D1;                               // mov eax, D1
    D0 = eax;                               // mov D0, eax
    SetTeamGlobalNumbers();                 // call SetTeamGlobalNumbers
}

// =============== S U B R O U T I N E =======================================
//
void cseg_31F58()
{
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 0
    if (flags.zero)
        { cseg_31F79(); return; }           // jz short cseg_31F79

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 1
    if (flags.zero)
        { cseg_32024(); return; }           // jz cseg_32024

    cseg_320A3();                           // jmp cseg_320A3
}

// =============== S U B R O U T I N E =======================================
//
void cseg_31F79()
{
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_31FCA;                    // jz short cseg_31FCA

    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    al = (byte)readMemory(esi + 13, 1);     // mov al, [esi+13]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 7
    A6 = eax;                               // mov A6, eax
    A2 = 318944;                            // mov A2, offset dseg_10EFD6
    { cseg_32E15(); return; }               // jmp cseg_32E15

cseg_31FCA:;
    ax = D1;                                // mov ax, word ptr D1
    bx = 6;                                 // mov bx, 6
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    esi = A0;                               // mov esi, A0
    eax = D0;                               // mov eax, D0
    al = (byte)readMemory(esi + eax + 13, 1); // mov al, [esi+eax+13]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_3283C();                           // jmp cseg_3283C
}

// =============== S U B R O U T I N E =======================================
//
void cseg_32024()
{
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_3207B;                    // jz short cseg_3207B

    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    al = (byte)readMemory(esi + 10, 1);     // mov al, [esi+0Ah]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    {
        word res = *(word *)&D7 & 255;
        *(word *)&D7 = res;
    }                                       // and word ptr D7, 0FFh
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 7
    A6 = eax;                               // mov A6, eax
    A2 = 319232;                            // mov A2, offset dseg_10F0F6
    { cseg_32E15(); return; }               // jmp cseg_32E15

cseg_3207B:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 10, 1);     // mov al, [esi+0Ah]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_32128();                           // jmp cseg_32128
}

// =============== S U B R O U T I N E =======================================
//
void cseg_320A3()
{
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_320FA;                    // jz short cseg_320FA

    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    al = (byte)readMemory(esi + 15, 1);     // mov al, [esi+15]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    {
        word res = *(word *)&D7 & 255;
        *(word *)&D7 = res;
    }                                       // and word ptr D7, 0FFh
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 7
    A6 = eax;                               // mov A6, eax
    A2 = 317741;                            // mov A2, offset dseg_10EB23
    { cseg_32E15(); return; }               // jmp cseg_32E15

cseg_320FA:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 15, 1);     // mov al, [esi+15]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_3252E();                           // jmp cseg_3252E
}

// =============== S U B R O U T I N E =======================================
//
void cseg_32128()
{
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    A2 = 319232;                            // mov A2, offset dseg_10F0F6
    LoadTeamFile();                         // call LoadTeamFile
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A4 = eax;                               // mov A4, eax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    bx = 684;                               // mov bx, 2ACh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, eax
    ax = *(word *)&g_memByte[129476];       // mov ax, dseg_E0052
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_321C3;                    // jnz short cseg_321C3

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (!flags.zero)
        goto cseg_321C3;                    // jnz short cseg_321C3

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    if (flags.zero)
        return;                             // jz cseg_323DD

cseg_321C3:;
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 3
    if (!flags.zero)
        goto cseg_32298;                    // jnz cseg_32298

    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_32298;                    // jz cseg_32298

    *(word *)&D4 = 1000;                    // mov word ptr D4, 3E8h

cseg_321EF:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D5;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    bx = 684;                               // mov bx, 2ACh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A1 = eax;                               // mov A1, eax
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_3228B;                    // jz short cseg_3228B

    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_324F2();                           // call cseg_324F2
    if (flags.zero)
        goto cseg_3228B;                    // jz short cseg_3228B

    ax = D0;                                // mov ax, word ptr D0
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    if (flags.zero)
        return;                             // jz cseg_323DD

cseg_3228B:;
    (*(int16_t *)&D4)--;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto cseg_321EF;                    // jns cseg_321EF

cseg_32298:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 20h
    if (flags.carry || flags.zero)
        goto cseg_3231B;                    // jbe short cseg_3231B

    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3231B;                    // jz short cseg_3231B

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A1 = eax;                               // mov A1, eax

cseg_322C9:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_324F2();                           // call cseg_324F2
    if (flags.zero)
        goto cseg_32303;                    // jz short cseg_32303

    ax = D0;                                // mov ax, word ptr D0
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    if (flags.zero)
        return;                             // jz cseg_323DD

cseg_32303:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 2ACh
    A1 = eax;                               // mov A1, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_322C9;                    // jns short cseg_322C9

cseg_3231B:;
    *(word *)&D3 = 2;                       // mov word ptr D3, 2
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 64;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 40h
    if (!flags.carry)
        goto cseg_32341;                    // jnb short cseg_32341

    *(word *)&D3 = 1;                       // mov word ptr D3, 1
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 20h
    if (flags.carry)
        goto cseg_32387;                    // jb short cseg_32387

cseg_32341:;
    *(word *)&D2 = 0;                       // mov word ptr D2, 0

cseg_3234A:;
    *(word *)&D4 = 1000;                    // mov word ptr D4, 3E8h

cseg_32353:;
    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_323DD

    cseg_323DE();                           // call cseg_323DE
    (*(int16_t *)&D4)--;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto cseg_32353;                    // jns short cseg_32353

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_3234A;                    // jnz short cseg_3234A

cseg_32387:;
    A3 = 487647;                            // mov A3, offset dseg_172C38
    A6 = 252468;                            // mov A6, (offset teamFileBuffer+2)
    ax = *(word *)&g_memByte[252466];       // mov ax, word ptr teamFileBuffer
    {
        byte tmp = al;
        al = ah;
        ah = tmp;
    }                                       // xchg ah, al
    *(word *)&D5 = ax;                      // mov word ptr D5, ax

cseg_323A9:;
    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_323DD

    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 31;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 1Fh
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    cseg_323DE();                           // call cseg_323DE
    goto cseg_323A9;                        // jmp short cseg_323A9
}

// =============== S U B R O U T I N E =======================================
//
void cseg_323DE()
{
    A6 = 252468;                            // mov A6, (offset teamFileBuffer+2)
    ax = *(word *)&g_memByte[252466];       // mov ax, word ptr teamFileBuffer
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_324F1

    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D5;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        dword res = D0 >> 8;
        D0 = res;
    }                                       // shr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A6;                               // mov eax, A6
    A1 = eax;                               // mov A1, eax
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 25, 1);     // mov al, [esi+19h]
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.zero)
        return;                             // jnz cseg_324F1

    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_324F2();                           // call cseg_324F2
    if (flags.zero)
        return;                             // jz short cseg_324F1

    ax = D0;                                // mov ax, word ptr D0
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    FindTeamInCache();                      // call FindTeamInCache
    if (flags.zero)
        return;                             // jz short cseg_324F1

    *(word *)&D0 = 341;                     // mov word ptr D0, 155h

cseg_324B3:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A4 = res;
    }                                       // add A4, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_324B3;                    // jns short cseg_324B3

    esi = A4;                               // mov esi, A4
    writeMemory(esi + -680, 1, 1);          // mov byte ptr [esi-2A8h], 1
    {
        word src = *(word *)&g_memByte[131757];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[131757] = src;
    }                                       // add g_numSelectedTeams, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_324F2()
{
    A0 = 319232;                            // mov A0, offset dseg_10F0F6

cseg_324FC:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, eax
    if (flags.zero)
        goto cseg_32526;                    // jz short cseg_32526

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_324FC;                    // jnz short cseg_324FC

    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

cseg_32526:;
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3252E()
{
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    A2 = 317741;                            // mov A2, offset dseg_10EB23
    LoadTeamFile();                         // call LoadTeamFile
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A4 = eax;                               // mov A4, eax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, eax
    ax = *(word *)&g_memByte[129476];       // mov ax, dseg_E0052
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_325BD;                    // jnz short cseg_325BD

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (!flags.zero)
        goto cseg_325BD;                    // jnz short cseg_325BD

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    if (flags.zero)
        return;                             // jz cseg_327DF

cseg_325BD:;
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 3
    if (!flags.zero)
        goto cseg_32692;                    // jnz cseg_32692

    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_32692;                    // jz cseg_32692

    *(word *)&D4 = 1000;                    // mov word ptr D4, 3E8h

cseg_325E9:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D5;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    bx = 684;                               // mov bx, 2ACh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A1 = eax;                               // mov A1, eax
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_32685;                    // jz short cseg_32685

    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_327E0();                           // call cseg_327E0
    if (flags.zero)
        goto cseg_32685;                    // jz short cseg_32685

    ax = D0;                                // mov ax, word ptr D0
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    if (flags.zero)
        return;                             // jz cseg_327DF

cseg_32685:;
    (*(int16_t *)&D4)--;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto cseg_325E9;                    // jns cseg_325E9

cseg_32692:;
    A3 = 2612;                              // mov A3, offset cseg_3281C
    A6 = 252468;                            // mov A6, (offset teamFileBuffer+2)
    ax = *(word *)&g_memByte[252466];       // mov ax, word ptr teamFileBuffer
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)&D5 = ax;                      // mov word ptr D5, ax

cseg_326B4:;
    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_327DF

cseg_326C3:;
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 31;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 1Fh
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D5;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    bx = 684;                               // mov bx, 2ACh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A6;                               // mov eax, A6
    A1 = eax;                               // mov A1, eax
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 25, 1);     // mov al, [esi+19h]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_326C3;                    // jnz cseg_326C3

    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_327E0();                           // call cseg_327E0
    if (flags.zero)
        goto cseg_326C3;                    // jz cseg_326C3

    ax = D0;                                // mov ax, word ptr D0
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    FindTeamInCache();                      // call FindTeamInCache
    if (flags.zero)
        goto cseg_326B4;                    // jz cseg_326B4

    *(word *)&D0 = 341;                     // mov word ptr D0, 155h

cseg_3279C:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A4 = res;
    }                                       // add A4, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_3279C;                    // jns short cseg_3279C

    esi = A4;                               // mov esi, A4
    writeMemory(esi + -680, 1, 1);          // mov byte ptr [esi-2A8h], 1
    {
        word src = *(word *)&g_memByte[131757];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[131757] = src;
    }                                       // add g_numSelectedTeams, 1
    goto cseg_326B4;                        // jmp cseg_326B4
}

// =============== S U B R O U T I N E =======================================
//
void cseg_327E0()
{
    A0 = 317741;                            // mov A0, offset dseg_10EB23

cseg_327EA:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, eax
    if (flags.zero)
        goto cseg_32811;                    // jz short cseg_32811

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_327EA;                    // jnz short cseg_327EA

    return;                                 // retn

cseg_32811:;
    D0 |= 65536;
    flags.carry = false;
    flags.sign = (D0 & 0x80000000) != 0;
    flags.zero = D0 == 0;                   // or D0, 10000h
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team number
//      D1 - league index
//      D2 - expected number of teams with that league index
//
void cseg_3283C()
{
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    LoadTeamFile();                         // call LoadTeamFile
    A1 = 252468;                            // mov A1, (offset teamFileBuffer+2)
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax = *(word *)&g_memByte[252466];       // mov ax, word ptr teamFileBuffer
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

l_teams_loop:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 25, 1);     // mov al, [esi+TeamFile.league]
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D6, al
    if (!flags.zero)
        goto l_next_team;                   // jnz short @@next_team

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1

l_next_team:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 684
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_teams_loop;                  // jns short @@teams_loop

    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto l_numbers_match;               // jz short @@numbers_match

    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop

l_numbers_match:;
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A4 = eax;                               // mov A4, eax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, eax
    A2 = 318944;                            // mov A2, offset dseg_10EFD6
    A1 = 252468;                            // mov A1, (offset teamFileBuffer+2)
    ax = *(word *)&g_memByte[252466];       // mov ax, word ptr teamFileBuffer
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

l_teams_loop2:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 25, 1);     // mov al, [esi+TeamFile.league]
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D6, al
    if (!flags.zero)
        goto l_next_team2;                  // jnz @@next_team2

    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A2 = res;
    }                                       // add A2, 2
    FindTeamInCache();                      // call FindTeamInCache
    if (flags.zero)
        goto l_next_team2;                  // jz short @@next_team2

    {
        word src = *(word *)&g_memByte[131757];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[131757] = src;
    }                                       // add g_numSelectedTeams, 1
    *(word *)&D0 = 341;                     // mov word ptr D0, 341

l_copy_team_loop:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A4 = res;
    }                                       // add A4, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_team_loop;              // jns short @@copy_team_loop

    esi = A4;                               // mov esi, A4
    writeMemory(esi + -680, 1, 1);          // mov byte ptr [esi-680], 1
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 684;
        dword res = dstSigned - srcSigned;
        A1 = res;
    }                                       // sub A1, 684

l_next_team2:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 684
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_teams_loop2;                 // jns @@teams_loop2
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 - team file extension number
//                   (100 = customs.edt)
// out:
//      A0 - 0 = ok, 1 = error
//      zero flag: set - all ok
//                 clear - error
//
// globals:
//      read: teamsLoaded - if false forces team loading
//            skipLeagueNumbers - if true skips setting league numbers
//
// Loads requested file into teamFileBuffer.
// Sets numberOfTeams and sizeOfTeamFile.
// Team file must be max. 64000 bytes or the program will exit.
//
void LoadTeamFile()
{
_l_start:;
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ax = *(word *)&g_memByte[323894];       // mov ax, teamsLoaded
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_load_file;                   // jz short @@load_file

    al = g_memByte[316572];                 // mov al, lastLoadedExtNumber
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto l_loaded_ok;                   // jz @@loaded_ok

l_load_file:;
    *(word *)&g_memByte[323894] = 1;        // mov teamsLoaded, 1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 100;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 100
    if (!flags.zero)
        goto l_not_edited_file;             // jnz short @@not_edited_file

    al = D0;                                // mov al, byte ptr D0
    g_memByte[316572] = al;                 // mov lastLoadedExtNumber, al
    A0 = 252426;                            // mov A0, offset aCustoms_edt
    A1 = 252466;                            // mov A1, offset teamFileBuffer
    SWOS::LoadFile();                       // call LoadFile
    if (!flags.zero)
        goto l_customs_file_error;          // jnz @@customs_file_error

    {
        int32_t dstSigned = D1;
        int32_t srcSigned = 64000;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, 64000
    if (!flags.carry && !flags.zero)
        { FatalError(); return; }           // ja FatalError

    SetLoadedTeamsGlobalNumbers();          // call SetLoadedTeamsGlobalNumbers
    goto l_skip_setting_league_numbers;     // jmp @@skip_setting_league_numbers

l_not_edited_file:;
    al = D0;                                // mov al, byte ptr D0
    g_memByte[316572] = al;                 // mov lastLoadedExtNumber, al
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = '0';
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, '0'
    al = D0;                                // mov al, byte ptr D0
    g_memByte[252422] = al;                 // mov byte ptr aDataTeam_nnn+0Ah, al
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 10;                                // mov bx, 10
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = '0';
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, '0'
    al = D0;                                // mov al, byte ptr D0
    g_memByte[252423] = al;                 // mov byte ptr aDataTeam_nnn+0Bh, al
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = '0';
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, '0'
    al = D0;                                // mov al, byte ptr D0
    g_memByte[252424] = al;                 // mov byte ptr aDataTeam_nnn+0Ch, al
    A0 = 252412;                            // mov A0, offset aDataTeam_nnn
    A1 = 316520;                            // mov A1, offset teamFilenameBuffer
    StringCopy();                           // call StringCopy
    A0 = 316520;                            // mov A0, offset teamFilenameBuffer
    A1 = 252466;                            // mov A1, offset teamFileBuffer
    SWOS::LoadFile();                       // call LoadFile
    if (!flags.zero)
        goto l_second_try;                  // jnz @@second_try

    {
        int32_t dstSigned = D1;
        int32_t srcSigned = 64000;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, 64000
    if (!flags.carry && !flags.zero)
        { FatalError(); return; }           // ja FatalError

    SetLoadedTeamsGlobalNumbers();          // call SetLoadedTeamsGlobalNumbers
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto l_skip_setting_league_numbers; // jnz short @@skip_setting_league_numbers

    ax = *(word *)&g_memByte[487679];       // mov ax, skipLeagueNumbers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_skip_setting_league_numbers; // jnz short @@skip_setting_league_numbers

    SetLeagueNumbers();                     // call SetLeagueNumbers

l_skip_setting_league_numbers:;
    A0 = 252466;                            // mov A0, offset teamFileBuffer
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)&g_memByte[316570] = ax;       // mov numberOfTeams, ax
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        D0 = res;
    }                                       // add D0, 2
    eax = D0;                               // mov eax, D0
    *(dword *)&g_memByte[316516] = eax;     // mov sizeOfTeamFile, eax

l_loaded_ok:;
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    return;                                 // retn

l_second_try:;
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    goto _l_start;                          // jmp LoadTeamFile

l_customs_file_error:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -1
    if (!flags.zero)
        goto l_to_err_out;                  // jnz short @@to_err_out

    A0 = 19993;                             // mov A0, offset aEditedCustomTe
    SWOS::ShowErrorMenu();                  // call ShowErrorMenu
    goto l_err_out;                         // jmp short @@err_out

l_to_err_out:;
    nullsub_9();                            // call nullsub_9

l_err_out:;
    *(word *)&g_memByte[323894] = 0;        // mov teamsLoaded, 0
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void SetLoadedTeamsGlobalNumbers()
{
    A0 = 252466;                            // mov A0, offset teamFileBuffer
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 2
    A0 = eax;                               // mov A0, eax
    SetTeamGlobalNumbers();                 // jmp SetTeamGlobalNumbers
}

// =============== S U B R O U T I N E =======================================

// Called by LoadTeam only for career teams.
//
void SetLeagueNumbers()
{
    A1 = 96218;                             // mov A1, offset someLeaguesTable
    A0 = 252466;                            // mov A0, offset teamFileBuffer
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

l_next_team:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+TeamFile.globalTeamNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 25, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 25, 1, src);
    }                                       // add [esi+TeamFile.league], al
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 684
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_next_team;                   // jns short @@next_team
}

// =============== S U B R O U T I N E =======================================
//
void FatalError()
{
    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      A6 -
//      D7 -
//
void cseg_32E15()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    A5 = 487681;                            // mov A5, offset dseg_172C5A
    eax = A6;                               // mov eax, A6
    A4 = eax;                               // mov A4, eax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1

cseg_32E97:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    (*(int32_t *)&A5)++;                    // inc A5
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // add A4, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    FindTeamInCache();                      // call FindTeamInCache
    if (!flags.zero)
        goto cseg_32ECD;                    // jnz short cseg_32ECD

    esi = A5;                               // mov esi, A5
    writeMemory(esi + -1, 1, 1);            // mov byte ptr [esi-1], 1

cseg_32ECD:;
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto cseg_32E97;                    // jns short cseg_32E97

    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A5 = eax;                               // mov A5, eax
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, eax

cseg_32F11:;
    A4 = 487681;                            // mov A4, offset dseg_172C5A
    eax = A6;                               // mov eax, A6
    A3 = eax;                               // mov A3, eax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_32F39:;
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_32F60;                    // jz short cseg_32F60

    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A3 = res;
    }                                       // add A3, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_32F39;                    // jns short cseg_32F39

    goto cseg_330F4;                        // jmp cseg_330F4

cseg_32F60:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SearchTeamInTmdFile();                  // call SearchTeamInTmdFile
    if (!flags.zero)
        goto cseg_32FCC;                    // jnz short cseg_32FCC

    *(word *)&D0 = 341;                     // mov word ptr D0, 341

cseg_32F7F:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A5 = res;
    }                                       // add A5, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_32F7F;                    // jns short cseg_32F7F

    esi = A5;                               // mov esi, A5
    writeMemory(esi + -680, 1, 1);          // mov byte ptr [esi-680], 1
    esi = A4;                               // mov esi, A4
    writeMemory(esi + -1, 1, 1);            // mov byte ptr [esi-1], 1
    {
        word src = *(word *)&g_memByte[131757];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[131757] = src;
    }                                       // add g_numSelectedTeams, 1
    goto cseg_32F11;                        // jmp cseg_32F11

cseg_32FCC:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    LoadTeamFile();                         // call LoadTeamFile
    al = g_memByte[316572];                 // mov al, lastLoadedExtNumber
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    A4 = 487681;                            // mov A4, offset dseg_172C5A
    eax = A6;                               // mov eax, A6
    A1 = eax;                               // mov A1, eax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_33015:;
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_330DB;                    // jnz cseg_330DB

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = D5;                                // mov al, byte ptr D5
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto cseg_330DB;                    // jnz cseg_330DB

    A0 = 252466;                            // mov A0, offset teamFileBuffer
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = -682;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, -682

cseg_3306E:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 684
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_3306E;                    // jnz short cseg_3306E

    *(word *)&D0 = 341;                     // mov word ptr D0, 341

cseg_33093:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A5 = res;
    }                                       // add A5, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_33093;                    // jns short cseg_33093

    esi = A5;                               // mov esi, A5
    writeMemory(esi + -680, 1, 1);          // mov byte ptr [esi-680], 1
    esi = A4;                               // mov esi, A4
    writeMemory(esi + -1, 1, 1);            // mov byte ptr [esi-1], 1
    {
        word src = *(word *)&g_memByte[131757];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[131757] = src;
    }                                       // add g_numSelectedTeams, 1

cseg_330DB:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_33015;                    // jns cseg_33015

    goto cseg_32F11;                        // jmp cseg_32F11

cseg_330F4:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_330FC:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 2
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A2 = res;
    }                                       // add A2, 2
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_330FC;                    // jns short cseg_330FC

    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void LoadCareerFile()
{
    push(A0);                               // push A0
    SaveOptions();                          // call SaveOptions
    pop(A0);                                // pop A0
    A1 = 36606;                             // mov A1, offset careerFileBuffer
    SWOS::LoadFile();                       // call LoadFile
    if (!flags.zero)
        goto l_read_error;                  // jnz short @@read_error

    SetZeroFlag2();                         // call SetZeroFlag2
    if (!flags.zero)
        goto l_impossible_jump;             // jnz short @@impossible_jump

    ProcessCareerFile();                    // call ProcessCareerFile
    CycleMenuMusic();                       // call CycleMenuMusic
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

l_read_error:;
    nullsub_9();                            // call nullsub_9

l_impossible_jump:;
    RestoreOptions();                       // call RestoreOptions
    InitUserTactics();                      // call InitUserTactics
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> filename to save
//
void SaveCareerFile()
{
    push(A0);                               // push A0
    nullsub_9();                            // call nullsub_9
    D1 = 131757;                            // mov D1, offset g_numSelectedTeams
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        D0 = res;
    }                                       // add D0, 2
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    A1 = 36606;                             // mov A1, offset careerFileBuffer
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // sub D1, eax
    SWOS::WriteFile();                      // call WriteFile
    if (flags.zero)
        goto l_out;                         // jz short @@out

    nullsub_9();                            // call nullsub_9
    *(word *)&D0 = 1;                       // mov word ptr D0, 1

l_out:;
    pop(A0);                                // pop A0
}

// =============== S U B R O U T I N E =======================================
//
void j_LoadCareerFile()
{
    LoadCareerFile();                       // jmp LoadCareerFile
}

// =============== S U B R O U T I N E =======================================
//
void j_SaveCareerFile()
{
    SaveCareerFile();                       // jmp SaveCareerFile
}

// =============== S U B R O U T I N E =======================================
//
void LoadPresetFile()
{
    push(A0);                               // push A0
    SaveOptions();                          // call SaveOptions
    pop(A0);                                // pop A0
    A1 = 126568;                            // mov A1, offset competitionFileBuffer
    SWOS::LoadFile();                       // call LoadFile
    if (!flags.zero)
        goto cseg_332A6;                    // jnz short cseg_332A6

    SetZeroFlag2();                         // call SetZeroFlag2
    if (!flags.zero)
        goto cseg_332AB;                    // jnz short cseg_332AB

    CycleMenuMusic();                       // call CycleMenuMusic
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

cseg_332A6:;
    nullsub_9();                            // call nullsub_9

cseg_332AB:;
    RestoreOptions();                       // call RestoreOptions
    InitUserTactics();                      // call InitUserTactics
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//     A0 -> filename
//
void SavePresetCompetitionFile()
{
    nullsub_9();                            // call nullsub_9
    D1 = 131757;                            // mov D1, offset g_numSelectedTeams
    ax = *(word *)&g_memByte[126617];       // mov ax, numDiyTeams
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        D0 = res;
    }                                       // add D0, 2
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    A1 = 126568;                            // mov A1, offset competitionFileBuffer
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // sub D1, eax
    SWOS::WriteFile();                      // call WriteFile
    if (flags.zero)
        return;                             // jz short @@out

    nullsub_9();                            // call nullsub_9
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> diy filename to load
// out:
//      D1 = file size
//      D0 = 0 : OK,  = 1 : error
//      zero flag: set = OK, clear = error
//
//      [can not fail, because LoadFile ends program if error]
//
void LoadDIYFile()
{
    push(A0);                               // push A0
    SaveOptions();                          // call SaveOptions
    pop(A0);                                // pop A0
    A1 = 126568;                            // mov A1, offset competitionFileBuffer
    SWOS::LoadFile();                       // call LoadFile
    if (!flags.zero)
        goto l_error_loading_diy;           // jnz short @@error_loading_diy

    SetZeroFlag2();                         // call SetZeroFlag2
    if (!flags.zero)
        goto l_restore_options;             // jnz short @@restore_options

    CycleMenuMusic();                       // call CycleMenuMusic
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

l_error_loading_diy:;
    nullsub_9();                            // call nullsub_9

l_restore_options:;
    RestoreOptions();                       // call RestoreOptions
    InitUserTactics();                      // call InitUserTactics
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void SaveDIYFile()
{
    nullsub_9();                            // call nullsub_9
    D1 = 131757;                            // mov D1, offset g_numSelectedTeams
    ax = *(word *)&g_memByte[126617];       // mov ax, numDiyTeams
    bx = 684;                               // mov bx, 684
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        D0 = res;
    }                                       // add D0, 2
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D1 = res;
    }                                       // add D1, eax
    A1 = 126568;                            // mov A1, offset competitionFileBuffer
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // sub D1, eax
    SWOS::WriteFile();                      // call WriteFile
    if (flags.zero)
        return;                             // jz short @@out

    nullsub_9();                            // call nullsub_9
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 =  number of teams
//      A0 -> first team
//
void SetTeamGlobalNumbers()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    if (flags.sign)
        goto l_out;                         // js @@out

    A1 = 487135;                            // mov A1, offset teamsCountryNumbers

l_teams_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 255;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFh
    {
        word res = *(word *)&D1 << 1;
        *(word *)&D1 = res;
    }                                       // shl word ptr D1, 1
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        word res = *(word *)&D2 & 255;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 0FFh
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 2, 2, ax);            // mov [esi+2], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 684
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_teams_loop;                  // jns short @@teams_loop

l_out:;
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void ProcessCareerFile()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    A0 = 99944;                             // mov A0, offset arrayOfPointers
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 126568);            // mov dword ptr [esi], offset competitionFileBuffer
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 99964);             // mov dword ptr [esi], offset dseg_D8D0A
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 102862);            // mov dword ptr [esi], offset dseg_D985C
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 105044);            // mov dword ptr [esi], offset dseg_DA0E2
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 103953);            // mov dword ptr [esi], offset dseg_D9C9F
    *(dword *)&g_memByte[131738] = 131759;  // mov selTeamsPtr, offset g_selectedTeams
    {
        word src = *(word *)&g_memByte[91676];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp isNationalSelector, 1
    if (!flags.zero)
        goto cseg_33816;                    // jnz short cseg_33816

    cseg_66A98();                           // call cseg_66A98
    A6 = 91694;                             // mov A6, offset dseg_D6CBC
    goto cseg_3382E;                        // jmp short cseg_3382E

cseg_33816:;
    esi = 33933;                            // mov esi, offset competitionsTable
    ebx = *(word *)&g_memByte[131744];      // movzx ebx, compCountryNumber
    {
        dword res = ebx << 2;
        ebx = res;
    }                                       // shl ebx, 2
    esi = readMemory(esi + ebx, 4);         // mov esi, [esi+ebx]
    A6 = esi;                               // mov A6, esi

cseg_3382E:;
    *(dword *)&g_memByte[99884] = 0;        // mov dseg_D8CBA, 0
    *(dword *)&g_memByte[99890] = 0;        // mov dseg_D8CC0, 0
    *(dword *)&g_memByte[99880] = 0;        // mov dseg_D8CB6, 0
    *(dword *)&g_memByte[99872] = 0;        // mov dseg_D8CAE, 0
    *(dword *)&g_memByte[99876] = 0;        // mov dseg_D8CB2, 0
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 4
    *(dword *)&g_memByte[99868] = eax;      // mov dseg_D8CAA, eax
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 4
    esi = A6;                               // mov esi, A6
    {
        dword src = readMemory(esi, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi], 0FFFFFFFFh
    if (flags.zero)
        goto cseg_338BC;                    // jz short cseg_338BC

    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 4
    *(dword *)&g_memByte[99872] = eax;      // mov dseg_D8CAE, eax
    esi = A6;                               // mov esi, A6
    {
        dword src = readMemory(esi, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi], 0FFFFFFFFh
    if (flags.zero)
        goto cseg_338BC;                    // jz short cseg_338BC

    eax = readMemory(esi, 4);               // mov eax, [esi]
    *(dword *)&g_memByte[99876] = eax;      // mov dseg_D8CB2, eax

cseg_338BC:;
    {
        word src = *(word *)&g_memByte[91676];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp isNationalSelector, 1
    if (flags.zero)
        goto l_out;                         // jz @@out

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (!flags.zero)
        goto l_out;                         // jnz @@out

    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    bx = 6;                                 // mov bx, 6
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A1;                               // mov eax, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 18, 1);     // mov al, [esi+12h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_3396D;                    // jz short cseg_3396D

    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 18;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 12h
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    *(dword *)&g_memByte[99884] = eax;      // mov dseg_D8CBA, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    *(dword *)&g_memByte[99890] = eax;      // mov dseg_D8CC0, eax

cseg_3396D:;
    {
        word src = *(word *)&g_memByte[131745];
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_E092F, 0FFFFh
    if (flags.zero)
        goto l_out;                         // jz short @@out

    A0 = 108070;                            // mov A0, offset euroCupCopy
    {
        word src = *(word *)&g_memByte[131745];
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_E092F, 0
    if (flags.zero)
        goto cseg_339B5;                    // jz short cseg_339B5

    A0 = 108149;                            // mov A0, offset cupWinnersCupCopy
    {
        word src = *(word *)&g_memByte[131745];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_E092F, 1
    if (flags.zero)
        goto cseg_339B5;                    // jz short cseg_339B5

    A0 = 108241;                            // mov A0, offset uefaCupCopy
    {
        word src = *(word *)&g_memByte[131745];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_E092F, 2
    if (flags.zero)
        goto cseg_339B5;                    // jz short cseg_339B5

    goto l_out;                             // jmp short @@out

cseg_339B5:;
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[99880] = eax;      // mov dseg_D8CB6, eax

l_out:;
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_33A1A()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    LoadTeamFile();                         // call LoadTeamFile
    ax = *(word *)&g_memByte[252466];       // mov ax, word ptr teamFileBuffer
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    A0 = 252468;                            // mov A0, (offset teamFileBuffer+2)
    A1 = 456386;                            // mov A1, offset dseg_168967
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_33AA6:;
    eax = A0;                               // mov eax, A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 2ACh
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_33AA6;                    // jns short cseg_33AA6

    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, 2

cseg_33AE6:;
    A1 = 456386;                            // mov A1, offset dseg_168967
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D6 = ax;                      // mov word ptr D6, ax

cseg_33AFC:;
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 4
    A0 = eax;                               // mov A0, eax
    push(D1);                               // push small [word ptr D1]
    push(D2);                               // push small [word ptr D2]
    push(D3);                               // push small [word ptr D3]
    push(D4);                               // push small [word ptr D4]
    push(D5);                               // push small [word ptr D5]
    push(D6);                               // push small [word ptr D6]
    push(D7);                               // push small [word ptr D7]
    push(A0);                               // push small [word ptr A0]
    push(A1);                               // push small [word ptr A1]
    push(A2);                               // push small [word ptr A2]
    push(A3);                               // push small [word ptr A3]
    push(A4);                               // push small [word ptr A4]
    push(A5);                               // push small [word ptr A5]
    push(A6);                               // push small [word ptr A6]
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    {
        int32_t val = stack[stackTop++];
        *(word *)&A6 = val;
    }                                       // pop small [word ptr A6]
    {
        int32_t val = stack[stackTop++];
        *(word *)&A5 = val;
    }                                       // pop small [word ptr A5]
    {
        int32_t val = stack[stackTop++];
        *(word *)&A4 = val;
    }                                       // pop small [word ptr A4]
    {
        int32_t val = stack[stackTop++];
        *(word *)&A3 = val;
    }                                       // pop small [word ptr A3]
    {
        int32_t val = stack[stackTop++];
        *(word *)&A2 = val;
    }                                       // pop small [word ptr A2]
    {
        int32_t val = stack[stackTop++];
        *(word *)&A1 = val;
    }                                       // pop small [word ptr A1]
    {
        int32_t val = stack[stackTop++];
        *(word *)&A0 = val;
    }                                       // pop small [word ptr A0]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D7 = val;
    }                                       // pop small [word ptr D7]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D6 = val;
    }                                       // pop small [word ptr D6]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D5 = val;
    }                                       // pop small [word ptr D5]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D4 = val;
    }                                       // pop small [word ptr D4]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D3 = val;
    }                                       // pop small [word ptr D3]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D2 = val;
    }                                       // pop small [word ptr D2]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D1 = val;
    }                                       // pop small [word ptr D1]
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    push(D1);                               // push small [word ptr D1]
    push(D2);                               // push small [word ptr D2]
    push(D3);                               // push small [word ptr D3]
    push(D4);                               // push small [word ptr D4]
    push(D5);                               // push small [word ptr D5]
    push(D6);                               // push small [word ptr D6]
    push(D7);                               // push small [word ptr D7]
    push(A0);                               // push small [word ptr A0]
    push(A1);                               // push small [word ptr A1]
    push(A2);                               // push small [word ptr A2]
    push(A3);                               // push small [word ptr A3]
    push(A4);                               // push small [word ptr A4]
    push(A5);                               // push small [word ptr A5]
    push(A6);                               // push small [word ptr A6]
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    {
        int32_t val = stack[stackTop++];
        *(word *)&A6 = val;
    }                                       // pop small [word ptr A6]
    {
        int32_t val = stack[stackTop++];
        *(word *)&A5 = val;
    }                                       // pop small [word ptr A5]
    {
        int32_t val = stack[stackTop++];
        *(word *)&A4 = val;
    }                                       // pop small [word ptr A4]
    {
        int32_t val = stack[stackTop++];
        *(word *)&A3 = val;
    }                                       // pop small [word ptr A3]
    {
        int32_t val = stack[stackTop++];
        *(word *)&A2 = val;
    }                                       // pop small [word ptr A2]
    {
        int32_t val = stack[stackTop++];
        *(word *)&A1 = val;
    }                                       // pop small [word ptr A1]
    {
        int32_t val = stack[stackTop++];
        *(word *)&A0 = val;
    }                                       // pop small [word ptr A0]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D7 = val;
    }                                       // pop small [word ptr D7]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D6 = val;
    }                                       // pop small [word ptr D6]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D5 = val;
    }                                       // pop small [word ptr D5]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D4 = val;
    }                                       // pop small [word ptr D4]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D3 = val;
    }                                       // pop small [word ptr D3]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D2 = val;
    }                                       // pop small [word ptr D2]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D1 = val;
    }                                       // pop small [word ptr D1]
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.carry)
        goto cseg_33CF6;                    // jnb short cseg_33CF6

    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + -4, 4);          // mov eax, [esi-4]
    D0 = eax;                               // mov D0, eax
    eax = readMemory(esi, 4);               // mov eax, [esi]
    writeMemory(esi + -4, 4, eax);          // mov [esi-4], eax
    eax = D0;                               // mov eax, D0
    writeMemory(esi, 4, eax);               // mov [esi], eax

cseg_33CF6:;
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto cseg_33AFC;                    // jns cseg_33AFC

    (*(int16_t *)&D5)--;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto cseg_33AE6;                    // jns cseg_33AE6

    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, 2
    A1 = 456386;                            // mov A1, offset dseg_168967

cseg_33D2E:;
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 3
    if (!flags.zero)
        goto cseg_33D69;                    // jnz short cseg_33D69

    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    D0 = eax;                               // mov D0, eax
    eax = readMemory(esi + 4, 4);           // mov eax, [esi+4]
    writeMemory(esi, 4, eax);               // mov [esi], eax
    eax = D0;                               // mov eax, D0
    writeMemory(esi + 4, 4, eax);           // mov [esi+4], eax

cseg_33D69:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 4
    A1 = eax;                               // mov A1, eax
    (*(int16_t *)&D5)--;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto cseg_33D2E;                    // jns short cseg_33D2E

    A0 = 456386;                            // mov A0, offset dseg_168967
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_33DA7:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A6;                               // mov esi, A6
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A6 = res;
    }                                       // add A6, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_33DA7;                    // jns short cseg_33DA7

    A6 = 456386;                            // mov A6, offset dseg_168967
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_33E38()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+DIY_Competition.competitionType], DIY_CUP
    if (flags.zero)
        goto l_diy_cup;                     // jz @@diy_cup

    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+43]
    *(word *)&g_memByte[336816] = ax;       // mov dseg_114D3A, ax
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+49]
    *(word *)&g_memByte[336826] = ax;       // mov diyNumberOfTeams, ax
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+71]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_33E91;                    // jz short cseg_33E91

    ax = (word)readMemory(esi + 77, 2);     // mov ax, [esi+77]
    *(word *)&g_memByte[336826] = ax;       // mov diyNumberOfTeams, ax

cseg_33E91:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4
    *(dword *)&g_memByte[336818] = eax;     // mov diyNameOfCompetitionPtr, eax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 301;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 301
    A1 = eax;                               // mov A1, eax
    *(dword *)&g_memByte[336822] = eax;     // mov diyTeamsBufferPtr, eax
    *(word *)&g_memByte[336814] = 0;        // mov diyCompetitionType, 0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+71]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_33F6B;                    // jnz cseg_33F6B

    goto cseg_33F74;                        // jmp cseg_33F74

l_diy_cup:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+43]
    *(word *)&g_memByte[336816] = ax;       // mov dseg_114D3A, ax
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+49]
    *(word *)&g_memByte[336826] = ax;       // mov diyNumberOfTeams, ax
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+71]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_33F21;                    // jz short cseg_33F21

    ax = (word)readMemory(esi + 77, 2);     // mov ax, [esi+77]
    *(word *)&g_memByte[336826] = ax;       // mov diyNumberOfTeams, ax

cseg_33F21:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4
    *(dword *)&g_memByte[336818] = eax;     // mov diyNameOfCompetitionPtr, eax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 589
    A1 = eax;                               // mov A1, eax
    *(dword *)&g_memByte[336822] = eax;     // mov diyTeamsBufferPtr, eax
    *(word *)&g_memByte[336814] = 1;        // mov diyCompetitionType, 1
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+71]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_33F6B;                    // jnz short cseg_33F6B

    goto cseg_33F74;                        // jmp short cseg_33F74

cseg_33F6B:;
    *(word *)&g_memByte[336814] = 2;        // mov diyCompetitionType, 2

cseg_33F74:;
    A6 = 487747;                            // mov A6, offset competitionStatsMenu
    SWOS::ShowMenu();                       // call ShowMenu
}

// =============== S U B R O U T I N E =======================================
//
void StatsHighestScorerList()
{
    eax = *(dword *)&g_memByte[336818];     // mov eax, diyNameOfCompetitionPtr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[336816];       // mov ax, dseg_114D3A
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    dseg_1733C6();                          // call dseg_1733C6
}

// =============== S U B R O U T I N E =======================================
//
void CompetitionInfo()
{
    {
        word src = *(word *)&g_memByte[336814];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp diyCompetitionType, 2
    if (flags.zero)
        goto l_diy_tournament;              // jz short @@diy_tournament

    ax = *(word *)&g_memByte[336814];       // mov ax, diyCompetitionType
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_diy_cup;                     // jnz short @@diy_cup

    ShowLeagueInfo();                       // call ShowLeagueInfo
    return;                                 // retn

l_diy_cup:;
    ShowCupInfo();                          // call ShowCupInfo
    return;                                 // retn

l_diy_tournament:;
    ShowTournamentInfo();                   // call ShowTournamentInfo
}

// =============== S U B R O U T I N E =======================================
//
void StatsViewSquads()
{
    eax = *(dword *)&g_memByte[336822];     // mov eax, diyTeamsBufferPtr
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[336826];       // mov ax, diyNumberOfTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[318702];       // mov ax, dseg_10EEE4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    SelectAndShowSquadToView();             // call SelectAndShowSquadToView
}

// =============== S U B R O U T I N E =======================================
//
void StatsExit()
{
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void NullMenuInit()
{
    *(word *)&g_memByte[252398] = 1;        // mov fireResetFlag, 1
}

// =============== S U B R O U T I N E =======================================
//
void CareerMenuInit()
{
    SetDefaultNameAndSurname();             // call SetDefaultNameAndSurname

    CareerMenuFinish();
}

// =============== S U B R O U T I N E =======================================
//
void CareerMenuFinish()
{
    CheckSex();                             // call CheckSex
    SetPlayerCoachFieldColor();             // call SetPlayerCoachFieldColor
    al = g_memByte[91763];                  // mov al, plNationality
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    A0 = 491249;                            // mov A0, offset nationalityOrdinalsArray
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

l_find_nationality_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto l_found;                       // jz short @@found

    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, 1
    goto l_find_nationality_loop;           // jmp short @@find_nationality_loop

l_found:;
    al = D1;                                // mov al, byte ptr D1
    g_memByte[489731] = al;                 // mov nationalityOrdinal, al
    SetNationalityField();                  // call SetNationalityField
}

// =============== S U B R O U T I N E =======================================
//
void SetPlayerCoachFieldColor()
{
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+30]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 13;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Dh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+30], ax
    ax = *(word *)&g_memByte[91722];        // mov ax, coachOrPlayer
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+30]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Bh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+30], ax
}

// =============== S U B R O U T I N E =======================================
//
void ChooseTeamAndStartCareer()
{
    SelectTeamToManage();                   // call SelectTeamToManage
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        { j_SetExitMenuFlag2(); return; }   // jz j_SetExitMenuFlag2

    InitCareer();                           // call InitCareer
    A6 = 489733;                            // mov A6, offset contestMenu
    SWOS::ActivateMenu();                   // jmp ActivateMenu
}

// =============== S U B R O U T I N E =======================================
//
void LoadLiverpool()
{
    *(word *)&g_memByte[91722] = 0;         // mov coachOrPlayer, 0
    *(word *)&D0 = 2065;                    // mov word ptr D0, 811h
    InitCareer();                           // call InitCareer
    A6 = 489733;                            // mov A6, offset contestMenu
    SWOS::ActivateMenu();                   // jmp ActivateMenu
}

// =============== S U B R O U T I N E =======================================
//
void ChangeSex()
{
    {
        word src = *(word *)&g_memByte[91734];
        src ^= 1;
        *(word *)&g_memByte[91734] = src;
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor mrOrMs, 1
    CheckSex();                             // call CheckSex
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void CheckSex()
{
    A0 = 15121;                             // mov A0, offset aMr
    ax = *(word *)&g_memByte[91734];        // mov ax, mrOrMs
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_mr;                          // jz short @@mr

    A0 = 15124;                             // mov A0, offset aMs

l_mr:;
    A1 = 91736;                             // mov A1, offset managerSexBuffer
    StringCopy();                           // jmp StringCopy
}

// =============== S U B R O U T I N E =======================================
//
void SetName()
{
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A0 = eax;                               // mov A0, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    SWOS::InputText();                      // jmp InputText
}

// =============== S U B R O U T I N E =======================================
//
void SetSurname()
{
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A0 = eax;                               // mov A0, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    *(word *)&D0 = 13;                      // mov word ptr D0, 13
    SWOS::InputText();                      // jmp InputText
}

// =============== S U B R O U T I N E =======================================
//
void CoachOrPlayerCoach()
{
    {
        word src = *(word *)&g_memByte[91722];
        src ^= 1;
        *(word *)&g_memByte[91722] = src;
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor coachOrPlayer, 1
    SetPlayerCoachFieldColor();             // call SetPlayerCoachFieldColor
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void j_SetExitMenuFlag2()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ContestMenuInit()
{
    ax = *(word *)&g_memByte[91346];        // mov ax, retired
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_still_active;                // jz short @@still_active

    A6 = 491313;                            // mov A6, offset careerOverMenu
    { SWOS::ActivateMenu(); return; }       // jmp ActivateMenu

l_still_active:;
    ContestSetButtons();                    // call ContestSetButtons
    ContestMenuOnReturn();                  // call ContestMenuOnReturn
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        return;                             // jnz short @@out

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 20
    if (flags.zero)
        return;                             // jz short @@out

    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void ContestMenuOnReturn()
{
    *(word *)&D0 = 17;                      // mov word ptr D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 18;                      // mov word ptr D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 16;                      // mov word ptr D0, 16
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 15;                      // mov word ptr D0, 15
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 19;                      // mov word ptr D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 21;                      // mov word ptr D0, 21
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 14;                      // mov word ptr D0, 14
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 20;                      // mov word ptr D0, 20
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 13;                      // mov word ptr D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_SEASON
    if (flags.zero)
        goto l_season;                      // jz short @@season

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (flags.zero)
        goto l_common_part;                 // jz @@common_part

    return;                                 // retn

l_season:;
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 17;                      // mov word ptr D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 18;                      // mov word ptr D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 16;                      // mov word ptr D0, 16
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 15;                      // mov word ptr D0, 15
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 19;                      // mov word ptr D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 14;                      // mov word ptr D0, 14
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 21;                      // mov word ptr D0, 21
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 13;                      // mov word ptr D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 20;                      // mov word ptr D0, 20
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 15;                      // mov word ptr D0, 15
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    {
        word src = *(word *)&g_memByte[99894];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp seasonNumberOfSquads, 1
    if (flags.zero)
        goto l_one_squad;                   // jz short @@one_squad

    push(D0);                               // push D0
    D0 = 16;                                // mov D0, 16
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17395);        // mov [esi+MenuEntry.fg.string], offset aSquads

l_one_squad:;
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 12;                      // mov word ptr D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

l_common_part:;
    push(D0);                               // push D0
    D0 = 22;                                // mov D0, 22
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    *(word *)&g_memByte[489615] = ax;       // mov gameListY, ax
    {
        word src = *(word *)&g_memByte[489615];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[489615] = src;
    }                                       // add gameListY, 2
    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+MenuEntry.dwHeight]
    *(word *)&g_memByte[489617] = ax;       // mov contestEntryHeight, ax
    {
        word src = *(word *)&g_memByte[489617];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[489617] = src;
    }                                       // sub contestEntryHeight, 4
    PrintNameAndSeason();                   // call PrintNameAndSeason
    nullsub_15();                           // call nullsub_15
    *(word *)&g_memByte[489583] = 0;        // mov dseg_174570, 0
    *(word *)&g_memByte[489585] = 0;        // mov currentGame, 0
    ax = *(word *)&g_memByte[109908];       // mov ax, dseg_DB3E2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[489587] = ax;       // mov dseg_174574, ax
    cseg_34DA3();                           // call cseg_34DA3
    cseg_34D5A();                           // call cseg_34D5A
    cseg_3563E();                           // call cseg_3563E
    ContestSetButtons();                    // call ContestSetButtons
    CheckTransfers();                       // call CheckTransfers
    CheckClubBusiness();                    // call CheckClubBusiness
    CheckJobOffers();                       // call CheckJobOffers
    SetNationalSelectorButtons();           // call SetNationalSelectorButtons
}

// =============== S U B R O U T I N E =======================================
//
void PlayMatchMenu()
{
    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { SeasonFinished(); return; }       // jnz SeasonFinished

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (flags.zero)
        goto l_career;                      // jz short @@career

    ax = *(word *)&g_memByte[99894];        // mov ax, seasonNumberOfSquads
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        { NextMatch(); return; }            // jz NextMatch

l_career:;
    ax = *(word *)&g_memByte[99866];        // mov ax, careerFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_still_playing;               // jz short @@still_playing

    CareerPlayMatch();                      // call CareerPlayMatch
    { SeasonFinished(); return; }           // jmp SeasonFinished

l_still_playing:;
    push(A5);                               // push A5
    cseg_8E3DA();                           // call cseg_8E3DA
    pop(A5);                                // pop A5
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_SEASON
    if (flags.zero)
        goto l_season;                      // jz @@season

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_3B860();                           // call cseg_3B860
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_347A1;                    // jz short cseg_347A1

    cseg_3BEA0();                           // call cseg_3BEA0
    A6 = 489733;                            // mov A6, offset contestMenu
    { SWOS::ActivateMenu(); return; }       // jmp ActivateMenu

cseg_347A1:;
    CheckClubBusiness();                    // call CheckClubBusiness

l_season:;
    cseg_8EA56();                           // call cseg_8EA56
    push(A5);                               // push A5
    cseg_34DA3();                           // call cseg_34DA3
    pop(A5);                                // pop A5
    cseg_350AE();                           // call cseg_350AE
    cseg_34D5A();                           // call cseg_34D5A
    cseg_3563E();                           // call cseg_3563E
    CheckTransfers();                       // call CheckTransfers
    nullsub_15();                           // call nullsub_15
    ax = *(word *)&g_memByte[99866];        // mov ax, careerFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_347EB;                    // jnz short cseg_347EB

    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_347F4

cseg_347EB:;
    *(word *)&g_memByte[252398] = 1;        // mov fireResetFlag, 1
}

// =============== S U B R O U T I N E =======================================
//
void NextMatch()
{
    push(A5);                               // push A5
    cseg_8E469();                           // call cseg_8E469
    pop(A5);                                // pop A5
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_SEASON
    if (flags.zero)
        goto l_season;                      // jz @@season

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_3B860();                           // call cseg_3B860
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_348EC;                    // jz short cseg_348EC

    cseg_3BEA0();                           // call cseg_3BEA0
    A6 = 489733;                            // mov A6, offset contestMenu
    { SWOS::ActivateMenu(); return; }       // jmp ActivateMenu

cseg_348EC:;
    CheckClubBusiness();                    // call CheckClubBusiness

l_season:;
    cseg_8EA56();                           // call cseg_8EA56
    cseg_350AE();                           // call cseg_350AE
    cseg_34DA3();                           // call cseg_34DA3
    cseg_34D5A();                           // call cseg_34D5A
    cseg_3563E();                           // call cseg_3563E
    CheckTransfers();                       // call CheckTransfers
    nullsub_15();                           // call nullsub_15
    ax = *(word *)&g_memByte[99866];        // mov ax, careerFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3492A;                    // jnz short cseg_3492A

    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_34933

cseg_3492A:;
    *(word *)&g_memByte[252398] = 1;        // mov fireResetFlag, 1
}

// =============== S U B R O U T I N E =======================================
//
void ViewCompetitionsMenu()
{
    A6 = 491587;                            // mov A6, offset viewCompetitionsMenu
    SWOS::ShowMenu();                       // call ShowMenu
    cseg_8EA56();                           // call cseg_8EA56
    ContestSetButtons();                    // call ContestSetButtons
    CheckTransfers();                       // call CheckTransfers
    nullsub_15();                           // jmp nullsub_15
}

// =============== S U B R O U T I N E =======================================
//
void SquadMenu()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_SEASON
    if (flags.zero)
        goto l_game_season;                 // jz short @@game_season

    ax = *(word *)&g_memByte[126627];       // mov ax, dseg_DF531
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    { cseg_10520(); return; }               // jmp cseg_10520

l_game_season:;
    ax = *(word *)&g_memByte[99894];        // mov ax, seasonNumberOfSquads
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_349F3;                    // jnz short cseg_349F3

    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+49]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 301;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 301
    A1 = eax;                               // mov A1, eax
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 0
    if (flags.zero)
        goto cseg_349E2;                    // jz short cseg_349E2

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 589
    A1 = eax;                               // mov A1, eax
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (flags.zero)
        goto cseg_349E2;                    // jz short cseg_349E2

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 153;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 153
    A1 = eax;                               // mov A1, eax

cseg_349E2:;
    ax = *(word *)&g_memByte[126627];       // mov ax, dseg_DF531
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    { SelectAndShowSquadToView(); return; } // jmp SelectAndShowSquadToView

cseg_349F3:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_34A1F;                    // jnz short cseg_34A1F

    ax = *(word *)&g_memByte[99896];        // mov ax, dseg_D8CC6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    ax = *(word *)&g_memByte[126627];       // mov ax, dseg_DF531
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    { cseg_1053F(); return; }               // jmp cseg_1053F

cseg_34A1F:;
    A1 = 99896;                             // mov A1, offset dseg_D8CC6
    ax = *(word *)&g_memByte[126627];       // mov ax, dseg_DF531
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    SelectAndShowSquadToView();             // jmp SelectAndShowSquadToView
}

// =============== S U B R O U T I N E =======================================
//
void ClubBussinesMenu()
{
    ShowClubBussinesMenu();                 // jmp ShowClubBussinesMenu
}

// =============== S U B R O U T I N E =======================================
//
void JobOffersMenu()
{
    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, -1
    if (!flags.zero)
        goto cseg_34A7A;                    // jnz short cseg_34A7A

    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_34A60;                    // jnz short cseg_34A60

    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_34AC1

cseg_34A60:;
    *(word *)&g_memByte[518824] = 0;        // mov dseg_17C228, 0
    A6 = 517136;                            // mov A6, offset jobOffersMenu
    SWOS::ShowMenu();                       // call ShowMenu
    goto cseg_34A89;                        // jmp short cseg_34A89

cseg_34A7A:;
    A6 = 518454;                            // mov A6, offset gotJobOfferMenu
    SWOS::ShowMenu();                       // call ShowMenu

cseg_34A89:;
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 6, 2);      // mov ax, [esi+6]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_34AC1

    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void SeasonFinished()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (flags.zero)
        goto l_career;                      // jz short @@career

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    CareerInitVars();                       // call CareerInitVars
    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

l_career:;
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_34B13;                    // jz short cseg_34B13

    cseg_3E11C();                           // call cseg_3E11C
    cseg_3E55C();                           // call cseg_3E55C
    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_34B13;                    // jz short cseg_34B13

    cseg_3BEA0();                           // call cseg_3BEA0
    A6 = 489733;                            // mov A6, offset contestMenu
    { SWOS::ActivateMenu(); return; }       // jmp ActivateMenu

cseg_34B13:;
    push(A5);                               // push A5
    cseg_3C07C();                           // call cseg_3C07C
    pop(A5);                                // pop A5
    A6 = 489733;                            // mov A6, offset contestMenu
    SWOS::ActivateMenu();                   // jmp ActivateMenu
}

// =============== S U B R O U T I N E =======================================
//
void TransfersMenu()
{
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_club;                        // jz short @@club

    { ShowSelectRepresentationMenu(); return; } // jmp ShowSelectRepresentationMenu

l_club:;
    ax = *(word *)&g_memByte[92298];        // mov ax, timeToNegotiate
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_got_time;                    // jnz short @@got_time

    *(word *)&g_memByte[337240] = 3;        // mov currentMessage, NO_MORE_TIME_TO_NEGOTIATE
    { ShowChairmanMessage(); return; }      // jmp ShowChairmanMessage

l_got_time:;
    *(word *)&g_memByte[456254] = -1;       // mov inTransferMarketMenu, -1
    A6 = 511224;                            // mov A6, offset transferMarketMenu
    SWOS::ShowMenu();                       // call ShowMenu
    *(word *)&g_memByte[456254] = 0;        // mov inTransferMarketMenu, 0
}

// =============== S U B R O U T I N E =======================================
//
void ViewWorldMenu()
{
    ChooseCompetitionMenu();                // call ChooseCompetitionMenu
    ax = *(word *)&g_memByte[330694];       // mov ax, chooseTeamsResult
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    eax = *(dword *)&g_memByte[330194];     // mov eax, selectedContest
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[330198];       // mov ax, dseg_1132B9
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_3AA17();                           // call cseg_3AA17
    ContestMenuOnReturn();                  // call ContestMenuOnReturn
}

// =============== S U B R O U T I N E =======================================
//
void jmp_SetExitMenuFlag()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ContestMenuScrollUp()
{
    cseg_34C08();                           // call cseg_34C08
    cseg_3563E();                           // call cseg_3563E
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 22;                                // mov D0, 22
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 15;                      // mov word ptr D0, 15
    SWOS::DrawMenu();                       // call DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_34C08()
{
    {
        word src = *(word *)&g_memByte[489585];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[489585] = src;
    }                                       // sub currentGame, 1
    if (!flags.sign)
        return;                             // jns short @@out

    {
        word src = *(word *)&g_memByte[489583];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[489583] = src;
    }                                       // sub dseg_174570, 1
    if (!flags.sign)
        goto cseg_34C30;                    // jns short cseg_34C30

    *(word *)&g_memByte[489583] = 0;        // mov dseg_174570, 0
    *(word *)&g_memByte[489585] = 0;        // mov currentGame, 0
    return;                                 // jmp short @@out

cseg_34C30:;
    ax = *(word *)&g_memByte[489583];       // mov ax, dseg_174570
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_8E98E();                           // call cseg_8E98E
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_34C69;                    // jz short cseg_34C69

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_34C69:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[489585] = ax;       // mov currentGame, ax
}

// =============== S U B R O U T I N E =======================================
//
void ContestMenuScrollDown()
{
    cseg_34CCA();                           // call cseg_34CCA
    cseg_3563E();                           // call cseg_3563E
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 22;                                // mov D0, 22
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 15;                      // mov word ptr D0, 15
    SWOS::DrawMenu();                       // call DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_34CCA()
{
    ax = *(word *)&g_memByte[489583];       // mov ax, dseg_174570
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_8E98E();                           // call cseg_8E98E
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_34D1B;                    // jz short cseg_34D1B

    ax = *(word *)&g_memByte[489585];       // mov ax, currentGame
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto cseg_34D1B;                    // jz short cseg_34D1B

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[489585] = ax;       // mov currentGame, ax
    return;                                 // jmp short cseg_34D59

cseg_34D1B:;
    ax = *(word *)&g_memByte[489583];       // mov ax, dseg_174570
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = *(word *)&g_memByte[489587];       // mov ax, dseg_174574
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        return;                             // jz short cseg_34D59

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[489583] = ax;       // mov dseg_174570, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    *(word *)&g_memByte[489585] = 0;        // mov currentGame, 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_34D5A()
{
    ax = *(word *)&g_memByte[489589];       // mov ax, dseg_174576
    *(word *)&g_memByte[489583] = ax;       // mov dseg_174570, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_34D87;                    // jns short cseg_34D87

    ax = *(word *)&g_memByte[109904];       // mov ax, dseg_DB3DE
    *(word *)&g_memByte[489583] = ax;       // mov dseg_174570, ax
    *(word *)&g_memByte[489585] = 0;        // mov currentGame, 0
    cseg_34C08();                           // call cseg_34C08
    goto cseg_34D93;                        // jmp short cseg_34D93

cseg_34D87:;
    ax = *(word *)&g_memByte[489591];       // mov ax, dseg_174578
    *(word *)&g_memByte[489585] = ax;       // mov currentGame, ax

cseg_34D93:;
    cseg_34C08();                           // call cseg_34C08
    cseg_34C08();                           // call cseg_34C08
    cseg_34C08();                           // call cseg_34C08
}

// =============== S U B R O U T I N E =======================================
//
void cseg_34DA3()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (flags.zero)
        goto l_career;                      // jz short @@career

    ax = *(word *)&g_memByte[99894];        // mov ax, seasonNumberOfSquads
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_career;                      // jnz short @@career

    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_season_finished;             // jnz @@season_finished

    cseg_8EA56();                           // call cseg_8EA56
    ax = *(word *)&g_memByte[109904];       // mov ax, dseg_DB3DE
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[489589] = ax;       // mov dseg_174576, ax
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[489593] = eax;     // mov dseg_17457A, eax
    *(word *)&g_memByte[489591] = 0;        // mov dseg_174578, 0
    *(dword *)&g_memByte[489597] = eax;     // mov dseg_17457E, eax
    return;                                 // retn

l_career:;
    ax = *(word *)&g_memByte[99866];        // mov ax, careerFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_season_finished;             // jnz @@season_finished

    cseg_8EA56();                           // call cseg_8EA56
    A6 = 109912;                            // mov A6, offset dseg_DB3E6
    ax = *(word *)&g_memByte[109904];       // mov ax, dseg_DB3DE
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_34E2F:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_34ECD;                    // jz cseg_34ECD

    al = (byte)readMemory(esi + 6, 1);      // mov al, [esi+6]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_34ECD;                    // jz cseg_34ECD

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[489589] = ax;       // mov dseg_174576, ax
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[489593] = eax;     // mov dseg_17457A, eax
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 6, 1);      // mov al, [esi+6]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&g_memByte[489591] = ax;       // mov dseg_174578, ax
    bx = 12;                                // mov bx, 12
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, eax
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[489597] = eax;     // mov dseg_17457E, eax
    return;                                 // retn

cseg_34ECD:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    esi = A0;                               // mov esi, A0
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    ax = *(word *)&g_memByte[109908];       // mov ax, dseg_DB3E2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_34E2F;                    // jnz cseg_34E2F

l_season_finished:;
    *(word *)&g_memByte[489589] = -1;       // mov dseg_174576, -1
    *(dword *)&g_memByte[489593] = -1;      // mov dseg_17457A, -1
}

// =============== S U B R O U T I N E =======================================
//
void CheckClubBusiness()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        return;                             // jnz short @@out

    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91352];        // mov ax, clubBusinessActive
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_have_overdraft;              // jnz short @@have_overdraft

    {
        word res = *(word *)&D0 & 57343;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0DFFFh
    goto l_set_string_flag;                 // jmp short @@set_string_flag

l_have_overdraft:;
    *(word *)&D0 |= 8192;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // or word ptr D0, 2000h

l_set_string_flag:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
}

// =============== S U B R O U T I N E =======================================
//
void CheckJobOffers()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        return;                             // jnz @@out

    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 11
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 0);             // mov [esi+MenuEntry.isDisabled], 0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 57343;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0DFFFh
    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, -1
    if (!flags.zero)
        goto l_jobs_waiting;                // jnz short @@jobs_waiting

    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_got_new_job_offers;          // jnz short @@got_new_job_offers

    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_job_offers;               // jz short @@no_job_offers

    return;                                 // retn

l_got_new_job_offers:;
    *(word *)&D1 |= 8192;
    flags.carry = false;
    flags.sign = (*(word *)&D1 & 0x8000) != 0;
    flags.zero = *(word *)&D1 == 0;         // or word ptr D1, 2000h

l_ok_out:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax

l_out:;
    return;                                 // retn

l_jobs_waiting:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17248);        // mov [esi+MenuEntry.fg.string], offset aNewJob
    goto l_ok_out;                          // jmp short @@ok_out

l_no_job_offers:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17265);        // mov [esi+MenuEntry.fg.string], offset aNoJobOffers
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 7;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 7
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    goto l_ok_out;                          // jmp short @@ok_out
}

// =============== S U B R O U T I N E =======================================
//
void cseg_350AE()
{
    ContestSetButtons();                    // call ContestSetButtons
    esi = A5;                               // mov esi, A5
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 17;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2], 11h
    if (flags.zero)
        goto cseg_350CD;                    // jz short cseg_350CD

    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2], 0Ah
    if (!flags.zero)
        return;                             // jnz short cseg_350E6

cseg_350CD:;
    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_350E6

    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void ContestSetButtons()
{
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17344);        // mov [esi+MenuEntry.fg.string], offset aPlayMatch_0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 57343;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0DFFFh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_SEASON
    if (flags.zero)
        goto l_season_game;                 // jz @@season_game

    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_season_finished_not_season_game; // jnz @@season_finished_not_season_game

    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 4
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    ax = *(word *)&g_memByte[99866];        // mov ax, careerFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_career_season_finished;      // jnz short @@career_season_finished

    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    ax = *(word *)&g_memByte[126566];       // mov ax, dseg_DF4F4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D0 |= 8192;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // or word ptr D0, 2000h
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax

l_out:;
    return;                                 // retn

l_career_season_finished:;
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17327);        // mov [esi+MenuEntry.fg.string], offset aFinishSeason
    return;                                 // retn

l_season_finished_not_season_game:;
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17327);        // mov [esi+MenuEntry.fg.string], offset aFinishSeason
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    return;                                 // retn

l_season_game:;
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 4
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 0);             // mov [esi+MenuEntry.isDisabled], 0
    ax = *(word *)&g_memByte[99894];        // mov ax, seasonNumberOfSquads
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_35388;                    // jnz short cseg_35388

    push(D0);                               // push D0
    D0 = 15;                                // mov D0, 15
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17361);        // mov [esi+MenuEntry.fg.string], offset aNextMatch
    SeasonLowerButtons();                   // call SeasonLowerButtons
    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_season_career_finished;      // jnz short @@season_career_finished

    return;                                 // retn

cseg_35388:;
    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_season_lower_buttons;        // jnz short @@season_lower_buttons

    ax = *(word *)&g_memByte[99866];        // mov ax, careerFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_season_career_finished;      // jnz short @@season_career_finished

    return;                                 // retn

l_season_lower_buttons:;
    SeasonLowerButtons();                   // call SeasonLowerButtons

l_season_career_finished:;
    push(D0);                               // push D0
    D0 = 15;                                // mov D0, 15
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17327);        // mov [esi+MenuEntry.fg.string], offset aFinishSeason
}

// =============== S U B R O U T I N E =======================================

// Set "view competitions" and lower "next match" buttons
// lower in line with "exit" and make upper "next match" invisible
//
void SeasonLowerButtons()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    *(word *)&D0 = 17;                      // mov word ptr D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
}

// =============== S U B R O U T I N E =======================================
//
void CheckTransfers()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_national_selector;           // jz short @@national_selector

    cseg_3D597();                           // call cseg_3D597
    if (!flags.zero)
        goto l_disable_transfers;           // jnz @@disable_transfers

    goto cseg_354B6;                        // jmp short cseg_354B6

l_national_selector:;
    ax = *(word *)&g_memByte[126566];       // mov ax, dseg_DF4F4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_disable_transfers;           // jnz @@disable_transfers

cseg_354B6:;
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 0);             // mov [esi+MenuEntry.isDisabled], 0
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[92298];        // mov ax, timeToNegotiate
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_time_to_negotiate;        // jz @@no_time_to_negotiate

    push(A0);                               // push A0
    CheckForTransferOffers();               // call CheckForTransferOffers
    pop(A0);                                // pop A0
    if (!flags.zero)
        goto l_no_time_to_negotiate;        // jnz @@no_time_to_negotiate

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D0 |= 8192;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // or word ptr D0, 2000h
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax

l_out:;
    return;                                 // retn

l_disable_transfers:;
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1

l_no_time_to_negotiate:;
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 57343;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0DFFFh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3563E()
{
    ax = *(word *)&g_memByte[489583];       // mov ax, dseg_174570
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[489585];       // mov ax, currentGame
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    cseg_8E94F();                           // call cseg_8E94F
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    eax = A1;                               // mov eax, A1
    A4 = eax;                               // mov A4, eax
    A3 = 489619;                            // mov A3, offset gameListArray
    ax = *(word *)&g_memByte[489583];       // mov ax, dseg_174570
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = *(word *)&g_memByte[489585];       // mov ax, currentGame
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)&D5 = 13;                      // mov word ptr D5, 13

cseg_3569A:;
    ax = *(word *)&g_memByte[489587];       // mov ax, dseg_174574
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (flags.zero)
        goto cseg_35745;                    // jz cseg_35745

cseg_356AD:;
    eax = A6;                               // mov eax, A6
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 4
    eax = A4;                               // mov eax, A4
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 4
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_3570C;                    // jz short cseg_3570C

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, al
    if (flags.zero)
        goto cseg_3570C;                    // jz short cseg_3570C

    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 12;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A4 = res;
    }                                       // add A4, 12
    (*(int16_t *)&D5)--;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto cseg_356AD;                    // jns short cseg_356AD

    return;                                 // retn

cseg_3570C:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    esi = A6;                               // mov esi, A6
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A6 = res;
    }                                       // add A6, eax
    eax = A6;                               // mov eax, A6
    A4 = eax;                               // mov A4, eax
    (*(int16_t *)&D5)--;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto cseg_3569A;                    // jns cseg_3569A

    return;                                 // retn

cseg_35745:;
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 4, 0);                 // mov dword ptr [esi], 0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 4
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 4, 0);                 // mov dword ptr [esi], 0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A3 = res;
    }                                       // add A3, 4
    (*(int16_t *)&D5)--;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto cseg_35745;                    // jns short cseg_35745
}

// =============== S U B R O U T I N E =======================================
//
void PrintNameAndSeason()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (flags.zero)
        goto l_career;                      // jz short @@career

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 60, 2, 1);            // mov word ptr [esi+60], 1
    writeMemory(esi + 116, 2, 1);           // mov word ptr [esi+116], 1
    return;                                 // retn

l_career:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    writeMemory(esi + 60, 2, 0);            // mov word ptr [esi+60], 0
    writeMemory(esi + 116, 2, 0);           // mov word ptr [esi+116], 0
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 91741;                             // mov A0, offset managerNameBuffer
    GetStringLength();                      // call GetStringLength
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    A0 = 91750;                             // mov A0, offset managerSurnameBuffer
    GetStringLength();                      // call GetStringLength
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    A0 = 91741;                             // mov A0, offset managerNameBuffer
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 12;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 12
    if (flags.carry || flags.zero)
        goto l_copy_whole_name;             // jbe short @@copy_whole_name

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_copy_surname;                // jz short @@copy_surname

    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    goto l_copy_surname;                    // jmp short @@copy_surname

l_copy_whole_name:;
    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1

l_copy_surname:;
    A0 = 91750;                             // mov A0, offset managerSurnameBuffer
    StringCopy();                           // call StringCopy
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    StringCopy();                           // call StringCopy
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    al = g_memByte[129467];                 // mov al, seasonPlaying
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1900;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1900
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1996;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1996
    if (!flags.carry)
        goto l_calc_next_season_number;     // jnb short @@calc_next_season_number

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 100;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 100

l_calc_next_season_number:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 100
    if (flags.carry)
        goto l_less_than_100;               // jb short @@less_than_100

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 100

l_less_than_100:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 10
    if (flags.carry)
        goto l_less_than_10;                // jb short @@less_than_10

    A0 = 9249;                              // mov A0, offset a01Season
    { PrintFormatted(); return; }           // jmp PrintFormatted

l_less_than_10:;
    A0 = 9263;                              // mov A0, offset a001Season
    PrintFormatted();                       // jmp PrintFormatted
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_15()
{
}

// =============== S U B R O U T I N E =======================================
//
void SetNationalSelectorButtons()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 6590);         // mov [esi+MenuEntry.fg.string], offset aSquadSelected
    push(A0);                               // push A0
    cseg_3D597();                           // call cseg_3D597
    pop(A0);                                // pop A0
    if (!flags.zero)
        goto l_team_full;                   // jnz short @@team_full

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 6564);         // mov [esi+MenuEntry.fg.string], offset aChangeSquad
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 20
    if (flags.zero)
        goto l_team_full;                   // jz short @@team_full

    writeMemory(esi + 38, 4, 6577);         // mov [esi+MenuEntry.fg.string], offset aSelectSquad

l_team_full:;
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 4
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 0);             // mov [esi+MenuEntry.isDisabled], 0
    cseg_3D597();                           // call cseg_3D597
    if (flags.zero)
        goto cseg_35B81;                    // jz short cseg_35B81

    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1

cseg_35B81:;
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        word src = *(word *)&g_memByte[94090];
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerNumPlayers, 20
    if (flags.zero)
        return;                             // jz @@out

    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
}

// =============== S U B R O U T I N E =======================================
//
void CareerGameListCommon()
{
    push(D0);                               // push D0
    D0 = 23;                                // mov D0, 23
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (!flags.zero)
        goto l_not_first;                   // jnz short @@not_first

    ax = *(word *)&g_memByte[489615];       // mov ax, gameListY
    *(word *)&g_memByte[489611] = ax;       // mov columnMarker, ax
    *(word *)&g_memByte[489613] = 0;        // mov cglmVar3, 0

l_not_first:;
    ax = *(word *)&g_memByte[489611];       // mov ax, columnMarker
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[489613];       // mov ax, cglmVar3
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_36D7A;                    // jnz cseg_36D7A

    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    {
        word res = *(word *)&D0 << 3;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 3
    A3 = 489619;                            // mov A3, offset gameListArray
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A6 = eax;                               // mov A6, eax
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, 0
    if (flags.zero)
        goto cseg_36D7A;                    // jz cseg_36D7A

    eax = readMemory(esi + ebx + 4, 4);     // mov eax, [esi+ebx+4]
    A4 = eax;                               // mov A4, eax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 37;                                // mov D0, 37
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    *(dword *)&g_memByte[489601] = 331620;  // mov careerGameTopTeamName, offset aError
    *(dword *)&g_memByte[489605] = 331620;  // mov careerGameBottomTeamName, offset aError
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_36052;                    // jz cseg_36052

    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 12, 2);     // mov ax, [esi+12]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A0 = eax;                               // mov A0, eax
    *(dword *)&g_memByte[489601] = eax;     // mov careerGameTopTeamName, eax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 14, 2);     // mov ax, [esi+14]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], 1
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    if (flags.zero)
        goto l_computer_team;               // jz short @@computer_team

    *(byte *)&D0 = -1;                      // mov byte ptr D0, -1

l_computer_team:;
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[489609] = ax;       // mov cglm_team_control, ax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A0 = eax;                               // mov A0, eax
    *(dword *)&g_memByte[489605] = eax;     // mov careerGameBottomTeamName, eax
    esi = A4;                               // mov esi, A4
    {
        byte src = (byte)readMemory(esi + 11, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+11], 0
    if (flags.zero)
        goto cseg_36048;                    // jz cseg_36048

    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    al = (byte)readMemory(esi + 11, 1);     // mov al, [esi+11]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    ax = (word)readMemory(esi + 16, 2);     // mov ax, [esi+16]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = (word)readMemory(esi + 18, 2);     // mov ax, [esi+18]
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+20]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    eax = *(dword *)&g_memByte[489601];     // mov eax, careerGameTopTeamName
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[489605];     // mov eax, careerGameBottomTeamName
    A2 = eax;                               // mov A2, eax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    cseg_289AC();                           // call cseg_289AC
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_36048;                    // jz short cseg_36048

    eax = A0;                               // mov eax, A0
    A2 = eax;                               // mov A2, eax
    goto cseg_36052;                        // jmp short cseg_36052

cseg_36048:;
    A2 = 0;                                 // mov A2, 0

cseg_36052:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A1 = 99868;                             // mov A1, offset dseg_D8CAA
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A1 = eax;                               // mov A1, eax
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 0
    if (flags.zero)
        goto cseg_36134;                    // jz cseg_36134

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 1
    if (flags.zero)
        goto cseg_36149;                    // jz cseg_36149

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 2
    if (flags.zero)
        goto cseg_3615E;                    // jz cseg_3615E

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 3
    if (flags.zero)
        goto cseg_36173;                    // jz cseg_36173

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 4;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 4
    if (flags.zero)
        goto cseg_36188;                    // jz cseg_36188

    A0 = 17229;                             // mov A0, offset aMinus
    eax = A0;                               // mov eax, A0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A5 = res;
    }                                       // add A5, 56
    *(word *)&D5 = 1;                       // mov word ptr D5, 1
    goto cseg_367B5;                        // jmp cseg_367B5

cseg_36134:;
    A0 = 331848;                            // mov A0, offset dseg_11392A
    *(word *)&D5 = 2;                       // mov word ptr D5, 2
    goto cseg_3619B;                        // jmp short cseg_3619B

cseg_36149:;
    A0 = 18121;                             // mov A0, offset aCup_0
    *(word *)&D5 = 6;                       // mov word ptr D5, 6
    goto cseg_3619B;                        // jmp short cseg_3619B

cseg_3615E:;
    A0 = 18132;                             // mov A0, offset aCup_1
    *(word *)&D5 = 15;                      // mov word ptr D5, 0Fh
    goto cseg_3619B;                        // jmp short cseg_3619B

cseg_36173:;
    A0 = 331620;                            // mov A0, offset aError
    *(word *)&D5 = 13;                      // mov word ptr D5, 0Dh
    goto cseg_3619B;                        // jmp short cseg_3619B

cseg_36188:;
    A0 = 18154;                             // mov A0, offset aPlayoffs
    *(word *)&D5 = 14;                      // mov word ptr D5, 0Eh

cseg_3619B:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A3 = 99944;                             // mov A3, offset arrayOfPointers
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A3 = eax;                               // mov A3, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_361FB;                    // jz short cseg_361FB

    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (flags.zero)
        goto cseg_36332;                    // jz cseg_36332

    goto cseg_36576;                        // jmp cseg_36576

cseg_361FB:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 8
    ax = *(word *)&g_memByte[489615];       // mov ax, gameListY
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = *(word *)&g_memByte[489617];       // mov ax, contestEntryHeight
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_36D7A;                    // jnb cseg_36D7A

    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 8
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 8
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_3628C;                    // jnz short cseg_3628C

    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    goto cseg_362DE;                        // jmp short cseg_362DE

cseg_3628C:;
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 3;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 3
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx + 4, 4);     // mov eax, [esi+ebx+4]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, offset aChairmanScenes
    A0 = eax;                               // mov A0, eax

cseg_362DE:;
    eax = A0;                               // mov eax, A0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+22], 8
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A5 = res;
    }                                       // add A5, 56
    goto cseg_367B5;                        // jmp cseg_367B5

cseg_36332:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_3637A;                    // jz short cseg_3637A

    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 4, 4);           // mov eax, [esi+4]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, offset aChairmanScenes
    A0 = eax;                               // mov A0, eax

cseg_3637A:;
    eax = A0;                               // mov eax, A0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (flags.zero)
        goto cseg_363CB;                    // jz short cseg_363CB

    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 8
    ax = *(word *)&g_memByte[489615];       // mov ax, gameListY
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = *(word *)&g_memByte[489617];       // mov ax, contestEntryHeight
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_36D7A;                    // jnb cseg_36D7A

    goto cseg_363FF;                        // jmp short cseg_363FF

cseg_363CB:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 16
    ax = *(word *)&g_memByte[489615];       // mov ax, gameListY
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = *(word *)&g_memByte[489617];       // mov ax, contestEntryHeight
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_36D7A;                    // jnb cseg_36D7A

cseg_363FF:;
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 16;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 16
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 8
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+22], 8
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 9, 1);      // mov al, [esi+9]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 331960;                            // mov A0, offset dseg_11399A
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 3
    if (!flags.zero)
        goto cseg_364BA;                    // jnz short cseg_364BA

    A0 = 332008;                            // mov A0, offset dseg_1139CA
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax

cseg_364BA:;
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    A0 = 17801;                             // mov A0, offset aLeg1
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 1
    if (flags.zero)
        goto cseg_3650F;                    // jz short cseg_3650F

    A0 = 17807;                             // mov A0, offset aLeg2
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 2
    if (flags.zero)
        goto cseg_3650F;                    // jz short cseg_3650F

    A0 = 16239;                             // mov A0, offset aReplay
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 3
    if (!flags.zero)
        goto cseg_36523;                    // jnz short cseg_36523

cseg_3650F:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    StringCopy();                           // call StringCopy

cseg_36523:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_36569;                    // jz short cseg_36569

    {
        byte src = (byte)readMemory(esi + 5, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+5], 1
    if (!flags.zero)
        goto cseg_36571;                    // jnz short cseg_36571

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, 0
    if (!flags.zero)
        goto cseg_36571;                    // jnz short cseg_36571

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 4;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 4

cseg_36569:;
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 8

cseg_36571:;
    goto cseg_367B5;                        // jmp cseg_367B5

cseg_36576:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_365BE;                    // jz short cseg_365BE

    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 4, 4);           // mov eax, [esi+4]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, offset aChairmanScenes
    A0 = eax;                               // mov A0, eax

cseg_365BE:;
    eax = A0;                               // mov eax, A0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (flags.zero)
        goto cseg_3660F;                    // jz short cseg_3660F

    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 8
    ax = *(word *)&g_memByte[489615];       // mov ax, gameListY
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = *(word *)&g_memByte[489617];       // mov ax, contestEntryHeight
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_36D7A;                    // jnb cseg_36D7A

    goto cseg_36643;                        // jmp short cseg_36643

cseg_3660F:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 16
    ax = *(word *)&g_memByte[489615];       // mov ax, gameListY
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = *(word *)&g_memByte[489617];       // mov ax, contestEntryHeight
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_36D7A;                    // jnb cseg_36D7A

cseg_36643:;
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 16;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 16
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 8
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+22], 8
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 9, 1);      // mov al, [esi+9]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 331960;                            // mov A0, offset dseg_11399A
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 3
    if (!flags.zero)
        goto cseg_366FE;                    // jnz short cseg_366FE

    A0 = 332008;                            // mov A0, offset dseg_1139CA
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax

cseg_366FE:;
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    A0 = 17801;                             // mov A0, offset aLeg1
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 1
    if (flags.zero)
        goto cseg_36753;                    // jz short cseg_36753

    A0 = 17807;                             // mov A0, offset aLeg2
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 2
    if (flags.zero)
        goto cseg_36753;                    // jz short cseg_36753

    A0 = 16239;                             // mov A0, offset aReplay
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 3
    if (!flags.zero)
        goto cseg_36767;                    // jnz short cseg_36767

cseg_36753:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    StringCopy();                           // call StringCopy

cseg_36767:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_367AD;                    // jz short cseg_367AD

    {
        byte src = (byte)readMemory(esi + 5, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+5], 1
    if (!flags.zero)
        goto cseg_367B5;                    // jnz short cseg_367B5

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, 0
    if (!flags.zero)
        goto cseg_367B5;                    // jnz short cseg_367B5

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 4;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 4

cseg_367AD:;
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 8

cseg_367B5:;
    push(D0);                               // push D0
    D0 = 37;                                // mov D0, 37
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D1 = 9;                       // mov word ptr D1, 9

cseg_367D9:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+36]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+36], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_367D9;                    // jns short cseg_367D9

    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (flags.zero)
        goto cseg_3685B;                    // jz short cseg_3685B

    eax = A5;                               // mov eax, A5
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned - srcSigned;
        A0 = res;
    }                                       // sub A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned - srcSigned;
        A0 = res;
    }                                       // sub A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1

cseg_3685B:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_36D40;                    // jz cseg_36D40

    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_SEASON
    if (flags.zero)
        goto cseg_368E4;                    // jz short cseg_368E4

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 10, 1);     // mov al, [esi+10]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_368E4;                    // jz short cseg_368E4

    A0 = 18952;                             // mov A0, offset aH_
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 1
    if (flags.zero)
        goto cseg_368CA;                    // jz short cseg_368CA

    A0 = 18956;                             // mov A0, offset aA
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 2
    if (!flags.zero)
        goto cseg_368D8;                    // jnz short cseg_368D8

cseg_368CA:;
    eax = A0;                               // mov eax, A0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax

cseg_368D8:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_368E4:;
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub word ptr [esi+22], 1
    writeMemory(esi + 26, 2, 7);            // mov word ptr [esi+26], 7
    eax = *(dword *)&g_memByte[489593];     // mov eax, dseg_17457A
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, eax
    if (!flags.zero)
        goto cseg_3693A;                    // jnz short cseg_3693A

    eax = *(dword *)&g_memByte[489597];     // mov eax, dseg_17457E
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (!flags.zero)
        goto cseg_3693A;                    // jnz short cseg_3693A

    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    goto cseg_36946;                        // jmp short cseg_36946

cseg_3693A:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1

cseg_36946:;
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    eax = *(dword *)&g_memByte[489601];     // mov eax, careerGameTopTeamName
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[489609];       // mov ax, cglm_team_control
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3697C;                    // jz short cseg_3697C

    eax = *(dword *)&g_memByte[489605];     // mov eax, careerGameBottomTeamName
    A0 = eax;                               // mov A0, eax

cseg_3697C:;
    eax = A0;                               // mov eax, A0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    esi = A4;                               // mov esi, A4
    {
        byte src = (byte)readMemory(esi + 11, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+11], 0
    if (flags.zero)
        goto cseg_36AAF;                    // jz cseg_36AAF

    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 17, 1);     // mov al, [esi+17]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = *(word *)&g_memByte[489609];       // mov ax, cglm_team_control
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_369E4;                    // jz short cseg_369E4

    al = (byte)readMemory(esi + 16, 1);     // mov al, [esi+16]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al

cseg_369E4:;
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 2, ax);           // mov [esi+38], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    writeMemory(esi + 38, 4, 17229);        // mov [esi+MenuEntry.fg.string], offset aMinus
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 16, 1);     // mov al, [esi+16]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = *(word *)&g_memByte[489609];       // mov ax, cglm_team_control
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_36A7D;                    // jz short cseg_36A7D

    al = (byte)readMemory(esi + 17, 1);     // mov al, [esi+17]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al

cseg_36A7D:;
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 2, ax);           // mov word ptr [esi+MenuEntry.fg.string], ax
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A5 = res;
    }                                       // add A5, 56
    goto cseg_36B25;                        // jmp short cseg_36B25

cseg_36AAF:;
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    writeMemory(esi + 38, 4, 17225);        // mov [esi+MenuEntry.fg.string], offset aV
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56

cseg_36B25:;
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    eax = *(dword *)&g_memByte[489605];     // mov eax, careerGameBottomTeamName
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[489609];       // mov ax, cglm_team_control
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_36B54;                    // jz short cseg_36B54

    eax = *(dword *)&g_memByte[489601];     // mov eax, careerGameTopTeamName
    A0 = eax;                               // mov A0, eax

cseg_36B54:;
    eax = A0;                               // mov eax, A0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 4, eax);          // mov [esi+38], eax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+22], 8
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, 0
    if (flags.zero)
        goto cseg_36BD6;                    // jz short cseg_36BD6

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 8
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    StringCopy();                           // call StringCopy
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_36BD6:;
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 56

cseg_36BDD:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_36C4C;                    // jz short cseg_36C4C

    eax = A4;                               // mov eax, A4
    D0 = eax;                               // mov D0, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D0 = res;
    }                                       // sub D0, eax
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 12;                                // mov bx, 12
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto cseg_36C54;                    // jnz short cseg_36C54

cseg_36C4C:;
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 4;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 4

cseg_36C54:;
    ax = D4;                                // mov ax, word ptr D4
    {
        word src = *(word *)&g_memByte[489611];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[489611] = src;
    }                                       // add columnMarker, ax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (!flags.zero)
        goto cseg_36CB7;                    // jnz short cseg_36CB7

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 37;                                // mov D0, 37
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    { SWOS::DrawMultipleItems(); return; }  // jmp DrawMultipleItems

cseg_36CB7:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 37;                                // mov D0, 37
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    SWOS::DrawMenuItem();                   // call DrawMenuItem
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 40;                                // mov D0, 40
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    { SWOS::DrawMultipleItems(); return; }  // jmp DrawMultipleItems

cseg_36D40:;
    *(word *)&D0 = 7;                       // mov word ptr D0, 7

cseg_36D49:;
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A5 = res;
    }                                       // add A5, 56
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_36D49;                    // jns short cseg_36D49

    goto cseg_36BDD;                        // jmp cseg_36BDD

cseg_36D7A:;
    *(word *)&g_memByte[489613] = 1;        // mov cglmVar3, 1
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 37;                                // mov D0, 37
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 10;                      // mov word ptr D0, 10

l_entries_invisible_loop:;
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A5 = res;
    }                                       // add A5, 56
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_entries_invisible_loop;      // jns short @@entries_invisible_loop
}

// =============== S U B R O U T I N E =======================================
//
void CareerOverInit()
{
    {
        word src = *(word *)&g_memByte[91330];
        int16_t dstSigned = src;
        int16_t srcSigned = 19;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp currentSeasonShowing, 19
    if (!flags.zero)
        goto l_not_last_season2;            // jnz short @@not_last_season2

    goto l_finish_career;                   // jmp short @@finish_career

l_not_last_season2:;
    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_got_job_offers;              // jnz short @@got_job_offers

    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_got_job_offers;              // jnz short @@got_job_offers

    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_finish_career;               // jz short @@finish_career

    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    goto l_finish_career;                   // jmp short @@finish_career

l_got_job_offers:;
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

l_finish_career:;

    CareerOverFinish();
}

// =============== S U B R O U T I N E =======================================
//
void CareerOverFinish()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 91741;                             // mov A0, offset managerNameBuffer
    GetStringLength();                      // call GetStringLength
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    A0 = 91750;                             // mov A0, offset managerSurnameBuffer
    GetStringLength();                      // call GetStringLength
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    A0 = 91741;                             // mov A0, offset managerNameBuffer
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 12;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 12
    if (flags.carry || flags.zero)
        goto l_whole_name_fits;             // jbe short @@whole_name_fits

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_no_name;                     // jz short @@no_name

    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    goto l_no_name;                         // jmp short @@no_name

l_whole_name_fits:;
    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1

l_no_name:;
    A0 = 91750;                             // mov A0, offset managerSurnameBuffer
    StringCopy();                           // call StringCopy
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    StringCopy();                           // call StringCopy
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    al = g_memByte[129467];                 // mov al, seasonPlaying
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1900;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1900
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1995;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1995
    if (!flags.carry)
        goto l_1995_or_greater;             // jnb short @@1995_or_greater

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 100;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 100

l_1995_or_greater:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    A0 = 9278;                              // mov A0, offset a0EndSeason
    PrintFormatted();                       // call PrintFormatted
    CareerOverUpdateJobOffersEntry();       // call CareerOverUpdateJobOffersEntry
    {
        word src = *(word *)&g_memByte[91330];
        int16_t dstSigned = src;
        int16_t srcSigned = 19;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp currentSeasonShowing, 19
    if (!flags.zero)
        goto l_not_last_season;             // jnz short @@not_last_season

    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 9063);         // mov [esi+MenuEntry.fg.string], offset aRetire
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    return;                                 // retn

l_not_last_season:;
    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, -1
    if (!flags.zero)
        goto l_got_jobs_waiting;            // jnz @@got_jobs_waiting

    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_got_jobs_waiting;            // jz @@got_jobs_waiting

    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_got_jobs_waiting;            // jnz @@got_jobs_waiting

    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_got_jobs_waiting;            // jnz @@got_jobs_waiting

    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0

l_got_jobs_waiting:;
    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, -1
    if (!flags.zero)
        return;                             // jnz short @@out

    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
}

// =============== S U B R O U T I N E =======================================
//
void CareerOverUpdateJobOffersEntry()
{
    {
        word src = *(word *)&g_memByte[91330];
        int16_t dstSigned = src;
        int16_t srcSigned = 19;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp currentSeasonShowing, 19
    if (!flags.zero)
        goto l_not_last_season;             // jnz short @@not_last_season

    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    return;                                 // retn

l_not_last_season:;
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 14
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 0);             // mov [esi+MenuEntry.isDisabled], 0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 57343;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0DFFFh
    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, -1
    if (!flags.zero)
        goto l_got_job_pending;             // jnz short @@got_job_pending

    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_got_new_jobs;                // jnz short @@got_new_jobs

    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_job_offers;               // jz short @@no_job_offers

l_got_new_jobs:;
    *(word *)&D1 |= 8192;
    flags.carry = false;
    flags.sign = (*(word *)&D1 & 0x8000) != 0;
    flags.zero = *(word *)&D1 == 0;         // or word ptr D1, 2000h

l_set_string_flag:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    return;                                 // retn

l_got_job_pending:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17248);        // mov [esi+MenuEntry.fg.string], offset aNewJob
    goto l_set_string_flag;                 // jmp short @@set_string_flag

l_no_job_offers:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17265);        // mov [esi+MenuEntry.fg.string], offset aNoJobOffers
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    goto l_set_string_flag;                 // jmp short @@set_string_flag
}

// =============== S U B R O U T I N E =======================================
//
void ViewCompetitionsMenuRetired()
{
    A6 = 491587;                            // mov A6, offset viewCompetitionsMenu
    SWOS::ShowMenu();                       // jmp ShowMenu
}

// =============== S U B R O U T I N E =======================================
//
void JobOffersMenuRetired()
{
    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, -1
    if (!flags.zero)
        goto cseg_37457;                    // jnz short cseg_37457

    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_373F7;                    // jnz short cseg_373F7

    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_3749E

cseg_373F7:;
    *(word *)&g_memByte[518824] = 1;        // mov dseg_17C228, 1
    A6 = 517136;                            // mov A6, offset jobOffersMenu
    SWOS::ShowMenu();                       // call ShowMenu
    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, 0FFFFh
    if (!flags.zero)
        goto cseg_37466;                    // jnz short cseg_37466

    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_37455;                    // jz short cseg_37455

    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    if (!flags.zero)
        goto cseg_37455;                    // jnz short cseg_37455

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    CareerInitVars();                       // call CareerInitVars
    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

cseg_37455:;
    goto cseg_37466;                        // jmp short cseg_37466

cseg_37457:;
    A6 = 518454;                            // mov A6, offset gotJobOfferMenu
    SWOS::ShowMenu();                       // call ShowMenu

cseg_37466:;
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 6, 2);      // mov ax, [esi+6]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_3749E

    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void ContinueCareer()
{
    {
        word src = *(word *)&g_memByte[91330];
        int16_t dstSigned = src;
        int16_t srcSigned = 19;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp currentSeasonShowing, 19
    if (!flags.zero)
        goto l_start_new_season;            // jnz short @@start_new_season

    ShowRetirementMessage();                // call ShowRetirementMessage
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    CareerInitVars();                       // call CareerInitVars
    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

l_start_new_season:;
    ContinueCareerNextSeason();             // call ContinueCareerNextSeason
    A6 = 489733;                            // mov A6, offset contestMenu
    SWOS::ActivateMenu();                   // jmp ActivateMenu
}

// =============== S U B R O U T I N E =======================================
//
void SaveCareer()
{
    A0 = 9075;                              // mov A0, offset aSaveCareer
    SetZeroFlag();                          // call SetZeroFlag
    if (!flags.zero)
        return;                             // jnz short @@out

    A0 = 316646;                            // mov A0, offset competitionFilename
    D0 = 776159570;                         // mov D0, '.CAR'
    A1 = 9075;                              // mov A1, offset aSaveCareer
    SWOS::SelectFileToSaveDialog();         // call SelectFileToSaveDialog
    if (!flags.zero)
        goto l_nothing_found;               // jnz short @@nothing_found

    *(byte *)&D0 = 4;                       // mov byte ptr D0, 4
    push(A0);                               // push A0
    SaveCareerFile();                       // call SaveCareerFile
    pop(A0);                                // pop A0
    if (!flags.zero)
        goto l_nothing_found;               // jnz short @@nothing_found

    *(word *)&g_memByte[129474] = 1;        // mov contestStarted, 1
    A1 = 316646;                            // mov A1, offset competitionFilename
    StringCopy();                           // call StringCopy

l_nothing_found:;
    A0 = 9075;                              // mov A0, offset aSaveCareer
    SetZeroFlag();                          // call SetZeroFlag
}

// =============== S U B R O U T I N E =======================================
//
void ExitCareerMenu()
{
    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, 0FFFFh
    if (!flags.zero)
        goto cseg_37588;                    // jnz short cseg_37588

    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_37588;                    // jz short cseg_37588

    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_37588;                    // jnz short cseg_37588

    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_37588;                    // jnz short cseg_37588

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    CareerInitVars();                       // call CareerInitVars

cseg_37588:;
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================

// out:
//      D0 - selected team country number
//      A0 - selected team pointer
//
void SelectTeamToManage()
{
    A0 = 16702;                             // mov A0, offset aSelectTeamToMa
    A1 = 0;                                 // mov A1, 0
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    ChooseTeamsDialog();                    // call ChooseTeamsDialog
}

// =============== S U B R O U T I N E =======================================
//
void cseg_375C2()
{
    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108369;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset tourCopy
    if (flags.zero)
        goto cseg_375DA;                    // jz short cseg_375DA

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108405;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset friendlyCopy
    if (!flags.zero)
        { cseg_3760C(); return; }           // jnz short cseg_3760C

cseg_375DA:;
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_375FE;                    // jnz short cseg_375FE

    ax = *(word *)&g_memByte[109904];       // mov ax, dseg_DB3DE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { cseg_3760C(); return; }           // jnz short cseg_3760C

cseg_375FE:;
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

    cseg_3760C();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3760C()
{
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 126572);       // mov dword ptr [esi+26h], offset diyPresetNameOfCompetition
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 99968);        // mov dword ptr [esi+26h], offset dseg_D8D0E
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 102866);       // mov dword ptr [esi+26h], offset dseg_D9860
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 105048);       // mov dword ptr [esi+26h], offset dseg_DA0E6
    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108369;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset tourCopy
    if (flags.zero)
        goto cseg_376C8;                    // jz short cseg_376C8

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108405;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset friendlyCopy
    if (!flags.zero)
        goto cseg_37839;                    // jnz cseg_37839

cseg_376C8:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax

cseg_37839:;
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto cseg_3795C;                    // jnz cseg_3795C

cseg_37846:;
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    goto cseg_3797C;                        // jmp short cseg_3797C

cseg_3795C:;
    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 108405;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset friendlyCopy
    if (flags.zero)
        goto cseg_37846;                    // jz cseg_37846

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 108369;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset tourCopy
    if (flags.zero)
        goto cseg_37846;                    // jz cseg_37846

cseg_3797C:;
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto cseg_37A50;                    // jnz cseg_37A50

cseg_37989:;
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    goto cseg_37A70;                        // jmp short cseg_37A70

cseg_37A50:;
    {
        dword src = *(dword *)&g_memByte[99876];
        int32_t dstSigned = src;
        int32_t srcSigned = 108405;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CB2, offset friendlyCopy
    if (flags.zero)
        goto cseg_37989;                    // jz cseg_37989

    {
        dword src = *(dword *)&g_memByte[99876];
        int32_t dstSigned = src;
        int32_t srcSigned = 108369;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CB2, offset tourCopy
    if (flags.zero)
        goto cseg_37989;                    // jz cseg_37989

cseg_37A70:;
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto cseg_37AEF;                    // jnz short cseg_37AEF

    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax

cseg_37AEF:;
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_37B05;                    // jnz short cseg_37B05

    ax = *(word *)&g_memByte[109904];       // mov ax, dseg_DB3DE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_37B1F;                    // jnz short cseg_37B1F

cseg_37B05:;
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1

cseg_37B1F:;
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (flags.zero)
        return;                             // jz short cseg_37B43

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_37B44()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    cseg_37B74();                           // jmp short cseg_37B74
}

// =============== S U B R O U T I N E =======================================
//
void cseg_37B50()
{
    A0 = 99964;                             // mov A0, offset dseg_D8D0A
    cseg_37B74();                           // jmp short cseg_37B74
}

// =============== S U B R O U T I N E =======================================
//
void cseg_37B5C()
{
    A0 = 102862;                            // mov A0, offset dseg_D985C
    cseg_37B74();                           // jmp short cseg_37B74
}

// =============== S U B R O U T I N E =======================================
//
void cseg_37B68()
{
    A0 = 105044;                            // mov A0, offset dseg_DA0E2

    cseg_37B74();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_37B74()
{
    push(A0);                               // push A0
    cseg_8B71C();                           // call cseg_8B71C
    pop(A0);                                // pop A0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_37BC1;                    // jnz short cseg_37BC1

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(A0);                               // push A0
    ShowDiyLeaguesTournamentMenu();         // call ShowDiyLeaguesTournamentMenu
    pop(A0);                                // pop A0
    goto cseg_37C27;                        // jmp short cseg_37C27

cseg_37BC1:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (!flags.zero)
        goto cseg_37BFB;                    // jnz short cseg_37BFB

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(A0);                               // push A0
    cseg_45B51();                           // call cseg_45B51
    pop(A0);                                // pop A0
    goto cseg_37C27;                        // jmp short cseg_37C27

cseg_37BFB:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(A0);                               // push A0
    cseg_89B5C();                           // call cseg_89B5C
    pop(A0);                                // pop A0

cseg_37C27:;
    cseg_8B7EA();                           // call cseg_8B7EA
}

// =============== S U B R O U T I N E =======================================
//
void TopGoalScorersMenu()
{
    dseg_17343E();                          // jmp dseg_17343E
}

// =============== S U B R O U T I N E =======================================
//
void ManagementRecordMenu()
{
    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_37C42;                    // jnz short cseg_37C42

    cseg_39392();                           // call cseg_39392

cseg_37C42:;
    A6 = 491865;                            // mov A6, offset management_record_menu
    SWOS::ShowMenu();                       // jmp ShowMenu
}

// =============== S U B R O U T I N E =======================================
//
void jmp_SetExitMenuFlag_2()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ShowRetirementMessage()
{
    *(word *)&D0 = 37;                      // mov word ptr D0, WISH_YOU_BEST_AT_THE_END
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_club;                        // jnz short @@club

    *(word *)&D0 = 23;                      // mov word ptr D0, ENJOY_YOUR_RETIREMENT

l_club:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[337240] = ax;       // mov currentMessage, ax
    ShowChairmanMessage();                  // jmp ShowChairmanMessage
}

// =============== S U B R O U T I N E =======================================
//
void ManagementRecordInit()
{
    ax = *(word *)&g_memByte[91330];        // mov ax, currentSeasonShowing
    *(word *)&g_memByte[492315] = ax;       // mov currentSeasonNumber, ax
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 4329;                              // mov A0, offset aManagementReco
    A2 = 91741;                             // mov A2, offset managerNameBuffer
    A3 = 91750;                             // mov A3, offset managerSurnameBuffer
    PrintFormatted();                       // call PrintFormatted
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 16;                                // mov D0, 16
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    A0 = 4714;                              // mov A0, offset aDash
    ax = *(word *)&g_memByte[91630];        // mov ax, gamesPlayed
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_games_yet;                // jz short @@no_games_yet

    ax = *(word *)&g_memByte[91632];        // mov ax, numWins
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[91634];        // mov ax, numDrawn
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[91636];        // mov ax, numLost
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = *(word *)&g_memByte[91638];        // mov ax, goalsScored
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = *(word *)&g_memByte[91640];        // mov ax, goalsTaken
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    A0 = 4642;                              // mov A0, offset aPl0W1D2L3F4A5

l_no_games_yet:;
    PrintFormatted();                       // call PrintFormatted
}

// =============== S U B R O U T I N E =======================================
//
void jmp_SetExitMenuFlag_3()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ManagementArrowUpSelect()
{
    ax = *(word *)&g_memByte[492315];       // mov ax, currentSeasonNumber
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        word src = *(word *)&g_memByte[492315];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[492315] = src;
    }                                       // sub currentSeasonNumber, 1
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void ManagementArrowDownSelect()
{
    ax = *(word *)&g_memByte[91330];        // mov ax, currentSeasonShowing
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[492315];       // mov ax, currentSeasonNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        word src = *(word *)&g_memByte[492315];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[492315] = src;
    }                                       // add currentSeasonNumber, 1
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void FillManagementRecordInfo()
{
    ax = *(word *)&g_memByte[492315];       // mov ax, currentSeasonNumber
    bx = 106;                               // mov bx, 106
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A6 = 94096;                             // mov A6, offset dseg_D761E
    eax = A6;                               // mov eax, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A6 = eax;                               // mov A6, eax
    SetTrophySprites();                     // call SetTrophySprites
    ax = *(word *)&g_memByte[492315];       // mov ax, currentSeasonNumber
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)&D5 = 40;                      // mov word ptr D5, 40
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[492315];       // mov ax, currentSeasonNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = *(word *)&g_memByte[492315];       // mov ax, currentSeasonNumber
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1996;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1996
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 97;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 97
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 100
    if (flags.carry)
        goto l_season_below_100;            // jb short @@season_below_100

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 100

l_season_below_100:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 10
    if (flags.carry)
        goto l_season_below_10;             // jb short @@season_below_10

    A0 = 4302;                              // mov A0, offset a12Season
    goto l_print_season;                    // jmp short @@print_season

l_season_below_10:;
    A0 = 4315;                              // mov A0, offset a102Season

l_print_season:;
    PrintFormatted();                       // call PrintFormatted
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 10
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 2
    A0 = eax;                               // mov A0, eax
    StringCopy();                           // call StringCopy
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 10
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, CN_EUROPE
    if (flags.carry)
        goto l_not_national;                // jb short @@not_national

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 85;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, CN_OCEANIA
    if (!flags.carry && !flags.zero)
        goto l_not_national;                // ja short @@not_national

    A2 = 4288;                              // mov A2, offset aNational
    goto l_write_club_country;              // jmp short @@write_club_country

l_not_national:;
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A2 = 24755;                             // mov A2, offset countriesTable
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 1
    A2 = eax;                               // mov A2, eax

l_write_club_country:;
    A0 = 4297;                              // mov A0, offset aA_0
    PrintFormatted();                       // call PrintFormatted
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 10
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 22, 4);          // mov eax, [esi+22]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, offset aChairmanScenes
    A0 = eax;                               // mov A0, eax
    al = (byte)readMemory(esi + 86, 1);     // mov al, [esi+86]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    al = (byte)readMemory(esi + 104, 1);    // mov al, [esi+104]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    cseg_3892C();                           // call cseg_3892C
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 26, 4);          // mov eax, [esi+26]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, offset aChairmanScenes
    A0 = eax;                               // mov A0, eax
    al = (byte)readMemory(esi + 87, 1);     // mov al, [esi+87]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    *(byte *)&D7 = 0;                       // mov byte ptr D7, 0
    cseg_3892C();                           // call cseg_3892C
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 30, 4);          // mov eax, [esi+30]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, offset aChairmanScenes
    A0 = eax;                               // mov A0, eax
    al = (byte)readMemory(esi + 88, 1);     // mov al, [esi+88]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    *(byte *)&D7 = 0;                       // mov byte ptr D7, 0
    cseg_3892C();                           // call cseg_3892C
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi + 34, 4);          // mov eax, [esi+34]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, offset aChairmanScenes
    A0 = eax;                               // mov A0, eax
    al = (byte)readMemory(esi + 89, 1);     // mov al, [esi+89]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    *(byte *)&D7 = 0;                       // mov byte ptr D7, 0
    cseg_3892C();                           // call cseg_3892C
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 4;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 4
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 7;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 7
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 40, 1);     // mov al, [esi+SeasonInformations.bestScorerName]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_has_best_scorer_name;        // jnz short @@has_best_scorer_name

    A0 = 4714;                              // mov A0, offset aDash
    StringCopy();                           // call StringCopy
    goto l_no_best_scorer;                  // jmp @@no_best_scorer

l_has_best_scorer_name:;
    push(D5);                               // push small [word ptr D5]
    A0 = 4714;                              // mov A0, offset aDash
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 94, 1);     // mov al, [esi+SeasonInformations.totalGames]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_no_games_played;             // jz short @@no_games_played

    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    al = (byte)readMemory(esi + 95, 1);     // mov al, [esi+SeasonInformations.totalWins]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    al = (byte)readMemory(esi + 96, 1);     // mov al, [esi+SeasonInformations.totalDrawn]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    al = (byte)readMemory(esi + 97, 1);     // mov al, [esi+SeasonInformations.totalLost]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    ax = (word)readMemory(esi + 90, 2);     // mov ax, [esi+SeasonInformations.totalGoalsScored]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = (word)readMemory(esi + 92, 2);     // mov ax, [esi+SeasonInformations.totalGoalsTaken]
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    A0 = 4642;                              // mov A0, offset aPl0W1D2L3F4A5

l_no_games_played:;
    PrintFormatted();                       // call PrintFormatted

l_no_best_scorer:;
    {
        int32_t val = stack[stackTop++];
        *(word *)&D5 = val;
    }                                       // pop small [word ptr D5]
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A6);                               // push A6
    SWOS::DrawMultipleItems();              // call DrawMultipleItems
    pop(A6);                                // pop A6
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 13;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 13
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 105, 1);    // mov al, [esi+SeasonInformations.managerStatus]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_manager_still_active;        // jz @@manager_still_active

    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 105, 1);    // mov al, [esi+SeasonInformations.managerStatus]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto l_sacked;                      // js short @@sacked

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 38, 4, 4263);         // mov [esi+MenuEntry.fg.string], offset aResigned
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 105, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+SeasonInformations.managerStatus], 1
    if (flags.zero)
        goto l_sacked;                      // jz short @@sacked

    *(word *)&D0 = 15;                      // mov word ptr D0, 15
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 38, 4, 4276);         // mov [esi+MenuEntry.fg.string], offset aRetired

l_sacked:;
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 65520;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFF0h
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 |= ax;                     // or word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D1 |= 8192;
    flags.carry = false;
    flags.sign = (*(word *)&D1 & 0x8000) != 0;
    flags.zero = *(word *)&D1 == 0;         // or word ptr D1, 2000h
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A6);                               // push A6
    SWOS::DrawMultipleItems();              // call DrawMultipleItems
    pop(A6);                                // pop A6
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5

l_manager_still_active:;
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 6;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 6
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 38, 4, 4569);         // mov [esi+MenuEntry.fg.string], offset aSeasonSTopScor
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 40, 1);     // mov al, [esi+SeasonInformations.bestScorerName]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_more_best_scorers;           // jz short @@more_best_scorers

    al = (byte)readMemory(esi + 63, 1);     // mov al, [esi+63]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_more_best_scorers;           // jz short @@more_best_scorers

    esi = A4;                               // mov esi, A4
    writeMemory(esi + 38, 4, 4589);         // mov [esi+MenuEntry.fg.string], offset aSeasonSTopSc_0

l_more_best_scorers:;
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 10
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 38, 2);     // mov ax, [esi+SeasonInformations.bestScorerNumGoals]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_best_scorer_zero_goals;      // jz short @@best_scorer_zero_goals

    al = (byte)readMemory(esi + 40, 1);     // mov al, [esi+SeasonInformations.bestScorerName]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_print_scorer_and_goals;      // jnz short @@print_scorer_and_goals

l_best_scorer_zero_goals:;
    A0 = 4714;                              // mov A0, offset aDash
    StringCopy();                           // call StringCopy
    goto cseg_385EE;                        // jmp short cseg_385EE

l_print_scorer_and_goals:;
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 40;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 40
    A2 = eax;                               // mov A2, eax
    A0 = 4610;                              // mov A0, offset aA0
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 38, 2);     // mov ax, [esi+SeasonInformations.bestScorerNumGoals]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    PrintFormatted();                       // call PrintFormatted

cseg_385EE:;
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A6);                               // push A6
    SWOS::DrawMultipleItems();              // call DrawMultipleItems
    pop(A6);                                // pop A6
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 8
    *(word *)&D0 = 14;                      // mov word ptr D0, 14
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 40, 1);     // mov al, [esi+SeasonInformations.bestScorerName]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_no_best_scorer2;             // jz @@no_best_scorer2

    al = (byte)readMemory(esi + 63, 1);     // mov al, [esi+63]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_no_best_scorer2;             // jz @@no_best_scorer2

    *(word *)&D0 = 14;                      // mov word ptr D0, 14
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 14;                                // mov D0, 14
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 63;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 63
    A2 = eax;                               // mov A2, eax
    A0 = 4610;                              // mov A0, offset aA0
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 38, 2);     // mov ax, word ptr [esi+MenuEntry.fg.string]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    PrintFormatted();                       // call PrintFormatted
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 14;                                // mov D0, 14
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A6);                               // push A6
    SWOS::DrawMultipleItems();              // call DrawMultipleItems
    pop(A6);                                // pop A6
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 10

l_no_best_scorer2:;
    *(word *)&D5 = 21;                      // mov word ptr D5, 21
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+SeasonInformations.trophyFlags]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 20;                                // mov D0, 20
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D4 -
//      D5 -  starting y coordinate for following entries
//      D7 -
//      A0 -> league string
//
void cseg_3892C()
{
    eax = A0;                               // mov eax, A0
    A2 = eax;                               // mov A2, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4201;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset aChairmanScenes
    if (flags.zero)
        return;                             // jz @@out

    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 7200;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset aFriendly_0
    if (!flags.zero)
        goto l_not_friendly;                // jnz short @@not_friendly

    A0 = 7218;                              // mov A0, offset aFriendlies

l_not_friendly:;
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    al = D4;                                // mov al, byte ptr D4
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+36]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    *(word *)&D0 |= 2;                      // or word ptr D0, 2
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+36], ax
    A0 = 4714;                              // mov A0, offset aDash
    ax = D4;                                // mov ax, word ptr D4
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_print_string;                // jz @@print_string

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 7200;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset aFriendly_0
    if (!flags.zero)
        goto l_not_friendly_2;              // jnz @@not_friendly_2

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 98, 1);     // mov al, [esi+98]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 99, 1);     // mov al, [esi+99]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 100, 1);    // mov al, [esi+100]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = D1;                                // mov al, byte ptr D1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    al = D2;                                // mov al, byte ptr D2
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_print_won_drawn_lost;        // jnz short @@print_won_drawn_lost

    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_print_won_drawn_lost;        // jnz short @@print_won_drawn_lost

    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_print_string;                // jz @@print_string

l_print_won_drawn_lost:;
    A0 = 4688;                              // mov A0, offset aWon0Drawn1Lost
    goto l_print_string;                    // jmp @@print_string

l_not_friendly_2:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 7067;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset aEuropeanTour
    if (flags.carry)
        goto l_not_a_tour;                  // jb @@not_a_tour

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 7145;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset aOceaniaTour
    if (!flags.carry && !flags.zero)
        goto l_not_a_tour;                  // ja @@not_a_tour

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 101, 1);    // mov al, [esi+101]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+102]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+103]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = D1;                                // mov al, byte ptr D1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    al = D2;                                // mov al, byte ptr D2
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    A0 = 4714;                              // mov A0, offset aDash
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_38B9A;                    // jnz short cseg_38B9A

    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_38B9A;                    // jnz short cseg_38B9A

    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_print_string;                // jz @@print_string

cseg_38B9A:;
    A0 = 4688;                              // mov A0, offset aWon0Drawn1Lost
    goto l_print_string;                    // jmp @@print_string

l_not_a_tour:;
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 1
    if (!flags.zero)
        goto cseg_38BE3;                    // jnz short cseg_38BE3

    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+36]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 65520;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFF0h
    *(word *)&D1 |= 15;                     // or word ptr D1, 0Fh
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 36, 2, ax);           // mov [esi+36], ax

cseg_38BE3:;
    A0 = 4407;                              // mov A0, offset aWinners
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 1
    if (flags.zero)
        goto l_print_string;                // jz @@print_string

    A0 = 4415;                              // mov A0, offset aRunnerUp
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 2
    if (flags.zero)
        goto l_print_string;                // jz @@print_string

    A0 = 4438;                              // mov A0, offset aFinalist
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = -100;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, -100
    if (flags.zero)
        goto l_print_string;                // jz @@print_string

    A0 = 4472;                              // mov A0, offset aReachedSemiFin
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = -101;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, -101
    if (flags.zero)
        goto l_print_string;                // jz @@print_string

    A0 = 4491;                              // mov A0, offset aReachedQuarter
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = -102;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, -102
    if (flags.zero)
        goto l_print_string;                // jz @@print_string

    A0 = 4447;                              // mov A0, offset aThirdPlace
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = -103;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, -103
    if (flags.zero)
        goto l_print_string;                // jz @@print_string

    A0 = 4459;                              // mov A0, offset aFourthPlace
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = -105;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, -105
    if (flags.zero)
        goto l_print_string;                // jz @@print_string

    A0 = 4537;                              // mov A0, offset aStillInCompeti
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = -104;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, -104
    if (flags.zero)
        goto l_print_string;                // jz @@print_string

    A0 = 4714;                              // mov A0, offset aDash
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = -106;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, -106
    if (flags.zero)
        goto l_print_string;                // jz short @@print_string

    ax = D4;                                // mov ax, word ptr D4
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_position;                    // jns short @@position

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = -110;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, -110
    if (!flags.zero && flags.sign == flags.overflow)
        goto l_position_neg;                // jg short @@position_neg

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 110;
        word res = dstSigned + srcSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 110
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = *(int16_t *)&D0 != 0;
    flags.overflow = *(int16_t *)&D0 == INT16_MIN;
    *(int16_t *)&D0 = -*(int16_t *)&D0;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // neg word ptr D0
    A0 = 4513;                              // mov A0, offset aKnockedOutInRo
    goto l_print_string;                    // jmp short @@print_string

l_position:;
    A0 = 4425;                              // mov A0, offset aPosition0
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    goto l_print_string;                    // jmp short @@print_string

l_position_neg:;
    A0 = 4425;                              // mov A0, offset aPosition0
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = *(int16_t *)&D0 != 0;
    flags.overflow = *(int16_t *)&D0 == INT16_MIN;
    *(int16_t *)&D0 = -*(int16_t *)&D0;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // neg word ptr D0

l_print_string:;
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    PrintFormatted();                       // call PrintFormatted
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A6);                               // push A6
    SWOS::DrawMultipleItems();              // call DrawMultipleItems
    pop(A6);                                // pop A6
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 8
    al = D7;                                // mov al, byte ptr D7
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        return;                             // jz @@out

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    ax = D5;                                // mov ax, word ptr D5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    A0 = 4356;                              // mov A0, offset aQualified
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, 1
    if (flags.zero)
        goto l_copy_string;                 // jz short @@copy_string

    A0 = 4368;                              // mov A0, offset aNotQualified
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, 2
    if (flags.zero)
        goto l_copy_string;                 // jz short @@copy_string

    A0 = 4384;                              // mov A0, offset aPromoted
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, 3
    if (flags.zero)
        goto l_copy_string;                 // jz short @@copy_string

    A0 = 4395;                              // mov A0, offset aRelegated
    *(word *)&D0 = 10;                      // mov word ptr D0, 10

l_copy_string:;
    StringCopy();                           // call StringCopy
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+36]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 65520;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFF0h
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 |= ax;
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (*(word *)&D1 & 0x8000) != 0;
    flags.zero = *(word *)&D1 == 0;         // or word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 36, 2, ax);           // mov [esi+36], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A6);                               // push A6
    SWOS::DrawMultipleItems();              // call DrawMultipleItems
    pop(A6);                                // pop A6
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 8
}

// =============== S U B R O U T I N E =======================================

// in:
//      A6 -> season informations
// out:
//      A0 -> first unknown string (management record for ...)
//
void SetTrophySprites()
{
    *(word *)&D0 = 17;                      // mov word ptr D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 60, 2, 1);            // mov [esi+(MenuEntry.isInvisible+38h)], 1
    writeMemory(esi + 116, 2, 1);           // mov [esi+(MenuEntry.isInvisible+70h)], 1
    writeMemory(esi + 172, 2, 1);           // mov [esi+(MenuEntry.isInvisible+0A8h)], 1
    *(word *)&D0 = 160;                     // mov word ptr D0, 160
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 2, ax);           // mov [esi+MenuEntry.x], ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 20
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 2, ax);           // mov [esi+MenuEntry.x], ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 20
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 2, ax);           // mov [esi+MenuEntry.x], ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 20
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 2, ax);           // mov [esi+MenuEntry.x], ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 20;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 20
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 56
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+20]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    *(word *)&D6 = 0;                       // mov word ptr D6, 0

l_trophies_loop:;
    ax = 1;                                 // mov ax, 1
    cl = D6;                                // mov cl, byte ptr D6
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            word res = ax << shiftCount;
            ax = res;
        }
    }                                       // shl ax, cl
    {
        word res = *(word *)&D7 & ax;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D7, ax
    if (flags.zero)
        goto l_not_this_trophy;             // jz short @@not_this_trophy

    SetTrophySprite();                      // call SetTrophySprite

l_not_this_trophy:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 10
    if (!flags.zero)
        goto l_trophies_loop;               // jnz short @@trophies_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      D6 - trophy index
//      A1 - entry whose sprite needs to be filled
//
void SetTrophySprite()
{
    A2 = 492295;                            // mov A2, offset trophySprites
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 38, 2, ax);           // mov [esi+38], ax
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 56
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+MenuEntry.x], 10
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+MenuEntry.x], 10
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+MenuEntry.x], 10
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // sub [esi+MenuEntry.x], 10
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 56
}

// =============== S U B R O U T I N E =======================================

// Set nationality field when starting career.
//
void SetNationalityField()
{
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    al = g_memByte[91763];                  // mov al, plNationality
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = -1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, -1
    if (flags.zero)
        goto l_other;                       // jz @@other

    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    A0 = 25865;                             // mov A0, offset shortCountryNames
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    return;                                 // retn

l_other:;
    A0 = 6245;                              // mov A0, offset aOther
    StringCopy();                           // jmp StringCopy
}

// =============== S U B R O U T I N E =======================================
//
void ChangeNationality()
{
    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 81h
    if (flags.zero)
        goto l_next_nationality;            // jz short @@next_nationality

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 257;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 101h
    if (flags.zero)
        goto l_next_nationality;            // jz short @@next_nationality

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 65;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 41h
    if (flags.zero)
        goto l_prev_nationality;            // jz short @@prev_nationality

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 513;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 201h
    if (flags.zero)
        goto l_prev_nationality;            // jz short @@prev_nationality

    return;                                 // retn

l_prev_nationality:;
    al = g_memByte[489731];                 // mov al, nationalityOrdinal
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 1
    if (!flags.sign)
        goto l_common_exit;                 // jns short @@common_exit

    *(byte *)&D0 = 63;                      // mov byte ptr D0, 63
    goto l_common_exit;                     // jmp short @@common_exit

l_next_nationality:;
    al = g_memByte[489731];                 // mov al, nationalityOrdinal
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 64;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 64
    if (!flags.zero)
        goto l_common_exit;                 // jnz short @@common_exit

    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0

l_common_exit:;
    al = D0;                                // mov al, byte ptr D0
    g_memByte[489731] = al;                 // mov nationalityOrdinal, al
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 491249;                            // mov A0, offset nationalityOrdinalsArray
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    g_memByte[91763] = al;                  // mov plNationality, al
    SetNationalityField();                  // call SetNationalityField
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================

// out:
//      A0 -> current season
//
// Returns pointer to current season that is showing.
//
void GetCurrentSeasonPointer()
{
    A0 = 94096;                             // mov A0, offset dseg_D761E
    ax = *(word *)&g_memByte[91330];        // mov ax, currentSeasonShowing
    bx = 106;                               // mov bx, 106
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3934F()
{
    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    *(byte *)&D1 = 3;                       // mov byte ptr D1, 3
    ax = *(word *)&g_memByte[91730];        // mov ax, playPromotedAnimation
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3937E;                    // jnz short cseg_3937E

    ax = *(word *)&g_memByte[91732];        // mov ax, playRelegatedAnimation
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    *(byte *)&D1 = 4;                       // mov byte ptr D1, 4

cseg_3937E:;
    GetCurrentSeasonPointer();              // call GetCurrentSeasonPointer
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 104, 1, al);          // mov [esi+SeasonInformations.tournamentStatus], al
}

// =============== S U B R O U T I N E =======================================
//
void cseg_39392()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        { nullsub_33(); return; }           // jnz nullsub_33

    cseg_3D7CB();                           // call cseg_3D7CB
    GetCurrentSeasonPointer();              // call GetCurrentSeasonPointer
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax = *(word *)&g_memByte[91612];        // mov ax, dseg_D6C6A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_393D0;                    // jz short cseg_393D0

    *(word *)&D0 |= 1;                      // or word ptr D0, 1

cseg_393D0:;
    ax = *(word *)&g_memByte[91614];        // mov ax, dseg_D6C6C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_393E3;                    // jz short cseg_393E3

    *(word *)&D0 |= 2;                      // or word ptr D0, 2

cseg_393E3:;
    ax = *(word *)&g_memByte[91606];        // mov ax, dseg_D6C64
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_393F6;                    // jz short cseg_393F6

    *(word *)&D0 |= 4;                      // or word ptr D0, 4

cseg_393F6:;
    ax = *(word *)&g_memByte[91610];        // mov ax, dseg_D6C68
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_39409;                    // jz short cseg_39409

    *(word *)&D0 |= 8;                      // or word ptr D0, 8

cseg_39409:;
    ax = *(word *)&g_memByte[91608];        // mov ax, dseg_D6C66
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3941C;                    // jz short cseg_3941C

    *(word *)&D0 |= 16;                     // or word ptr D0, 10h

cseg_3941C:;
    ax = *(word *)&g_memByte[91600];        // mov ax, playWinCupAnimation
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3944A;                    // jz short cseg_3944A

    *(word *)&D0 |= 32;                     // or word ptr D0, 20h
    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3944A;                    // jz short cseg_3944A

    {
        word res = *(word *)&D0 & 65503;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFDFh
    *(word *)&D0 |= 64;                     // or word ptr D0, 40h

cseg_3944A:;
    ax = *(word *)&g_memByte[91602];        // mov ax, dseg_D6C60
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3945E;                    // jz short cseg_3945E

    *(word *)&D0 |= 128;                    // or word ptr D0, 80h

cseg_3945E:;
    ax = *(word *)&g_memByte[91604];        // mov ax, dseg_D6C62
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_39472;                    // jz short cseg_39472

    *(word *)&D0 |= 256;                    // or word ptr D0, 100h

cseg_39472:;
    ax = *(word *)&g_memByte[91616];        // mov ax, dseg_D6C6E
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_39486;                    // jz short cseg_39486

    *(word *)&D0 |= 512;                    // or word ptr D0, 200h

cseg_39486:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 20, 2, ax);           // mov [esi+14h], ax
    {
        word src = *(word *)&g_memByte[91330];
        int16_t dstSigned = src;
        int16_t srcSigned = 19;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp currentSeasonShowing, 13h
    if (!flags.zero)
        goto cseg_394B5;                    // jnz short cseg_394B5

    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_394B5;                    // jz short cseg_394B5

    writeMemory(esi + 105, 1, 2);           // mov byte ptr [esi+69h], 2

cseg_394B5:;
    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_394CA;                    // jz short cseg_394CA

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 105, 1, 255);         // mov byte ptr [esi+69h], 0FFh

cseg_394CA:;
    al = g_memByte[91642];                  // mov al, byte ptr dseg_D6C88
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 94, 1, al);           // mov [esi+5Eh], al
    al = g_memByte[91644];                  // mov al, byte ptr dseg_D6C8A
    writeMemory(esi + 95, 1, al);           // mov [esi+5Fh], al
    al = g_memByte[91646];                  // mov al, byte ptr dseg_D6C8C
    writeMemory(esi + 96, 1, al);           // mov [esi+60h], al
    al = g_memByte[91648];                  // mov al, byte ptr dseg_D6C8E
    writeMemory(esi + 97, 1, al);           // mov [esi+61h], al
    ax = *(word *)&g_memByte[91650];        // mov ax, dseg_D6C90
    writeMemory(esi + 90, 2, ax);           // mov [esi+5Ah], ax
    ax = *(word *)&g_memByte[91652];        // mov ax, dseg_D6C92
    writeMemory(esi + 92, 2, ax);           // mov [esi+5Ch], ax
    al = g_memByte[91654];                  // mov al, byte ptr dseg_D6C94
    writeMemory(esi + 98, 1, al);           // mov [esi+62h], al
    al = g_memByte[91656];                  // mov al, byte ptr dseg_D6C96
    writeMemory(esi + 99, 1, al);           // mov [esi+63h], al
    al = g_memByte[91658];                  // mov al, byte ptr dseg_D6C98
    writeMemory(esi + 100, 1, al);          // mov [esi+64h], al
    al = g_memByte[91660];                  // mov al, byte ptr dseg_D6C9A
    writeMemory(esi + 101, 1, al);          // mov [esi+65h], al
    al = g_memByte[91662];                  // mov al, byte ptr dseg_D6C9C
    writeMemory(esi + 102, 1, al);          // mov [esi+66h], al
    al = g_memByte[91664];                  // mov al, byte ptr dseg_D6C9E
    writeMemory(esi + 103, 1, al);          // mov [esi+67h], al
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_3959C:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    pop(D1);                                // pop D1
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 109, 1);    // mov al, [esi+6Dh]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    al = (byte)readMemory(esi + 110, 1);    // mov al, [esi+6Eh]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    al = (byte)readMemory(esi + 111, 1);    // mov al, [esi+6Fh]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    al = (byte)readMemory(esi + 112, 1);    // mov al, [esi+70h]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto cseg_39685;                    // jb short cseg_39685

    if (flags.zero)
        goto cseg_39669;                    // jz short cseg_39669

    *(word *)&D4 = 1;                       // mov word ptr D4, 1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    goto cseg_39685;                        // jmp short cseg_39685

cseg_39669:;
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, 1
    eax = A1;                               // mov eax, A1
    A2 = eax;                               // mov A2, eax
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax

cseg_39685:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_3959C;                    // jns cseg_3959C

    ax = D3;                                // mov ax, word ptr D3
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 1
    if (flags.zero)
        goto cseg_39722;                    // jz short cseg_39722

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 2
    if (flags.zero)
        goto cseg_396E2;                    // jz short cseg_396E2

    A0 = 4716;                              // mov A0, offset aSeveral
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 40;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 28h
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 63, 1, 0);            // mov byte ptr [esi+3Fh], 0
    goto cseg_3974B;                        // jmp short cseg_3974B

cseg_396E2:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4Fh
    A0 = eax;                               // mov A0, eax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 40;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 28h
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4Fh
    A0 = eax;                               // mov A0, eax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 63;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 3Fh
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    goto cseg_3974B;                        // jmp short cseg_3974B

cseg_39722:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4Fh
    A0 = eax;                               // mov A0, eax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 40;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 28h
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 63, 1, 0);            // mov byte ptr [esi+3Fh], 0

cseg_3974B:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 104, 1, 0);           // mov byte ptr [esi+68h], 0
    A6 = 126568;                            // mov A6, offset competitionFileBuffer
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(A6);                               // push A6
    FindTeamInDIY();                        // call FindTeamInDIY
    pop(A6);                                // pop A6
    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    A4 = eax;                               // mov A4, eax
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_39822;                    // js cseg_39822

    cseg_39916();                           // call cseg_39916
    al = D1;                                // mov al, byte ptr D1
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 86, 1, al);           // mov [esi+56h], al
    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 109191;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset world_cup_qualifying_group_1_copy
    if (flags.carry)
        goto cseg_397C0;                    // jb short cseg_397C0

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 109867;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset oceaniaWorldCupQualificationCopy
    if (flags.carry || flags.zero)
        goto cseg_397D8;                    // jbe short cseg_397D8

cseg_397C0:;
    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108523;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset e_c_qualifying_group_1_copy
    if (flags.carry)
        goto cseg_39822;                    // jb short cseg_39822

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108803;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset e_c_qualifying_group_8_copy
    if (!flags.carry && !flags.zero)
        goto cseg_39822;                    // ja short cseg_39822

cseg_397D8:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 104, 1, 1);           // mov byte ptr [esi+68h], 1
    ax = *(word *)&g_memByte[91618];        // mov ax, dseg_D6C70
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_39822;                    // jnz short cseg_39822

    ax = *(word *)&g_memByte[91620];        // mov ax, dseg_D6C72
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_39822;                    // jnz short cseg_39822

    writeMemory(esi + 104, 1, 2);           // mov byte ptr [esi+68h], 2
    ax = *(word *)&g_memByte[91622];        // mov ax, dseg_D6C74
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_39822;                    // jnz short cseg_39822

    ax = *(word *)&g_memByte[91624];        // mov ax, dseg_D6C76
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_39822;                    // jnz short cseg_39822

    writeMemory(esi + 104, 1, 0);           // mov byte ptr [esi+68h], 0

cseg_39822:;
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 26, 4);          // mov eax, [esi+1Ah]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_39873;                    // jz short cseg_39873

    A6 = 99964;                             // mov A6, offset dseg_D8D0A
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(A6);                               // push A6
    FindTeamInDIY();                        // call FindTeamInDIY
    pop(A6);                                // pop A6
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    A4 = eax;                               // mov A4, eax
    cseg_39916();                           // call cseg_39916
    al = D1;                                // mov al, byte ptr D1
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 87, 1, al);           // mov [esi+57h], al

cseg_39873:;
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 30, 4);          // mov eax, [esi+1Eh]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_398C4;                    // jz short cseg_398C4

    A6 = 102862;                            // mov A6, offset dseg_D985C
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(A6);                               // push A6
    FindTeamInDIY();                        // call FindTeamInDIY
    pop(A6);                                // pop A6
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    A4 = eax;                               // mov A4, eax
    cseg_39916();                           // call cseg_39916
    al = D1;                                // mov al, byte ptr D1
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 88, 1, al);           // mov [esi+58h], al

cseg_398C4:;
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 34, 4);          // mov eax, [esi+22h]
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        { nullsub_33(); return; }           // jz short nullsub_33

    A6 = 105044;                            // mov A6, offset dseg_DA0E2
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(A6);                               // push A6
    FindTeamInDIY();                        // call FindTeamInDIY
    pop(A6);                                // pop A6
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    A4 = eax;                               // mov A4, eax
    cseg_39916();                           // call cseg_39916
    al = D1;                                // mov al, byte ptr D1
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 89, 1, al);           // mov [esi+59h], al

    nullsub_33();
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_33()
{
}

// =============== S U B R O U T I N E =======================================
//
void cseg_39916()
{
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    esi = A4;                               // mov esi, A4
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 0
    if (flags.zero)
        goto cseg_39B5F;                    // jz cseg_39B5F

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 1
    if (flags.zero)
        goto cseg_39BB9;                    // jz cseg_39BB9

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_39A25;                    // jnz cseg_39A25

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    FindTeamInDIY();                        // call FindTeamInDIY
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[456642];       // mov ax, dseg_168A67
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_39D78;                    // jz cseg_39D78

cseg_39A25:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1
    if (flags.zero)
        { nullsub_33(); return; }           // jz nullsub_33

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 3
    if (!flags.zero)
        goto cseg_39A53;                    // jnz short cseg_39A53

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 345, 2);    // mov ax, [esi+159h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_39D6E;                    // jnz cseg_39D6E

cseg_39A53:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 4
    if (!flags.zero)
        goto cseg_39A73;                    // jnz short cseg_39A73

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 345, 2);    // mov ax, [esi+159h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_39D82;                    // jnz cseg_39D82

cseg_39A73:;
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = -118;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0FFFFFF8Ah
    A0 = eax;                               // mov A0, eax

cseg_39A89:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 118;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 76h
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.carry && !flags.zero)
        goto cseg_39AC7;                    // ja short cseg_39AC7

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.carry || flags.zero)
        goto cseg_39A89;                    // jbe short cseg_39A89

cseg_39AC7:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = -118;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0FFFFFF8Ah
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_39B46;                    // jnz short cseg_39B46

    {
        word src = (word)readMemory(esi + 353, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+161h], 2
    if (flags.zero)
        goto cseg_39D50;                    // jz cseg_39D50

    {
        word src = (word)readMemory(esi + 353, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+161h], 4
    if (flags.zero)
        goto cseg_39D5A;                    // jz cseg_39D5A

    {
        word src = (word)readMemory(esi + 353, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+161h], 8
    if (flags.zero)
        goto cseg_39D64;                    // jz cseg_39D64

cseg_39B22:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(int16_t *)&D1 = -*(int16_t *)&D1;     // neg word ptr D1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 110;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 6Eh
    return;                                 // retn

cseg_39B46:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.carry && !flags.zero)
        { nullsub_33(); return; }           // ja nullsub_33

    goto cseg_39B22;                        // jmp short cseg_39B22

cseg_39B5F:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 67, 2);     // mov ax, [esi+43h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_39D8C;                    // jz cseg_39D8C

    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 109191;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, offset world_cup_qualifying_group_1_copy
    if (flags.carry)
        goto cseg_39B8A;                    // jb short cseg_39B8A

    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 109867;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, offset oceaniaWorldCupQualificationCopy
    if (flags.carry || flags.zero)
        goto cseg_39BB1;                    // jbe short cseg_39BB1

cseg_39B8A:;
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 108523;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, offset e_c_qualifying_group_1_copy
    if (flags.carry)
        goto cseg_39BA2;                    // jb short cseg_39BA2

    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 108803;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, offset e_c_qualifying_group_8_copy
    if (flags.carry || flags.zero)
        goto cseg_39BB1;                    // jbe short cseg_39BB1

cseg_39BA2:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+5Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_39BB8

cseg_39BB1:;
    flags.carry = *(int16_t *)&D1 != 0;
    *(int16_t *)&D1 = -*(int16_t *)&D1;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // neg word ptr D1

cseg_39BB8:;
    return;                                 // retn

cseg_39BB9:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+55h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_39CA0;                    // jnz cseg_39CA0

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    FindTeamInDIY();                        // call FindTeamInDIY
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[456642];       // mov ax, dseg_168A67
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_39D78;                    // jz cseg_39D78

cseg_39CA0:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1
    if (flags.zero)
        { nullsub_33(); return; }           // jz nullsub_33

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 2
    if (flags.zero)
        goto cseg_39D50;                    // jz cseg_39D50

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 4
    if (flags.carry || flags.zero)
        goto cseg_39D5A;                    // jbe cseg_39D5A

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 8
    if (flags.carry || flags.zero)
        goto cseg_39D64;                    // jbe cseg_39D64

    *(word *)&D2 = 65535;                   // mov word ptr D2, 0FFFFh
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_39CF1:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.carry)
        goto cseg_39CF1;                    // jb short cseg_39CF1

    esi = A6;                               // mov esi, A6
    ax = D2;                                // mov ax, word ptr D2
    return;                                 // retn

    return;                                 // retn

    *(word *)&D1 = 2;                       // mov word ptr D1, 2
    return;                                 // retn

cseg_39D50:;
    *(word *)&D1 = 65436;                   // mov word ptr D1, 0FF9Ch
    return;                                 // retn

cseg_39D5A:;
    *(word *)&D1 = 65435;                   // mov word ptr D1, 0FF9Bh
    return;                                 // retn

cseg_39D64:;
    *(word *)&D1 = 65434;                   // mov word ptr D1, 0FF9Ah
    return;                                 // retn

cseg_39D6E:;
    *(word *)&D1 = 65433;                   // mov word ptr D1, 0FF99h
    return;                                 // retn

cseg_39D78:;
    *(word *)&D1 = 65432;                   // mov word ptr D1, 0FF98h
    return;                                 // retn

cseg_39D82:;
    *(word *)&D1 = 65431;                   // mov word ptr D1, 0FF97h
    return;                                 // retn

cseg_39D8C:;
    *(word *)&D1 = 65430;                   // mov word ptr D1, 0FF96h
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - number of players
//      A0 -> team
// out:
//      D0 - number of substitute players
//
void GetNumberOfSubstitutes()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.playerNumbers
    A2 = eax;                               // mov A2, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto l_not_a_career_team;           // jnz short @@not_a_career_team

    A2 = 92766;                             // mov A2, offset currentMatchPlayers
    goto cseg_39DE7;                        // jmp short cseg_39DE7

l_not_a_career_team:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset currentTeam
    if (!flags.zero)
        goto cseg_39DE7;                    // jnz short cseg_39DE7

    A2 = 99510;                             // mov A2, offset playerPositions

cseg_39DE7:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0

l_players_loop:;
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, size PlayerFile
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        word res = *(word *)&D2 & 224;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 11100000b
    {
        word res = *(word *)&D2 >> 5;
        *(word *)&D2 = res;
    }                                       // shr word ptr D2, 5
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 0
    if (!flags.zero)
        goto l_next_player;                 // jnz short @@next_player

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1

l_next_player:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_players_loop;                // jns @@players_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_39E7E()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 0Ah
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 3Ch
    A2 = eax;                               // mov A2, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto cseg_39EB7;                    // jnz short cseg_39EB7

    A2 = 92766;                             // mov A2, offset currentMatchPlayers
    goto cseg_39ECD;                        // jmp short cseg_39ECD

cseg_39EB7:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset currentTeam
    if (!flags.zero)
        goto cseg_39ECD;                    // jnz short cseg_39ECD

    A2 = 99510;                             // mov A2, offset playerPositions

cseg_39ECD:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0

cseg_39ED6:;
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, size PlayerFile
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        word res = *(word *)&D2 & 224;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 0E0h
    {
        word res = *(word *)&D2 >> 5;
        *(word *)&D2 = res;
    }                                       // shr word ptr D2, 5
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 0
    if (!flags.zero)
        goto cseg_39F56;                    // jnz short cseg_39F56

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1

cseg_39F56:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0Bh
    if (!flags.carry)
        goto cseg_39ED6;                    // jnb cseg_39ED6
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team (file)
//      D0 - exclude players by cards flag (-1 = previous game cards, 1 = red only, 0 = both)
//      D1 - number of players (if 0 init on your own)
// out:
//      D6 - number of disabled players
//      D7 - number of available players
//
void GetNumberOfAvailablePlayers()
{
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.playerNumbers
    A2 = eax;                               // mov A2, eax
    *(word *)&D5 = 16;                      // mov word ptr D5, 16
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto l_not_career_team;             // jnz short @@not_career_team

    A2 = 92766;                             // mov A2, offset currentMatchPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    goto l_check_num_players;               // jmp short @@check_num_players

l_not_career_team:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset currentTeam
    if (!flags.zero)
        goto l_check_num_players;           // jnz short @@check_num_players

    A2 = 99510;                             // mov A2, offset playerPositions
    ax = *(word *)&g_memByte[99542];        // mov ax, numPlayers
    *(word *)&D5 = ax;                      // mov word ptr D5, ax

l_check_num_players:;
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_init_loop;                   // jnz short @@init_loop

    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_init_loop:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

l_players_loop:;
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, size PlayerFile
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = D0;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, D0
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto l_not_injured;                 // jz short @@not_injured

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 20h
    if (!flags.zero)
        goto l_player_disabled;             // jnz short @@player_disabled

l_not_injured:;
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_next_player;                 // jnz short @@next_player

    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, 1
    if (flags.zero)
        goto l_skip_red_card_test;          // jz short @@skip_red_card_test

    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 28;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1Ch
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto l_no_cards;                    // jz short @@no_cards

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (!flags.zero)
        goto l_player_disabled;             // jnz short @@player_disabled

l_no_cards:;
    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_next_player;                 // jns short @@next_player

l_skip_red_card_test:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto l_next_player;                 // jz short @@next_player

l_player_disabled:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

l_next_player:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_players_loop;                // jns @@players_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team
//      D0 -
// out:
//      D6 -
//      D7 -
//
void cseg_3A110()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.playerNumbers
    A2 = eax;                               // mov A2, eax
    *(word *)&D1 = 16;                      // mov word ptr D1, 16
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto l_not_career_team;             // jnz short @@not_career_team

    A2 = 92766;                             // mov A2, offset currentMatchPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    goto l_init_loop;                       // jmp short @@init_loop

l_not_career_team:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset currentTeam
    if (!flags.zero)
        goto l_init_loop;                   // jnz short @@init_loop

    A2 = 99510;                             // mov A2, offset playerPositions
    ax = *(word *)&g_memByte[99542];        // mov ax, numPlayers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_init_loop:;
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

l_players_loop:;
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, size PlayerFile
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = D0;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, D0
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (!flags.zero)
        goto l_next_player;                 // jnz @@next_player

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto cseg_3A242;                    // jz short cseg_3A242

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 20h
    if (!flags.zero)
        goto cseg_3A2B0;                    // jnz short cseg_3A2B0

cseg_3A242:;
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_next_player;                 // jnz short @@next_player

    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, 1
    if (flags.zero)
        goto cseg_3A290;                    // jz short cseg_3A290

    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 28;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1Ch
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto cseg_3A285;                    // jz short cseg_3A285

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (!flags.zero)
        goto cseg_3A2B0;                    // jnz short cseg_3A2B0

cseg_3A285:;
    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_next_player;                 // jns short @@next_player

cseg_3A290:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto l_next_player;                 // jz short @@next_player

cseg_3A2B0:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

l_next_player:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_players_loop;                // jns @@players_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3A2CE()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 3Ch
    A2 = eax;                               // mov A2, eax
    *(word *)&D1 = 16;                      // mov word ptr D1, 16
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto cseg_3A312;                    // jnz short cseg_3A312

    A2 = 92766;                             // mov A2, offset currentMatchPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_3A312:;
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_3A32C:;
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = D0;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, D0
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto cseg_3A45A;                    // jz cseg_3A45A

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto cseg_3A3DC;                    // jz short cseg_3A3DC

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 20h
    if (!flags.zero)
        goto cseg_3A44A;                    // jnz short cseg_3A44A

cseg_3A3DC:;
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3A45A;                    // jnz short cseg_3A45A

    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, 1
    if (flags.zero)
        goto cseg_3A42A;                    // jz short cseg_3A42A

    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 28;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1Ch
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto cseg_3A41F;                    // jz short cseg_3A41F

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (!flags.zero)
        goto cseg_3A44A;                    // jnz short cseg_3A44A

cseg_3A41F:;
    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_3A45A;                    // jns short cseg_3A45A

cseg_3A42A:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto cseg_3A45A;                    // jz short cseg_3A45A

cseg_3A44A:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_3A45A:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_3A32C;                    // jns cseg_3A32C
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 -
//      A0 -> player struct + sizeof(header)
// out:
//      DO - 1 is injured, 0 not
//      zero flag - clear is injured, set is not
//
void IsPlayerInjured()
{
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_training_game;               // jnz short @@training_game

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1
    if (flags.zero)
        goto cseg_3A9AE;                    // jz short cseg_3A9AE

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 28;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 11100b
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto l_zero;                        // jz short @@zero

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (!flags.zero)
        goto l_out_injured;                 // jnz short @@out_injured

l_zero:;
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_training_game;               // jns short @@training_game

cseg_3A9AE:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (!flags.zero)
        goto l_out_injured;                 // jnz short @@out_injured

l_training_game:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+(PlayerFile.cardsInjuries+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto l_out_ok;                      // jz short @@out_ok

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 20h
    if (!flags.zero)
        goto l_out_injured;                 // jnz short @@out_injured

l_out_ok:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

l_out_injured:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> selected contest
//
void cseg_3AA17()
{
    A2 = 27453;                             // mov A2, offset careerContests-6

l_next_contest:;
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 6;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 6
    A2 = eax;                               // mov A2, eax
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 4
    A1 = eax;                               // mov A1, eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, -1
    if (flags.zero)
        goto l_last_contest;                // jz short @@last_contest

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, eax
    if (!flags.zero)
        goto l_next_contest;                // jnz short @@next_contest

    esi = A2;                               // mov esi, A2
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax

l_last_contest:;
    A1 = 126568;                            // mov A1, offset competitionFileBuffer
    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, eax
    if (!flags.zero)
        goto cseg_3AA8B;                    // jnz short cseg_3AA8B

    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_3AAD4;                    // jz short cseg_3AAD4

cseg_3AA8B:;
    A1 = 99964;                             // mov A1, offset dseg_D8D0A
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, eax
    if (flags.zero)
        goto cseg_3AAD4;                    // jz short cseg_3AAD4

    A1 = 102862;                            // mov A1, offset dseg_D985C
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, eax
    if (flags.zero)
        goto cseg_3AAD4;                    // jz short cseg_3AAD4

    A1 = 105044;                            // mov A1, offset dseg_DA0E2
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, eax
    if (!flags.zero)
        goto cseg_3AB65;                    // jnz cseg_3AB65

cseg_3AAD4:;
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    push(A0);                               // push A0
    cseg_8B71C();                           // call cseg_8B71C
    pop(A0);                                // pop A0
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 1
    if (flags.zero)
        goto cseg_3AB25;                    // jz short cseg_3AB25

    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 2
    if (flags.zero)
        goto cseg_3AB45;                    // jz short cseg_3AB45

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    { ShowDiyLeaguesTournamentMenu(); return; } // jmp ShowDiyLeaguesTournamentMenu

cseg_3AB25:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    { cseg_45B51(); return; }               // jmp cseg_45B51

cseg_3AB45:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    { cseg_89B5C(); return; }               // jmp cseg_89B5C

cseg_3AB65:;
    push(D0);                               // push D0
    push(A0);                               // push A0
    SaveSelectedTeams();                    // call SaveSelectedTeams
    pop(A0);                                // pop A0
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 1
    if (flags.zero)
        goto cseg_3ABA1;                    // jz short cseg_3ABA1

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 2
    if (flags.zero)
        goto cseg_3ABA8;                    // jz short cseg_3ABA8

    cseg_3ABB2();                           // call cseg_3ABB2
    goto cseg_3ABAD;                        // jmp short cseg_3ABAD

cseg_3ABA1:;
    cseg_3ACAB();                           // call cseg_3ACAB
    goto cseg_3ABAD;                        // jmp short cseg_3ABAD

cseg_3ABA8:;
    cseg_3ADAE();                           // call cseg_3ADAE

cseg_3ABAD:;
    RestoreSelectedTeams();                 // jmp RestoreSelectedTeams
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3ABB2()
{
    *(word *)&g_memByte[129476] = 1;        // mov dseg_E0052, 1
    ax = *(word *)&g_memByte[317174];       // mov ax, inCareerSeasonUpdate
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3ABDA;                    // jnz short cseg_3ABDA

    ax = *(word *)&g_memByte[317172];       // mov ax, inDIYRestore
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3ABDA;                    // jnz short cseg_3ABDA

    *(word *)&g_memByte[126566] = 1;        // mov dseg_DF4F4, 1

cseg_3ABDA:;
    *(word *)&g_memByte[323894] = 0;        // mov teamsLoaded, 0
    SaveRand2State();                       // call SaveRand2State
    push(*(dword *)&g_memByte[129466]);     // push small [word ptr dseg_E0048]
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 << 8;
        flags.carry = ((word)*(word *)&D0 >> 8) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 8
    al = g_memByte[129467];                 // mov al, seasonPlaying
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    Randomize2();                           // call Randomize2
    *(word *)&g_memByte[131757] = 0;        // mov g_numSelectedTeams, 0
    push(D1);                               // push D1
    push(A0);                               // push A0
    cseg_31F79();                           // call cseg_31F79
    pop(A0);                                // pop A0
    pop(D1);                                // pop D1
    push(D1);                               // push D1
    push(A0);                               // push A0
    cseg_8C623();                           // call cseg_8C623
    pop(A0);                                // pop A0
    pop(D1);                                // pop D1
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(A0);                               // push A0
    cseg_8F1F2();                           // call cseg_8F1F2
    pop(A0);                                // pop A0
    push(A0);                               // push A0
    InitTeams();                            // call InitTeams
    pop(A0);                                // pop A0
    cseg_3AE87();                           // call cseg_3AE87
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[129466] = val;
    }                                       // pop small [word ptr dseg_E0048]
    RestoreRand2State();                    // call RestoreRand2State
    *(word *)&g_memByte[129476] = 0;        // mov dseg_E0052, 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3ACAB()
{
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 32953;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset englishCup
    if (!flags.zero)
        goto cseg_3ACC3;                    // jnz short cseg_3ACC3

    A0 = 33009;                             // mov A0, offset dseg_C8780
    goto cseg_3ACD9;                        // jmp short cseg_3ACD9

cseg_3ACC3:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 32981;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset englishLeagueCup
    if (!flags.zero)
        goto cseg_3ACD9;                    // jnz short cseg_3ACD9

    A0 = 33037;                             // mov A0, offset dseg_C879C

cseg_3ACD9:;
    *(word *)&g_memByte[129476] = 1;        // mov dseg_E0052, 1
    ax = *(word *)&g_memByte[317174];       // mov ax, inCareerSeasonUpdate
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3AD01;                    // jnz short cseg_3AD01

    ax = *(word *)&g_memByte[317172];       // mov ax, inDIYRestore
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3AD01;                    // jnz short cseg_3AD01

    *(word *)&g_memByte[126566] = 1;        // mov dseg_DF4F4, 1

cseg_3AD01:;
    *(word *)&g_memByte[323894] = 0;        // mov teamsLoaded, 0
    SaveRand2State();                       // call SaveRand2State
    push(*(dword *)&g_memByte[129466]);     // push small [word ptr dseg_E0048]
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 << 8;
        flags.carry = ((word)*(word *)&D0 >> 8) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 8
    al = g_memByte[129467];                 // mov al, seasonPlaying
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    Randomize2();                           // call Randomize2
    *(word *)&g_memByte[131757] = 0;        // mov g_numSelectedTeams, 0
    push(A0);                               // push A0
    cseg_32024();                           // call cseg_32024
    pop(A0);                                // pop A0
    push(D1);                               // push D1
    push(A0);                               // push A0
    cseg_8C623();                           // call cseg_8C623
    pop(A0);                                // pop A0
    pop(D1);                                // pop D1
    push(A0);                               // push A0
    cseg_87DA0();                           // call cseg_87DA0
    pop(A0);                                // pop A0
    push(A0);                               // push A0
    InitTeams();                            // call InitTeams
    pop(A0);                                // pop A0
    cseg_3B18F();                           // call cseg_3B18F
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[129466] = val;
    }                                       // pop small [word ptr dseg_E0048]
    RestoreRand2State();                    // call RestoreRand2State
    *(word *)&g_memByte[129476] = 0;        // mov dseg_E0052, 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3ADAE()
{
    *(word *)&g_memByte[129476] = 1;        // mov dseg_E0052, 1
    ax = *(word *)&g_memByte[317174];       // mov ax, inCareerSeasonUpdate
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3ADD6;                    // jnz short cseg_3ADD6

    ax = *(word *)&g_memByte[317172];       // mov ax, inDIYRestore
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3ADD6;                    // jnz short cseg_3ADD6

    *(word *)&g_memByte[126566] = 1;        // mov dseg_DF4F4, 1

cseg_3ADD6:;
    *(word *)&g_memByte[323894] = 0;        // mov teamsLoaded, 0
    SaveRand2State();                       // call SaveRand2State
    push(*(dword *)&g_memByte[129466]);     // push small [word ptr dseg_E0048]
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 << 8;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 8
    al = g_memByte[129467];                 // mov al, seasonPlaying
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    Randomize2();                           // call Randomize2
    *(word *)&g_memByte[131757] = 0;        // mov g_numSelectedTeams, 0
    push(A0);                               // push A0
    cseg_320A3();                           // call cseg_320A3
    pop(A0);                                // pop A0
    push(D1);                               // push D1
    push(A0);                               // push A0
    cseg_8C623();                           // call cseg_8C623
    pop(A0);                                // pop A0
    pop(D1);                                // pop D1
    push(A0);                               // push A0
    cseg_24DFA();                           // call cseg_24DFA
    pop(A0);                                // pop A0
    push(A0);                               // push A0
    InitTeams();                            // call InitTeams
    pop(A0);                                // pop A0
    cseg_3B56F();                           // call cseg_3B56F
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[129466] = val;
    }                                       // pop small [word ptr dseg_E0048]
    RestoreRand2State();                    // call RestoreRand2State
    *(word *)&g_memByte[129476] = 0;        // mov dseg_E0052, 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3AE87()
{
    ax = *(word *)&g_memByte[379876];       // mov ax, dseg_11F9CC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3AEB3;                    // jnz short cseg_3AEB3

    ax = *(word *)&g_memByte[317174];       // mov ax, inCareerSeasonUpdate
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3AEB3;                    // jnz short cseg_3AEB3

    ax = *(word *)&g_memByte[317172];       // mov ax, inDIYRestore
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3AEB3;                    // jnz short cseg_3AEB3

    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3AEC3;                    // jz short cseg_3AEC3

cseg_3AEB3:;
    *(byte *)&D0 = 255;                     // mov byte ptr D0, 0FFh
    *(byte *)&D1 = 255;                     // mov byte ptr D1, 0FFh
    goto cseg_3AF20;                        // jmp short cseg_3AF20

cseg_3AEC3:;
    cseg_8EA56();                           // call cseg_8EA56
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = *(word *)&g_memByte[109904];       // mov ax, dseg_DB3DE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    ax = *(word *)&g_memByte[109908];       // mov ax, dseg_DB3E2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        goto cseg_3AF19;                    // jz short cseg_3AF19

    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    goto cseg_3AF20;                        // jmp short cseg_3AF20

cseg_3AF19:;
    *(byte *)&D1 = 255;                     // mov byte ptr D1, 0FFh

cseg_3AF20:;
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    A1 = 99686;                             // mov A1, offset dseg_D8BF4
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 45, 1);     // mov al, [esi+2Dh]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        word res = *(word *)&D2 & 255;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 0FFh
    eax = A1;                               // mov eax, A1
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    *(byte *)&D6 = 0;                       // mov byte ptr D6, 0
    cseg_3B122();                           // call cseg_3B122

cseg_3AF77:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry || flags.zero)
        goto cseg_3B02A;                    // jbe cseg_3B02A

    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D6);                               // push D6
    push(A0);                               // push A0
    push(A1);                               // push A1
    cseg_88A12();                           // call cseg_88A12
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D6);                                // pop D6
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 447, 2);    // mov ax, [esi+1BFh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3AF77;                    // jz short cseg_3AF77

    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+5Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3B00D;                    // jz short cseg_3B00D

    cseg_3B122();                           // call cseg_3B122
    goto cseg_3AF77;                        // jmp cseg_3AF77

cseg_3B00D:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3B03B;                    // jz short cseg_3B03B

    {
        word src = (word)readMemory(esi + 71, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+47h], 2
    if (flags.zero)
        goto cseg_3B03B;                    // jz short cseg_3B03B

cseg_3B029:;
    return;                                 // retn

cseg_3B02A:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.carry && !flags.zero)
        goto cseg_3B071;                    // ja short cseg_3B071

cseg_3B03B:;
    ax = *(word *)&g_memByte[317172];       // mov ax, inDIYRestore
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short cseg_3B029

    ax = *(word *)&g_memByte[379876];       // mov ax, dseg_11F9CC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short cseg_3B029

cseg_3B051:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    { ShowDiyLeaguesTournamentMenu(); return; } // jmp ShowDiyLeaguesTournamentMenu

cseg_3B071:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.zero)
        goto cseg_3B0E3;                    // jnz short cseg_3B0E3

cseg_3B082:;
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(A0);                               // push A0
    push(A1);                               // push A1
    cseg_88A12();                           // call cseg_88A12
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 447, 2);    // mov ax, [esi+1BFh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3B082;                    // jz short cseg_3B082

    goto cseg_3B03B;                        // jmp cseg_3B03B

cseg_3B0E3:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        word src = *(word *)&g_memByte[378420];
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp viewTeamIndex, 0FFFFh
    if (!flags.zero)
        goto cseg_3B051;                    // jnz cseg_3B051

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    ShowDiyLeaguesTournamentMenu();         // jmp ShowDiyLeaguesTournamentMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3B122()
{
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    cseg_5353F();                           // call cseg_5353F
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    al = D7;                                // mov al, byte ptr D7
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D6 = res;
    }                                       // add byte ptr D6, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3B18F()
{
    ax = *(word *)&g_memByte[379876];       // mov ax, dseg_11F9CC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3B1BB;                    // jnz short cseg_3B1BB

    ax = *(word *)&g_memByte[317174];       // mov ax, inCareerSeasonUpdate
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3B1BB;                    // jnz short cseg_3B1BB

    ax = *(word *)&g_memByte[317172];       // mov ax, inDIYRestore
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3B1BB;                    // jnz short cseg_3B1BB

    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3B1CB;                    // jz short cseg_3B1CB

cseg_3B1BB:;
    *(byte *)&D0 = 255;                     // mov byte ptr D0, 0FFh
    *(byte *)&D1 = 255;                     // mov byte ptr D1, 0FFh
    goto cseg_3B22A;                        // jmp short cseg_3B22A

cseg_3B1CB:;
    cseg_8EA56();                           // call cseg_8EA56
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = *(word *)&g_memByte[109904];       // mov ax, dseg_DB3DE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    ax = *(word *)&g_memByte[109908];       // mov ax, dseg_DB3E2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        goto cseg_3B223;                    // jz short cseg_3B223

    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    goto cseg_3B22A;                        // jmp short cseg_3B22A

cseg_3B223:;
    *(byte *)&D1 = 255;                     // mov byte ptr D1, 0FFh

cseg_3B22A:;
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    A1 = 99686;                             // mov A1, offset dseg_D8BF4
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 45, 1);     // mov al, [esi+2Dh]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        word res = *(word *)&D2 & 255;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 0FFh
    eax = A1;                               // mov eax, A1
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    *(byte *)&D6 = 0;                       // mov byte ptr D6, 0
    cseg_3B4F7();                           // call cseg_3B4F7
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry || flags.zero)
        goto cseg_3B393;                    // jbe cseg_3B393

cseg_3B296:;
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D6);                               // push D6
    push(A0);                               // push A0
    push(A1);                               // push A1
    cseg_28E76();                           // call cseg_28E76
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D6);                                // pop D6
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3B296;                    // jz short cseg_3B296

    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+55h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3B376;                    // jnz short cseg_3B376

    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry || flags.zero)
        goto cseg_3B393;                    // jbe short cseg_3B393

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D6);                               // push D6
    push(A0);                               // push A0
    push(A1);                               // push A1
    cseg_284D8();                           // call cseg_284D8
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D6);                                // pop D6
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    cseg_3B4F7();                           // call cseg_3B4F7
    goto cseg_3B296;                        // jmp cseg_3B296

cseg_3B376:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3B3A4;                    // jz short cseg_3B3A4

    {
        word src = (word)readMemory(esi + 71, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+47h], 2
    if (flags.zero)
        goto cseg_3B3A4;                    // jz short cseg_3B3A4

cseg_3B392:;
    return;                                 // retn

cseg_3B393:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.carry && !flags.zero)
        goto cseg_3B3DA;                    // ja short cseg_3B3DA

cseg_3B3A4:;
    ax = *(word *)&g_memByte[317172];       // mov ax, inDIYRestore
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short cseg_3B392

    ax = *(word *)&g_memByte[379876];       // mov ax, dseg_11F9CC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short cseg_3B392

cseg_3B3BA:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    { cseg_45B51(); return; }               // jmp cseg_45B51

cseg_3B3DA:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3B43B;                    // jz short cseg_3B43B

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D6);                               // push D6
    push(A0);                               // push A0
    push(A1);                               // push A1
    cseg_284D8();                           // call cseg_284D8
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D6);                                // pop D6
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    cseg_3B4F7();                           // call cseg_3B4F7

cseg_3B43B:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    {
        int8_t dstSigned = *(byte *)&D2;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D2, al
    if (!flags.zero)
        goto cseg_3B4B6;                    // jnz short cseg_3B4B6

cseg_3B44C:;
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D6);                               // push D6
    push(A0);                               // push A0
    push(A1);                               // push A1
    cseg_28E76();                           // call cseg_28E76
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D6);                                // pop D6
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3B44C;                    // jz short cseg_3B44C

    goto cseg_3B3A4;                        // jmp cseg_3B3A4

cseg_3B4B6:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        word src = *(word *)&g_memByte[378420];
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp viewTeamIndex, 0FFFFh
    if (!flags.zero)
        goto cseg_3B3BA;                    // jnz cseg_3B3BA

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_45B51();                           // jmp cseg_45B51
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3B4F7()
{
    *(byte *)&D6 = 0;                       // mov byte ptr D6, 0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    cseg_5353F();                           // call cseg_5353F
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    al = D7;                                // mov al, byte ptr D7
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D6 = res;
    }                                       // add byte ptr D6, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3B56F()
{
_l_start:;
    A2 = 317588;                            // mov A2, offset diyFileBufferCopy
    eax = A2;                               // mov eax, A2
    A3 = eax;                               // mov A3, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    bx = 118;                               // mov bx, 76h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, eax
    A4 = 318643;                            // mov A4, offset DIY_competitionStart
    A5 = 318643;                            // mov A5, offset DIY_competitionStart
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3B70F;                    // jz cseg_3B70F

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 71, 2, 1);            // mov word ptr [esi+47h], 1
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_3B625;                    // jnz short cseg_3B625

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 71, 2, 2);            // mov word ptr [esi+47h], 2

cseg_3B625:;
    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_3AE87();                           // call cseg_3AE87
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js cseg_3B7F7

    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_883DD();                           // call cseg_883DD
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_8A147();                           // call cseg_8A147
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto _l_start;                      // jz cseg_3B56F

    return;                                 // retn

cseg_3B70F:;
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 71, 2, 1);            // mov word ptr [esi+47h], 1
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_3B752;                    // jnz short cseg_3B752

    esi = A4;                               // mov esi, A4
    writeMemory(esi + 71, 2, 2);            // mov word ptr [esi+47h], 2

cseg_3B752:;
    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_3B18F();                           // call cseg_3B18F
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js short cseg_3B7F7

    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_8A147();                           // call cseg_8A147
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto _l_start;                      // jz cseg_3B56F

    return;                                 // retn
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3B7F8()
{
    {
        dword src = *(dword *)&g_memByte[91354];
        int32_t dstSigned = src;
        int32_t srcSigned = 100000000;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp newBalance, 100000000
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_3B80E;                    // jle short cseg_3B80E

    *(dword *)&g_memByte[91354] = 100000000; // mov newBalance, 100000000

cseg_3B80E:;
    g_memByte[91352] = 0;                   // mov byte ptr clubBusinessActive, 0
    eax = *(dword *)&g_memByte[91354];      // mov eax, newBalance
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.sign)
        goto l_not_in_minus;                // jns short @@not_in_minus

    g_memByte[91352] = -1;                  // mov byte ptr clubBusinessActive, -1

l_not_in_minus:;
    eax = *(dword *)&g_memByte[91354];      // mov eax, newBalance
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.sign)
        goto cseg_3B838;                    // jns short cseg_3B838

    {
        word src = *(word *)&g_memByte[91334];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91334] = src;
    }                                       // add dseg_D6B54, 1
    return;                                 // jmp short @@out

cseg_3B838:;
    *(word *)&g_memByte[91334] = 0;         // mov dseg_D6B54, 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3B842()
{
    ax = *(word *)&g_memByte[91336];        // mov ax, dseg_D6B56
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_3B85F

    eax = *(dword *)&g_memByte[91354];      // mov eax, newBalance
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.sign)
        return;                             // js short cseg_3B85F

    *(word *)&g_memByte[91336] = 0;         // mov dseg_D6B56, 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3B860()
{
    cseg_3B7F8();                           // call cseg_3B7F8
    cseg_3B842();                           // call cseg_3B842
    cseg_3CCF0();                           // call cseg_3CCF0
    ax = *(word *)&g_memByte[91772];        // mov ax, dseg_D6D0A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3B893;                    // jz short cseg_3B893

    {
        word src = *(word *)&g_memByte[91772];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91772] = src;
    }                                       // sub dseg_D6D0A, 1
    push(D7);                               // push D7
    AddCareerTeamPlayer();                  // call AddCareerTeamPlayer
    pop(D7);                                // pop D7

cseg_3B893:;
    CheckPlayersLeavingComing();            // call CheckPlayersLeavingComing
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0 -  team file number
//     A6 -> DIY competition
// out:
//     D1 -  index of that team in DIY competition, or -1 if not found
//
void FindTeamInDIY()
{
    *(word *)&g_memByte[456642] = 0;        // mov dseg_168A67, 0
    *(word *)&g_memByte[456644] = 0;        // mov dseg_168A69, 0
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+DIY_Competition.numTeams]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+DIY_Competition.competitionType], DIY_CUP
    if (flags.zero)
        goto l_cup;                         // jz @@cup

    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+DIY_Competition.competitionType], DIY_TOURNAMENT
    if (flags.zero)
        goto l_tournament;                  // jz @@tournament

    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+95]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    g_memByte[456644] = 0;                  // mov byte ptr dseg_168A69, 0
    if (!flags.zero)
        goto cseg_3B904;                    // jnz short cseg_3B904

    g_memByte[456644] = -1;                 // mov byte ptr dseg_168A69, -1

cseg_3B904:;
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 301;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 301
    A0 = eax;                               // mov A0, eax
    *(word *)&D1 = -2;                      // mov word ptr D1, -2

l_next_league_team:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    if (flags.sign)
        goto l_err_out;                     // js @@err_out

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 2
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    ax = (word)readMemory(esi + ebx + 109, 2); // mov ax, [esi+ebx+109]
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 18;                                // mov bx, 18
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.zero)
        goto l_next_league_team;            // jnz short @@next_league_team

    {
        word res = *(word *)&D1 >> 1;
        flags.carry = ((word)*(word *)&D1 >> 15) & 1;
        *(word *)&D1 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D1, 1
    return;                                 // retn

l_cup:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+85]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    g_memByte[456644] = 0;                  // mov byte ptr dseg_168A69, 0
    if (flags.zero)
        goto cseg_3B9BD;                    // jz short cseg_3B9BD

    g_memByte[456644] = -1;                 // mov byte ptr dseg_168A69, -1

cseg_3B9BD:;
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 589
    A0 = eax;                               // mov A0, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 717
    A1 = eax;                               // mov A1, eax
    *(word *)&D1 = -1;                      // mov word ptr D1, -1

l_next_cup_team:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    if (flags.sign)
        goto l_err_out;                     // js @@err_out

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.zero)
        goto l_next_cup_team;               // jnz short @@next_cup_team

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+85]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3BA80;                    // jz short cseg_3BA80

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 2
    if (!flags.carry)
        goto cseg_3BA80;                    // jnb short cseg_3BA80

    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    ax = (word)readMemory(esi + 57, 2);     // mov ax, [esi+57]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (flags.zero)
        return;                             // jz @@out

    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    return;                                 // retn

cseg_3BA80:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+79]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry)
        goto cseg_3BAC2;                    // jnb short cseg_3BAC2

    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    return;                                 // retn

cseg_3BAC2:;
    *(word *)&g_memByte[456642] = 1;        // mov dseg_168A67, 1
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 32;                      // mov word ptr D1, 32

cseg_3BAE0:;
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_3BAF8;                    // jnb short cseg_3BAF8

    {
        word res = *(word *)&D1 >> 1;
        flags.carry = ((word)*(word *)&D1 >> 15) & 1;
        *(word *)&D1 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D1, 1
    goto cseg_3BAE0;                        // jmp short cseg_3BAE0

cseg_3BAF8:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    return;                                 // retn

l_tournament:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+87]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    g_memByte[456644] = 0;                  // mov byte ptr dseg_168A69, 0
    if (flags.zero)
        goto cseg_3BB3E;                    // jz short cseg_3BB3E

    g_memByte[456644] = -1;                 // mov byte ptr dseg_168A69, -1

cseg_3BB3E:;
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 153;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 153
    A0 = eax;                               // mov A0, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 89
    A1 = eax;                               // mov A1, eax
    *(word *)&D1 = -1;                      // mov word ptr D1, -1

l_next_tournament_team:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    if (flags.sign)
        goto l_err_out;                     // js @@err_out

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.zero)
        goto l_next_tournament_team;        // jnz short @@next_tournament_team

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+83]
    bx = 118;                               // mov bx, 118
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A6;                               // mov eax, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+87]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3BC5B;                    // jz short cseg_3BC5B

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+353]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry)
        goto cseg_3BC5B;                    // jnb short cseg_3BC5B

    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 1055;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 1055
    A6 = eax;                               // mov A6, eax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+49]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+349]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3B9BD;                    // jz cseg_3B9BD

    goto cseg_3B904;                        // jmp cseg_3B904

cseg_3BC5B:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+353]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry)
        goto cseg_3BC94;                    // jnb short cseg_3BC94

    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+353]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    return;                                 // retn

cseg_3BC94:;
    *(word *)&g_memByte[456642] = 1;        // mov dseg_168A67, 1
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 345, 2);    // mov ax, [esi+345]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3BCCB;                    // jz short cseg_3BCCB

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 3
    if (flags.zero)
        return;                             // jz @@out

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 4
    if (flags.zero)
        return;                             // jz @@out

cseg_3BCCB:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax

cseg_3BCE1:;
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 118;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 118
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+353]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto cseg_3BCE1;                    // jb short cseg_3BCE1

    ax = (word)readMemory(esi + 235, 2);    // mov ax, [esi+235]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[456646];       // mov ax, dseg_168A6B
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3BD5E;                    // jz short cseg_3BD5E

    GetMoreExpensiveTeamsCountWrapper();    // call GetMoreExpensiveTeamsCountWrapper
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (flags.carry)
        goto cseg_3BD5E;                    // jb short cseg_3BD5E

    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (!flags.carry)
        goto cseg_3BD5E;                    // jnb short cseg_3BD5E

    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    return;                                 // retn

cseg_3BD5E:;
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

l_out:;
    return;                                 // retn

l_err_out:;
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        { EndlessLoop(); return; }          // jz EndlessLoop

    *(word *)&D1 = -1;                      // mov word ptr D1, -1
    ax = -1;                                // mov ax, -1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//     D7 -  team number
//     A6 -> diy competition
// out:
//     D6 -  number of more expensive teams in the competition
//
// Save all registers and call GetMoreExpensiveTeamsCount.
//
void GetMoreExpensiveTeamsCountWrapper()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetMoreExpensiveTeamsCount();           // call GetMoreExpensiveTeamsCount
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void EndlessLoop()
{
    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================
//
void CareerPlayMatch()
{
    ax = *(word *)&g_memByte[99866];        // mov ax, careerFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_int3;                        // jz short @@int3

    ax = *(word *)&g_memByte[109910];       // mov ax, dseg_DB3E4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3BE8C;                    // jnz short cseg_3BE8C

cseg_3BE87:;
    cseg_8E841();                           // call cseg_8E841

cseg_3BE8C:;
    cseg_8EA82();                           // call cseg_8EA82
    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3BE87;                    // jz short cseg_3BE87

    return;                                 // retn

l_int3:;
    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3BEA0()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_39392();                           // call cseg_39392
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    cseg_60E1C();                           // call cseg_60E1C
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 1;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)&D6 = 99;                      // mov word ptr D6, 63h

cseg_3BF88:;
    ax = *(word *)&g_memByte[92166];        // mov ax, numJobOffers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[92034];        // mov ax, numNewJobOffers
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_3BFD6;                    // jnb short cseg_3BFD6

    push(D6);                               // push D6
    push(D7);                               // push D7
    cseg_5B705();                           // call cseg_5B705
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto cseg_3BF88;                    // jns short cseg_3BF88

cseg_3BFD6:;
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { cseg_3C07C(); return; }           // jnz cseg_3C07C

    push(*(dword *)&g_memByte[91720]);      // push small [selTeamNumber]
    al = g_memByte[92802];                  // mov al, careerTeam+4
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    push(D0);                               // push D0
    *(word *)&g_memByte[91720] = -1;        // mov selTeamNumber, -1
    g_memByte[92802] = 1;                   // mov careerTeam+4, 1
    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    A0 = eax;                               // mov A0, eax
    cseg_3C09F();                           // call cseg_3C09F
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        goto cseg_3C033;                    // jz short cseg_3C033

    cseg_3C09F();                           // call cseg_3C09F

cseg_3C033:;
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        goto cseg_3C04B;                    // jz short cseg_3C04B

    cseg_3C09F();                           // call cseg_3C09F

cseg_3C04B:;
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        goto cseg_3C063;                    // jz short cseg_3C063

    cseg_3C09F();                           // call cseg_3C09F

cseg_3C063:;
    pop(D0);                                // pop D0
    al = D0;                                // mov al, byte ptr D0
    g_memByte[92802] = al;                  // mov careerTeam+4, al
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[91720] = val;
    }                                       // pop small [selTeamNumber]

    cseg_3C07C();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3C07C()
{
    *(word *)&g_memByte[91346] = 1;         // mov retired, 1
    cseg_3D7CB();                           // call cseg_3D7CB
    cseg_3DCC8();                           // call cseg_3DCC8
    cseg_3D5E1();                           // call cseg_3D5E1
    cseg_5B705();                           // call cseg_5B705
    cseg_3D6A2();                           // call cseg_3D6A2
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3C09F()
{
    *(word *)&g_memByte[379876] = 1;        // mov dseg_11F9CC, 1
    A1 = 126568;                            // mov A1, offset competitionFileBuffer
    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, eax
    if (flags.zero)
        goto cseg_3C0F7;                    // jz short cseg_3C0F7

    A1 = 99964;                             // mov A1, offset dseg_D8D0A
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, eax
    if (flags.zero)
        goto cseg_3C0F7;                    // jz short cseg_3C0F7

    A1 = 102862;                            // mov A1, offset dseg_D985C
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, eax
    if (flags.zero)
        goto cseg_3C0F7;                    // jz short cseg_3C0F7

    A1 = 105044;                            // mov A1, offset dseg_DA0E2

cseg_3C0F7:;
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    push(A0);                               // push A0
    cseg_8B71C();                           // call cseg_8B71C
    pop(A0);                                // pop A0
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 1
    if (flags.zero)
        goto cseg_3C13B;                    // jz short cseg_3C13B

    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 2
    if (flags.zero)
        goto cseg_3C14E;                    // jz short cseg_3C14E

    push(A0);                               // push A0
    cseg_3AE87();                           // call cseg_3AE87
    pop(A0);                                // pop A0
    goto cseg_3C15F;                        // jmp short cseg_3C15F

cseg_3C13B:;
    push(A0);                               // push A0
    cseg_3B18F();                           // call cseg_3B18F
    pop(A0);                                // pop A0
    goto cseg_3C15F;                        // jmp short cseg_3C15F

cseg_3C14E:;
    push(A0);                               // push A0
    cseg_3B56F();                           // call cseg_3B56F
    pop(A0);                                // pop A0

cseg_3C15F:;
    cseg_8B7EA();                           // call cseg_8B7EA
    *(word *)&g_memByte[379876] = 0;        // mov dseg_11F9CC, 0
}

// =============== S U B R O U T I N E =======================================
//
void ShowChairmanOpinionAboutTheSeason()
{
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { ShowSeasonOpinion(); return; }    // jnz ShowSeasonOpinion

    A6 = 126568;                            // mov A6, offset competitionFileBuffer
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(A6);                               // push A6
    FindTeamInDIY();                        // call FindTeamInDIY
    pop(A6);                                // pop A6
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    GetMoreExpensiveTeamsCount();           // call GetMoreExpensiveTeamsCount
    pop(D1);                                // pop D1
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+49]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    eax = *(int16_t *)&D0;                  // movsx eax, word ptr D0
    ebx = 100;                              // mov ebx, 100
    {
        int64_t res = (int64_t)eax * (int32_t)ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // imul ebx
    edx ^= edx;                             // xor edx, edx
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    {
        int64_t dividend = ((int64_t)edx << 32) | (int32_t)eax;
        int32_t quot = (int32_t)(dividend / (int32_t)ebx);
        int32_t rem = (int32_t)(dividend % (int32_t)ebx);
        eax = quot;
        edx = rem;
    }                                       // idiv ebx
    D0 = eax;                               // mov D0, eax
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0
    if (flags.zero)
        goto cseg_3C271;                    // jz short cseg_3C271

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1Eh
    if (flags.sign == flags.overflow)
        goto cseg_3C271;                    // jge short cseg_3C271

    *(word *)&D7 = 1;                       // mov word ptr D7, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0Ah
    if (flags.sign == flags.overflow)
        goto cseg_3C271;                    // jge short cseg_3C271

    *(word *)&D7 = 2;                       // mov word ptr D7, 2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 65526;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0FFF6h
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_3C271;                    // jg short cseg_3C271

    *(word *)&D7 = 3;                       // mov word ptr D7, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 65506;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0FFE2h
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_3C271;                    // jg short cseg_3C271

    *(word *)&D7 = 4;                       // mov word ptr D7, 4

cseg_3C271:;
    ax = D1;                                // mov ax, word ptr D1
    bx = 100;                               // mov bx, 64h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 49, 2);
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / src);
        word rem = (word)(dividend % src);
        ax = quot;
        dx = rem;
    }                                       // div word ptr [esi+31h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 19h
    if (!flags.carry && !flags.zero)
        goto cseg_3C2CD;                    // ja short cseg_3C2CD

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_3C2CD:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 75;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4Bh
    if (flags.carry)
        goto cseg_3C2DF;                    // jb short cseg_3C2DF

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1

cseg_3C2DF:;
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_3C321;                    // jz short cseg_3C321

    A6 = 99964;                             // mov A6, offset dseg_D8D0A
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D7);                               // push D7
    FindTeamInDIY();                        // call FindTeamInDIY
    pop(D7);                                // pop D7
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 2
    if (!flags.carry)
        goto cseg_3C321;                    // jnb short cseg_3C321

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 2

cseg_3C321:;
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_3C363;                    // jz short cseg_3C363

    A6 = 102862;                            // mov A6, offset dseg_D985C
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D7);                               // push D7
    FindTeamInDIY();                        // call FindTeamInDIY
    pop(D7);                                // pop D7
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 2
    if (!flags.carry)
        goto cseg_3C363;                    // jnb short cseg_3C363

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 2

cseg_3C363:;
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_3C3A5;                    // jz short cseg_3C3A5

    A6 = 105044;                            // mov A6, offset dseg_DA0E2
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D7);                               // push D7
    FindTeamInDIY();                        // call FindTeamInDIY
    pop(D7);                                // pop D7
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 2
    if (!flags.carry)
        goto cseg_3C3A5;                    // jnb short cseg_3C3A5

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 3

cseg_3C3A5:;
    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_3C3B9;                    // jns short cseg_3C3B9

    *(word *)&D7 = 0;                       // mov word ptr D7, 0

cseg_3C3B9:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 4
    if (!flags.carry)
        goto l_disappointing_season;        // jnb short @@disappointing_season

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 3
    if (flags.zero)
        goto l_not_very_good_season;        // jz short @@not_very_good_season

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 2
    if (flags.zero)
        goto l_so_so_season;                // jz short @@so_so_season

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 1
    if (flags.zero)
        goto l_good_season;                 // jz short @@good_season

    *(word *)&D0 = 13;                      // mov word ptr D0, WELL_DONE_EXCELLENT_JOB
    goto cseg_3C416;                        // jmp short cseg_3C416

l_good_season:;
    *(word *)&D0 = 14;                      // mov word ptr D0, GOOD_SEASON_ALL_PLEASED
    goto cseg_3C416;                        // jmp short cseg_3C416

l_so_so_season:;
    *(word *)&D0 = 15;                      // mov word ptr D0, UP_AND_DOWN_SEASON
    goto cseg_3C416;                        // jmp short cseg_3C416

l_not_very_good_season:;
    *(word *)&D0 = 16;                      // mov word ptr D0, NOT_A_VERY_GOOD_SEASON
    goto cseg_3C416;                        // jmp short cseg_3C416

l_disappointing_season:;
    *(word *)&D0 = 17;                      // mov word ptr D0, DISAPPOINTING_SEASON

cseg_3C416:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[337240] = ax;       // mov currentMessage, ax
    ShowChairmanMessage();                  // jmp ShowChairmanMessage
}

// =============== S U B R O U T I N E =======================================

// out:
//      D0 - average player price in all selected teams
//           (0 if no teams selected)
//
void GetAveragePlayerPriceInSelectedTeams()
{
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A6 = eax;                               // mov A6, eax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1
    *(word *)&D6 = 0;                       // mov word ptr D6, 0

l_teams_average_price_loop:;
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 684
    A6 = eax;                               // mov A6, eax
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_teams_average_price_loop;    // jns short @@teams_average_price_loop

    ax = D6;                                // mov ax, word ptr D6
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    {
        word src = *(word *)&g_memByte[131757];
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / src);
        word rem = (word)(dividend % src);
        ax = quot;
        dx = rem;
    }                                       // div g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3C4CE()
{
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_3CB04

    eax = A0;                               // mov eax, A0
    A3 = eax;                               // mov A3, eax
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 43, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2Bh], 0
    if (flags.zero)
        goto cseg_3C53B;                    // jz short cseg_3C53B

    {
        word src = (word)readMemory(esi + 43, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2Bh], 4
    if (flags.zero)
        goto cseg_3C8DA;                    // jz cseg_3C8DA

    {
        word src = (word)readMemory(esi + 43, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2Bh], 1
    if (flags.zero)
        goto cseg_3C825;                    // jz cseg_3C825

    {
        word src = (word)readMemory(esi + 43, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2Bh], 2
    if (flags.zero)
        goto cseg_3C825;                    // jz cseg_3C825

    {
        word src = (word)readMemory(esi + 43, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2Bh], 3
    if (flags.zero)
        goto cseg_3C8DF;                    // jz cseg_3C8DF

    debugBreak();                           // int 3

cseg_3C539:;
    goto cseg_3C539;                        // jmp short cseg_3C539

cseg_3C53B:;
    cseg_3CB08();                           // call cseg_3CB08
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3C7C4;                    // jnz cseg_3C7C4

    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 0
    if (flags.zero)
        goto cseg_3C562;                    // jz short cseg_3C562

    debugBreak();                           // int 3

cseg_3C560:;
    goto cseg_3C560;                        // jmp short cseg_3C560

cseg_3C562:;
    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3C5BD;                    // jz short cseg_3C5BD

    {
        word src = *(word *)&g_memByte[91726];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6CDC, 1
    if (flags.zero)
        goto cseg_3C5A9;                    // jz short cseg_3C5A9

    {
        word src = *(word *)&g_memByte[91726];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6CDC, 2
    if (flags.zero)
        goto cseg_3C595;                    // jz short cseg_3C595

    *(word *)&D3 = 88;                      // mov word ptr D3, 58h
    *(word *)&D4 = 113;                     // mov word ptr D4, 71h
    goto cseg_3C5CF;                        // jmp short cseg_3C5CF

cseg_3C595:;
    *(word *)&D3 = 89;                      // mov word ptr D3, 59h
    *(word *)&D4 = 120;                     // mov word ptr D4, 78h
    goto cseg_3C5CF;                        // jmp short cseg_3C5CF

cseg_3C5A9:;
    *(word *)&D3 = 85;                      // mov word ptr D3, 55h
    *(word *)&D4 = 129;                     // mov word ptr D4, 81h
    goto cseg_3C5CF;                        // jmp short cseg_3C5CF

cseg_3C5BD:;
    *(word *)&D3 = 82;                      // mov word ptr D3, 52h
    *(word *)&D4 = 125;                     // mov word ptr D4, 7Dh

cseg_3C5CF:;
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 301;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 12Dh
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)&D1 = 65534;                   // mov word ptr D1, 0FFFEh

cseg_3C5F3:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 2
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    ax = (word)readMemory(esi + ebx + 109, 2); // mov ax, [esi+ebx+6Dh]
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    edx ^= edx;                             // xor edx, edx
    ebx = 18;                               // mov ebx, 12h
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D0 = eax;                               // mov D0, eax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_3C5F3;                    // jnz short cseg_3C5F3

    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    ebx = 100;                              // mov ebx, 64h
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    D1 = eax;                               // mov D1, eax
    edx ^= edx;                             // xor edx, edx
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D1 = eax;                               // mov D1, eax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    D1 = eax;                               // mov D1, eax
    edx ^= edx;                             // xor edx, edx
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    ebx = 100;                              // mov ebx, 64h
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D1 = eax;                               // mov D1, eax
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[337178] = ax;       // mov ballSpeed, ax
    al = (byte)readMemory(esi + 47, 1);     // mov al, [esi+2Fh]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
        flags.carry = edx != 0 != 0;
    }                                       // mul ebx
    D1 = eax;                               // mov D1, eax
    A0 = 92798;                             // mov A0, offset careerTeam
    push(D1);                               // push D1
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    pop(D1);                                // pop D1
    edx ^= edx;                             // xor edx, edx
    eax = *(word *)&D1;                     // movzx eax, word ptr D1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D1 = eax;                               // mov D1, eax
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    {
        int64_t res = (int64_t)eax * (int32_t)ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // imul ebx
    edx ^= edx;                             // xor edx, edx
    ebx = 100;                              // mov ebx, 64h
    {
        int64_t dividend = ((int64_t)edx << 32) | (int32_t)eax;
        int32_t quot = (int32_t)(dividend / (int32_t)ebx);
        int32_t rem = (int32_t)(dividend % (int32_t)ebx);
        eax = quot;
        edx = rem;
    }                                       // idiv ebx
    D7 = eax;                               // mov D7, eax
    *(word *)&g_memByte[337182] = ax;       // mov dseg_114EA8, ax
    goto cseg_3CA8F;                        // jmp cseg_3CA8F

cseg_3C7C4:;
    ax = *(word *)&g_memByte[317671];       // mov ax, dseg_10EADD
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ebx = 118;                              // mov ebx, 76h
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    D0 = eax;                               // mov D0, eax
    eax = A3;                               // mov eax, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3CA8F;                    // jnz cseg_3CA8F

    {
        word src = (word)readMemory(esi + 365, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+16Dh], 2
    if (flags.zero)
        goto cseg_3CA8F;                    // jz cseg_3CA8F

    goto cseg_3CAA9;                        // jmp cseg_3CAA9

cseg_3C825:;
    cseg_3CBFE();                           // call cseg_3CBFE
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (flags.zero)
        goto cseg_3C839;                    // jz short cseg_3C839

    debugBreak();                           // int 3

cseg_3C837:;
    goto cseg_3C837;                        // jmp short cseg_3C837

cseg_3C839:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    A0 = 492467;                            // mov A0, offset dseg_1750B4
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ebx = (word)readMemory(esi + ebx, 2);   // movzx ebx, word ptr [esi+ebx]
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    edx ^= edx;                             // xor edx, edx
    ebx = 100;                              // mov ebx, 64h
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D7 = eax;                               // mov D7, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        word src = (word)readMemory(esi + ebx + 101, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+ebx+65h], 2
    if (flags.zero)
        goto cseg_3CA8F;                    // jz cseg_3CA8F

    goto cseg_3CAA9;                        // jmp cseg_3CAA9

cseg_3C8DA:;
    goto cseg_3C825;                        // jmp cseg_3C825

cseg_3C8DF:;
    cseg_3CBFE();                           // call cseg_3CBFE
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3C9B8;                    // jnz cseg_3C9B8

    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 0
    if (flags.zero)
        goto cseg_3C912;                    // jz short cseg_3C912

    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (flags.zero)
        goto cseg_3C917;                    // jz short cseg_3C917

    debugBreak();                           // int 3

cseg_3C910:;
    goto cseg_3C910;                        // jmp short cseg_3C910

cseg_3C912:;
    goto cseg_3CA8F;                        // jmp cseg_3CA8F

cseg_3C917:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    A0 = 492479;                            // mov A0, offset dseg_1750C0
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ebx = (word)readMemory(esi + ebx, 2);   // movzx ebx, word ptr [esi+ebx]
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    edx ^= edx;                             // xor edx, edx
    ebx = 100;                              // mov ebx, 64h
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D7 = eax;                               // mov D7, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        word src = (word)readMemory(esi + ebx + 101, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+ebx+65h], 2
    if (flags.zero)
        goto cseg_3CA8F;                    // jz cseg_3CA8F

    goto cseg_3CAA9;                        // jmp cseg_3CAA9

cseg_3C9B8:;
    A0 = 317588;                            // mov A0, offset diyFileBufferCopy
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    A0 = 492479;                            // mov A0, offset dseg_1750C0
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ebx = (word)readMemory(esi + ebx, 2);   // movzx ebx, word ptr [esi+ebx]
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    edx ^= edx;                             // xor edx, edx
    ebx = 100;                              // mov ebx, 64h
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D7 = eax;                               // mov D7, eax
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    bx = 118;                               // mov bx, 76h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A3;                               // mov eax, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3CA8F;                    // jnz short cseg_3CA8F

    {
        word src = (word)readMemory(esi + 365, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+16Dh], 2
    if (flags.zero)
        goto cseg_3CA8F;                    // jz short cseg_3CA8F

    goto cseg_3CAA9;                        // jmp short cseg_3CAA9

cseg_3CA8F:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (!flags.zero)
        goto cseg_3CAB3;                    // jnz short cseg_3CAB3

    {
        dword res = D7 << 1;
        D7 = res;
    }                                       // shl D7, 1
    {
        word src = *(word *)&g_memByte[492503];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[492503] = src;
    }                                       // add dseg_1750D8, 1

cseg_3CAA9:;
    {
        word src = *(word *)&g_memByte[492503];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[492503] = src;
    }                                       // add dseg_1750D8, 1
    goto cseg_3CABD;                        // jmp short cseg_3CABD

cseg_3CAB3:;
    D7 = 0;                                 // mov D7, 0

cseg_3CABD:;
    {
        dword res = D7 & 65535;
        D7 = res;
    }                                       // and D7, 0FFFFh
    {
        dword res = D7 << 4;
        D7 = res;
    }                                       // shl D7, 4
    eax = D7;                               // mov eax, D7
    {
        dword src = *(dword *)&g_memByte[91378];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91378] = src;
    }                                       // add gateReceipts, eax
    {
        dword src = *(dword *)&g_memByte[91354];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91354] = src;
    }                                       // add newBalance, eax
    {
        dword src = *(dword *)&g_memByte[492507];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[492507] = src;
    }                                       // add dseg_1750DC, eax
    {
        dword src = *(dword *)&g_memByte[492499];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(dword *)&g_memByte[492499] = src;
    }                                       // add dseg_1750D4, eax
    cseg_3B7F8();                           // call cseg_3B7F8
    cseg_3B842();                           // call cseg_3B842
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3CB05()
{

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3CB08()
{
    eax = *(dword *)&g_memByte[91412];      // mov eax, dseg_D6BA2
    D0 = eax;                               // mov D0, eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_3CB3C;                    // jz short cseg_3CB3C

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    cseg_5E535();                           // call cseg_5E535

cseg_3CB3C:;
    eax = D0;                               // mov eax, D0
    edx ^= edx;                             // xor edx, edx
    ebx = 4000;                             // mov ebx, 0FA0h
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    ebx = 10000;                            // mov ebx, 2710h
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    D7 = eax;                               // mov D7, eax
    eax = *(dword *)&g_memByte[91412];      // mov eax, dseg_D6BA2
    D0 = eax;                               // mov D0, eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (flags.zero)
        goto cseg_3CB9E;                    // jz short cseg_3CB9E

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    cseg_5E535();                           // call cseg_5E535

cseg_3CB9E:;
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    edx ^= edx;                             // xor edx, edx
    ebx = 4000;                             // mov ebx, 0FA0h
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D0 = eax;                               // mov D0, eax
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ebx = 2000;                             // mov ebx, 7D0h
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    D0 = eax;                               // mov D0, eax
    {
        int32_t dstSigned = D7;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D7 = res;
    }                                       // add D7, eax
    {
        dword res = D7 >> 4;
        D7 = res;
    }                                       // shr D7, 4
    eax = D7;                               // mov eax, D7
    edx ^= edx;                             // xor edx, edx
    ebx = *(word *)&g_memByte[91584];       // movzx ebx, dseg_D6C4E
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D7 = eax;                               // mov D7, eax
    {
        dword res = D7 & 65535;
        D7 = res;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and D7, 0FFFFh
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3CBFE()
{
    eax = *(dword *)&g_memByte[91412];      // mov eax, dseg_D6BA2
    D0 = eax;                               // mov D0, eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_3CC32;                    // jz short cseg_3CC32

    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    cseg_5E535();                           // call cseg_5E535

cseg_3CC32:;
    eax = D0;                               // mov eax, D0
    edx ^= edx;                             // xor edx, edx
    ebx = 4000;                             // mov ebx, 0FA0h
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    ebx = 6000;                             // mov ebx, 1770h
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    D7 = eax;                               // mov D7, eax
    eax = *(dword *)&g_memByte[91412];      // mov eax, dseg_D6BA2
    D0 = eax;                               // mov D0, eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (flags.zero)
        goto cseg_3CC94;                    // jz short cseg_3CC94

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    cseg_5E535();                           // call cseg_5E535

cseg_3CC94:;
    eax = D0;                               // mov eax, D0
    edx ^= edx;                             // xor edx, edx
    ebx = 4000;                             // mov ebx, 0FA0h
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    ebx = 6000;                             // mov ebx, 1770h
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    D0 = eax;                               // mov D0, eax
    {
        int32_t dstSigned = D7;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D7 = res;
    }                                       // add D7, eax
    {
        dword res = D7 >> 4;
        D7 = res;
    }                                       // shr D7, 4
    eax = D7;                               // mov eax, D7
    edx ^= edx;                             // xor edx, edx
    ebx = *(word *)&g_memByte[91584];       // movzx ebx, dseg_D6C4E
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D7 = eax;                               // mov D7, eax
    {
        dword res = D7 & 65535;
        D7 = res;
        flags.carry = false;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and D7, 0FFFFh
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3CCF0()
{
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[91340];        // mov ax, dseg_D6B5A
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3CD12;                    // jz short cseg_3CD12

    {
        word src = *(word *)&g_memByte[91340];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[91340] = src;
    }                                       // sub dseg_D6B5A, 1

cseg_3CD12:;
    ax = *(word *)&g_memByte[91342];        // mov ax, dseg_D6B5C
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3CD25;                    // jz short cseg_3CD25

    {
        word src = *(word *)&g_memByte[91342];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91342] = src;
    }                                       // sub dseg_D6B5C, 1

cseg_3CD25:;
    A6 = 126568;                            // mov A6, offset competitionFileBuffer
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    FindTeamInDIY();                        // call FindTeamInDIY
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    al = g_memByte[129466];                 // mov al, dseg_E0048
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = g_memByte[109913];                 // mov al, dseg_DB3E6+1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    {
        word src = *(word *)&g_memByte[91668];
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / src);
        word rem = (word)(dividend % src);
        ax = quot;
        dx = rem;
    }                                       // div dseg_D6CA2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3CFF1;                    // jz cseg_3CFF1

    {
        word src = *(word *)&g_memByte[126568];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp competitionFileBuffer, 2
    if (flags.zero)
        goto cseg_3CE12;                    // jz short cseg_3CE12

    ax = *(word *)&g_memByte[126663];       // mov ax, dseg_DF555
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3CFF1;                    // jz cseg_3CFF1

    ax = *(word *)&g_memByte[126655];       // mov ax, dseg_DF54D
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[126657];       // mov ax, dseg_DF54F
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    if (!flags.zero)
        goto cseg_3CDEF;                    // jnz short cseg_3CDEF

    *(word *)&D0 = 1;                       // mov word ptr D0, 1

cseg_3CDEF:;
    *(int16_t *)&D0 = -*(int16_t *)&D0;     // neg word ptr D0
    ax = *(word *)&g_memByte[126617];       // mov ax, numDiyTeams
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.carry)
        goto cseg_3CE74;                    // jnb short cseg_3CE74

cseg_3CE12:;
    ax = *(word *)&g_memByte[91586];        // mov ax, dseg_D6C50
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
    ax = D2;                                // mov ax, word ptr D2
    bx = 100;                               // mov bx, 100
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    {
        int16_t src = *(word *)&g_memByte[126617];
        int32_t dividend = ((int16_t)dx << 16) | (int16_t)ax;
        int16_t quot = (int16_t)(dividend / src);
        int16_t rem = (int16_t)(dividend % src);
        ax = quot;
        dx = rem;
    }                                       // idiv numDiyTeams
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 65511;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 0FFE7h
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_3CFE8;                    // jg cseg_3CFE8

cseg_3CE74:;
    ax = *(word *)&g_memByte[91342];        // mov ax, dseg_D6B5C
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91338];        // mov ax, dseg_D6B58
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3CF8F;                    // jz cseg_3CF8F

    {
        word src = *(word *)&g_memByte[91338];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6B58, 1
    if (flags.zero)
        goto cseg_3CFB6;                    // jz cseg_3CFB6

    {
        word src = *(word *)&g_memByte[91338];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6B58, 2
    if (flags.zero)
        goto cseg_3CF0C;                    // jz short cseg_3CF0C

    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3CEC0;                    // jnz short cseg_3CEC0

    *(word *)&g_memByte[91338] = 3;         // mov dseg_D6B58, 3
    goto cseg_3CFF6;                        // jmp cseg_3CFF6

cseg_3CEC0:;
    {
        word src = *(word *)&g_memByte[91338];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91338] = src;
    }                                       // add dseg_D6B58, 1
    {
        word src = *(word *)&g_memByte[91338];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6B58, 6
    if (flags.carry)
        goto cseg_3CFF6;                    // jb cseg_3CFF6

    ax = *(word *)&g_memByte[91350];        // mov ax, dseg_D6B64
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3CFF6;                    // jnz cseg_3CFF6

    ax = *(word *)&g_memByte[91348];        // mov ax, dseg_D6B62
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3CFF6;                    // jnz cseg_3CFF6

    *(word *)&g_memByte[337240] = 12;       // mov currentMessage, YOURE_SACKED_2
    ShowChairmanMessage();                  // call ShowChairmanMessage
    *(word *)&g_memByte[91344] = 1;         // mov youreSacked, 1
    return;                                 // retn

cseg_3CF0C:;
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3CFF6;                    // jnz cseg_3CFF6

    {
        word src = *(word *)&g_memByte[91336];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6B56, 3
    if (!flags.carry)
        goto cseg_3CFDD;                    // jnb cseg_3CFDD

    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3CFDD;                    // jz cseg_3CFDD

    ax = *(word *)&g_memByte[91350];        // mov ax, dseg_D6B64
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3CFDD;                    // jnz cseg_3CFDD

    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_3CF5F;                    // jz short cseg_3CF5F

    ax = *(word *)&g_memByte[100039];       // mov ax, dseg_D8D55
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3CFDD;                    // jnz cseg_3CFDD

cseg_3CF5F:;
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_3CF73;                    // jz short cseg_3CF73

    ax = *(word *)&g_memByte[102937];       // mov ax, dseg_D98A7
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3CFDD;                    // jnz short cseg_3CFDD

cseg_3CF73:;
    *(word *)&g_memByte[91338] = 3;         // mov dseg_D6B58, 3
    cseg_3D1C8();                           // call cseg_3D1C8
    *(word *)&g_memByte[337240] = 11;       // mov currentMessage, THREE_MORE_MATCHES_TO_IMPROVE_TEAM
    { ShowChairmanMessage(); return; }      // jmp ShowChairmanMessage

cseg_3CF8F:;
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3CFF6;                    // jnz short cseg_3CFF6

    *(word *)&g_memByte[91338] = 1;         // mov dseg_D6B58, 1
    cseg_3D1C8();                           // call cseg_3D1C8
    *(word *)&g_memByte[337240] = 9;        // mov currentMessage, IMPROVE_LEAGUE_POSITION
    { ShowChairmanMessage(); return; }      // jmp ShowChairmanMessage

cseg_3CFB6:;
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3CFF6;                    // jnz short cseg_3CFF6

    *(word *)&g_memByte[91338] = 2;         // mov dseg_D6B58, 2

cseg_3CFCA:;
    cseg_3D1C8();                           // call cseg_3D1C8
    *(word *)&g_memByte[337240] = 10;       // mov currentMessage, IMPROVE_LEAGUE_POSITION_SOON
    { ShowChairmanMessage(); return; }      // jmp ShowChairmanMessage

cseg_3CFDD:;
    {
        byte src = g_memByte[323904];
        byte res = src & 4;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr currentGameTick, 4
    if (flags.zero)
        goto cseg_3CFCA;                    // jz short cseg_3CFCA

    goto cseg_3CFF6;                        // jmp short cseg_3CFF6

cseg_3CFE8:;
    *(word *)&g_memByte[91338] = 0;         // mov dseg_D6B58, 0

cseg_3CFF1:;
    cseg_3D1C8();                           // call cseg_3D1C8

cseg_3CFF6:;
    cseg_3B842();                           // call cseg_3B842
    eax = *(dword *)&g_memByte[91354];      // mov eax, newBalance
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.sign)
        goto cseg_3D186;                    // jns cseg_3D186

    {
        word src = *(word *)&g_memByte[126568];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp competitionFileBuffer, 2
    if (flags.zero)
        goto cseg_3D021;                    // jz short cseg_3D021

    ax = *(word *)&g_memByte[126663];       // mov ax, dseg_DF555
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

cseg_3D021:;
    ax = *(word *)&g_memByte[91340];        // mov ax, dseg_D6B5A
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91336];        // mov ax, dseg_D6B56
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3D138;                    // jz cseg_3D138

    {
        word src = *(word *)&g_memByte[91336];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6B56, 1
    if (flags.zero)
        goto cseg_3D15F;                    // jz cseg_3D15F

    {
        word src = *(word *)&g_memByte[91336];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6B56, 2
    if (flags.zero)
        goto cseg_3D0B9;                    // jz short cseg_3D0B9

    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3D06D;                    // jnz short cseg_3D06D

    *(word *)&g_memByte[91336] = 3;         // mov dseg_D6B56, 3
    return;                                 // jmp @@out

cseg_3D06D:;
    {
        word src = *(word *)&g_memByte[91336];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91336] = src;
    }                                       // add dseg_D6B56, 1
    {
        word src = *(word *)&g_memByte[91336];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6B56, 6
    if (flags.carry)
        return;                             // jb @@out

    ax = *(word *)&g_memByte[91350];        // mov ax, dseg_D6B64
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[91348];        // mov ax, dseg_D6B62
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    *(word *)&g_memByte[337240] = 8;        // mov currentMessage, YOURE_SACKED
    ShowChairmanMessage();                  // call ShowChairmanMessage
    *(word *)&g_memByte[91344] = 1;         // mov youreSacked, 1
    return;                                 // retn

cseg_3D0B9:;
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    {
        word src = *(word *)&g_memByte[91338];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6B58, 3
    if (!flags.carry)
        goto cseg_3D16A;                    // jnb cseg_3D16A

    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3D16A;                    // jz cseg_3D16A

    ax = *(word *)&g_memByte[91350];        // mov ax, dseg_D6B64
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3D16A;                    // jnz short cseg_3D16A

    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_3D108;                    // jz short cseg_3D108

    ax = *(word *)&g_memByte[100039];       // mov ax, dseg_D8D55
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3D16A;                    // jnz short cseg_3D16A

cseg_3D108:;
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_3D11C;                    // jz short cseg_3D11C

    ax = *(word *)&g_memByte[102937];       // mov ax, dseg_D98A7
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3D16A;                    // jnz short cseg_3D16A

cseg_3D11C:;
    *(word *)&g_memByte[91336] = 3;         // mov dseg_D6B56, 3
    cseg_3D18C();                           // call cseg_3D18C
    *(word *)&g_memByte[337240] = 7;        // mov currentMessage, CLEAR_OVERDRAFT_IMMEDIEATELY
    { ShowChairmanMessage(); return; }      // jmp ShowChairmanMessage

cseg_3D138:;
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&g_memByte[91336] = 1;         // mov dseg_D6B56, 1
    cseg_3D18C();                           // call cseg_3D18C
    *(word *)&g_memByte[337240] = 5;        // mov currentMessage, BANK_BALANCE_OVERDRAFT
    { ShowChairmanMessage(); return; }      // jmp ShowChairmanMessage

cseg_3D15F:;
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

cseg_3D16A:;
    *(word *)&g_memByte[91336] = 2;         // mov dseg_D6B56, 2
    cseg_3D18C();                           // call cseg_3D18C
    *(word *)&g_memByte[337240] = 6;        // mov currentMessage, OVERDRAFT_LAST_WARNING
    { ShowChairmanMessage(); return; }      // jmp ShowChairmanMessage

cseg_3D186:;
    cseg_3D18C();                           // call cseg_3D18C
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3D18C()
{
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 5;                                 // mov bx, 5
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 4
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[91340] = ax;        // mov dseg_D6B5A, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3D1C8()
{
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 5;                                 // mov bx, 5
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 4
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[91342] = ax;        // mov dseg_D6B5C, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3D204()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A6 = 126568;                            // mov A6, offset competitionFileBuffer
    push(A6);                               // push A6
    GetMoreExpensiveTeamsCount();           // call GetMoreExpensiveTeamsCount
    pop(A6);                                // pop A6
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[91586] = ax;        // mov dseg_D6C50, ax
    A6 = 126568;                            // mov A6, offset competitionFileBuffer
    cseg_9111F();                           // call cseg_9111F
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_3D2DD;                    // jz short cseg_3D2DD

    A6 = 99964;                             // mov A6, offset dseg_D8D0A
    push(D5);                               // push D5
    cseg_9111F();                           // call cseg_9111F
    pop(D5);                                // pop D5
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, ax

cseg_3D2DD:;
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_3D30E;                    // jz short cseg_3D30E

    A6 = 102862;                            // mov A6, offset dseg_D985C
    push(D5);                               // push D5
    cseg_9111F();                           // call cseg_9111F
    pop(D5);                                // pop D5
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, ax

cseg_3D30E:;
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_3D33F;                    // jz short cseg_3D33F

    A6 = 105044;                            // mov A6, offset dseg_DA0E2
    push(D5);                               // push D5
    cseg_9111F();                           // call cseg_9111F
    pop(D5);                                // pop D5
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, ax

cseg_3D33F:;
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&g_memByte[91584] = ax;        // mov dseg_D6C4E, ax
    D6 = 0;                                 // mov D6, 0
    eax = *(dword *)&g_memByte[91408];      // mov eax, dseg_D6B9E
    D0 = eax;                               // mov D0, eax
    ax = *(word *)&g_memByte[91668];        // mov ax, dseg_D6CA2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_3D373:;
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = D6;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        D6 = res;
    }                                       // add D6, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_3D373;                    // jns short cseg_3D373

    eax = D6;                               // mov eax, D6
    *(dword *)&g_memByte[91412] = eax;      // mov dseg_D6BA2, eax
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 1000;                              // mov bx, 3E8h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    bx = 207;                               // mov bx, 0CFh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 6144;                              // mov bx, 1800h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    bx = 96;                                // mov bx, 60h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    {
        word src = *(word *)&g_memByte[91668];
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / src);
        word rem = (word)(dividend % src);
        ax = quot;
        dx = rem;
    }                                       // div dseg_D6CA2
    bx = 1000;                              // mov bx, 3E8h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    *(dword *)&g_memByte[91404] = eax;      // mov dseg_D6B9A, eax
    *(dword *)&g_memByte[492491] = 0;       // mov dseg_1750CC, 0
    *(dword *)&g_memByte[492495] = 0;       // mov dseg_1750D0, 0
    *(dword *)&g_memByte[492499] = 0;       // mov dseg_1750D4, 0
    *(word *)&g_memByte[492503] = 0;        // mov dseg_1750D8, 0
    *(word *)&g_memByte[492505] = 0;        // mov dseg_1750DA, 0
    *(dword *)&g_memByte[492507] = 0;       // mov dseg_1750DC, 0
    *(dword *)&g_memByte[492511] = 0;       // mov dseg_1750E0, 0
    ax = *(word *)&g_memByte[91332];        // mov ax, stayingInOldClub
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3D4D9;                    // jnz short cseg_3D4D9

    eax = *(dword *)&g_memByte[91386];      // mov eax, dseg_D6B88
    D0 = eax;                               // mov D0, eax
    eax = *(dword *)&g_memByte[91390];      // mov eax, competitionBonuses
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        D0 = res;
    }                                       // add D0, eax
    eax = D0;                               // mov eax, D0
    {
        dword src = *(dword *)&g_memByte[91358];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(dword *)&g_memByte[91358] = src;
    }                                       // add old_balance, eax
    *(dword *)&g_memByte[91386] = 0;        // mov dseg_D6B88, 0
    *(dword *)&g_memByte[91390] = 0;        // mov competitionBonuses, 0

cseg_3D4D9:;
    *(word *)&g_memByte[91334] = 0;         // mov dseg_D6B54, 0
    *(word *)&g_memByte[91336] = 0;         // mov dseg_D6B56, 0
    *(word *)&g_memByte[91338] = 0;         // mov dseg_D6B58, 0
    *(word *)&g_memByte[91340] = 0;         // mov dseg_D6B5A, 0
    *(word *)&g_memByte[91342] = 0;         // mov dseg_D6B5C, 0
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3D597()
{
    ax = *(word *)&g_memByte[91626];        // mov ax, isCareer
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        cseg_3E69D();                       // jz cseg_3E69D
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3D5A7()
{
    cseg_3D6D8();                           // call cseg_3D6D8
    ax = *(word *)&g_memByte[91588];        // mov ax, dseg_D6C52
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = *(word *)&g_memByte[91590];        // mov ax, dseg_D6C54
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = *(word *)&g_memByte[91592];        // mov ax, dseg_D6C56
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = *(word *)&g_memByte[91596];        // mov ax, dseg_D6C5A
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3D5E1()
{
    ax = *(word *)&g_memByte[91596];        // mov ax, dseg_D6C5A
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91606];        // mov ax, dseg_D6C64
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3D600;                    // jz short cseg_3D600

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 100;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 64h

cseg_3D600:;
    ax = *(word *)&g_memByte[91610];        // mov ax, dseg_D6C68
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3D613;                    // jz short cseg_3D613

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 50;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 32h

cseg_3D613:;
    ax = *(word *)&g_memByte[91608];        // mov ax, dseg_D6C66
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3D626;                    // jz short cseg_3D626

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 50;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 32h

cseg_3D626:;
    ax = *(word *)&g_memByte[91600];        // mov ax, playWinCupAnimation
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3D644;                    // jz short cseg_3D644

    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3D644;                    // jnz short cseg_3D644

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 50;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 32h

cseg_3D644:;
    ax = *(word *)&g_memByte[91602];        // mov ax, dseg_D6C60
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3D657;                    // jz short cseg_3D657

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 25;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 19h

cseg_3D657:;
    ax = *(word *)&g_memByte[91612];        // mov ax, dseg_D6C6A
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3D66B;                    // jz short cseg_3D66B

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 150;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 96h

cseg_3D66B:;
    ax = *(word *)&g_memByte[91614];        // mov ax, dseg_D6C6C
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3D67E;                    // jz short cseg_3D67E

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 100;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 64h

cseg_3D67E:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 200;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0C8h
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_3D692;                    // jle short cseg_3D692

    *(word *)&D0 = 200;                     // mov word ptr D0, 0C8h

cseg_3D692:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[91596] = ax;        // mov dseg_D6C5A, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3D6A2()
{
    ax = *(word *)&g_memByte[91592];        // mov ax, dseg_D6C56
    *(word *)&g_memByte[91594] = ax;        // mov dseg_D6C58, ax
    ax = *(word *)&g_memByte[91590];        // mov ax, dseg_D6C54
    *(word *)&g_memByte[91592] = ax;        // mov dseg_D6C56, ax
    ax = *(word *)&g_memByte[91588];        // mov ax, dseg_D6C52
    *(word *)&g_memByte[91590] = ax;        // mov dseg_D6C54, ax
    cseg_3D6D8();                           // call cseg_3D6D8
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[91588] = ax;        // mov dseg_D6C52, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3D6D8()
{
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_club_selector;               // jz short @@club_selector

    ax = *(word *)&g_memByte[91594];        // mov ax, dseg_D6C58
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    A0 = 492319;                            // mov A0, offset dseg_175020
    ax = *(word *)&g_memByte[91692];        // mov ax, seasonReview
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    return;                                 // retn

l_club_selector:;
    A6 = 126568;                            // mov A6, offset competitionFileBuffer
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    FindTeamInDIY();                        // call FindTeamInDIY
    ax = *(word *)&g_memByte[91586];        // mov ax, dseg_D6C50
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    bx = 100;                               // mov bx, 64h
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    {
        int32_t dividend = ((int16_t)dx << 16) | (int16_t)ax;
        int16_t quot = (int16_t)(dividend / *(int16_t *)&D3);
        int16_t rem = (int16_t)(dividend % *(int16_t *)&D3);
        ax = quot;
        dx = rem;
    }                                       // idiv word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3D7CB()
{
    *(word *)&g_memByte[91618] = 0;         // mov dseg_D6C70, 0
    *(word *)&g_memByte[91620] = 0;         // mov dseg_D6C72, 0
    *(word *)&g_memByte[91622] = 0;         // mov dseg_D6C74, 0
    *(word *)&g_memByte[91624] = 0;         // mov dseg_D6C76, 0
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3DA22;                    // jz cseg_3DA22

    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto cseg_3D950;                    // jz cseg_3D950

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91716];        // mov ax, dseg_D6CD2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_3D93C;                    // jz cseg_3D93C

    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_3D93C;                    // jz cseg_3D93C

    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 109191;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset world_cup_qualifying_group_1_copy
    if (flags.carry)
        goto cseg_3D950;                    // jb cseg_3D950

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 109867;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset oceaniaWorldCupQualificationCopy
    if (!flags.carry && !flags.zero)
        goto cseg_3D950;                    // ja cseg_3D950

    A6 = 126568;                            // mov A6, offset competitionFileBuffer
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    FindTeamInDIY();                        // call FindTeamInDIY
    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 109511;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset north_america_world_cup_qualification_copy
    if (flags.zero)
        goto cseg_3D917;                    // jz short cseg_3D917

    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 109583;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset south_america_world_cup_qualification_copy
    if (flags.zero)
        goto cseg_3D917;                    // jz short cseg_3D917

    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 109647;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset africa_world_cup_qualification_copy
    if (flags.zero)
        goto cseg_3D917;                    // jz short cseg_3D917

    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 109759;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset asiaWorldCupQualificationCopy
    if (flags.zero)
        goto cseg_3D917;                    // jz short cseg_3D917

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 109867;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset oceaniaWorldCupQualificationCopy
    if (flags.zero)
        goto cseg_3D917;                    // jz short cseg_3D917

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 109471;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset world_cup_qualifying_group_8_copy
    if (flags.zero)
        goto cseg_3D917;                    // jz short cseg_3D917

    *(word *)&D0 = 2;                       // mov word ptr D0, 2

cseg_3D917:;
    ax = *(word *)&g_memByte[456642];       // mov ax, dseg_168A67
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3D947;                    // jnz short cseg_3D947

    ax = *(word *)&g_memByte[456644];       // mov ax, dseg_168A69
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3D950;                    // jz short cseg_3D950

    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry)
        goto cseg_3D947;                    // jnb short cseg_3D947

cseg_3D93C:;
    *(word *)&g_memByte[91618] = 1;         // mov dseg_D6C70, 1
    goto cseg_3D950;                        // jmp short cseg_3D950

cseg_3D947:;
    *(word *)&g_memByte[91622] = 1;         // mov dseg_D6C74, 1

cseg_3D950:;
    {
        byte src = g_memByte[91678];
        byte res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 1
    if (flags.zero)
        goto cseg_3DA22;                    // jz cseg_3DA22

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91718];        // mov ax, dseg_D6CD4
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_3DA0E;                    // jz cseg_3DA0E

    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 108523;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset e_c_qualifying_group_1_copy
    if (flags.carry)
        goto cseg_3DA22;                    // jb cseg_3DA22

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 108803;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset e_c_qualifying_group_8_copy
    if (!flags.carry && !flags.zero)
        goto cseg_3DA22;                    // ja cseg_3DA22

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    A6 = 126568;                            // mov A6, offset competitionFileBuffer
    FindTeamInDIY();                        // call FindTeamInDIY
    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 108803;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset e_c_qualifying_group_8_copy
    if (flags.zero)
        goto cseg_3D9E9;                    // jz short cseg_3D9E9

    *(word *)&D0 = 2;                       // mov word ptr D0, 2

cseg_3D9E9:;
    ax = *(word *)&g_memByte[456642];       // mov ax, dseg_168A67
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3DA19;                    // jnz short cseg_3DA19

    ax = *(word *)&g_memByte[456644];       // mov ax, dseg_168A69
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3DA22;                    // jz short cseg_3DA22

    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry)
        goto cseg_3DA19;                    // jnb short cseg_3DA19

cseg_3DA0E:;
    *(word *)&g_memByte[91620] = 1;         // mov dseg_D6C72, 1
    goto cseg_3DA22;                        // jmp short cseg_3DA22

cseg_3DA19:;
    *(word *)&g_memByte[91624] = 1;         // mov dseg_D6C76, 1

cseg_3DA22:;
    *(word *)&g_memByte[91612] = 0;         // mov dseg_D6C6A, 0
    *(word *)&g_memByte[91614] = 0;         // mov dseg_D6C6C, 0
    *(word *)&g_memByte[91616] = 0;         // mov dseg_D6C6E, 0
    *(word *)&g_memByte[91600] = 0;         // mov playWinCupAnimation, 0
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[126625];       // mov ax, dseg_DF52F
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_3DB4B;                    // jnz cseg_3DB4B

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108405;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset friendlyCopy
    if (flags.zero)
        goto cseg_3DB4B;                    // jz cseg_3DB4B

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108369;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset tourCopy
    if (flags.zero)
        goto cseg_3DB4B;                    // jz cseg_3DB4B

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108523;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset e_c_qualifying_group_1_copy
    if (flags.carry)
        goto cseg_3DAA1;                    // jb short cseg_3DAA1

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108803;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset e_c_qualifying_group_8_copy
    if (flags.carry || flags.zero)
        goto cseg_3DB4B;                    // jbe cseg_3DB4B

cseg_3DAA1:;
    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 109191;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset world_cup_qualifying_group_1_copy
    if (flags.carry)
        goto cseg_3DABD;                    // jb short cseg_3DABD

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 109867;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset oceaniaWorldCupQualificationCopy
    if (flags.carry || flags.zero)
        goto cseg_3DB4B;                    // jbe cseg_3DB4B

cseg_3DABD:;
    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108333;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset invitationTournamentCopy
    if (flags.zero)
        goto cseg_3DB37;                    // jz short cseg_3DB37

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 109079;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset worldCup2Copy
    if (flags.zero)
        goto cseg_3DB2C;                    // jz short cseg_3DB2C

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108445;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset europeanChampionships2Copy
    if (flags.zero)
        goto cseg_3DB21;                    // jz short cseg_3DB21

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108839;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset copaAmericaCopy
    if (flags.zero)
        goto cseg_3DB21;                    // jz short cseg_3DB21

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108909;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset africanNationsCupCopy
    if (flags.zero)
        goto cseg_3DB21;                    // jz short cseg_3DB21

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108957;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset northAmericanCupCopy
    if (flags.zero)
        goto cseg_3DB21;                    // jz short cseg_3DB21

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 109003;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset asianCupCopy
    if (flags.zero)
        goto cseg_3DB21;                    // jz short cseg_3DB21

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 109051;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset oceaniaCupCopy
    if (!flags.zero)
        goto cseg_3DB42;                    // jnz short cseg_3DB42

cseg_3DB21:;
    *(word *)&g_memByte[91614] = 1;         // mov dseg_D6C6C, 1
    goto cseg_3DB4B;                        // jmp short cseg_3DB4B

cseg_3DB2C:;
    *(word *)&g_memByte[91612] = 1;         // mov dseg_D6C6A, 1
    goto cseg_3DB4B;                        // jmp short cseg_3DB4B

cseg_3DB37:;
    *(word *)&g_memByte[91616] = 1;         // mov dseg_D6C6E, 1
    goto cseg_3DB4B;                        // jmp short cseg_3DB4B

cseg_3DB42:;
    *(word *)&g_memByte[91600] = 1;         // mov playWinCupAnimation, 1

cseg_3DB4B:;
    *(word *)&g_memByte[91602] = 0;         // mov dseg_D6C60, 0
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_3DC13;                    // jz cseg_3DC13

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[100021];       // mov ax, dseg_D8D43
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_3DC13;                    // jnz cseg_3DC13

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 108405;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset friendlyCopy
    if (flags.zero)
        goto cseg_3DC13;                    // jz cseg_3DC13

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108369;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset tourCopy
    if (flags.zero)
        goto cseg_3DC13;                    // jz short cseg_3DC13

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 108333;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset invitationTournamentCopy
    if (flags.zero)
        goto cseg_3DBFF;                    // jz short cseg_3DBFF

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 108445;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset europeanChampionships2Copy
    if (flags.zero)
        goto cseg_3DBF4;                    // jz short cseg_3DBF4

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 108839;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset copaAmericaCopy
    if (flags.zero)
        goto cseg_3DBF4;                    // jz short cseg_3DBF4

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 108909;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset africanNationsCupCopy
    if (flags.zero)
        goto cseg_3DBF4;                    // jz short cseg_3DBF4

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 108957;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset northAmericanCupCopy
    if (flags.zero)
        goto cseg_3DBF4;                    // jz short cseg_3DBF4

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 109003;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset asianCupCopy
    if (flags.zero)
        goto cseg_3DBF4;                    // jz short cseg_3DBF4

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 109051;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset oceaniaCupCopy
    if (!flags.zero)
        goto cseg_3DC0A;                    // jnz short cseg_3DC0A

cseg_3DBF4:;
    *(word *)&g_memByte[91614] = 1;         // mov dseg_D6C6C, 1
    goto cseg_3DC13;                        // jmp short cseg_3DC13

cseg_3DBFF:;
    *(word *)&g_memByte[91616] = 1;         // mov dseg_D6C6E, 1
    goto cseg_3DC13;                        // jmp short cseg_3DC13

cseg_3DC0A:;
    *(word *)&g_memByte[91602] = 1;         // mov dseg_D6C60, 1

cseg_3DC13:;
    *(word *)&g_memByte[91604] = 0;         // mov dseg_D6C62, 0
    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_3DC55;                    // jz short cseg_3DC55

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[102919];       // mov ax, dseg_D9895
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_3DC55;                    // jnz short cseg_3DC55

    {
        dword src = *(dword *)&g_memByte[99876];
        int32_t dstSigned = src;
        int32_t srcSigned = 108405;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CB2, offset friendlyCopy
    if (flags.zero)
        goto cseg_3DC55;                    // jz short cseg_3DC55

    *(word *)&g_memByte[91604] = 1;         // mov dseg_D6C62, 1

cseg_3DC55:;
    *(word *)&g_memByte[91606] = 0;         // mov dseg_D6C64, 0
    *(word *)&g_memByte[91608] = 0;         // mov dseg_D6C66, 0
    *(word *)&g_memByte[91610] = 0;         // mov dseg_D6C68, 0
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        return;                             // jz short cseg_3DCC7

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[105101];       // mov ax, dseg_DA11B
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        return;                             // jnz short cseg_3DCC7

    {
        word src = *(word *)&g_memByte[99888];
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CBE, 0
    if (flags.zero)
        goto cseg_3DCB3;                    // jz short cseg_3DCB3

    {
        word src = *(word *)&g_memByte[99888];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CBE, 2
    if (flags.zero)
        goto cseg_3DCBE;                    // jz short cseg_3DCBE

    *(word *)&g_memByte[91608] = 1;         // mov dseg_D6C66, 1
    return;                                 // jmp short cseg_3DCC7

cseg_3DCB3:;
    *(word *)&g_memByte[91606] = 1;         // mov dseg_D6C64, 1
    return;                                 // jmp short cseg_3DCC7

cseg_3DCBE:;
    *(word *)&g_memByte[91610] = 1;         // mov dseg_D6C68, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3DCC8()
{
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3DD32;                    // jz short cseg_3DD32

    A0 = 492457;                            // mov A0, offset dseg_1750AA
    ax = *(word *)&g_memByte[91692];        // mov ax, seasonReview
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word src = *(word *)&g_memByte[91688];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91688] = src;
    }                                       // add dseg_D6CB6, ax
    if (!flags.sign)
        goto cseg_3DD1F;                    // jns short cseg_3DD1F

    *(word *)&g_memByte[91688] = 0;         // mov dseg_D6CB6, 0

cseg_3DD1F:;
    {
        word src = *(word *)&g_memByte[91688];
        int16_t dstSigned = src;
        int16_t srcSigned = 49;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6CB6, 31h
    if (flags.carry || flags.zero)
        goto cseg_3DD32;                    // jbe short cseg_3DD32

    *(word *)&g_memByte[91688] = 49;        // mov dseg_D6CB6, 31h

cseg_3DD32:;
    A6 = 126568;                            // mov A6, offset competitionFileBuffer
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 2
    if (flags.zero)
        goto cseg_3DEA6;                    // jz cseg_3DEA6

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 301;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 12Dh
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)&D1 = 65534;                   // mov word ptr D1, 0FFFEh

cseg_3DD92:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 2
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    ax = (word)readMemory(esi + ebx + 109, 2); // mov ax, [esi+ebx+6Dh]
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 18;                                // mov bx, 12h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_3DD92;                    // jnz short cseg_3DD92

    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1
    ax = *(word *)&g_memByte[91586];        // mov ax, dseg_D6C50
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    bx = 100;                               // mov bx, 64h
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    esi = A6;                               // mov esi, A6
    {
        int16_t src = (int16_t)readMemory(esi + 49, 2);
        int32_t dividend = ((int16_t)dx << 16) | (int16_t)ax;
        int16_t quot = (int16_t)(dividend / src);
        int16_t rem = (int16_t)(dividend % src);
        ax = quot;
        dx = rem;
    }                                       // idiv word ptr [esi+31h]
    {
        int32_t res = (int16_t)ax * *(int16_t *)&D7;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul word ptr D7
    bx = 200;                               // mov bx, 0C8h
    {
        int32_t dividend = ((int16_t)dx << 16) | (int16_t)ax;
        int16_t quot = (int16_t)(dividend / (int16_t)bx);
        int16_t rem = (int16_t)(dividend % (int16_t)bx);
        ax = quot;
        dx = rem;
    }                                       // idiv bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word src = *(word *)&g_memByte[91770];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91770] = src;
    }                                       // add dseg_D6D08, ax

cseg_3DEA6:;
    ax = *(word *)&g_memByte[91612];        // mov ax, dseg_D6C6A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3DEC0;                    // jz short cseg_3DEC0

    al = g_memByte[126615];                 // mov al, dseg_DF525
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_3DFCB();                           // call cseg_3DFCB

cseg_3DEC0:;
    ax = *(word *)&g_memByte[91614];        // mov ax, dseg_D6C6C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3DF32;                    // jz short cseg_3DF32

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108445;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset europeanChampionships2Copy
    if (flags.zero)
        goto cseg_3DF23;                    // jz short cseg_3DF23

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108839;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset copaAmericaCopy
    if (flags.zero)
        goto cseg_3DF23;                    // jz short cseg_3DF23

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108909;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset africanNationsCupCopy
    if (flags.zero)
        goto cseg_3DF23;                    // jz short cseg_3DF23

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108957;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset northAmericanCupCopy
    if (flags.zero)
        goto cseg_3DF23;                    // jz short cseg_3DF23

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 109003;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset asianCupCopy
    if (flags.zero)
        goto cseg_3DF23;                    // jz short cseg_3DF23

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 109051;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset oceaniaCupCopy
    if (flags.zero)
        goto cseg_3DF23;                    // jz short cseg_3DF23

    al = g_memByte[100011];                 // mov al, dseg_D8D39
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    goto cseg_3DF2D;                        // jmp short cseg_3DF2D

cseg_3DF23:;
    al = g_memByte[126615];                 // mov al, dseg_DF525
    *(byte *)&D0 = al;                      // mov byte ptr D0, al

cseg_3DF2D:;
    cseg_3DFCB();                           // call cseg_3DFCB

cseg_3DF32:;
    ax = *(word *)&g_memByte[91600];        // mov ax, playWinCupAnimation
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3DF54;                    // jz short cseg_3DF54

    {
        word src = *(word *)&g_memByte[91764];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91764] = src;
    }                                       // add dseg_D6D02, 1
    al = g_memByte[126615];                 // mov al, dseg_DF525
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_3DFCB();                           // call cseg_3DFCB

cseg_3DF54:;
    ax = *(word *)&g_memByte[91602];        // mov ax, dseg_D6C60
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3DF76;                    // jz short cseg_3DF76

    {
        word src = *(word *)&g_memByte[91766];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91766] = src;
    }                                       // add dseg_D6D04, 1
    al = g_memByte[100011];                 // mov al, dseg_D8D39
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_3DFCB();                           // call cseg_3DFCB

cseg_3DF76:;
    ax = *(word *)&g_memByte[91604];        // mov ax, dseg_D6C62
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3DF90;                    // jz short cseg_3DF90

    al = g_memByte[102909];                 // mov al, dseg_D988B
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_3DFEE();                           // call cseg_3DFEE

cseg_3DF90:;
    ax = *(word *)&g_memByte[91606];        // mov ax, dseg_D6C64
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3DFB1;                    // jnz short cseg_3DFB1

    ax = *(word *)&g_memByte[91608];        // mov ax, dseg_D6C66
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3DFB1;                    // jnz short cseg_3DFB1

    ax = *(word *)&g_memByte[91610];        // mov ax, dseg_D6C68
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_3DFCA

cseg_3DFB1:;
    {
        word src = *(word *)&g_memByte[91768];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91768] = src;
    }                                       // add dseg_D6D06, 1
    al = g_memByte[105091];                 // mov al, dseg_DA111
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    cseg_3DFCB();                           // call cseg_3DFCB
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3DFCB()
{
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[91770];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91770] = src;
    }                                       // add dseg_D6D08, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3DFEE()
{
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[91770];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91770] = src;
    }                                       // add dseg_D6D08, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//     A1 -> team general
// out:
//     D0 = 1, zero flag clear - team is national
//     D0 = 0, zero flag set - team is not national
//
// Return national for any team if playing career.
//
void IsTeamNational()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto l_its_national;                // jnz short @@its_national

    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.countryNumber], 80
    if (flags.carry)
        goto l_not_national;                // jb short @@not_national

    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 85;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.countryNumber], 85
    if (flags.carry || flags.zero)
        goto l_its_national;                // jbe short @@its_national

l_not_national:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

l_its_national:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3E04F()
{
    cseg_2484B();                           // call cseg_2484B
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 113;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 71h
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 34, 2, 3);            // mov word ptr [esi+22h], 3
    writeMemory(esi + 36, 2, 0);            // mov word ptr [esi+24h], 0
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    writeMemory(esi + 40, 2, 0);            // mov word ptr [esi+28h], 0
}

// =============== S U B R O U T I N E =======================================
//
void ShowSeasonOpinion()
{
    ax = *(word *)&g_memByte[91692];        // mov ax, seasonReview
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 4
    if (!flags.carry)
        goto l_dissapointing_season;        // jnb short @@dissapointing_season

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 3
    if (flags.zero)
        goto l_not_a_very_good_season;      // jz short @@not_a_very_good_season

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 2
    if (flags.zero)
        goto l_up_and_down_season;          // jz short @@up_and_down_season

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 1
    if (flags.zero)
        goto l_good_season;                 // jz short @@good_season

    *(word *)&D0 = 27;                      // mov word ptr D0, EXCELLENT_JOB_THIS_SEASON
    goto l_show_message;                    // jmp short @@show_message

l_good_season:;
    *(word *)&D0 = 28;                      // mov word ptr D0, GOOD_SEASON
    goto l_show_message;                    // jmp short @@show_message

l_up_and_down_season:;
    *(word *)&D0 = 29;                      // mov word ptr D0, UP_AND_DOWN_SEASON2
    goto l_show_message;                    // jmp short @@show_message

l_not_a_very_good_season:;
    *(word *)&D0 = 30;                      // mov word ptr D0, NOT_A_VERY_GOOD_SEASON2
    goto l_show_message;                    // jmp short @@show_message

l_dissapointing_season:;
    *(word *)&D0 = 31;                      // mov word ptr D0, VERY_DISSAPOINTING_SEASON

l_show_message:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[337240] = ax;       // mov currentMessage, ax
    ShowChairmanMessage();                  // jmp ShowChairmanMessage
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3E11C()
{
    D5 = 0;                                 // mov D5, 0
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    A6 = 126568;                            // mov A6, offset competitionFileBuffer
    push(D5);                               // push D5
    push(D6);                               // push D6
    cseg_3E3B0();                           // call cseg_3E3B0
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_3E17D;                    // js short cseg_3E17D

    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    A0 = eax;                               // mov A0, eax
    cseg_3E26B();                           // call cseg_3E26B
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax

cseg_3E17D:;
    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (flags.zero)
        goto cseg_3E1D4;                    // jz short cseg_3E1D4

    A6 = 99964;                             // mov A6, offset dseg_D8D0A
    push(D6);                               // push D6
    push(D5);                               // push D5
    cseg_3E3B0();                           // call cseg_3E3B0
    pop(D5);                                // pop D5
    pop(D6);                                // pop D6
    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_3E1D4;                    // js short cseg_3E1D4

    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    A0 = eax;                               // mov A0, eax
    cseg_3E26B();                           // call cseg_3E26B
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax

cseg_3E1D4:;
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax
    ax = D6;                                // mov ax, word ptr D6
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D6 = eax;                               // mov D6, eax
    dx = *(word *)((byte *)&D6 + 2);        // mov dx, word ptr D6+2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D5);
        word rem = (word)(dividend % *(word *)&D5);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D5
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)((byte *)&D6 + 2) = dx;        // mov word ptr D6+2, dx
    ax = *(word *)&g_memByte[91612];        // mov ax, dseg_D6C6A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3E237;                    // jz short cseg_3E237

    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    goto cseg_3E24A;                        // jmp short cseg_3E24A

cseg_3E237:;
    ax = *(word *)&g_memByte[91614];        // mov ax, dseg_D6C6C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3E24A;                    // jz short cseg_3E24A

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 2

cseg_3E24A:;
    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_3E25E;                    // jns short cseg_3E25E

    *(word *)&D6 = 0;                       // mov word ptr D6, 0

cseg_3E25E:;
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&g_memByte[91692] = ax;        // mov seasonReview, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3E26B()
{
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 109079;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset worldCup2Copy
    if (flags.zero)
        goto cseg_3E384;                    // jz cseg_3E384

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 108405;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset friendlyCopy
    if (flags.zero)
        goto cseg_3E3A7;                    // jz cseg_3E3A7

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 108333;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset invitationTournamentCopy
    if (flags.zero)
        goto cseg_3E3A7;                    // jz cseg_3E3A7

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 108369;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset tourCopy
    if (flags.zero)
        goto cseg_3E3A7;                    // jz cseg_3E3A7

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 108445;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset europeanChampionships2Copy
    if (flags.zero)
        goto cseg_3E361;                    // jz cseg_3E361

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 108957;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset northAmericanCupCopy
    if (flags.zero)
        goto cseg_3E361;                    // jz cseg_3E361

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 108839;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset copaAmericaCopy
    if (flags.zero)
        goto cseg_3E361;                    // jz cseg_3E361

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 108909;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset africanNationsCupCopy
    if (flags.zero)
        goto cseg_3E361;                    // jz short cseg_3E361

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 109003;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset asianCupCopy
    if (flags.zero)
        goto cseg_3E361;                    // jz short cseg_3E361

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 109051;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset oceaniaCupCopy
    if (flags.zero)
        goto cseg_3E361;                    // jz short cseg_3E361

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 109191;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset world_cup_qualifying_group_1_copy
    if (flags.carry)
        goto cseg_3E31B;                    // jb short cseg_3E31B

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 109867;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset oceaniaWorldCupQualificationCopy
    if (flags.carry || flags.zero)
        goto cseg_3E33E;                    // jbe short cseg_3E33E

cseg_3E31B:;
    ax = D7;                                // mov ax, word ptr D7
    bx = 3;                                 // mov bx, 3
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 3
    return;                                 // retn

cseg_3E33E:;
    ax = D7;                                // mov ax, word ptr D7
    bx = 4;                                 // mov bx, 4
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 4;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 4
    return;                                 // retn

cseg_3E361:;
    ax = D7;                                // mov ax, word ptr D7
    bx = 6;                                 // mov bx, 6
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 6;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 6
    return;                                 // retn

cseg_3E384:;
    ax = D7;                                // mov ax, word ptr D7
    bx = 8;                                 // mov bx, 8
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 8
    return;                                 // retn

cseg_3E3A7:;
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3E3B0()
{
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[456646] = 1;        // mov dseg_168A6B, 1
    push(A6);                               // push A6
    FindTeamInDIY();                        // call FindTeamInDIY
    pop(A6);                                // pop A6
    *(word *)&g_memByte[456646] = 0;        // mov dseg_168A6B, 0
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_3E552;                    // js cseg_3E552

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    GetMoreExpensiveTeamsCount();           // call GetMoreExpensiveTeamsCount
    pop(D1);                                // pop D1
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    bx = 100;                               // mov bx, 64h
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    {
        int32_t dividend = ((int16_t)dx << 16) | (int16_t)ax;
        int16_t quot = (int16_t)(dividend / *(int16_t *)&D3);
        int16_t rem = (int16_t)(dividend % *(int16_t *)&D3);
        ax = quot;
        dx = rem;
    }                                       // idiv word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0
    if (flags.zero)
        goto cseg_3E4CE;                    // jz short cseg_3E4CE

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1Eh
    if (flags.sign == flags.overflow)
        goto cseg_3E4CE;                    // jge short cseg_3E4CE

    *(word *)&D7 = 1;                       // mov word ptr D7, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0Ah
    if (flags.sign == flags.overflow)
        goto cseg_3E4CE;                    // jge short cseg_3E4CE

    *(word *)&D7 = 2;                       // mov word ptr D7, 2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 65526;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0FFF6h
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_3E4CE;                    // jg short cseg_3E4CE

    *(word *)&D7 = 3;                       // mov word ptr D7, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 65506;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0FFE2h
    if (!flags.zero && flags.sign == flags.overflow)
        goto cseg_3E4CE;                    // jg short cseg_3E4CE

    *(word *)&D7 = 4;                       // mov word ptr D7, 4

cseg_3E4CE:;
    ax = D1;                                // mov ax, word ptr D1
    bx = 100;                               // mov bx, 64h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 49, 2);
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / src);
        word rem = (word)(dividend % src);
        ax = quot;
        dx = rem;
    }                                       // div word ptr [esi+31h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 19h
    if (!flags.carry && !flags.zero)
        goto cseg_3E535;                    // ja short cseg_3E535

    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3E535;                    // jz short cseg_3E535

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_3E535:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 75;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4Bh
    if (flags.carry)
        return;                             // jb short cseg_3E551

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 4
    if (flags.zero)
        return;                             // jz short cseg_3E551

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1

cseg_3E551:;
    return;                                 // retn

cseg_3E552:;
    *(word *)&D7 = 65535;                   // mov word ptr D7, 0FFFFh
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3E55C()
{
    ax = *(word *)&g_memByte[91332];        // mov ax, stayingInOldClub
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_3E607

    ax = *(word *)&g_memByte[91612];        // mov ax, dseg_D6C6A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_3E607

    ax = *(word *)&g_memByte[91614];        // mov ax, dseg_D6C6C
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_3E607

    ax = *(word *)&g_memByte[91618];        // mov ax, dseg_D6C70
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short cseg_3E607

    ax = *(word *)&g_memByte[91620];        // mov ax, dseg_D6C72
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short cseg_3E607

    {
        word src = *(word *)&g_memByte[91692];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp seasonReview, 2
    if (flags.carry)
        return;                             // jb short cseg_3E607

    SWOS::Rand();                           // call Rand
    *(word *)&D1 = 32;                      // mov word ptr D1, 20h
    {
        word src = *(word *)&g_memByte[91692];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp seasonReview, 2
    if (flags.zero)
        goto cseg_3E5E1;                    // jz short cseg_3E5E1

    *(word *)&D1 = 85;                      // mov word ptr D1, 55h
    {
        word src = *(word *)&g_memByte[91692];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp seasonReview, 3
    if (flags.zero)
        goto cseg_3E5E1;                    // jz short cseg_3E5E1

    *(word *)&D1 = 170;                     // mov word ptr D1, 0AAh

cseg_3E5E1:;
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        return;                             // ja short cseg_3E607

    *(word *)&g_memByte[337240] = 38;       // mov currentMessage, WE_DIDNT_RENEW_YOUR_CONTRACT
    ShowChairmanMessage();                  // call ShowChairmanMessage
    *(word *)&g_memByte[91344] = 1;         // mov youreSacked, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3E608()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto cseg_3E631;                    // jnz short cseg_3E631

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_3E631;                    // jz short cseg_3E631

    cseg_3E67C();                           // call cseg_3E67C
    if (!flags.zero)
        goto cseg_3E631;                    // jnz short cseg_3E631

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

cseg_3E631:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3E642()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto l_err_out;                     // jnz short @@err_out

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_err_out;                     // jz short @@err_out

    cseg_3E69D();                           // call cseg_3E69D
    if (!flags.zero)
        goto l_err_out;                     // jnz short @@err_out

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

l_err_out:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3E67C()
{
    push(A0);                               // push A0
    cseg_3E6BE();                           // call cseg_3E6BE
    if (flags.zero)
        goto cseg_3E696;                    // jz short cseg_3E696

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 67, 2);     // mov ax, [esi+43h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax

cseg_3E696:;
    pop(A0);                                // pop A0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3E69D()
{
    push(A0);                               // push A0
    cseg_3E6BE();                           // call cseg_3E6BE
    if (flags.zero)
        goto l_out;                         // jz short @@out

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 69, 2);     // mov ax, [esi+69]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax

l_out:;
    pop(A0);                                // pop A0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3E6BE()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 109079;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset worldCup2Copy
    if (flags.zero)
        goto l_err_out;                     // jz @@err_out

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108445;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset europeanChampionships2Copy
    if (flags.zero)
        goto l_err_out;                     // jz @@err_out

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108839;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset copaAmericaCopy
    if (flags.zero)
        goto l_err_out;                     // jz @@err_out

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108909;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset africanNationsCupCopy
    if (flags.zero)
        goto l_err_out;                     // jz @@err_out

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108957;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset northAmericanCupCopy
    if (flags.zero)
        goto l_err_out;                     // jz @@err_out

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 109003;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset asianCupCopy
    if (flags.zero)
        goto l_err_out;                     // jz @@err_out

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 109051;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset oceaniaCupCopy
    if (flags.zero)
        goto l_err_out;                     // jz @@err_out

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108333;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset invitationTournamentCopy
    if (flags.zero)
        goto l_err_out;                     // jz @@err_out

    {
        dword src = *(dword *)&g_memByte[99868];
        int32_t dstSigned = src;
        int32_t srcSigned = 108369;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAA, offset tourCopy
    if (flags.zero)
        goto l_err_out;                     // jz short @@err_out

    A0 = 99964;                             // mov A0, offset dseg_D8D0A
    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 108445;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset europeanChampionships2Copy
    if (flags.zero)
        goto l_err_out;                     // jz short @@err_out

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 108839;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset copaAmericaCopy
    if (flags.zero)
        goto l_err_out;                     // jz short @@err_out

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 108909;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset africanNationsCupCopy
    if (flags.zero)
        goto l_err_out;                     // jz short @@err_out

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 108957;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset northAmericanCupCopy
    if (flags.zero)
        goto l_err_out;                     // jz short @@err_out

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 109003;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset asianCupCopy
    if (flags.zero)
        goto l_err_out;                     // jz short @@err_out

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 109051;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset oceaniaCupCopy
    if (flags.zero)
        goto l_err_out;                     // jz short @@err_out

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 108333;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset invitationTournamentCopy
    if (flags.zero)
        goto l_err_out;                     // jz short @@err_out

    {
        dword src = *(dword *)&g_memByte[99872];
        int32_t dstSigned = src;
        int32_t srcSigned = 108369;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CAE, offset tourCopy
    if (flags.zero)
        goto l_err_out;                     // jz short @@err_out

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

l_err_out:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void ChooseTeamsFriendlyInit()
{
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&g_memByte[332874] = ax;       // mov numSelectedTeamsCopy, ax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&g_memByte[332548] = ax;       // mov selTeamsUpperBound, ax
    A1 = 332618;                            // mov A1, offset teamPointers
    A2 = 332554;                            // mov A2, offset teamNumbersIndices
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax
    *(word *)&D7 = 0;                       // mov word ptr D7, 0

l_loop:;
    eax = A0;                               // mov eax, A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    al = D7;                                // mov al, byte ptr D7
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A2)++;                    // inc A2
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 684
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    ax = *(word *)&g_memByte[332548];       // mov ax, selTeamsUpperBound
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.zero)
        goto l_loop;                        // jnz short @@loop

    ax = *(word *)&g_memByte[332548];       // mov ax, selTeamsUpperBound
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 2
    if (flags.sign)
        goto l_skip_1;                      // js @@skip_1

    A3 = 332618;                            // mov A3, offset teamPointers

cseg_3E88F:;
    A2 = 332554;                            // mov A2, offset teamNumbersIndices
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_3E8AE:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    A1 = eax;                               // mov A1, eax

cseg_3E93C:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_3E9A2;                    // jz short cseg_3E9A2

    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_3E9A2;                    // jb short cseg_3E9A2

    if (!flags.carry && !flags.zero)
        goto cseg_3E96D;                    // ja short cseg_3E96D

    goto cseg_3E93C;                        // jmp short cseg_3E93C

cseg_3E96D:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    writeMemory(esi + -1, 1, al);           // mov [esi-1], al
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi, 1, al);                // mov [esi], al
    *(word *)&D3 = 1;                       // mov word ptr D3, 1

cseg_3E9A2:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_3E8AE;                    // jns cseg_3E8AE

    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_3E88F;                    // jnz cseg_3E88F

l_skip_1:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[330658];     // mov eax, chooseTeamsHeader1stPart
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (!flags.zero)
        goto l_got_first_part;              // jnz @@got_first_part

    A0 = 16581;                             // mov A0, offset aAllSelectedTea
    StringCopy();                           // call StringCopy
    eax = *(dword *)&g_memByte[330202];     // mov eax, gameTypeStr
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        goto l_no_game_type_string;         // jz short @@no_game_type_string

    StringCopy();                           // call StringCopy

l_no_game_type_string:;
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A0 = eax;                               // mov A0, eax
    GetStringLength();                      // call GetStringLength
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = *(dword *)&g_memByte[330206];     // mov eax, curCountryStr
    A0 = eax;                               // mov A0, eax
    GetStringLength();                      // call GetStringLength
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 47;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 47
    if (!flags.carry && !flags.zero)
        goto l_no_space_for_country;        // ja short @@no_space_for_country

    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, '-');               // mov byte ptr [esi], '-'
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    eax = *(dword *)&g_memByte[330206];     // mov eax, curCountryStr
    A0 = eax;                               // mov A0, eax

l_got_first_part:;
    StringCopy();                           // call StringCopy

l_no_space_for_country:;
    {
        word src = *(word *)&g_memByte[332548];
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp selTeamsUpperBound, 8
    if (!flags.carry && !flags.zero)
        goto l_more_than_8_teams;           // ja short @@more_than_8_teams

    *(word *)&g_memByte[332542] = 0;        // mov viewTeamsColumn1, 0
    ax = *(word *)&g_memByte[332548];       // mov ax, selTeamsUpperBound
    *(word *)&g_memByte[332544] = ax;       // mov viewTeamsColumn2, ax
    *(word *)&g_memByte[332546] = 0;        // mov viewTeamsColumn3, 0
    goto l_no_moduo;                        // jmp @@no_moduo

l_more_than_8_teams:;
    ax = *(word *)&g_memByte[332548];       // mov ax, selTeamsUpperBound
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 3;                                 // mov bx, 3
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[332542] = ax;       // mov viewTeamsColumn1, ax
    *(word *)&g_memByte[332544] = ax;       // mov viewTeamsColumn2, ax
    *(word *)&g_memByte[332546] = ax;       // mov viewTeamsColumn3, ax
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto l_mod_not_1;                   // jnz short @@mod_not_1

    {
        word src = *(word *)&g_memByte[332544];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[332544] = src;
    }                                       // add viewTeamsColumn2, 1
    goto l_no_moduo;                        // jmp short @@no_moduo

l_mod_not_1:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (!flags.zero)
        goto l_no_moduo;                    // jnz short @@no_moduo

    {
        word src = *(word *)&g_memByte[332542];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[332542] = src;
    }                                       // add viewTeamsColumn1, 1
    {
        word src = *(word *)&g_memByte[332544];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[332544] = src;
    }                                       // add viewTeamsColumn2, 1

l_no_moduo:;
    ViewSelTeamsSetColumns();               // call ViewSelTeamsSetColumns
    ax = *(word *)&g_memByte[467196];       // mov ax, choosingPreset
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_preset;                  // jz short @@not_preset

    {
        dword src = *(dword *)&g_memByte[330194];
        int32_t dstSigned = src;
        int32_t srcSigned = 29621;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp selectedContest, offset copaAmerica
    if (!flags.zero)
        goto l_not_preset;                  // jnz short @@not_preset

    *(word *)&D0 = 74;                      // mov word ptr D0, 74
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

l_not_preset:;
    SetChooseChangeTeamsEntries();          // call SetChooseChangeTeamsEntries
    SetTeamEntriesStringsAndColors();       // call SetTeamEntriesStringsAndColors
    {
        word src = *(word *)&g_memByte[330698];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp viewSelectedTeams, 2
    if (flags.zero)
        goto cseg_3EBE6;                    // jz short cseg_3EBE6

    {
        word src = *(word *)&g_memByte[330698];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp viewSelectedTeams, 1
    if (flags.zero)
        goto cseg_3EBF5;                    // jz short cseg_3EBF5

    return;                                 // retn

cseg_3EBE6:;
    *(word *)&D0 = 76;                      // mov word ptr D0, 76
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    return;                                 // retn

cseg_3EBF5:;
    *(word *)&D0 = 74;                      // mov word ptr D0, 74
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void SetTeamEntriesStringsAndColors()
{
    A3 = 332554;                            // mov A3, offset teamNumbersIndices
    A4 = 332618;                            // mov A4, offset teamPointers
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    *(word *)&D6 = 0;                       // mov word ptr D6, 0

l_team_entries_loop:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = *(word *)&g_memByte[332548];       // mov ax, selTeamsUpperBound
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (!flags.carry)
        goto l_next;                        // jnb @@next

cseg_3EC7B:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 22;                                // mov bx, 22
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_try_column2;                 // jnz short @@try_column2

    ax = *(word *)&g_memByte[332542];       // mov ax, viewTeamsColumn1
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    goto l_column_calculated;               // jmp short @@column_calculated

l_try_column2:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto l_column3;                     // jnz short @@column3

    ax = *(word *)&g_memByte[332544];       // mov ax, viewTeamsColumn2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    goto l_column_calculated;               // jmp short @@column_calculated

l_column3:;
    ax = *(word *)&g_memByte[332546];       // mov ax, viewTeamsColumn3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_column_calculated:;
    ax = D0;                                // mov ax, word ptr D0
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto l_can_fit_in_column;           // jb short @@can_fit_in_column

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 56
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 74;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+MenuEntry.ordinal], 74
    if (flags.zero)
        return;                             // jz @@out

    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    goto cseg_3EC7B;                        // jmp cseg_3EC7B

l_can_fit_in_column:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A3)++;                    // inc A3
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A4;                               // mov esi, A4
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    {
        int32_t dstSigned = esi;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        esi = res;
    }                                       // add esi, eax
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A1 = eax;                               // mov A1, eax
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    *(word *)&D1 = 9;                       // mov word ptr D1, PINK_TO_BROWN_9
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_NOT_SELECTED
    if (flags.zero)
        goto l_set_entry_color;             // jz short @@set_entry_color

    *(word *)&D1 = 10;                      // mov word ptr D1, RED_10
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        goto l_set_entry_color;             // jz short @@set_entry_color

    *(word *)&D1 = 11;                      // mov word ptr D1, BLUE_TO_PURPLE_11
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (flags.zero)
        goto l_set_entry_color;             // jz short @@set_entry_color

    *(word *)&D1 = 13;                      // mov word ptr D1, BRIGHT_BLUE_TO_BLUE_13

l_set_entry_color:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

l_next:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 56
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 74;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+MenuEntry.ordinal], 74
    if (flags.zero)
        return;                             // jz short @@out

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    goto l_team_entries_loop;               // jmp @@team_entries_loop
}

// =============== S U B R O U T I N E =======================================
//
void ChangeTeams()
{
    DeselectAllTeams();                     // call DeselectAllTeams
    *(word *)&g_memByte[330696] = 1;        // mov changeTeams, 1
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
    *(word *)&g_memByte[330698] = 0;        // mov viewSelectedTeams, 0
    *(word *)&g_memByte[330700] = 0;        // mov abortSelectTeams, 0
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void AbortChooseTeamsFriendly()
{
    DeselectAllTeams();                     // call DeselectAllTeams
    *(word *)&g_memByte[330700] = 1;        // mov abortSelectTeams, 1
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
    *(word *)&g_memByte[330698] = 0;        // mov viewSelectedTeams, 0
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ChooseTeamsFriendlyOnSelect76()
{
    DeselectAllTeams();                     // call DeselectAllTeams
    *(word *)&g_memByte[330694] = 1;        // mov chooseTeamsResult, 1
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    *(word *)&g_memByte[330698] = 0;        // mov viewSelectedTeams, 0
    *(word *)&g_memByte[330700] = 0;        // mov abortSelectTeams, 0
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================

// in:
//     A5 -> menu entry for team that's being selected
//           (team entries start at 8, there are 66 of them max)
//
// This routine is executed when team name entry is selected, and it cycles
// through team controls in the following order:
// unselected -> CPU -> player coach -> coach -> unselected...
// It also updates the menu to reflect the new selection.
//
void ChooseTeamsFriendlyCommon()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 22;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 22
    if (flags.carry)
        goto l_fetch_team_pointer;          // jb short @@fetch_team_pointer

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 44;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 44
    if (flags.carry)
        goto l_two_columns_or_more;         // jb short @@two_columns_or_more

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 22;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 22
    ax = *(word *)&g_memByte[332544];       // mov ax, viewTeamsColumn2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax

l_two_columns_or_more:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 22;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 22
    ax = *(word *)&g_memByte[332542];       // mov ax, viewTeamsColumn1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax

l_fetch_team_pointer:;
    A0 = 332554;                            // mov A0, offset teamNumbersIndices
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    {
        int32_t dstSigned = esi;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        esi = res;
    }                                       // add esi, eax
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 332618;                            // mov A0, offset teamPointers
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    {
        int32_t dstSigned = esi;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        esi = res;
    }                                       // add esi, eax
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_NOT_SELECTED
    if (flags.zero)
        goto l_select_cpu;                  // jz short @@select_cpu

    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        goto l_select_player_coach;         // jz short @@select_player_coach

    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (flags.zero)
        goto l_select_coach;                // jz short @@select_coach

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 2, 9);            // mov [esi+MenuEntry.bg.backAndFrameColor], COLOR_PINK_GRAYISH
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 1, 0);             // mov [esi+TeamFile.teamControls], TEAM_NOT_SELECTED
    {
        word src = *(word *)&g_memByte[332874];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[332874] = src;
    }                                       // sub numSelectedTeamsCopy, 1
    goto l_update_menu;                     // jmp short @@update_menu

l_select_player_coach:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 1, 2);             // mov [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 2, 11);           // mov [esi+MenuEntry.bg.backAndFrameColor], COLOR_PURPLISH
    goto l_update_menu;                     // jmp short @@update_menu

l_select_coach:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 1, 3);             // mov [esi+TeamFile.teamControls], TEAM_COACH
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 2, 13);           // mov [esi+MenuEntry.bg.backAndFrameColor], COLOR_LIGHT_BLUE
    goto l_update_menu;                     // jmp short @@update_menu

l_select_cpu:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 2, 10);           // mov [esi+MenuEntry.bg.backAndFrameColor], COLOR_RED
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 1, 1);             // mov [esi+TeamFile.teamControls], TEAM_COMPUTER
    {
        word src = *(word *)&g_memByte[332874];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[332874] = src;
    }                                       // add numSelectedTeamsCopy, 1

l_update_menu:;
    cseg_3F011();                           // call cseg_3F011
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void cseg_3F011()
{
    push(A5);                               // push A5
    SetChooseChangeTeamsEntries();          // call SetChooseChangeTeamsEntries
    A0 = 2644;                              // mov A0, offset cseg_3F032
    nullsub_17();                           // call nullsub_17
    pop(A5);                                // pop A5
}

// =============== S U B R O U T I N E =======================================
//
void SetChooseChangeTeamsEntries()
{
    push(D0);                               // push D0
    D0 = 74;                                // mov D0, 74
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    A1 = 18259;                             // mov A1, offset aChooseTeams
    ax = *(word *)&g_memByte[332874];       // mov ax, numSelectedTeamsCopy
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[330674];       // mov ax, numNeededTeams
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_choose_teams;                // jnz short @@choose_teams

    A1 = 18276;                             // mov A1, offset aChangeTeams

l_choose_teams:;
    eax = A1;                               // mov eax, A1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 76;                                // mov D0, 76
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 77;                                // mov D0, 77
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[332874];       // mov ax, numSelectedTeamsCopy
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[330674];       // mov ax, numNeededTeams
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_num_teams_match;             // jz short @@num_teams_match

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    goto cseg_3F16F;                        // jmp short cseg_3F16F

l_num_teams_match:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 34, 2, 2);            // mov [esi+MenuEntry.content], ENTRY_STRING
    eax = *(dword *)&g_memByte[330654];     // mov eax, playWhatStr
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax

cseg_3F16F:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 77;                                // mov D0, 77
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[332874];       // mov ax, numSelectedTeamsCopy
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[330674];       // mov ax, numNeededTeams
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        goto l_error;                       // jz short @@error

    if (!flags.sign)
        goto l_selected_too_many;           // jns short @@selected_too_many

    *(int16_t *)&D0 = -*(int16_t *)&D0;     // neg word ptr D0
    A0 = 16368;                             // mov A0, offset aSelect1MoreTea
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto l_copy_string_out;             // jz short @@copy_string_out

    A0 = 16346;                             // mov A0, offset aSelect0MoreTea
    goto l_printf_string_out;               // jmp short @@printf_string_out

l_selected_too_many:;
    A0 = 16412;                             // mov A0, offset aSelect1LessTea
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto l_copy_string_out;             // jz short @@copy_string_out

    A0 = 16390;                             // mov A0, offset aSelect0LessTea

l_printf_string_out:;
    PrintFormatted();                       // call PrintFormatted
    return;                                 // retn

l_error:;
    A0 = 331620;                            // mov A0, offset aError

l_copy_string_out:;
    StringCopy();                           // call StringCopy

    nullsub_6();
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_6()
{
}

// =============== S U B R O U T I N E =======================================

// Set columns and dynamically calculate height of entries
// depending on their number.
//
void ViewSelTeamsSetColumns()
{
    ax = *(word *)&g_memByte[332542];       // mov ax, viewTeamsColumn1
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[332544];       // mov ax, viewTeamsColumn2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry && !flags.zero)
        goto l_check_column3;               // ja short @@check_column3

    ax = *(word *)&g_memByte[332544];       // mov ax, viewTeamsColumn2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_check_column3:;
    ax = *(word *)&g_memByte[332546];       // mov ax, viewTeamsColumn3
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry && !flags.zero)
        goto l_got_max;                     // ja short @@got_max

    ax = *(word *)&g_memByte[332546];       // mov ax, viewTeamsColumn3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_got_max:;
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+MenuEntry.dwHeight]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[332550] = ax;       // mov viewTeamsStartY, ax
    push(D0);                               // push D0
    D0 = 75;                                // mov D0, 75
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    *(word *)&g_memByte[332552] = ax;       // mov viewTeamsAbortY, ax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+MenuEntry.dwHeight]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)&D4 = 10;                      // mov word ptr D4, 10

l_check_for_fit:;
    ax = D1;                                // mov ax, word ptr D1
    tmp = ax * *(word *)&D4;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    ax = *(word *)&g_memByte[332552];       // mov ax, viewTeamsAbortY
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[332550];       // mov ax, viewTeamsStartY
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 4
    if (flags.sign == flags.overflow)
        goto l_enough_space;                // jge short @@enough_space

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 1
    goto l_check_for_fit;                   // jmp short @@check_for_fit

l_enough_space:;
    ax = D2;                                // mov ax, word ptr D2
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D1 = eax;                               // mov D1, eax
    dx = *(word *)((byte *)&D1 + 2);        // mov dx, word ptr D1+2
    bx = 3;                                 // mov bx, 3
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[332550];       // mov ax, viewTeamsStartY
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    ax = D2;                                // mov ax, word ptr D2
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 56
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+MenuEntry.dwHeight]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D2 = 2;                       // mov word ptr D2, 2

l_columns_loop:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D3 = 21;                      // mov word ptr D3, 21

l_teams_in_column_loop:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    ax = D4;                                // mov ax, word ptr D4
    writeMemory(esi + 26, 2, ax);           // mov [esi+MenuEntry.dwHeight], ax
    {
        word src = (word)readMemory(esi + 26, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 26, 2, src);
    }                                       // sub [esi+MenuEntry.dwHeight], 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D3)--;
    flags.overflow = (int16_t)(*(int16_t *)&D3) == INT16_MIN;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto l_teams_in_column_loop;        // jns short @@teams_in_column_loop

    (*(int16_t *)&D2)--;
    flags.overflow = (int16_t)(*(int16_t *)&D2) == INT16_MIN;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto l_columns_loop;                // jns short @@columns_loop
}

// =============== S U B R O U T I N E =======================================
//
void DeselectAllTeams()
{
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    *(word *)&D7 = 0;                       // mov word ptr D7, 0

l_deselect_loop:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], 0
    if (!flags.zero)
        goto l_team_not_selected;           // jnz short @@team_not_selected

    push(A0);                               // push A0
    DeselectTeam();                         // call DeselectTeam
    pop(A0);                                // pop A0
    goto l_loop_tail;                       // jmp short @@loop_tail

l_team_not_selected:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 684
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1

l_loop_tail:;
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (flags.carry)
        goto l_deselect_loop;               // jb short @@deselect_loop
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - control flags (bit 0/1 clear: clear player 1/2 controls)
//      D1 - max substitues (additional entries)
//      D2 -
//      D5 -
//      D6 - squad changed allowed (false when viewing result)
//      A1 -> team1 (file)
//      A2 -> team2 (file)
//
// out:
//      D0 - player number that started
//
void ShowPlayMatchMenu()
{
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&g_memByte[494096] = ax;       // mov isFirstPlayerChoosingTeam, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&g_memByte[336368] = ax;       // mov squadChangesAllowed, ax
    eax = A1;                               // mov eax, A1
    *(dword *)&g_memByte[336372] = eax;     // mov playMatchTeam1Ptr, eax
    eax = A2;                               // mov eax, A2
    *(dword *)&g_memByte[336376] = eax;     // mov playMatchTeam2Ptr, eax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[336380] = ax;       // mov maxSubstitutesEntries, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[336396] = ax;       // mov playMatchControlFlags, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[336400] = ax;       // mov playMatchExcludeFlags, ax
    *(word *)&g_memByte[131753] = ax;       // mov inEditTactics, ax
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto l_not_career;                  // jnz short @@not_career

    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[336400];       // mov ax, playMatchExcludeFlags
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[336380];       // mov ax, maxSubstitutesEntries
    cseg_52588();                           // call cseg_52588

l_not_career:;
    A6 = 494108;                            // mov A6, offset playMatchMenu
    SWOS::ShowMenu();                       // call ShowMenu
    ax = *(word *)&g_memByte[336398];       // mov ax, playerNumThatStarted
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
}

// =============== S U B R O U T I N E =======================================
//
void PlayMatchMenuInit()
{
    *(word *)&g_memByte[465962] = 1;        // mov g_allowShorterMenuItemsWithFrames, 1
    eax = *(dword *)&g_memByte[324018];     // mov eax, dword ptr leaveFireFlag
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    if (!flags.zero)
        goto l_dont_reset_fire;             // jnz short @@dont_reset_fire

    *(word *)&g_memByte[252398] = 1;        // mov fireResetFlag, 1

l_dont_reset_fire:;
    *(word *)&g_memByte[316508] = 0;        // mov player1ClearFlag, 0
    *(word *)&g_memByte[316510] = 0;        // mov player2ClearFlag, 0
    {
        byte src = g_memByte[336396];
        byte res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr playMatchControlFlags, 1
    if (!flags.zero)
        goto l_dont_clear_player1;          // jnz short @@dont_clear_player1

    g_memByte[316508] = -1;                 // mov byte ptr player1ClearFlag, -1

l_dont_clear_player1:;
    {
        byte src = g_memByte[336396];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr playMatchControlFlags, 2
    if (!flags.zero)
        goto l_dont_clear_player2;          // jnz short @@dont_clear_player2

    g_memByte[316510] = -1;                 // mov byte ptr player2ClearFlag, -1

l_dont_clear_player2:;
    *(word *)&g_memByte[494102] = 0;        // mov showingCpuTeams, 0
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (!flags.zero)
        goto l_got_player;                  // jnz short @@got_player

    eax = *(dword *)&g_memByte[336376];     // mov eax, playMatchTeam2Ptr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (!flags.zero)
        goto l_got_player;                  // jnz short @@got_player

    *(word *)&g_memByte[494102] = 1;        // mov showingCpuTeams, 1

l_got_player:;
    *(word *)&g_memByte[336386] = 0;        // mov viewingOpponentTeam, 0
    SetCurrentSelectedPlayerIndexPointer(); // call SetCurrentSelectedPlayerIndexPointer
    CheckIsTeamNational();                  // call CheckIsTeamNational
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    SetBenchPlayersNumbers();               // call SetBenchPlayersNumbers
    *(word *)&g_memByte[496522] = 0;        // mov is_A_team, 0
    PlayMatchMenuReinit();                  // call PlayMatchMenuReinit
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 4, 2);      // mov ax, word ptr [esi+TeamFile.teamControls]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void PlayMatchMenuReinit()
{
    UpdateTeamCheckmark();                  // call UpdateTeamCheckmark
    *(word *)&D0 = 16;                      // mov word ptr D0, 16
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 5
    ax = *(word *)&g_memByte[336380];       // mov ax, maxSubstitutesEntries
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[336382] = ax;       // mov pmMenuNumPlayers, ax
    ax = *(word *)&g_memByte[99542];        // mov ax, numPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        dword src = *(dword *)&g_memByte[336372];
        int32_t dstSigned = src;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp playMatchTeam1Ptr, offset currentTeam
    if (flags.zero)
        goto l_teams_not_swapped;           // jz short @@teams_not_swapped

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -1
    if (flags.zero)
        goto cseg_3F798;                    // jz short cseg_3F798

    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_3F7A3;                    // jz short cseg_3F7A3

cseg_3F798:;
    *(word *)&D0 = 16;                      // mov word ptr D0, 16
    goto l_teams_not_swapped;               // jmp short @@teams_not_swapped

cseg_3F7A3:;
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

l_teams_not_swapped:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[336384] = ax;       // mov numPlayersToShowInMenu, ax
    *(dword *)&g_memByte[336392] = 0;       // mov pmSelectedPlayerEntry, 0
    *(word *)&g_memByte[336386] = 0;        // mov viewingOpponentTeam, 0
    *(word *)&g_memByte[336388] = -1;       // mov selectedPlayerPosition, -1
    SetVariableButtons();                   // call SetVariableButtons
    SetUpTacticsButtons();                  // call SetUpTacticsButtons
    SetPlayerSurnamesOnSidePitch();         // call SetPlayerSurnamesOnSidePitch
    ShowOrHidePlayMatchButton();            // call ShowOrHidePlayMatchButton
    *(word *)&D7 = 4;                       // mov word ptr D7, 4
    ax = *(word *)&g_memByte[336380];       // mov ax, maxSubstitutesEntries
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    if (flags.sign)
        goto l_done;                        // js @@done

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 28;                                // mov D0, 28
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax

l_entries_loop:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A5 = res;
    }                                       // sub A5, 56
    push(D0);                               // push D0
    D0 = 12;                                // mov D0, 12
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 9;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub [esi+MenuEntry.y], 9
    push(D0);                               // push D0
    D0 = 30;                                // mov D0, 30
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 9;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub [esi+MenuEntry.y], 9
    push(D0);                               // push D0
    D0 = 29;                                // mov D0, 29
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 9;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub [esi+MenuEntry.y], 9
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_entries_loop;                // jns @@entries_loop

l_done:;
    SavePositionsAndUpdateLittleCheckmark(); // call SavePositionsAndUpdateLittleCheckmark
    UpdateLittleCheckmark();                // call UpdateLittleCheckmark
}

// =============== S U B R O U T I N E =======================================

// [play match menu procedure]
//
void SetCurrentSelectedPlayerIndexPointer()
{
    A0 = 378854;                            // mov A0, offset team1SelectedPlayerIndex
    A1 = 378856;                            // mov A1, offset team2SelectedPlayerIndex
    ax = *(word *)&g_memByte[494096];       // mov ax, isFirstPlayerChoosingTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_check_viewing_opponent;      // jnz short @@check_viewing_opponent

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax

l_check_viewing_opponent:;
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_this_team;                   // jz short @@this_team

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax

l_this_team:;
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[494098] = eax;     // mov currentSelectedPlayerIndexPtr, eax
}

// =============== S U B R O U T I N E =======================================

// in:
//     A5 -> menu entry that was selected
//
// Called when players are being swapped in play match menu
// (on fire pressed).
//
void OnSwapPlayer()
{
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_viewing_opponent_team;       // jnz short @@viewing_opponent_team

    ax = *(word *)&g_memByte[494102];       // mov ax, showingCpuTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_no_human_players;            // jnz short @@no_human_players

    goto l_no_cpu_players;                  // jmp @@no_cpu_players

l_viewing_opponent_team:;
    eax = *(dword *)&g_memByte[336376];     // mov eax, playMatchTeam2Ptr
    A1 = eax;                               // mov A1, eax

l_no_human_players:;
    ax = *(word *)&g_memByte[252390];       // mov ax, longFireFlag
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { out_0(); return; }                // jnz out_0

    ax = *(word *)&g_memByte[336368];       // mov ax, squadChangesAllowed
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        { out_0(); return; }                // jz out_0

    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        { out_0(); return; }                // jz out_0

    eax = *(dword *)&g_memByte[494098];     // mov eax, currentSelectedPlayerIndexPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto l_different_player_selected;   // jnz short @@different_player_selected

    *(word *)&D1 = -1;                      // mov word ptr D1, -1

l_different_player_selected:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    UpdateTeamCheckmark();                  // call UpdateTeamCheckmark
    { SWOS::DrawMenu(); return; }           // jmp DrawMenu

l_no_cpu_players:;
    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, ax
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 16
    if (!flags.zero)
        goto cseg_3FA9E;                    // jnz short cseg_3FA9E

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 5
    ax = *(word *)&g_memByte[336380];       // mov ax, maxSubstitutesEntries
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, ax

cseg_3FA9E:;
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    ax = *(word *)&g_memByte[336388];       // mov ax, selectedPlayerPosition
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_no_selected_player;          // js @@no_selected_player

    ax = *(word *)&g_memByte[336388];       // mov ax, selectedPlayerPosition
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (flags.zero)
        goto l_same_position;               // jz @@same_position

    ax = *(word *)&g_memByte[336388];       // mov ax, selectedPlayerPosition
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[336390];       // mov ax, selectedPlayerTacticsPosition
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    PlayMatchMenuSwapPlayers();             // call PlayMatchMenuSwapPlayers
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    SetBenchPlayersNumbers();               // call SetBenchPlayersNumbers
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 59, 1, 1);            // mov [esi+TeamFile.someFlag], 1
    SavePositionsAndUpdateLittleCheckmark(); // call SavePositionsAndUpdateLittleCheckmark
    *(word *)&g_memByte[336388] = -1;       // mov selectedPlayerPosition, -1
    SetPlayerSurnamesOnSidePitch();         // call SetPlayerSurnamesOnSidePitch
    ShowOrHidePlayMatchButton();            // call ShowOrHidePlayMatchButton
    UpdateTeamCheckmark();                  // call UpdateTeamCheckmark
    ShowUseMatchTeamIfTraining();           // call ShowUseMatchTeamIfTraining
    { SWOS::DrawMenu(); return; }           // jmp DrawMenu

l_same_position:;
    *(word *)&D7 = -1;                      // mov word ptr D7, -1
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_3FEC4();                           // call cseg_3FEC4
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    if (!flags.zero)
        goto l_player_selected_for_frst_time; // jnz short @@player_selected_for_frst_time

l_no_selected_player:;
    ax = *(word *)&g_memByte[252390];       // mov ax, longFireFlag
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { out_0(); return; }                // jnz out_0

l_player_selected_for_frst_time:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&g_memByte[336388] = ax;       // mov selectedPlayerPosition, ax
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&g_memByte[336390] = ax;       // mov selectedPlayerTacticsPosition, ax
    eax = *(dword *)&g_memByte[336392];     // mov eax, pmSelectedPlayerEntry
    A0 = eax;                               // mov A0, eax
    eax = A5;                               // mov eax, A5
    *(dword *)&g_memByte[336392] = eax;     // mov pmSelectedPlayerEntry, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        goto l_this_is_first_selected_player; // jz short @@this_is_first_selected_player

    push(A5);                               // push A5
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
    pop(A5);                                // pop A5

l_this_is_first_selected_player:;
    CallDrawMenuItem();                     // call CallDrawMenuItem
    UpdateLittleCheckmark();                // call UpdateLittleCheckmark
    RedrawPlayerNames();                    // call RedrawPlayerNames
}

// =============== S U B R O U T I N E =======================================

// in:
//     D3 - selected player menu position
//     D4 - destination player menu position
//
void PlayMatchMenuSwapPlayers()
{
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 16
    if (!flags.carry)
        goto l_banch_1st_lineup_combo;      // jnb short @@banch_1st_lineup_combo

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 16
    if (!flags.carry)
        goto l_banch_1st_lineup_combo;      // jnb short @@banch_1st_lineup_combo

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 11
    if (!flags.carry)
        goto cseg_3FCD3;                    // jnb short cseg_3FCD3

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 11
    if (flags.carry)
        goto l_skip_swapping_shirt_numbers; // jb @@skip_swapping_shirt_numbers

    goto l_banch_1st_lineup_combo;          // jmp short @@banch_1st_lineup_combo

cseg_3FCD3:;
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 11
    if (!flags.carry)
        goto l_skip_swapping_shirt_numbers; // jnb @@skip_swapping_shirt_numbers

l_banch_1st_lineup_combo:;
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    A2 = 378790;                            // mov A2, offset playerPositionsArray
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    al = D0;                                // mov al, byte ptr D0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+(PlayerFile.shirtNumber+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+(PlayerFile.shirtNumber+4Ch)]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 78, 1, al);           // mov [esi+(PlayerFile.shirtNumber+4Ch)], al
    al = D0;                                // mov al, byte ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 78, 1, al);           // mov [esi+(PlayerFile.shirtNumber+4Ch)], al

l_skip_swapping_shirt_numbers:;
    {
        dword src = *(dword *)&g_memByte[336372];
        int32_t dstSigned = src;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp playMatchTeam1Ptr, offset currentTeam
    if (!flags.zero)
        goto cseg_3FDE5;                    // jnz short cseg_3FDE5

    A0 = 99510;                             // mov A0, offset playerPositions
    goto l_swap_in_positions;               // jmp short @@swap_in_positions

cseg_3FDE5:;
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto l_no_career;                   // jnz @@no_career

    A0 = 92766;                             // mov A0, offset currentMatchPlayers

l_swap_in_positions:;
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    al = D0;                                // mov al, byte ptr D0
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    ax = *(word *)&g_memByte[496522];       // mov ax, is_A_team
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    ax = *(word *)&g_memByte[336380];       // mov ax, maxSubstitutesEntries
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (flags.carry)
        goto cseg_3FE93;                    // jb short cseg_3FE93

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (flags.carry)
        goto cseg_3FEA2;                    // jb short cseg_3FEA2

    return;                                 // jmp short @@out

cseg_3FE93:;
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (flags.carry)
        return;                             // jb short @@out

cseg_3FEA2:;
    cseg_64161();                           // call cseg_64161

l_out:;
    return;                                 // retn

l_no_career:;
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, TeamFile.playerNumbers
    A0 = eax;                               // mov A0, eax
    goto l_swap_in_positions;               // jmp @@swap_in_positions
}

// =============== S U B R O U T I N E =======================================

// in:
//     D6 -
// out:
//     D0 -
//     zero flag
//
void cseg_3FEC4()
{
    ax = *(word *)&g_memByte[99544];        // mov ax, currentTeamNumber
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    A6 = 99546;                             // mov A6, offset dseg_D8B68
    {
        dword src = *(dword *)&g_memByte[336372];
        int32_t dstSigned = src;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp playMatchTeam1Ptr, offset currentTeam
    if (flags.zero)
        goto l_test_long_fire_flag;         // jz short @@test_long_fire_flag

    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    A6 = 94092;                             // mov A6, offset dseg_D761A
    {
        dword src = *(dword *)&g_memByte[336372];
        int32_t dstSigned = src;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp playMatchTeam1Ptr, offset careerTeam
    if (flags.zero)
        goto l_test_long_fire_flag;         // jz short @@test_long_fire_flag

    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    eax = *(dword *)&g_memByte[494098];     // mov eax, currentSelectedPlayerIndexPtr
    A6 = eax;                               // mov A6, eax

l_test_long_fire_flag:;
    ax = *(word *)&g_memByte[252390];       // mov ax, longFireFlag
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        { ReturnFalseCode(); return; }      // jz ReturnFalseCode

    {
        word src = *(word *)&g_memByte[252390];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp longFireFlag, 1
    if (!flags.zero)
        goto l_out_false;                   // jnz @@out_false

    ax = *(word *)&g_memByte[336368];       // mov ax, squadChangesAllowed
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_out_false;                   // jz @@out_false

    ax = *(word *)&g_memByte[336382];       // mov ax, pmMenuNumPlayers
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (!flags.carry)
        goto l_out_false;                   // jnb @@out_false

    ax = *(word *)&g_memByte[336388];       // mov ax, selectedPlayerPosition
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto cseg_3FF93;                    // jnz short cseg_3FF93

    *(word *)&D1 = -1;                      // mov word ptr D1, -1
    goto l_unselect_player;                 // jmp short @@unselect_player

cseg_3FF93:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayer();                            // call GetPlayer
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto l_out_false;                   // jz short @@out_false

l_unselect_player:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A6;                               // mov esi, A6
    writeMemory(esi, 2, ax);                // mov [esi], ax
    *(word *)&g_memByte[336388] = -1;       // mov selectedPlayerPosition, -1
    UpdateTeamCheckmark();                  // call UpdateTeamCheckmark
    ShowUseMatchTeamIfTraining();           // call ShowUseMatchTeamIfTraining
    SWOS::DrawMenu();                       // call DrawMenu

l_out_false:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax

    out_0();
}

// =============== S U B R O U T I N E =======================================
//
void out_0()
{
}

// =============== S U B R O U T I N E =======================================
//
void ReturnFalseCode()
{
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void PlayMatchChangeTactics()
{
    push(A5);                               // push A5
    UpdateLittleCheckmark();                // call UpdateLittleCheckmark
    RedrawPlayerNames();                    // call RedrawPlayerNames
    pop(A5);                                // pop A5
    push(D0);                               // push D0
    D0 = 38;                                // mov D0, 38
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        return;                             // jz short @@out

    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 24, 1, al);           // mov [esi+TeamFile.tactics], al
    writeMemory(esi + 59, 1, 1);            // mov [esi+TeamFile.someFlag], 1
    SavePositionsAndUpdateLittleCheckmark(); // call SavePositionsAndUpdateLittleCheckmark
    SetUpTacticsButtons();                  // call SetUpTacticsButtons
    SetPlayerSurnamesOnSidePitch();         // call SetPlayerSurnamesOnSidePitch
    ShowUseMatchTeamIfTraining();           // call ShowUseMatchTeamIfTraining
    UpdateTeamCheckmark();                  // call UpdateTeamCheckmark
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void ExitPlayMatch()
{
    *(word *)&g_memByte[456648] = 1;        // mov g_exitGameFlag, 1
    *(word *)&g_memByte[316508] = 0;        // mov player1ClearFlag, 0
    *(word *)&g_memByte[316510] = 0;        // mov player2ClearFlag, 0
    *(word *)&g_memByte[465962] = 0;        // mov g_allowShorterMenuItemsWithFrames, 0
    *(word *)&g_memByte[91626] = 0;         // mov isCareer, 0
    {
        dword src = *(dword *)&g_memByte[336372];
        int32_t dstSigned = src;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp playMatchTeam1Ptr, offset careerTeam
    if (flags.zero)
        goto l_is_career;                   // jz short @@is_career

    {
        dword src = *(dword *)&g_memByte[336376];
        int32_t dstSigned = src;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp playMatchTeam2Ptr, offset careerTeam
    if (!flags.zero)
        goto l_out;                         // jnz short @@out

l_is_career:;
    *(word *)&g_memByte[91626] = 1;         // mov isCareer, 1

l_out:;
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void EditTacticsInPlayMatchMenu()
{
    UpdateLittleCheckmark();                // call UpdateLittleCheckmark
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    ShowStandardChooseTacticsMenu();        // jmp ShowStandardChooseTacticsMenu
}

// =============== S U B R O U T I N E =======================================
//
void ViewOpponentsSelect()
{
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_switch_to_opponent_view;     // jz short @@switch_to_opponent_view

    *(word *)&g_memByte[336386] = 0;        // mov viewingOpponentTeam, 0
    goto cseg_40266;                        // jmp cseg_40266

l_switch_to_opponent_view:;
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4022E;                    // jz short cseg_4022E

    {
        word src = *(word *)&g_memByte[496522];
        src ^= 1;
        *(word *)&g_memByte[496522] = src;
    }                                       // xor is_A_team, 1
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[336376];     // mov eax, playMatchTeam2Ptr
    *(dword *)&g_memByte[336372] = eax;     // mov playMatchTeam1Ptr, eax
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[336376] = eax;     // mov playMatchTeam2Ptr, eax
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&g_memByte[336384] = ax;       // mov numPlayersToShowInMenu, ax
    {
        dword src = *(dword *)&g_memByte[336372];
        int32_t dstSigned = src;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp playMatchTeam1Ptr, offset careerTeam
    if (flags.zero)
        goto cseg_401FD;                    // jz short cseg_401FD

    ax = *(word *)&g_memByte[99542];        // mov ax, numPlayers
    *(word *)&g_memByte[336384] = ax;       // mov numPlayersToShowInMenu, ax

cseg_401FD:;
    *(word *)&g_memByte[336388] = -1;       // mov selectedPlayerPosition, -1
    SavePositionsAndUpdateLittleCheckmark(); // call SavePositionsAndUpdateLittleCheckmark
    UpdateLittleCheckmark();                // call UpdateLittleCheckmark
    SetVariableButtons();                   // call SetVariableButtons
    SetUpTacticsButtons();                  // call SetUpTacticsButtons
    SetPlayerSurnamesOnSidePitch();         // call SetPlayerSurnamesOnSidePitch
    ShowOrHidePlayMatchButton();            // call ShowOrHidePlayMatchButton
    UpdateTeamCheckmark();                  // call UpdateTeamCheckmark
    { SWOS::DrawMenu(); return; }           // jmp DrawMenu

cseg_4022E:;
    *(word *)&g_memByte[336386] = 1;        // mov viewingOpponentTeam, 1
    eax = *(dword *)&g_memByte[336376];     // mov eax, playMatchTeam2Ptr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (!flags.zero)
        goto l_select_invisible_entry;      // jnz short @@select_invisible_entry

    ax = *(word *)&g_memByte[336368];       // mov ax, squadChangesAllowed
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_40266;                    // jnz short cseg_40266

l_select_invisible_entry:;
    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

cseg_40266:;
    SetCurrentSelectedPlayerIndexPointer(); // call SetCurrentSelectedPlayerIndexPointer
    UpdateLittleCheckmark();                // call UpdateLittleCheckmark
    SetVariableButtons();                   // call SetVariableButtons
    SetUpTacticsButtons();                  // call SetUpTacticsButtons
    SetPlayerSurnamesOnSidePitch();         // call SetPlayerSurnamesOnSidePitch
    ShowOrHidePlayMatchButton();            // call ShowOrHidePlayMatchButton
    UpdateTeamCheckmark();                  // call UpdateTeamCheckmark
    SWOS::RecalculateReachableEntries();    // call RecalculateReachableEntries
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void ReturnFromViewOpponent()
{
    *(word *)&g_memByte[336386] = 0;        // mov viewingOpponentTeam, 0
    SetVariableButtons();                   // call SetVariableButtons
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    SetUpTacticsButtons();                  // call SetUpTacticsButtons
    SetPlayerSurnamesOnSidePitch();         // call SetPlayerSurnamesOnSidePitch
    ShowOrHidePlayMatchButton();            // call ShowOrHidePlayMatchButton
    UpdateTeamCheckmark();                  // call UpdateTeamCheckmark
    SWOS::RecalculateReachableEntries();    // call RecalculateReachableEntries
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void PlayMatchOnSelect30()
{
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[336380];       // mov ax, maxSubstitutesEntries
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    RotatePlayersLeft();                    // call RotatePlayersLeft
    A0 = 2652;                              // mov A0, offset cseg_402ED
    nullsub_17();                           // jmp nullsub_17
}

// =============== S U B R O U T I N E =======================================
//
void PlayMatch30AfterDraw()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 29;                                // mov D0, 29
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    SWOS::DrawMenuItem();                   // jmp DrawMenuItem
}

// =============== S U B R O U T I N E =======================================

// [play match menu procedure]
// Show or hide small blinking checkmark when arranging players in a team.
// (the one next to a player)
//
void UpdateTeamCheckmark()
{
    *(word *)&D0 = 37;                      // mov word ptr D0, 37
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = *(word *)&g_memByte[336368];       // mov ax, squadChangesAllowed
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_this_team;                   // jz short @@this_team

    eax = *(dword *)&g_memByte[494098];     // mov eax, currentSelectedPlayerIndexPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js @@out

    eax = *(dword *)&g_memByte[336376];     // mov eax, playMatchTeam2Ptr
    A0 = eax;                               // mov A0, eax
    GetPlayerPosition();                    // call GetPlayerPosition
    goto l_show_checkmark;                  // jmp @@show_checkmark

l_this_team:;
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[94092];        // mov ax, dseg_D761A
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_403F0;                    // jz short cseg_403F0

    ax = *(word *)&g_memByte[99546];        // mov ax, dseg_D8B68
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset currentTeam
    if (flags.zero)
        goto cseg_403F0;                    // jz short cseg_403F0

    eax = *(dword *)&g_memByte[494098];     // mov eax, currentSelectedPlayerIndexPtr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_403F0:;
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js @@out

    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    GetPlayerPosition();                    // call GetPlayerPosition
    ax = *(word *)&g_memByte[336382];       // mov ax, pmMenuNumPlayers
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry)
        goto l_out_of_player_spots;         // jnb @@out_of_player_spots

l_show_checkmark:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 37;                                // mov D0, 37
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D0 |= 8192;                   // or word ptr D0, 2000h
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    *(word *)&D0 = 13;                      // mov word ptr D0, 13
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    *(word *)&D0 = 37;                      // mov word ptr D0, 37
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0

l_out:;
    return;                                 // retn

l_out_of_player_spots:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset currentTeam
    if (flags.zero)
        goto cseg_404E5;                    // jz short cseg_404E5

    *(word *)&g_memByte[94092] = -1;        // mov dseg_D761A, -1
    return;                                 // retn

cseg_404E5:;
    *(word *)&g_memByte[99546] = -1;        // mov dseg_D8B68, -1
}

// =============== S U B R O U T I N E =======================================

// Sets text on game start button in play match menu:
// "view result", "play match", "view match", "coach match"
// Set background color to green if match is simulated ("view result"), red otherwise.
//
void SetGameStartButtonText()
{
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 14
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 8076);         // mov [esi+MenuEntry.fg.string], offset aViewResult
    ax = *(word *)&g_memByte[336368];       // mov ax, squadChangesAllowed
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[336376];     // mov eax, playMatchTeam2Ptr
    A2 = eax;                               // mov A2, eax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (!flags.zero)
        goto l_at_least_one_player_team;    // jnz short @@at_least_one_player_team

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        goto l_no_player_teams;             // jz short @@no_player_teams

l_at_least_one_player_team:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 4768);         // mov [esi+MenuEntry.fg.string], offset aPlayMatch
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (flags.zero)
        goto l_set_entry_color_to_red;      // jz short @@set_entry_color_to_red

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 4756);         // mov [esi+MenuEntry.fg.string], offset aCoachMatch
    goto l_set_entry_color_to_red;          // jmp short @@set_entry_color_to_red

l_no_player_teams:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 18598);        // mov [esi+MenuEntry.fg.string], offset aViewMatch

l_set_entry_color_to_red:;
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 10
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
}

// =============== S U B R O U T I N E =======================================
//
void ShowOrHidePlayMatchButton()
{
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_our_team;                    // jz short @@our_team

    eax = *(dword *)&g_memByte[336376];     // mov eax, playMatchTeam2Ptr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+MenuEntry.isInvisible], 1
    if (!flags.zero)
        goto cseg_40A40;                    // jnz cseg_40A40

    ax = *(word *)&g_memByte[336368];       // mov ax, squadChangesAllowed
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_40A40;                    // jz cseg_40A40

    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    ax = *(word *)&g_memByte[494104];       // mov ax, dseg_175718
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_40A40;                    // jz cseg_40A40

    goto cseg_40A03;                        // jmp cseg_40A03

l_our_team:;
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 57343;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0DFFFh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_a_training_game;         // jz short @@not_a_training_game

    writeMemory(esi + 38, 4, 6667);         // mov dword ptr [esi+MenuEntry.fg], offset aViewATeam
    ax = *(word *)&g_memByte[496522];       // mov ax, is_A_team
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_not_a_training_game;         // jnz short @@not_a_training_game

    writeMemory(esi + 38, 4, 6679);         // mov dword ptr [esi+MenuEntry.fg], offset aViewBTeam

l_not_a_training_game:;
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[336400];       // mov ax, playMatchExcludeFlags
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    cseg_3A110();                           // call cseg_3A110
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[336400];       // mov ax, playMatchExcludeFlags
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    push(D2);                               // push D2
    GetNumberOfAvailablePlayers();          // call GetNumberOfAvailablePlayers
    pop(D2);                                // pop D2
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (flags.zero)
        goto l_career_game;                 // jz short @@career_game

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 1
    if (flags.carry)
        goto cseg_40A01;                    // jb cseg_40A01

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 2
    if (!flags.carry && !flags.zero)
        goto cseg_40A01;                    // ja cseg_40A01

    goto cseg_407F0;                        // jmp short cseg_407F0

l_career_game:;
    {
        dword src = *(dword *)&g_memByte[336372];
        int32_t dstSigned = src;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp playMatchTeam1Ptr, offset currentTeam
    if (!flags.zero)
        goto cseg_407D4;                    // jnz short cseg_407D4

    A0 = 92798;                             // mov A0, offset careerTeam
    ax = *(word *)&g_memByte[336400];       // mov ax, playMatchExcludeFlags
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    cseg_3A110();                           // call cseg_3A110
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 2
    if (!flags.carry)
        goto cseg_407E2;                    // jnb short cseg_407E2

cseg_407D4:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 1
    if (flags.carry)
        goto cseg_40A01;                    // jb cseg_40A01

cseg_407E2:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 4
    if (!flags.carry && !flags.zero)
        goto cseg_40A01;                    // ja cseg_40A01

cseg_407F0:;
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto l_not_career;                  // jnz @@not_career

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    GetNumberOfSubstitutes();               // call GetNumberOfSubstitutes
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_40A40;                    // jnz cseg_40A40

    {
        word src = *(word *)&g_memByte[336380];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp maxSubstitutesEntries, 5
    if (flags.carry || flags.zero)
        goto cseg_40854;                    // jbe short cseg_40854

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    cseg_39E7E();                           // call cseg_39E7E
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_40A40;                    // jnz cseg_40A40

cseg_40854:;
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[336400];       // mov ax, playMatchExcludeFlags
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 11;                      // mov word ptr D1, 0Bh
    ax = *(word *)&g_memByte[336380];       // mov ax, maxSubstitutesEntries
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    GetNumberOfAvailablePlayers();          // call GetNumberOfAvailablePlayers
    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_40A40;                    // jnz cseg_40A40

    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_40950;                    // jz cseg_40950

    {
        dword src = *(dword *)&g_memByte[336372];
        int32_t dstSigned = src;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp playMatchTeam1Ptr, offset careerTeam
    if (!flags.zero)
        goto cseg_40950;                    // jnz cseg_40950

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    A0 = 98218;                             // mov A0, offset currentTeam
    GetNumberOfSubstitutes();               // call GetNumberOfSubstitutes
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto cseg_40950;                    // jz short cseg_40950

    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+24h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D0 |= 8192;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // or word ptr D0, 2000h
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+24h], ax
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[336400];       // mov ax, playMatchExcludeFlags
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    cseg_3A110();                           // call cseg_3A110
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 2
    if (flags.carry)
        goto cseg_40A01;                    // jb cseg_40A01

    goto cseg_40A40;                        // jmp cseg_40A40

cseg_40950:;
    goto cseg_40A03;                        // jmp cseg_40A03

l_not_career:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    GetNumberOfSubstitutes();               // call GetNumberOfSubstitutes
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_40A40;                    // jnz cseg_40A40

    {
        word src = *(word *)&g_memByte[336380];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp maxSubstitutesEntries, 5
    if (flags.carry || flags.zero)
        goto cseg_409D0;                    // jbe short cseg_409D0

    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[336400];       // mov ax, playMatchExcludeFlags
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_3A110();                           // call cseg_3A110
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 2
    if (flags.carry)
        goto cseg_409D0;                    // jb short cseg_409D0

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    cseg_39E7E();                           // call cseg_39E7E
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_40A40;                    // jnz short cseg_40A40

cseg_409D0:;
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[336400];       // mov ax, playMatchExcludeFlags
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 11;                      // mov word ptr D1, 0Bh
    GetNumberOfAvailablePlayers();          // call GetNumberOfAvailablePlayers
    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_40A40;                    // jnz short cseg_40A40

    goto cseg_40A03;                        // jmp short cseg_40A03

cseg_40A01:;
    goto l_show_play_match_button;          // jmp short @@show_play_match_button

cseg_40A03:;
    {
        dword src = *(dword *)&g_memByte[336372];
        int32_t dstSigned = src;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp playMatchTeam1Ptr, offset currentTeam
    if (!flags.zero)
        goto cseg_40A1C;                    // jnz short cseg_40A1C

    ax = *(word *)&g_memByte[494104];       // mov ax, dseg_175718
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_hide_play_match_button;      // jz short @@hide_play_match_button

    goto l_show_play_match_button;          // jmp short @@show_play_match_button

cseg_40A1C:;
    *(word *)&g_memByte[494104] = 1;        // mov dseg_175718, 1

l_show_play_match_button:;
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    return;                                 // retn

cseg_40A40:;
    {
        dword src = *(dword *)&g_memByte[336372];
        int32_t dstSigned = src;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp playMatchTeam1Ptr, offset currentTeam
    if (flags.zero)
        goto l_hide_play_match_button;      // jz short @@hide_play_match_button

    *(word *)&g_memByte[494104] = 0;        // mov dseg_175718, 0

l_hide_play_match_button:;
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
}

// =============== S U B R O U T I N E =======================================

// Set color of tactics buttons, and if they're disabled or not.
// Non-selected tactics have red background, and selected tactics are brown for player, and gray for CPU/opponent.
//
void SetUpTacticsButtons()
{
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A6 = eax;                               // mov A6, eax
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_viewing_opponent;        // jz short @@not_viewing_opponent

    eax = *(dword *)&g_memByte[336376];     // mov eax, playMatchTeam2Ptr
    A6 = eax;                               // mov A6, eax

l_not_viewing_opponent:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    push(D0);                               // push D0
    D0 = 38;                                // mov D0, 38
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

l_next_entry:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_opponent_team;               // jnz short @@opponent_team

    ax = *(word *)&g_memByte[494102];       // mov ax, showingCpuTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_player_tactics;              // jz short @@player_tactics

l_opponent_team:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto l_current_opponent_tactics;    // jz short @@current_opponent_tactics

    *(word *)&D0 |= 10;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // or word ptr D0, 10
    goto l_set_color;                       // jmp short @@set_color

l_current_opponent_tactics:;
    *(word *)&D0 |= 1;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // or word ptr D0, 1
    goto l_set_color;                       // jmp short @@set_color

l_player_tactics:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto l_non_active_player_tactics;   // jnz short @@non_active_player_tactics

    *(word *)&D0 |= 5;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // or word ptr D0, 5
    goto l_set_color;                       // jmp short @@set_color

l_non_active_player_tactics:;
    *(word *)&D0 |= 10;                     // or word ptr D0, 10

l_set_color:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    writeMemory(esi + 6, 2, 0);             // mov [esi+MenuEntry.isDisabled], 0
    ax = *(word *)&g_memByte[494102];       // mov ax, showingCpuTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_disable_entry;               // jnz short @@disable_entry

    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_advance_entry_ptr;           // jz short @@advance_entry_ptr

l_disable_entry:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1

l_advance_entry_ptr:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 18;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 18
    if (!flags.zero)
        goto l_next_entry;                  // jnz @@next_entry
}

// =============== S U B R O U T I N E =======================================

// [play match menu procedure]
// Sets player surnames on green pitch on the right,
// (tactics) just before starting the game.
//
void SetPlayerSurnamesOnSidePitch()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 57;                                // mov D0, 57
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_this_team;                   // jz short @@this_team

    eax = *(dword *)&g_memByte[336376];     // mov eax, playMatchTeam2Ptr
    A0 = eax;                               // mov A0, eax

l_this_team:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A4 = 372768;                            // mov A4, offset g_tacticsTable
    esi = A4;                               // mov esi, A4
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A4 = eax;                               // mov A4, eax
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 369, 1);    // mov al, [esi+Tactics.ballOutOfPlayTactics]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A4 = 496450;                            // mov A4, offset sidePitchSurnamePositionsTable
    esi = A4;                               // mov esi, A4
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A4 = eax;                               // mov A4, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)&D7 = 10;                      // mov word ptr D7, 10
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

l_player_entries_loop:;
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 20, 2, ax);           // mov [esi+MenuEntry.x], ax
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 180;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add [esi+MenuEntry.x], 180
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+MenuEntry.y], 9
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // add A4, 2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    push(D2);                               // push D2
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, PlayerFile.playerName+4Ch
    A0 = eax;                               // mov A0, eax
    esi = A5;                               // mov esi, A5
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 246;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+MenuEntry.x], 246
    if (!flags.zero)
        goto cseg_40D8A;                    // jnz short cseg_40D8A

    *(word *)&D0 = 16399;                   // mov word ptr D0, 400Fh
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D7);                               // push D7
    push(A5);                               // push A5
    push(A6);                               // push A6
    ExtractSurname();                       // call ExtractSurname
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(D7);                                // pop D7
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    goto l_set_surname;                     // jmp short @@set_surname

cseg_40D8A:;
    *(word *)&D0 = 16394;                   // mov word ptr D0, 400Ah
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D7);                               // push D7
    push(A5);                               // push A5
    push(A6);                               // push A6
    ExtractSurname();                       // call ExtractSurname
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(D7);                                // pop D7
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1

l_set_surname:;
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, size MenuEntry
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_player_entries_loop;         // jns @@player_entries_loop
}

// =============== S U B R O U T I N E =======================================

// Set variable buttons such as view opponent, set team and coach name.
// (in play match menu)
//
void SetVariableButtons()
{
    SetGameStartButtonText();               // call SetGameStartButtonText
    ShowUseMatchTeamIfTraining();           // call ShowUseMatchTeamIfTraining
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 9293);         // mov [esi+MenuEntry.fg.string], offset aViewOppo
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_viewing_team;                // jz short @@viewing_team

    writeMemory(esi + 38, 4, 20937);        // mov [esi+MenuEntry.fg.string], offset aViewTeam

l_viewing_team:;
    ax = *(word *)&g_memByte[494102];       // mov ax, showingCpuTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_player;                   // jz short @@no_player

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 5818);         // mov [esi+MenuEntry.fg.string], offset aViewOtherTeam
    writeMemory(esi + 24, 2, 93);           // mov [esi+MenuEntry.dwWidth], 93

l_no_player:;
    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 57343;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0DFFFh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_a_training;              // jz @@not_a_training

    writeMemory(esi + 38, 4, 6667);         // mov [esi+MenuEntry.fg.string], offset aViewATeam
    ax = *(word *)&g_memByte[496522];       // mov ax, is_A_team
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_not_a_training;              // jnz @@not_a_training

    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 6679);         // mov [esi+MenuEntry.fg.string], offset aViewBTeam
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    A0 = 98218;                             // mov A0, offset currentTeam
    GetNumberOfSubstitutes();               // call GetNumberOfSubstitutes
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto l_not_a_training;              // jz short @@not_a_training

    push(D0);                               // push D0
    D0 = 7;                                 // mov D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D0 |= 8192;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // or word ptr D0, 2000h
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax

l_not_a_training:;
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_a_training3;             // jz short @@not_a_training3

    ax = *(word *)&g_memByte[496522];       // mov ax, is_A_team
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_is_A_team;                   // jnz @@is_A_team

l_not_a_training3:;
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A6 = eax;                               // mov A6, eax
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_this_team;                   // jz short @@this_team

    eax = *(dword *)&g_memByte[336376];     // mov eax, playMatchTeam2Ptr
    A6 = eax;                               // mov A6, eax

l_this_team:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi+TeamFile.countryNumber]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 24755;                             // mov A0, offset countriesTable
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 1
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, '(');               // mov byte ptr [esi], '('
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ')');               // mov byte ptr [esi], ')'
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1

l_is_A_team:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    UpdateCheckMarkSprite();                // call UpdateCheckMarkSprite
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A6 = eax;                               // mov A6, eax
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_this_team2;                  // jz @@this_team2

    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, 172);          // mov [esi+MenuEntry.y], 172
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, 172);          // mov [esi+MenuEntry.y], 172
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 12;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 12
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    eax = *(dword *)&g_memByte[336376];     // mov eax, playMatchTeam2Ptr
    A6 = eax;                               // mov A6, eax
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    eax = *(dword *)&g_memByte[336376];     // mov eax, playMatchTeam2Ptr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (!flags.zero)
        goto l_pl1_not_computer;            // jnz short @@pl1_not_computer

    ax = *(word *)&g_memByte[336368];       // mov ax, squadChangesAllowed
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_D6_param_non_zero;           // jnz short @@D6_param_non_zero

l_pl1_not_computer:;
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

l_D6_param_non_zero:;
    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 29;                      // mov word ptr D0, 29
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 30;                      // mov word ptr D0, 30
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    goto cseg_41734;                        // jmp cseg_41734

l_this_team2:;
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, 172);          // mov [esi+MenuEntry.y], 172
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, 172);          // mov [esi+MenuEntry.y], 172
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[494102];       // mov ax, showingCpuTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_player2;                  // jz short @@no_player2

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0

l_no_player2:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 8060);         // mov [esi+MenuEntry.fg.string], offset aCoach
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (!flags.zero)
        goto l_not_player;                  // jnz short @@not_player

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 8068);         // mov [esi+MenuEntry.fg.string], offset aPlayer

l_not_player:;
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 13;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 13
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (!flags.zero)
        goto l_not_player2;                 // jnz short @@not_player2

    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 11
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

l_not_player2:;
    ax = *(word *)&g_memByte[336368];       // mov ax, squadChangesAllowed
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_413F3;                    // jnz short cseg_413F3

    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

cseg_413F3:;
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 0);             // mov [esi+MenuEntry.isDisabled], 0
    ax = *(word *)&g_memByte[496522];       // mov ax, is_A_team
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_team_B;                      // jz short @@team_B

    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

l_team_B:;
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_a_training2;             // jz short @@not_a_training2

    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (flags.zero)
        goto l_player;                      // jz short @@player

    eax = *(dword *)&g_memByte[336376];     // mov eax, playMatchTeam2Ptr
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (!flags.zero)
        goto l_not_a_training2;             // jnz short @@not_a_training2

l_player:;
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (flags.zero)
        goto l_not_a_training2;             // jz short @@not_a_training2

    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1

l_not_a_training2:;
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 11
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (flags.zero)
        goto l_coach;                       // jz @@coach

    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 13;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 13
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COACH
    if (flags.zero)
        goto l_coach;                       // jz short @@coach

    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 12;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 12
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

l_coach:;
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_computer;                // jz short @@not_computer

    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (!flags.zero)
        goto l_not_computer;                // jnz short @@not_computer

    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 13;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 13
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

l_not_computer:;
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    ax = *(word *)&g_memByte[494102];       // mov ax, showingCpuTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_41643;                    // jz short cseg_41643

    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

cseg_41643:;
    ax = *(word *)&g_memByte[496522];       // mov ax, is_A_team
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_41668;                    // jz short cseg_41668

    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

cseg_41668:;
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 29;                      // mov word ptr D0, 29
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 30;                      // mov word ptr D0, 30
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = *(word *)&g_memByte[494102];       // mov ax, showingCpuTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_41734;                    // jnz short cseg_41734

    ax = *(word *)&g_memByte[336384];       // mov ax, numPlayersToShowInMenu
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[336382];       // mov ax, pmMenuNumPlayers
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    if (flags.zero)
        goto cseg_41734;                    // jz short cseg_41734

    *(word *)&D0 = 29;                      // mov word ptr D0, 29
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1
    if (flags.zero)
        goto cseg_41734;                    // jz short cseg_41734

    *(word *)&D0 = 30;                      // mov word ptr D0, 30
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0

cseg_41734:;
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_not_a_training_game;         // jz short @@not_a_training_game

    A1 = 456352;                            // mov A1, offset team_A_name
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A6, offset careerTeam
    if (flags.zero)
        goto l_not_a_training_game;         // jz short @@not_a_training_game

    A1 = 456369;                            // mov A1, offset team_B_name

l_not_a_training_game:;
    eax = A1;                               // mov eax, A1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 36;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, TeamFile.coachName
    A1 = eax;                               // mov A1, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
}

// =============== S U B R O U T I N E =======================================

// in:
//     A5 -> current entry that's about to be drawn
//
// Function for redrawing player names and all corresponding entries in play match menu.
//
void DrawPlayerEntries()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 13;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 13
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 16
    if (!flags.zero)
        goto l_standard_entry;              // jnz @@standard_entry

    *(word *)&D5 = 1;                       // mov word ptr D5, 1
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 5
    ax = *(word *)&g_memByte[336380];       // mov ax, maxSubstitutesEntries
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, ax
    push(D0);                               // push D0
    D0 = 31;                                // mov D0, 31
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 33;                                // mov D0, 33
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 8;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    goto l_set_positions;                   // jmp @@set_positions

l_standard_entry:;
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 11
    if (!flags.carry)
        goto l_substitutes;                 // jnb @@substitutes

    ax = *(word *)&g_memByte[494102];       // mov ax, showingCpuTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_viewing_cpu_teams;           // jnz @@viewing_cpu_teams

    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_viewing_cpu_teams;           // jnz @@viewing_cpu_teams

    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_drawing_goalkeeper;          // jz @@drawing_goalkeeper

    push(D0);                               // push D0
    D0 = 31;                                // mov D0, 31
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 13;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 13
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 33;                                // mov D0, 33
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 13;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 13
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    goto l_set_positions;                   // jmp @@set_positions

l_viewing_cpu_teams:;
    push(D0);                               // push D0
    D0 = 31;                                // mov D0, 31
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 10
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 33;                                // mov D0, 33
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 10
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    goto l_set_positions;                   // jmp @@set_positions

l_drawing_goalkeeper:;
    push(D0);                               // push D0
    D0 = 31;                                // mov D0, 31
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 14
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 33;                                // mov D0, 33
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 14
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    goto l_set_positions;                   // jmp @@set_positions

l_substitutes:;
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_41B4B;                    // jnz cseg_41B4B

    ax = *(word *)&g_memByte[494102];       // mov ax, showingCpuTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_41B4B;                    // jnz cseg_41B4B

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 11
    if (flags.zero)
        goto cseg_41BDA;                    // jz cseg_41BDA

l_starting_lineup:;
    push(D0);                               // push D0
    D0 = 31;                                // mov D0, 31
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 11
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 33;                                // mov D0, 33
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 0Bh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    goto l_set_positions;                   // jmp @@set_positions

cseg_41B4B:;
    push(D0);                               // push D0
    D0 = 31;                                // mov D0, 31
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 12;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 12
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 33;                                // mov D0, 33
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 12;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 12
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    goto l_set_positions;                   // jmp @@set_positions

cseg_41BDA:;
    {
        word src = *(word *)&g_memByte[336380];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp maxSubstitutesEntries, 5
    if (flags.carry || flags.zero)
        goto l_starting_lineup;             // jbe @@starting_lineup

    push(D0);                               // push D0
    D0 = 31;                                // mov D0, 31
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 14
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 33;                                // mov D0, 33
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 14;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 14
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

l_set_positions:;
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_41C91;                    // jz short cseg_41C91

    eax = *(dword *)&g_memByte[336376];     // mov eax, playMatchTeam2Ptr
    A0 = eax;                               // mov A0, eax

cseg_41C91:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    GetPlayerGameBreakPosition();           // call GetPlayerGameBreakPosition
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_not_injured;                 // jnz @@not_injured

    ax = *(word *)&g_memByte[336400];       // mov ax, playMatchExcludeFlags
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    IsPlayerInjured();                      // call IsPlayerInjured
    pop(D1);                                // pop D1
    if (flags.zero)
        goto l_not_injured;                 // jz @@not_injured

    push(D0);                               // push D0
    D0 = 31;                                // mov D0, 31
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 10
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 33;                                // mov D0, 33
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 10
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

l_not_injured:;
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_determine_small_checkmark;   // jnz @@determine_small_checkmark

    ax = *(word *)&g_memByte[336388];       // mov ax, selectedPlayerPosition
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto l_determine_small_checkmark;   // jnz @@determine_small_checkmark

    push(D0);                               // push D0
    D0 = 31;                                // mov D0, 31
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 6
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    push(D0);                               // push D0
    D0 = 33;                                // mov D0, 33
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 6
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

l_determine_small_checkmark:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    push(D0);                               // push D0
    D0 = 31;                                // mov D0, 31
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    ax = *(word *)&g_memByte[336400];       // mov ax, playMatchExcludeFlags
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    cseg_13A55();                           // call cseg_13A55
    pop(D1);                                // pop D1
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_neutral_replacement;         // jnz short @@neutral_replacement

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 11
    if (!flags.carry)
        goto l_neutral_replacement;         // jnb short @@neutral_replacement

    A1 = 378790;                            // mov A1, offset playerPositionsArray
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    A1 = 378822;                            // mov A1, offset oldPlayerPositionsArray
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.carry && !flags.zero)
        goto l_good_replacement;            // ja short @@good_replacement

    if (flags.zero)
        goto l_neutral_replacement;         // jz short @@neutral_replacement

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, 209);          // mov [esi+MenuEntry.fg.sprite2], SPR_NOT_CHECK_SMALL
    goto l_neutral_replacement;             // jmp short @@neutral_replacement

l_good_replacement:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, 208);          // mov [esi+MenuEntry.fg.sprite2], SPR_CHECK_SMALL

l_neutral_replacement:;
    eax = *(dword *)&g_memByte[494098];     // mov eax, currentSelectedPlayerIndexPtr
    A2 = eax;                               // mov A2, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_check_if_deselect;           // jnz short @@check_if_deselect

    ax = *(word *)&g_memByte[94092];        // mov ax, dseg_D761A
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        dword src = *(dword *)&g_memByte[336372];
        int32_t dstSigned = src;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp playMatchTeam1Ptr, offset careerTeam
    if (flags.zero)
        goto l_check_if_deselect;           // jz short @@check_if_deselect

    ax = *(word *)&g_memByte[99546];        // mov ax, dseg_D8B68
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        dword src = *(dword *)&g_memByte[336372];
        int32_t dstSigned = src;
        int32_t srcSigned = 98218;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp playMatchTeam1Ptr, offset currentTeam
    if (flags.zero)
        goto l_check_if_deselect;           // jz short @@check_if_deselect

    eax = *(dword *)&g_memByte[494098];     // mov eax, currentSelectedPlayerIndexPtr
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

l_check_if_deselect:;
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_no_deselect;                 // jnz short @@no_deselect

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 37;                                // mov D0, 37
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 38, 2);     // mov ax, [esi+MenuEntry.fg.sprite2]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.sprite2], ax

l_no_deselect:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, size MenuEntry
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_get_surname;                 // jnz short @@get_surname

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 78, 1);     // mov al, [esi+(PlayerFile.shirtNumber+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0

l_get_surname:;
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, size MenuEntry
    push(A0);                               // push A0
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, PlayerFile.playerName+4Ch
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 32781;                   // mov word ptr D0, 800Dh
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A6);                               // push A6
    ExtractSurname();                       // call ExtractSurname
    pop(A6);                                // pop A6
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    eax = A0;                               // mov eax, A0
    pop(A0);                                // pop A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, size MenuEntry
    A2 = 332080;                            // mov A2, offset playerPositionsStringTable
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 11100000b
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    ax = D7;                                // mov ax, word ptr D7
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, size MenuEntry
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    FormTopSkillsString();                  // call FormTopSkillsString
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, size MenuEntry
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    push(A0);                               // push A0
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A1 = eax;                               // mov A1, eax
    IsTeamNational();                       // call IsTeamNational
    if (flags.zero)
        goto l_not_national;                // jz short @@not_national

    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    cseg_3E04F();                           // call cseg_3E04F
    pop(A0);                                // pop A0
    goto cseg_421C2;                        // jmp short cseg_421C2

l_not_national:;
    A1 = 316574;                            // mov A1, offset fundsBuffer
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    cseg_247C8();                           // call cseg_247C8
    pop(A0);                                // pop A0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 316574);       // mov [esi+MenuEntry.fg.string], offset fundsBuffer

cseg_421C2:;
    *(word *)&D1 = 13;                      // mov word ptr D1, 0Dh
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+113], 9Bh
    if (flags.zero)
        goto cseg_4220A;                    // jz short cseg_4220A

    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+(PlayerFile.someFlag+4Ch)], 9Ah
    if (flags.zero)
        goto cseg_4220A;                    // jz short cseg_4220A

    *(word *)&D1 = 15;                      // mov word ptr D1, 0Fh
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test [esi+(PlayerFile.positionAndFace+4Ch)], 2
    if (!flags.zero)
        goto cseg_4220A;                    // jnz short cseg_4220A

    *(word *)&D1 = 2;                       // mov word ptr D1, 2

cseg_4220A:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, size MenuEntry
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 31;                                // mov D0, 31
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    SWOS::DrawMultipleItems();              // jmp DrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void RedrawPlayerNames()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    CallDrawMultipleItems();                // call CallDrawMultipleItems
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void UpdateLittleCheckmark()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ax = *(word *)&g_memByte[378786];       // mov ax, oldPlayerSkill
    *(word *)&g_memByte[378788] = ax;       // mov newPlayerSkill, ax
    flags.carry = false;                    // or ax, ax
    A0 = 378790;                            // mov A0, offset playerPositionsArray
    A1 = 378822;                            // mov A1, offset oldPlayerPositionsArray
    *(word *)&D0 = 31;                      // mov word ptr D0, 31

l_copy_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_loop;                   // jns short @@copy_loop

    UpdateCheckMarkSprite();                // call UpdateCheckMarkSprite
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void SavePositionsAndUpdateLittleCheckmark()
{
    ax = *(word *)&g_memByte[378786];       // mov ax, oldPlayerSkill
    *(word *)&g_memByte[378788] = ax;       // mov newPlayerSkill, ax
    A0 = 378790;                            // mov A0, offset playerPositionsArray
    A1 = 378822;                            // mov A1, offset oldPlayerPositionsArray
    *(word *)&D0 = 31;                      // mov word ptr D0, 31

l_copy_positions_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_positions_loop;         // jns short @@copy_positions_loop

    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 59, 1, 1);            // mov [esi+TeamFile.someFlag], 1
    ax = *(word *)&g_memByte[336380];       // mov ax, maxSubstitutesEntries
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SetupTeamSubstitutes();                 // call SetupTeamSubstitutes

    UpdateCheckMarkSprite();
}

// =============== S U B R O U T I N E =======================================

// Compare new line-up to the old, and display big check or X mark depending is it better or not.
// If skills are equal, or we are looking at opponents team leave it hidden.
//
void UpdateCheckMarkSprite()
{
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = *(word *)&g_memByte[336386];       // mov ax, viewingOpponentTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 57343;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0DFFFh
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    ax = *(word *)&g_memByte[378786];       // mov ax, oldPlayerSkill
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[378788];       // mov ax, newPlayerSkill
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry && !flags.zero)
        goto l_right;                       // ja short @@right

    ax = *(word *)&g_memByte[378788];       // mov ax, newPlayerSkill
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.carry)
        goto l_wrong;                       // jb short @@wrong

l_out:;
    return;                                 // retn

l_wrong:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, 207);          // mov [esi+MenuEntry.fg.sprite2], SPR_NOT_CHECK_BIG
    goto l_go_on;                           // jmp short @@go_on

l_right:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, 206);          // mov [esi+MenuEntry.fg.sprite2], SPR_CHECK_BIG

l_go_on:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 36, 2);     // mov ax, [esi+MenuEntry.stringFlags]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D1 |= 8192;
    flags.carry = false;
    flags.sign = (*(word *)&D1 & 0x8000) != 0;
    flags.zero = *(word *)&D1 == 0;         // or word ptr D1, 2000h
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 36, 2, ax);           // mov [esi+MenuEntry.stringFlags], ax
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
}

// =============== S U B R O U T I N E =======================================
//
void UseMatchTeamSelect()
{
    cseg_63E05();                           // call cseg_63E05
    al = g_memByte[98242];                  // mov al, currentTeam+18h
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    push(D0);                               // push small [word ptr D0]
    cseg_6481C();                           // call cseg_6481C
    {
        int32_t val = stack[stackTop++];
        *(word *)&D0 = val;
    }                                       // pop small [word ptr D0]
    al = D0;                                // mov al, byte ptr D0
    g_memByte[98242] = al;                  // mov currentTeam+18h, al
    cseg_63EC4();                           // call cseg_63EC4
    A0 = 92798;                             // mov A0, offset careerTeam
    SetBenchPlayersNumbers();               // call SetBenchPlayersNumbers
    cseg_64161();                           // call cseg_64161
    *(word *)&g_memByte[336388] = -1;       // mov selectedPlayerPosition, -1
    SavePositionsAndUpdateLittleCheckmark(); // call SavePositionsAndUpdateLittleCheckmark
    UpdateLittleCheckmark();                // call UpdateLittleCheckmark
    SetVariableButtons();                   // call SetVariableButtons
    SetUpTacticsButtons();                  // call SetUpTacticsButtons
    SetPlayerSurnamesOnSidePitch();         // call SetPlayerSurnamesOnSidePitch
    ShowOrHidePlayMatchButton();            // call ShowOrHidePlayMatchButton
    UpdateTeamCheckmark();                  // call UpdateTeamCheckmark
    *(word *)&D0 = 29;                      // mov word ptr D0, 1Dh
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void TogglePlayerCoach()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto l_not_career;                  // jnz @@not_career

    ax = *(word *)&g_memByte[496522];       // mov ax, is_A_team
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_b_team;                      // jz short @@b_team

    A1 = 98218;                             // mov A1, offset currentTeam
    *(byte *)&D0 = 3;                       // mov byte ptr D0, 3
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+TeamGeneralInfo.playerNumber], TEAM_PLAYER_COACH
    if (flags.zero)
        goto l_set_controls;                // jz short @@set_controls

    *(byte *)&D0 = 2;                       // mov byte ptr D0, 2

l_set_controls:;
    al = D0;                                // mov al, byte ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 4, 1, al);            // mov byte ptr [esi+TeamGeneralInfo.playerNumber], al
    g_memByte[92802] = 1;                   // mov careerTeam+4, 1
    *(word *)&g_memByte[91722] = 0;         // mov coachOrPlayer, 0
    goto cseg_426F6;                        // jmp cseg_426F6

l_b_team:;
    {
        word src = *(word *)&g_memByte[91722];
        src ^= 1;
        *(word *)&g_memByte[91722] = src;
    }                                       // xor coachOrPlayer, 1
    A1 = 92798;                             // mov A1, offset careerTeam
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A2 = eax;                               // mov A2, eax
    *(byte *)&D0 = 2;                       // mov byte ptr D0, 2
    ax = *(word *)&g_memByte[91722];        // mov ax, coachOrPlayer
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_42694;                    // jnz short cseg_42694

    *(byte *)&D0 = 3;                       // mov byte ptr D0, 3

cseg_42694:;
    al = D0;                                // mov al, byte ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 4, 1, al);            // mov [esi+4], al
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 4, 1, al);            // mov [esi+4], al
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_426F6;                    // jz short cseg_426F6

    g_memByte[98222] = 1;                   // mov currentTeam+4, 1
    goto cseg_426F6;                        // jmp short cseg_426F6

l_not_career:;
    eax = *(dword *)&g_memByte[336372];     // mov eax, playMatchTeam1Ptr
    A0 = eax;                               // mov A0, eax
    *(byte *)&D0 = 3;                       // mov byte ptr D0, 3
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 2
    if (flags.zero)
        goto cseg_426E8;                    // jz short cseg_426E8

    *(byte *)&D0 = 2;                       // mov byte ptr D0, 2

cseg_426E8:;
    al = D0;                                // mov al, byte ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 1, al);            // mov [esi+4], al

cseg_426F6:;
    SetVariableButtons();                   // call SetVariableButtons
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================

// Show or hide use match button. Show it only if this is a training
// game, we are using B team, and team has changed since the last game.
//
void ShowUseMatchTeamIfTraining()
{
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    ax = *(word *)&g_memByte[496522];       // mov ax, is_A_team
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    CheckIfTeamIsChanged();                 // call CheckIfTeamIsChanged
    if (flags.zero)
        return;                             // jz short @@out

    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentInit()
{
    ax = *(word *)&g_memByte[336542];       // mov ax, diyTournamentLookOnly
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_42A48;                    // jnz short cseg_42A48

    cseg_4346F();                           // call cseg_4346F

cseg_42A48:;

    DesignDIYTournamentReinit();
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentReinit()
{
    {
        word src = *(word *)&g_memByte[131708];
        int16_t dstSigned = src;
        int16_t srcSigned = 65534;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_pitchType, SEASONAL
    if (flags.zero)
        goto cseg_42B1B;                    // jz cseg_42B1B

    *(word *)&g_memByte[317639] = 0;        // mov diyPitchTypeOrSeason, 0
    ax = *(word *)&g_memByte[131708];       // mov ax, g_pitchType
    *(word *)&g_memByte[317641] = ax;       // mov diyPitchType, ax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1

cseg_42B1B:;
    cseg_42F6F();                           // call cseg_42F6F
    cseg_42CF0();                           // call cseg_42CF0
    ax = *(word *)&g_memByte[336542];       // mov ax, diyTournamentLookOnly
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_42BE2;                    // jnz cseg_42BE2

    ax = *(word *)&g_memByte[336544];       // mov ax, diyTournamentSelectTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_42BB4;                    // jnz short cseg_42BB4

    *(word *)&D0 = 89;                      // mov word ptr D0, 59h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 90;                      // mov word ptr D0, 5Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 92;                      // mov word ptr D0, 5Ch
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 91;                                // mov D0, 5Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 32;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add word ptr [esi+14h], 20h
    return;                                 // retn

cseg_42BB4:;
    cseg_42D98();                           // call cseg_42D98
    *(word *)&D0 = 90;                      // mov word ptr D0, 5Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 89;                      // mov word ptr D0, 59h
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    return;                                 // retn

cseg_42BE2:;
    cseg_42D98();                           // call cseg_42D98
    *(word *)&D0 = 89;                      // mov word ptr D0, 59h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 90;                      // mov word ptr D0, 5Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 92;                      // mov word ptr D0, 5Ch
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[317671];       // mov ax, dseg_10EADD
    bx = 12;                                // mov bx, 0Ch
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 17;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 11h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    *(word *)&D1 = 11;                      // mov word ptr D1, 0Bh

cseg_42C74:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 28, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+1Ch], 2
    if (!flags.zero)
        goto cseg_42CD1;                    // jnz short cseg_42CD1

    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Fh
    if (flags.zero)
        goto cseg_42CD1;                    // jz short cseg_42CD1

    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    *(word *)&D0 |= 11;                     // or word ptr D0, 0Bh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax

cseg_42CD1:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 38h
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_42C74;                    // jns short cseg_42C74

    *(word *)&D0 = 91;                      // mov word ptr D0, 5Bh
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void cseg_42CF0()
{
    al = g_memByte[317643];                 // mov al, dseg_10EAC1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 60h
    if (flags.carry)
        goto cseg_42D0A;                    // jb short cseg_42D0A

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 60h

cseg_42D0A:;
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 8;                                 // mov bx, 8
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[336538] = ax;       // mov dseg_114C1C, ax
    al = g_memByte[317644];                 // mov al, dseg_10EAC2
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 60h
    if (flags.carry)
        goto cseg_42D5B;                    // jb short cseg_42D5B

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 60h

cseg_42D5B:;
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 8;                                 // mov bx, 8
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[336540] = ax;       // mov dseg_114C1E, ax
    cseg_44C68();                           // call cseg_44C68
}

// =============== S U B R O U T I N E =======================================
//
void cseg_42D98()
{
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D1 = 86;                      // mov word ptr D1, 56h

cseg_42DBC:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 28, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+1Ch], 2
    if (!flags.zero)
        goto cseg_42E1F;                    // jnz short cseg_42E1F

    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Fh
    if (flags.zero)
        goto cseg_42E1F;                    // jz short cseg_42E1F

    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1

cseg_42E1F:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 38h
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_42DBC;                    // jns short cseg_42DBC

    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOK()
{
    *(word *)&g_memByte[336544] = 1;        // mov diyTournamentSelectTeams, 1
    A6 = 496525;                            // mov A6, offset designDiyTournamentMenu
    SWOS::ActivateMenu();                   // call ActivateMenu
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect91()
{
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect2()
{
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 25;                      // mov word ptr D0, 19h
    SWOS::InputText();                      // call InputText
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect89()
{
    ax = *(word *)&g_memByte[317637];       // mov ax, dseg_10EABB
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 317592;                            // mov A0, offset dseg_10EA8E
    A1 = 15958;                             // mov A1, offset aPlayTournament
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    *(word *)&D3 = 1;                       // mov word ptr D3, 1
    *(word *)&D4 = 1;                       // mov word ptr D4, 1
    GoGetTeamsForPlay();                    // call GoGetTeamsForPlay
    ax = *(word *)&g_memByte[330694];       // mov ax, chooseTeamsResult
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_42F07;                    // jnz short cseg_42F07

    { DesignDIYTournamentOnSelect91(); return; } // jmp short DesignDIYTournamentOnSelect91

cseg_42F07:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CareerInitVars();                       // call CareerInitVars
    A0 = 317741;                            // mov A0, offset dseg_10EB23
    ax = *(word *)&g_memByte[317637];       // mov ax, dseg_10EABB
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_87D60();                           // call cseg_87D60
    nullsub_13();                           // call nullsub_13
    cseg_2573C();                           // call cseg_2573C
    cseg_258E4();                           // call cseg_258E4
    InitTeams();                            // call InitTeams
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_89B5C();                           // call cseg_89B5C
    RestoreDIYTournament();                 // call RestoreDIYTournament
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void cseg_42F6F()
{
    ax = *(word *)&g_memByte[317639];       // mov ax, diyPitchTypeOrSeason
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_42FC7;                    // jnz short cseg_42FC7

    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 60, 2, 1);            // mov word ptr [esi+3Ch], 1
    writeMemory(esi + 116, 2, 1);           // mov word ptr [esi+74h], 1
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    return;                                 // retn

cseg_42FC7:;
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    writeMemory(esi + 60, 2, 0);            // mov word ptr [esi+3Ch], 0
    writeMemory(esi + 116, 2, 0);           // mov word ptr [esi+74h], 0
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect3()
{
    {
        word src = *(word *)&g_memByte[317639];
        src ^= 1;
        *(word *)&g_memByte[317639] = src;
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor diyPitchTypeOrSeason, 1
    cseg_42F6F();                           // call cseg_42F6F
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CallDrawMultipleItems();                // call CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect4()
{
    {
        word src = *(word *)&g_memByte[317641];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[317641] = src;
    }                                       // add diyPitchType, 1
    {
        word src = *(word *)&g_memByte[317641];
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp diyPitchType, 7
    if (!flags.zero)
        goto cseg_43086;                    // jnz short cseg_43086

    *(word *)&g_memByte[317641] = 65535;    // mov diyPitchType, 0FFFFh

cseg_43086:;
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect5()
{
    A0 = 317588;                            // mov A0, offset diyFileBufferCopy
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 55, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 8;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 55, 1, src);
    }                                       // add byte ptr [esi+37h], 8
    al = (byte)readMemory(esi + 55, 1);     // mov al, [esi+37h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 60h
    if (!flags.zero)
        goto cseg_430CA;                    // jnz short cseg_430CA

    writeMemory(esi + 55, 1, 0);            // mov byte ptr [esi+37h], 0
    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0

cseg_430CA:;
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 8;                                 // mov bx, 8
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[336538] = ax;       // mov dseg_114C1C, ax
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect7()
{
    A0 = 317588;                            // mov A0, offset diyFileBufferCopy
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 56, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 8;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 56, 1, src);
    }                                       // add byte ptr [esi+38h], 8
    al = (byte)readMemory(esi + 56, 1);     // mov al, [esi+38h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 60h
    if (!flags.zero)
        goto cseg_43143;                    // jnz short cseg_43143

    writeMemory(esi + 56, 1, 0);            // mov byte ptr [esi+38h], 0
    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0

cseg_43143:;
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 8;                                 // mov bx, 8
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[336540] = ax;       // mov dseg_114C1E, ax
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect9()
{
    cseg_433DE();                           // call cseg_433DE
    esi = A4;                               // mov esi, A4
    {
        word src = (word)readMemory(esi + 73, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 73, 2, src);
    }                                       // add word ptr [esi+49h], 1
    {
        word src = (word)readMemory(esi + 73, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+49h], 3
    if (flags.carry)
        goto cseg_4319D;                    // jb short cseg_4319D

    writeMemory(esi + 73, 2, 0);            // mov word ptr [esi+49h], 0

cseg_4319D:;
    DesignDIYTournamentOnDraw();            // call DesignDIYTournamentOnDraw
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect11()
{
    ax = *(word *)&g_memByte[317665];       // mov ax, dseg_10EAD7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_431E3

    {
        word src = *(word *)&g_memByte[317663];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[317663] = src;
    }                                       // add dseg_10EAD5, 1
    ax = *(word *)&g_memByte[317663];       // mov ax, dseg_10EAD5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_431D9;                    // jnb short cseg_431D9

    *(word *)&g_memByte[317663] = 1;        // mov dseg_10EAD5, 1

cseg_431D9:;
    cseg_44C68();                           // call cseg_44C68
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect13()
{
    {
        word src = *(word *)&g_memByte[317665];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[317665] = src;
    }                                       // add dseg_10EAD7, 1
    {
        word src = *(word *)&g_memByte[317665];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10EAD7, 5
    if (flags.carry || flags.zero)
        goto cseg_43208;                    // jbe short cseg_43208

    *(word *)&g_memByte[317665] = 0;        // mov dseg_10EAD7, 0
    *(word *)&g_memByte[317663] = 0;        // mov dseg_10EAD5, 0

cseg_43208:;
    {
        word src = *(word *)&g_memByte[317665];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10EAD7, 1
    if (!flags.zero)
        goto cseg_4321B;                    // jnz short cseg_4321B

    *(word *)&g_memByte[317663] = 1;        // mov dseg_10EAD5, 1

cseg_4321B:;
    cseg_44C68();                           // call cseg_44C68
    CallDrawMenuItem();                     // call CallDrawMenuItem
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 0Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect21()
{
    cseg_433DE();                           // call cseg_433DE
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 351, 2);
        src ^= 1;
        writeMemory(esi + 351, 2, src);
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor word ptr [esi+15Fh], 1
    DesignDIYTournamentOnDraw();            // call DesignDIYTournamentOnDraw
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect23()
{
    cseg_433DE();                           // call cseg_433DE
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 365, 2);
        src ^= 3;
        writeMemory(esi + 365, 2, src);
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor word ptr [esi+16Dh], 3
    push(A3);                               // push A3
    DesignDIYTournamentOnDraw();            // call DesignDIYTournamentOnDraw
    pop(A3);                                // pop A3
    eax = A3;                               // mov eax, A3
    A0 = eax;                               // mov A0, eax
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    cseg_443C7();                           // call cseg_443C7
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CallDrawMultipleItems();                // jmp CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect24()
{
    cseg_433DE();                           // call cseg_433DE
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 367, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 367, 2, src);
    }                                       // add word ptr [esi+16Fh], 1
    {
        word src = (word)readMemory(esi + 367, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+16Fh], 3
    if (!flags.zero)
        goto cseg_4333B;                    // jnz short cseg_4333B

    writeMemory(esi + 367, 2, 0);           // mov word ptr [esi+16Fh], 0

cseg_4333B:;
    DesignDIYTournamentOnDraw();            // call DesignDIYTournamentOnDraw
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect25()
{
    cseg_433DE();                           // call cseg_433DE
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 369, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 369, 2, src);
    }                                       // add word ptr [esi+171h], 1
    {
        word src = (word)readMemory(esi + 369, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+171h], 3
    if (!flags.zero)
        goto cseg_43378;                    // jnz short cseg_43378

    writeMemory(esi + 369, 2, 0);           // mov word ptr [esi+171h], 0

cseg_43378:;
    DesignDIYTournamentOnDraw();            // call DesignDIYTournamentOnDraw
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect26()
{
    cseg_433DE();                           // call cseg_433DE
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 359, 2);
        src ^= 1;
        writeMemory(esi + 359, 2, src);
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor word ptr [esi+167h], 1
    DesignDIYTournamentOnDraw();            // call DesignDIYTournamentOnDraw
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect28()
{
    cseg_433DE();                           // call cseg_433DE
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 357, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 357, 2, src);
    }                                       // add word ptr [esi+165h], 1
    {
        word src = (word)readMemory(esi + 357, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+165h], 5
    if (!flags.zero)
        goto cseg_433D3;                    // jnz short cseg_433D3

    writeMemory(esi + 357, 2, 1);           // mov word ptr [esi+165h], 1

cseg_433D3:;
    DesignDIYTournamentOnDraw();            // call DesignDIYTournamentOnDraw
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void cseg_433DE()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 17;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 11h
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    edx ^= edx;                             // xor edx, edx
    ebx = 12;                               // mov ebx, 0Ch
    {
        int64_t dividend = ((int64_t)edx << 32) | (int32_t)eax;
        int32_t quot = (int32_t)(dividend / (int32_t)ebx);
        int32_t rem = (int32_t)(dividend % (int32_t)ebx);
        eax = quot;
        edx = rem;
    }                                       // idiv ebx
    A4 = 317588;                            // mov A4, offset diyFileBufferCopy
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 83, 2, ax);           // mov [esi+53h], ax
    eax = A4;                               // mov eax, A4
    A3 = eax;                               // mov A3, eax
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    bx = 118;                               // mov bx, 76h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A3 = res;
    }                                       // add A3, eax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4346F()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 92;                                // mov D0, 5Ch
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[317637];       // mov ax, dseg_10EABB
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 16324;                             // mov A0, offset aSelect0Teams
    PrintFormatted();                       // call PrintFormatted
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnDraw()
{
    A2 = 317588;                            // mov A2, offset diyFileBufferCopy
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_434F6:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_43518;                    // jnz short cseg_43518

    {
        word src = (word)readMemory(esi + 365, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+16Dh], 2
    if (flags.zero)
        goto cseg_43584;                    // jz short cseg_43584

cseg_43518:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 118;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A2 = res;
    }                                       // add A2, 76h
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_434F6;                    // jns short cseg_434F6

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // sub A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    goto cseg_435E8;                        // jmp short cseg_435E8

cseg_43584:;
    A2 = 317588;                            // mov A2, offset diyFileBufferCopy
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // sub A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0

cseg_435E8:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    A2 = 317588;                            // mov A2, offset diyFileBufferCopy
    *(word *)&D7 = 0;                       // mov word ptr D7, 0

cseg_43671:;
    ax = *(word *)&g_memByte[317669];       // mov ax, dseg_10EADB
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.zero)
        goto cseg_43694;                    // jnz short cseg_43694

    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 235, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+235], 2
    if (flags.zero)
        goto cseg_43DCC;                    // jz cseg_43DCC

cseg_43694:;
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 5
    if (flags.zero)
        goto cseg_436DF;                    // jz short cseg_436DF

    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 353, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+161h], 2
    if (!flags.zero)
        goto cseg_436EB;                    // jnz short cseg_436EB

    ax = (word)readMemory(esi + 347, 2);    // mov ax, [esi+15Bh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_436EB;                    // jnz short cseg_436EB

cseg_436DF:;
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1

cseg_436EB:;
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    ax = *(word *)&g_memByte[317669];       // mov ax, dseg_10EADB
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (flags.zero)
        goto l_hide_everything;             // jz @@hide_everything

    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_437DA;                    // jnz short cseg_437DA

    A0 = 19203;                             // mov A0, offset a3rdPlayOff
    ax = (word)readMemory(esi + 347, 2);    // mov ax, [esi+15Bh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_437D3;                    // jnz short cseg_437D3

    A0 = 19216;                             // mov A0, offset aFinal
    {
        word src = (word)readMemory(esi + 353, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+161h], 2
    if (flags.zero)
        goto cseg_437D3;                    // jz short cseg_437D3

    A0 = 19058;                             // mov A0, offset aSemiFinal
    {
        word src = (word)readMemory(esi + 353, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+161h], 4
    if (flags.zero)
        goto cseg_437D3;                    // jz short cseg_437D3

    A0 = 19044;                             // mov A0, offset aQuarterFinal
    {
        word src = (word)readMemory(esi + 353, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+161h], 8
    if (flags.zero)
        goto cseg_437D3;                    // jz short cseg_437D3

    A0 = 15210;                             // mov A0, offset aKnockout

cseg_437D3:;
    StringCopy();                           // call StringCopy
    goto cseg_4382F;                        // jmp short cseg_4382F

cseg_437DA:;
    A0 = 15238;                             // mov A0, offset a0GroupsOf1
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 361, 2);    // mov ax, [esi+169h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 363, 2);    // mov ax, [esi+16Bh]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_4381E;                    // jnz short cseg_4381E

    A0 = 15222;                             // mov A0, offset a1GroupOf1

cseg_4381E:;
    push(A2);                               // push A2
    PrintFormatted();                       // call PrintFormatted
    pop(A2);                                // pop A2

cseg_4382F:;
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 351, 2);    // mov ax, [esi+15Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_43863;                    // jz short cseg_43863

    esi = A4;                               // mov esi, A4
    writeMemory(esi + 38, 4, 2660);         // mov [esi+MenuEntry.fg.string], offset aStar
    goto cseg_43870;                        // jmp short cseg_43870

cseg_43863:;
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 38, 4, 2662);         // mov [esi+MenuEntry.fg.string], offset cseg_4493D

cseg_43870:;
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_43927;                    // jnz cseg_43927

    {
        word src = (word)readMemory(esi + 365, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+16Dh], 2
    if (flags.zero)
        goto cseg_438EF;                    // jz short cseg_438EF

    {
        word src = (word)readMemory(esi + 355, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+163h], 1
    if (flags.zero)
        goto cseg_438DB;                    // jz short cseg_438DB

    A0 = 15575;                             // mov A0, offset aMatchWinnersQu
    StringCopy();                           // call StringCopy
    goto cseg_43A55;                        // jmp cseg_43A55

cseg_438DB:;
    A0 = 15719;                             // mov A0, offset aMatchWinnerWin
    StringCopy();                           // call StringCopy
    goto cseg_43A55;                        // jmp cseg_43A55

cseg_438EF:;
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 355, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+163h], 1
    if (flags.zero)
        goto cseg_43913;                    // jz short cseg_43913

    A0 = 15623;                             // mov A0, offset aMatchWinnersOn
    StringCopy();                           // call StringCopy
    goto cseg_43A55;                        // jmp cseg_43A55

cseg_43913:;
    A0 = 15767;                             // mov A0, offset aMatchWinnerOnA
    StringCopy();                           // call StringCopy
    goto cseg_43A55;                        // jmp cseg_43A55

cseg_43927:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 361, 2);    // mov ax, [esi+169h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 355, 2);    // mov ax, [esi+163h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 15815;                             // mov A0, offset aGroupWinnerWin
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto cseg_43A3D;                    // jz cseg_43A3D

    A0 = 15671;                             // mov A0, offset aTop0InGroupQua
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 1
    if (flags.zero)
        goto cseg_43A44;                    // jz cseg_43A44

    A0 = 15254;                             // mov A0, offset aWinnersOfEachG
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_43A3D;                    // jz cseg_43A3D

    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D2);
        word rem = (word)(dividend % *(word *)&D2);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    D1 = eax;                               // mov D1, eax
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_43A08;                    // jnz short cseg_43A08

    A0 = 15307;                             // mov A0, offset aWinnersOfEac_0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1
    if (flags.zero)
        goto cseg_43A3D;                    // jz short cseg_43A3D

    A0 = 15360;                             // mov A0, offset aWinnersOfEac_1
    goto cseg_43A44;                        // jmp short cseg_43A44

cseg_43A08:;
    A0 = 15415;                             // mov A0, offset aTop0InEachGrou
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_43A44;                    // jz short cseg_43A44

    A0 = 15468;                             // mov A0, offset aTop0InEachGr_0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 1
    if (flags.zero)
        goto cseg_43A44;                    // jz short cseg_43A44

    A0 = 15521;                             // mov A0, offset aTop0InEachGr_1
    goto cseg_43A44;                        // jmp short cseg_43A44

cseg_43A3D:;
    StringCopy();                           // call StringCopy
    goto cseg_43A55;                        // jmp short cseg_43A55

cseg_43A44:;
    push(A2);                               // push A2
    PrintFormatted();                       // call PrintFormatted
    pop(A2);                                // pop A2

cseg_43A55:;
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_43BC1;                    // jnz cseg_43BC1

    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 365, 2);    // mov ax, [esi+16Dh]
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 367, 2);    // mov ax, [esi+16Fh]
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 369, 2);    // mov ax, [esi+171h]
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 3
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 10, 1, al);           // mov [esi+0Ah], al
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 77;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2], 4Dh
    if (!flags.carry)
        goto cseg_43BA2;                    // jnb short cseg_43BA2

    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 9;
        byte res = dstSigned + srcSigned;
        *(byte *)&D0 = res;
    }                                       // add byte ptr D0, 9
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 11, 1, al);           // mov [esi+MenuEntry.downEntry], al

cseg_43BA2:;
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // add A4, size MenuEntry
    goto cseg_43CBC;                        // jmp cseg_43CBC

cseg_43BC1:;
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 359, 2);    // mov ax, [esi+167h]
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 1
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 10, 1, al);           // mov [esi+0Ah], al
    writeMemory(esi + 11, 1, al);           // mov [esi+0Bh], al
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 357, 2);    // mov ax, [esi+165h]
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h

cseg_43CBC:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 118;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 118
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 6
    if (!flags.zero)
        goto cseg_43671;                    // jnz cseg_43671

    return;                                 // retn

l_hide_everything:;
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned - srcSigned;
        A4 = res;
    }                                       // sub A4, size MenuEntry
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned - srcSigned;
        A4 = res;
    }                                       // sub A4, size MenuEntry
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned - srcSigned;
        A4 = res;
    }                                       // sub A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // add A4, size MenuEntry
    goto cseg_43EB0;                        // jmp cseg_43EB0

cseg_43DCC:;
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, size MenuEntry

cseg_43EB0:;
    esi = A4;                               // mov esi, A4
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 89;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+MenuEntry.ordinal], 89
    if (!flags.zero)
        goto cseg_43DCC;                    // jnz cseg_43DCC
}

// =============== S U B R O U T I N E =======================================
//
void cseg_43EC2()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 17;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 11h
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    edx ^= edx;                             // xor edx, edx
    ebx = 12;                               // mov ebx, 0Ch
    {
        int64_t dividend = ((int64_t)edx << 32) | (int32_t)eax;
        int32_t quot = (int32_t)(dividend / (int32_t)ebx);
        int32_t rem = (int32_t)(dividend % (int32_t)ebx);
        eax = quot;
        edx = rem;
    }                                       // idiv ebx
    *(word *)&g_memByte[336550] = ax;       // mov dseg_114C28, ax
    {
        word src = *(word *)&g_memByte[336550];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[336550] = src;
    }                                       // add dseg_114C28, 1
    bx = 118;                               // mov bx, 76h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 317588;
        dword res = dstSigned + srcSigned;
        D0 = res;
    }                                       // add D0, offset diyFileBufferCopy
    eax = D0;                               // mov eax, D0
    *(dword *)&g_memByte[336546] = eax;     // mov dseg_114C24, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_43F3E()
{
    cseg_43EC2();                           // call cseg_43EC2
    ax = *(word *)&g_memByte[336550];       // mov ax, dseg_114C28
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    eax = *(dword *)&g_memByte[336546];     // mov eax, dseg_114C24
    A3 = eax;                               // mov A3, eax
    A2 = eax;                               // mov A2, eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 118;
        dword res = dstSigned - srcSigned;
        A2 = res;
    }                                       // sub A2, 76h
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 1
    if (flags.zero)
        goto cseg_44214;                    // jz cseg_44214

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 355, 2);    // mov ax, [esi+163h]
    *(word *)&g_memByte[336552] = ax;       // mov dseg_114C2A, ax

cseg_43F8B:;
    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 81h
    if (flags.zero)
        goto cseg_44010;                    // jz short cseg_44010

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 257;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 101h
    if (flags.zero)
        goto cseg_44010;                    // jz short cseg_44010

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 65;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 41h
    if (flags.zero)
        goto cseg_43FBF;                    // jz short cseg_43FBF

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 513;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 201h
    if (flags.zero)
        goto cseg_43FBF;                    // jz short cseg_43FBF

    return;                                 // jmp cseg_44213

cseg_43FBF:;
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 355, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 355, 2, src);
    }                                       // sub word ptr [esi+163h], 1
    if (flags.sign)
        goto cseg_43FF8;                    // js short cseg_43FF8

    ax = (word)readMemory(esi + 355, 2);    // mov ax, [esi+163h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 361, 2);    // mov ax, [esi+169h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_44047;                    // jnb short cseg_44047

cseg_43FF8:;
    ax = *(word *)&g_memByte[336552];       // mov ax, dseg_114C2A
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 355, 2, ax);          // mov [esi+163h], ax
    return;                                 // jmp cseg_44213

cseg_44010:;
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 355, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 355, 2, src);
    }                                       // add word ptr [esi+163h], 1
    ax = (word)readMemory(esi + 355, 2);    // mov ax, [esi+163h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_43FF8;                    // jz short cseg_43FF8

cseg_44047:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 355, 2);    // mov ax, [esi+163h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[336552];       // mov ax, dseg_114C2A
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        return;                             // jz cseg_44213

    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 355, 2);    // mov ax, [esi+163h]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    cseg_445A7();                           // call cseg_445A7
    if (flags.zero)
        goto cseg_43F8B;                    // jz cseg_43F8B

    ax = D1;                                // mov ax, word ptr D1
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 349, 2, ax);          // mov [esi+15Dh], ax
    writeMemory(esi + 361, 2, ax);          // mov [esi+169h], ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 363, 2, ax);          // mov [esi+16Bh], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_44160;                    // jnz short cseg_44160

    ax = (word)readMemory(esi + 361, 2);    // mov ax, [esi+169h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 363, 2);    // mov ax, [esi+16Bh]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 355, 2);    // mov ax, [esi+163h]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    cseg_4477D();                           // call cseg_4477D
    ax = D1;                                // mov ax, word ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 349, 2, ax);          // mov [esi+15Dh], ax
    writeMemory(esi + 361, 2, ax);          // mov [esi+169h], ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 363, 2, ax);          // mov [esi+16Bh], ax

cseg_44160:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 355, 2);    // mov ax, [esi+163h]
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 353, 2, ax);          // mov [esi+161h], ax
    cseg_44459();                           // call cseg_44459
    push(D7);                               // push D7
    DesignDIYTournamentOnDraw();            // call DesignDIYTournamentOnDraw
    pop(D7);                                // pop D7
    eax = A2;                               // mov eax, A2
    A0 = eax;                               // mov A0, eax
    *(word *)&D1 = 2;                       // mov word ptr D1, 2
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 6
    if (flags.zero)
        goto cseg_441C5;                    // jz short cseg_441C5

    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 355, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+163h], 1
    if (!flags.zero)
        goto cseg_441C5;                    // jnz short cseg_441C5

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1

cseg_441C5:;
    cseg_443C7();                           // call cseg_443C7
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CallDrawMultipleItems();                // call CallDrawMultipleItems

cseg_44213:;
    return;                                 // retn

cseg_44214:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&g_memByte[336552] = ax;       // mov dseg_114C2A, ax

cseg_44224:;
    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 129;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 81h
    if (flags.zero)
        goto cseg_4427B;                    // jz short cseg_4427B

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 257;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 101h
    if (flags.zero)
        goto cseg_4427B;                    // jz short cseg_4427B

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 65;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 41h
    if (flags.zero)
        goto cseg_44251;                    // jz short cseg_44251

    {
        word src = *(word *)&g_memByte[252400];
        int16_t dstSigned = src;
        int16_t srcSigned = 513;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp controlMask, 201h
    if (flags.zero)
        goto cseg_44251;                    // jz short cseg_44251

    return;                                 // jmp short cseg_44213

cseg_44251:;
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 49, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 49, 2, src);
    }                                       // sub word ptr [esi+31h], 1
    {
        word src = (word)readMemory(esi + 49, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+31h], 1
    if (!flags.zero)
        goto cseg_44295;                    // jnz short cseg_44295

cseg_44269:;
    ax = *(word *)&g_memByte[336552];       // mov ax, dseg_114C2A
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 49, 2, ax);           // mov [esi+31h], ax
    return;                                 // jmp short cseg_44213

cseg_4427B:;
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 49, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 49, 2, src);
    }                                       // add word ptr [esi+31h], 1
    {
        word src = (word)readMemory(esi + 49, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 65;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+31h], 41h
    if (flags.carry)
        goto cseg_44295;                    // jb short cseg_44295

    goto cseg_44269;                        // jmp short cseg_44269

cseg_44295:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[336552];       // mov ax, dseg_114C2A
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        return;                             // jz cseg_44213

    ax = (word)readMemory(esi + 355, 2);    // mov ax, [esi+163h]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    cseg_445A7();                           // call cseg_445A7
    if (flags.zero)
        goto cseg_44224;                    // jz cseg_44224

    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    writeMemory(esi + 353, 2, ax);          // mov [esi+161h], ax
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 349, 2, ax);          // mov [esi+15Dh], ax
    writeMemory(esi + 361, 2, ax);          // mov [esi+169h], ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 363, 2, ax);          // mov [esi+16Bh], ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    cseg_44459();                           // call cseg_44459
    DesignDIYTournamentOnDraw();            // call DesignDIYTournamentOnDraw
    push(A3);                               // push A3
    DesignDIYTournamentOnDraw();            // call DesignDIYTournamentOnDraw
    pop(A3);                                // pop A3
    eax = A3;                               // mov eax, A3
    A0 = eax;                               // mov A0, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    cseg_443C7();                           // call cseg_443C7
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CallDrawMultipleItems();                // call CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void cseg_443C7()
{
    eax = A0;                               // mov eax, A0
    D0 = eax;                               // mov D0, eax
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 317588;
        dword res = dstSigned - srcSigned;
        D0 = res;
    }                                       // sub D0, offset diyFileBufferCopy
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 118;                               // mov bx, 76h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    bx = 12;                                // mov bx, 0Ch
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 17;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 11h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    ax = D1;                                // mov ax, word ptr D1
    bx = 12;                                // mov bx, 0Ch
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    SWOS::DrawMenu();                       // call DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_44459()
{
    A0 = 317588;                            // mov A0, offset diyFileBufferCopy
    *(word *)&D0 = 1;                       // mov word ptr D0, 1

cseg_4446C:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 355, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+163h], 1
    if (flags.zero)
        goto cseg_44495;                    // jz short cseg_44495

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 118;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 76h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 6
    if (!flags.zero)
        goto cseg_4446C;                    // jnz short cseg_4446C

cseg_44495:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[317669] = ax;       // mov dseg_10EADB, ax
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYTournamentOnSelect20()
{
    cseg_43EC2();                           // call cseg_43EC2
    ax = *(word *)&g_memByte[336550];       // mov ax, dseg_114C28
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    eax = *(dword *)&g_memByte[336546];     // mov eax, dseg_114C24
    A3 = eax;                               // mov A3, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 361, 2);    // mov ax, [esi+169h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 363, 2);    // mov ax, [esi+16Bh]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 355, 2);    // mov ax, [esi+163h]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    cseg_4477D();                           // call cseg_4477D
    ax = D1;                                // mov ax, word ptr D1
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 349, 2, ax);          // mov [esi+15Dh], ax
    writeMemory(esi + 361, 2, ax);          // mov [esi+169h], ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 363, 2, ax);          // mov [esi+16Bh], ax
    push(A3);                               // push A3
    DesignDIYTournamentOnDraw();            // call DesignDIYTournamentOnDraw
    pop(A3);                                // pop A3
    eax = A3;                               // mov eax, A3
    A0 = eax;                               // mov A0, eax
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    cseg_443C7();                           // call cseg_443C7
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CallDrawMultipleItems();                // call CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void cseg_445A7()
{
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 58;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 3Ah
    if (flags.zero)
        goto cseg_44770;                    // jz cseg_44770

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 62;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 3Eh
    if (flags.zero)
        goto cseg_44770;                    // jz cseg_44770

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 1
    if (!flags.zero)
        goto cseg_445EE;                    // jnz short cseg_445EE

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto cseg_445EE;                    // jnz short cseg_445EE

    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    goto cseg_4475F;                        // jmp cseg_4475F

cseg_445EE:;
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry || flags.zero)
        goto cseg_44770;                    // jbe cseg_44770

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D3 = eax;                               // mov D3, eax
    {
        word res = *(word *)&D3 & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D3, 1
    if (!flags.zero)
        goto cseg_44691;                    // jnz short cseg_44691

    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_44691;                    // jnz short cseg_44691

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 6
    if (!flags.zero)
        goto cseg_44675;                    // jnz short cseg_44675

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 2
    if (flags.zero)
        goto cseg_4475F;                    // jz cseg_4475F

    goto cseg_44691;                        // jmp short cseg_44691

cseg_44675:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 5
    if (!flags.zero)
        goto cseg_4475F;                    // jnz cseg_4475F

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 48;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 30h
    if (flags.carry || flags.zero)
        goto cseg_4475F;                    // jbe cseg_4475F

cseg_44691:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 9;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 9
    if (flags.zero)
        goto cseg_44770;                    // jz cseg_44770

    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry && !flags.zero)
        goto cseg_44770;                    // ja cseg_44770

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 6
    if (!flags.zero)
        goto cseg_446D2;                    // jnz short cseg_446D2

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 2
    if (flags.zero)
        goto cseg_44770;                    // jz cseg_44770

cseg_446D2:;
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        goto cseg_44770;                    // jz cseg_44770

    eax = D3;                               // mov eax, D3
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D1);
        word rem = (word)(dividend % *(word *)&D1);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D1
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_44691;                    // jnz cseg_44691

    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 24;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 18h
    if (!flags.carry && !flags.zero)
        goto cseg_44691;                    // ja cseg_44691

    *(word *)&D2 = ax;                      // mov word ptr D2, ax

cseg_4475F:;
    *(word *)&D3 = 1;                       // mov word ptr D3, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    return;                                 // retn

cseg_44770:;
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4477D()
{
    ax = D1;                                // mov ax, word ptr D1
    tmp = ax * *(word *)&D2;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    *(word *)((byte *)&D3 + 2) = dx;        // mov word ptr D3+2, dx
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_447D4;                    // jnz short cseg_447D4

    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D3 = eax;                               // mov D3, eax
    goto cseg_447DC;                        // jmp short cseg_447DC

cseg_447D4:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1

cseg_447DC:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 9;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 9
    if (flags.zero)
        goto cseg_448A8;                    // jz cseg_448A8

    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry && !flags.zero)
        goto cseg_448A8;                    // ja cseg_448A8

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 6
    if (!flags.zero)
        goto cseg_44815;                    // jnz short cseg_44815

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 2
    if (flags.zero)
        goto cseg_448A8;                    // jz cseg_448A8

cseg_44815:;
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        goto cseg_448A8;                    // jz cseg_448A8

    eax = D3;                               // mov eax, D3
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D1);
        word rem = (word)(dividend % *(word *)&D1);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D1
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_447D4;                    // jnz cseg_447D4

    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 24;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 18h
    if (!flags.carry && !flags.zero)
        goto cseg_447D4;                    // ja cseg_447D4

    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    return;                                 // retn

cseg_448A8:;
    {
        word res = *(word *)&D3 & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D3, 1
    if (!flags.zero)
        goto cseg_448D8;                    // jnz short cseg_448D8

    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_448F6;                    // jz short cseg_448F6

cseg_448D8:;
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    goto cseg_447DC;                        // jmp cseg_447DC

    return;                                 // retn

cseg_448F6:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 6
    if (!flags.zero)
        goto cseg_4490C;                    // jnz short cseg_4490C

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 2
    if (flags.zero)
        goto cseg_44920;                    // jz short cseg_44920

    goto cseg_448D8;                        // jmp short cseg_448D8

cseg_4490C:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 5
    if (!flags.zero)
        goto cseg_44920;                    // jnz short cseg_44920

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 48;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 30h
    if (!flags.carry && !flags.zero)
        goto cseg_448D8;                    // ja short cseg_448D8

cseg_44920:;
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void ShowDesignDIYTournamentMenu()
{
    SaveDIYTournament();                    // call SaveDIYTournament
    cseg_254F8();                           // call cseg_254F8
    *(word *)&g_memByte[336542] = 0;        // mov diyTournamentLookOnly, 0
    *(word *)&g_memByte[336544] = 0;        // mov diyTournamentSelectTeams, 0
    A6 = 496525;                            // mov A6, offset designDiyTournamentMenu
    SWOS::ShowMenu();                       // call ShowMenu
}

// =============== S U B R O U T I N E =======================================
//
void ShowTournamentInfo()
{
    *(word *)&g_memByte[336542] = 1;        // mov diyTournamentLookOnly, 1
    *(word *)&g_memByte[336544] = 0;        // mov diyTournamentSelectTeams, 0
    A6 = 496525;                            // mov A6, offset designDiyTournamentMenu
    SWOS::ShowMenu();                       // call ShowMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_44C68()
{
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 0Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[317663];       // mov ax, dseg_10EAD5
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SWOS::Int2Ascii();                      // call Int2Ascii
    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 0Dh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[317665];       // mov ax, dseg_10EAD7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SWOS::Int2Ascii();                      // call Int2Ascii
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupInit()
{
    ax = *(word *)&g_memByte[501323];       // mov ax, diyCupSelectTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_44CF0;                    // jz short cseg_44CF0

    cseg_4572C();                           // call cseg_4572C

cseg_44CF0:;

    DesignDIYCupReinit();
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupReinit()
{
    {
        word src = *(word *)&g_memByte[131708];
        int16_t dstSigned = src;
        int16_t srcSigned = 65534;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_pitchType, SEASONAL
    if (flags.zero)
        goto cseg_44DC3;                    // jz cseg_44DC3

    *(word *)&g_memByte[318694] = 0;        // mov diyPitchTypeOrSeason_2, 0
    ax = *(word *)&g_memByte[131708];       // mov ax, g_pitchType
    *(word *)&g_memByte[318696] = ax;       // mov diyLeaguePitchType, ax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1
    push(D0);                               // push D0
    D0 = 4;                                 // mov D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1

cseg_44DC3:;
    cseg_451B5();                           // call cseg_451B5
    cseg_44F40();                           // call cseg_44F40
    ax = *(word *)&g_memByte[501321];       // mov ax, diyCupLookOnly
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_44E63;                    // jnz cseg_44E63

    ax = *(word *)&g_memByte[501323];       // mov ax, diyCupSelectTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_44E36;                    // jnz short cseg_44E36

    *(word *)&D0 = 48;                      // mov word ptr D0, 30h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 49;                      // mov word ptr D0, 31h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 51;                      // mov word ptr D0, 33h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    return;                                 // retn

cseg_44E36:;
    cseg_44FE8();                           // call cseg_44FE8
    *(word *)&D0 = 49;                      // mov word ptr D0, 31h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 48;                      // mov word ptr D0, 30h
    { SWOS::SetCurrentEntry(); return; }    // jmp SetCurrentEntry

cseg_44E63:;
    cseg_44FE8();                           // call cseg_44FE8
    *(word *)&D0 = 48;                      // mov word ptr D0, 30h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 49;                      // mov word ptr D0, 31h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 51;                      // mov word ptr D0, 33h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    ax = *(word *)&g_memByte[318730];       // mov ax, dseg_10EF00
    bx = 5;                                 // mov bx, 5
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 18;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 12h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    *(word *)&D1 = 4;                       // mov word ptr D1, 4

cseg_44EF2:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    *(word *)&D0 |= 11;                     // or word ptr D0, 0Bh
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 38h
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_44EF2;                    // jns short cseg_44EF2

    *(word *)&D0 = 50;                      // mov word ptr D0, 32h
    SWOS::SetCurrentEntry();                // jmp SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void cseg_44F40()
{
    al = g_memByte[318698];                 // mov al, diyLeagueStartMonth
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 96
    if (flags.carry)
        goto cseg_44F5A;                    // jb short cseg_44F5A

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 96

cseg_44F5A:;
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 8;                                 // mov bx, 8
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[501317] = ax;       // mov dseg_1773C8, ax
    al = g_memByte[318699];                 // mov al, diyLeagueEndMonth
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 60h
    if (flags.carry)
        goto cseg_44FAB;                    // jb short cseg_44FAB

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 60h

cseg_44FAB:;
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 8;                                 // mov bx, 8
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[501319] = ax;       // mov dseg_1773CA, ax
    cseg_4549A();                           // call cseg_4549A
}

// =============== S U B R O U T I N E =======================================
//
void cseg_44FE8()
{
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D1 = 45;                      // mov word ptr D1, 2Dh

cseg_4500C:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 28, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+1Ch], 2
    if (!flags.zero)
        goto cseg_4506F;                    // jnz short cseg_4506F

    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Fh
    if (flags.zero)
        goto cseg_4506F;                    // jz short cseg_4506F

    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+1Eh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+1Eh], ax
    writeMemory(esi + 6, 2, 1);             // mov word ptr [esi+6], 1

cseg_4506F:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 38h
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_4500C;                    // jns short cseg_4500C

    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOK()
{
    *(word *)&g_memByte[501323] = 1;        // mov diyCupSelectTeams, 1
    A6 = 499229;                            // mov A6, offset designDiyCupMenu
    SWOS::ActivateMenu();                   // jmp ActivateMenu
}

// =============== S U B R O U T I N E =======================================
//
void jmp_SetExitMenuFlag_4()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOnSelect2()
{
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 25;                      // mov word ptr D0, 25
    SWOS::InputText();                      // jmp InputText
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOnSelect48()
{
    ax = *(word *)&g_memByte[318692];       // mov ax, diyLeagueNumTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 318647;                            // mov A0, offset diyLeagueName
    A1 = 15978;                             // mov A1, offset aPlayCup
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    *(word *)&D3 = 1;                       // mov word ptr D3, 1
    *(word *)&D4 = 1;                       // mov word ptr D4, 1
    GoGetTeamsForPlay();                    // call GoGetTeamsForPlay
    ax = *(word *)&g_memByte[330694];       // mov ax, chooseTeamsResult
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        { jmp_SetExitMenuFlag_4(); return; } // jz short jmp_SetExitMenuFlag_4

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CareerInitVars();                       // call CareerInitVars
    A0 = 319232;                            // mov A0, offset dseg_10F0F6
    ax = *(word *)&g_memByte[318692];       // mov ax, diyLeagueNumTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_87D60();                           // call cseg_87D60
    cseg_268C6();                           // call cseg_268C6
    cseg_28139();                           // call cseg_28139
    InitTeams();                            // call InitTeams
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_45B51();                           // call cseg_45B51
    cseg_28076();                           // call cseg_28076
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void cseg_451B5()
{
    ax = *(word *)&g_memByte[318694];       // mov ax, diyPitchTypeOrSeason_2
    *(word *)&g_memByte[501315] = ax;       // mov dseg_1773C6, ax
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 2
    if (flags.zero)
        goto cseg_451DF;                    // jz short cseg_451DF

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 3
    if (flags.zero)
        goto cseg_451DF;                    // jz short cseg_451DF

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (!flags.zero)
        goto cseg_451E8;                    // jnz short cseg_451E8

cseg_451DF:;
    *(word *)&g_memByte[501315] = 1;        // mov dseg_1773C6, 1

cseg_451E8:;
    ax = *(word *)&g_memByte[501315];       // mov ax, dseg_1773C6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_45240;                    // jnz short cseg_45240

    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 60, 2, 1);            // mov word ptr [esi+3Ch], 1
    writeMemory(esi + 116, 2, 1);           // mov word ptr [esi+74h], 1
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    return;                                 // retn

cseg_45240:;
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    writeMemory(esi + 60, 2, 0);            // mov word ptr [esi+3Ch], 0
    writeMemory(esi + 116, 2, 0);           // mov word ptr [esi+74h], 0
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOnSelect3()
{
    {
        word src = *(word *)&g_memByte[318694];
        src ^= 1;
        *(word *)&g_memByte[318694] = src;
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor diyPitchTypeOrSeason_2, 1
    cseg_451B5();                           // call cseg_451B5
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CallDrawMultipleItems();                // call CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOnSelect4()
{
    {
        word src = *(word *)&g_memByte[318696];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[318696] = src;
    }                                       // add diyLeaguePitchType, 1
    {
        word src = *(word *)&g_memByte[318696];
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp diyLeaguePitchType, 7
    if (!flags.zero)
        goto cseg_452FF;                    // jnz short cseg_452FF

    *(word *)&g_memByte[318696] = 65535;    // mov diyLeaguePitchType, 0FFFFh

cseg_452FF:;
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOnSelect5()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 55, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 8;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 55, 1, src);
    }                                       // add byte ptr [esi+37h], 8
    al = (byte)readMemory(esi + 55, 1);     // mov al, [esi+37h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 60h
    if (!flags.zero)
        goto cseg_45340;                    // jnz short cseg_45340

    writeMemory(esi + 55, 1, 0);            // mov byte ptr [esi+37h], 0
    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0

cseg_45340:;
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 8;                                 // mov bx, 8
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[501317] = ax;       // mov dseg_1773C8, ax
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOnSelect7()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 56, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 8;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 56, 1, src);
    }                                       // add byte ptr [esi+38h], 8
    al = (byte)readMemory(esi + 56, 1);     // mov al, [esi+38h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 60h
    if (!flags.zero)
        goto cseg_453B8;                    // jnz short cseg_453B8

    writeMemory(esi + 56, 1, 0);            // mov byte ptr [esi+38h], 0
    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0

cseg_453B8:;
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 8;                                 // mov bx, 8
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[501319] = ax;       // mov dseg_1773CA, ax
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOnSelect9()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 93, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 93, 2, src);
    }                                       // add word ptr [esi+5Dh], 1
    {
        word src = (word)readMemory(esi + 93, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+5Dh], 3
    if (flags.carry)
        goto cseg_45422;                    // jb short cseg_45422

    writeMemory(esi + 93, 2, 0);            // mov word ptr [esi+5Dh], 0

cseg_45422:;
    DesignDIYCupOnDraw();                   // call DesignDIYCupOnDraw
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOnSelect11()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 89, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 89, 2, src);
    }                                       // add word ptr [esi+59h], 1
    {
        word src = (word)readMemory(esi + 89, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+59h], 7
    if (flags.carry)
        goto cseg_4545A;                    // jb short cseg_4545A

    writeMemory(esi + 89, 2, 1);            // mov word ptr [esi+59h], 1

cseg_4545A:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    cl = D1;                                // mov cl, byte ptr D1
    {
        byte shiftCount = cl & 0x1f;
        if (shiftCount) {
            word res = *(word *)&D0 << shiftCount;
            if (shiftCount <= 16)
                flags.carry = ((word)*(word *)&D0 >> (16 - shiftCount)) & 1;
            else
                flags.carry = 0;
            *(word *)&D0 = res;
            flags.sign = (res & 0x8000) != 0;
            flags.zero = res == 0 != 0;
        }
    }                                       // shl word ptr D0, cl
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 49, 2, ax);           // mov [esi+31h], ax
    DesignDIYCupOnDraw();                   // call DesignDIYCupOnDraw
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4549A()
{
    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 0Dh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[318738];       // mov ax, diyMinSubstitutes
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SWOS::Int2Ascii();                      // call Int2Ascii
    push(D0);                               // push D0
    D0 = 15;                                // mov D0, 0Fh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[318740];       // mov ax, diyPointsForAWin
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SWOS::Int2Ascii();                      // call Int2Ascii
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOnSelect13()
{
    ax = *(word *)&g_memByte[318740];       // mov ax, diyPointsForAWin
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_4554A

    {
        word src = *(word *)&g_memByte[318738];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[318738] = src;
    }                                       // add diyMinSubstitutes, 1
    ax = *(word *)&g_memByte[318738];       // mov ax, diyMinSubstitutes
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_45540;                    // jnb short cseg_45540

    *(word *)&g_memByte[318738] = 1;        // mov diyMinSubstitutes, 1

cseg_45540:;
    cseg_4549A();                           // call cseg_4549A
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOnSelect15()
{
    {
        word src = *(word *)&g_memByte[318740];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[318740] = src;
    }                                       // add diyPointsForAWin, 1
    {
        word src = *(word *)&g_memByte[318740];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp diyPointsForAWin, 5
    if (flags.carry || flags.zero)
        goto cseg_4556F;                    // jbe short cseg_4556F

    *(word *)&g_memByte[318740] = 0;        // mov diyPointsForAWin, 0
    *(word *)&g_memByte[318738] = 0;        // mov diyMinSubstitutes, 0

cseg_4556F:;
    {
        word src = *(word *)&g_memByte[318740];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp diyPointsForAWin, 1
    if (!flags.zero)
        goto cseg_45582;                    // jnz short cseg_45582

    *(word *)&g_memByte[318738] = 1;        // mov diyMinSubstitutes, 1

cseg_45582:;
    cseg_4549A();                           // call cseg_4549A
    CallDrawMenuItem();                     // call CallDrawMenuItem
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 0Dh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOnSelect20()
{
    cseg_456C9();                           // call cseg_456C9
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    {
        word src = (word)readMemory(esi + ebx + 101, 2);
        src ^= 3;
        writeMemory(esi + ebx + 101, 2, src);
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor word ptr [esi+ebx+65h], 3
    DesignDIYCupOnDraw();                   // call DesignDIYCupOnDraw
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CallDrawMultipleItems();                // jmp CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOnSelect21()
{
    cseg_456C9();                           // call cseg_456C9
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    {
        word src = (word)readMemory(esi + ebx + 113, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + ebx + 113, 2, src);
    }                                       // add word ptr [esi+ebx+71h], 1
    {
        word src = (word)readMemory(esi + ebx + 113, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+ebx+71h], 3
    if (!flags.zero)
        goto cseg_45674;                    // jnz short cseg_45674

    writeMemory(esi + ebx + 113, 2, 0);     // mov word ptr [esi+ebx+71h], 0

cseg_45674:;
    DesignDIYCupOnDraw();                   // call DesignDIYCupOnDraw
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOnSelect22()
{
    cseg_456C9();                           // call cseg_456C9
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    {
        word src = (word)readMemory(esi + ebx + 125, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + ebx + 125, 2, src);
    }                                       // add word ptr [esi+ebx+7Dh], 1
    {
        word src = (word)readMemory(esi + ebx + 125, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+ebx+7Dh], 3
    if (!flags.zero)
        goto cseg_456BF;                    // jnz short cseg_456BF

    writeMemory(esi + ebx + 125, 2, 0);     // mov word ptr [esi+ebx+7Dh], 0

cseg_456BF:;
    DesignDIYCupOnDraw();                   // call DesignDIYCupOnDraw
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void cseg_456C9()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 18;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 12h
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 5;                                 // mov bx, 5
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 << 1;
        flags.carry = ((word)*(word *)&D1 >> 15) & 1;
        *(word *)&D1 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D1, 1
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4572C()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 51;                                // mov D0, 33h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[318692];       // mov ax, diyLeagueNumTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 16324;                             // mov A0, offset aSelect0Teams
    PrintFormatted();                       // call PrintFormatted
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYCupOnDraw()
{
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 93, 2);     // mov ax, [esi+5Dh]
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 0Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 12h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)&D5 = 0;                       // mov word ptr D5, 0

cseg_458C8:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_45A61;                    // jnb cseg_45A61

    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 1
    ax = *(word *)&g_memByte[318732];       // mov ax, dseg_10EF02
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[318734];       // mov ax, dseg_10EF04
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    cseg_28049();                           // call cseg_28049
    eax = A0;                               // mov eax, A0
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    ax = D6;                                // mov ax, word ptr D6
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    {
        word src = (word)readMemory(esi + ebx + 101, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+ebx+65h], 2
    if (!flags.zero)
        goto cseg_45984;                    // jnz short cseg_45984

    *(word *)&D5 = 1;                       // mov word ptr D5, 1

cseg_45984:;
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    ax = (word)readMemory(esi + ebx + 101, 2); // mov ax, [esi+ebx+65h]
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + ebx + 113, 2); // mov ax, [esi+ebx+71h]
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + ebx + 125, 2); // mov ax, [esi+ebx+7Dh]
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // add A4, 38h
    goto cseg_45AC0;                        // jmp short cseg_45AC0

cseg_45A61:;
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 38h

cseg_45AC0:;
    {
        word res = *(word *)&D6 >> 1;
        *(word *)&D6 = res;
    }                                       // shr word ptr D6, 1
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 2
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 12;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 0Ch
    if (!flags.zero)
        goto cseg_458C8;                    // jnz cseg_458C8

    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short cseg_45B02

    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
}

// =============== S U B R O U T I N E =======================================
//
void ShowDesignDIYCupMenu()
{
    cseg_27FFF();                           // call cseg_27FFF
    InitDIYCup();                           // call InitDIYCup
    *(word *)&g_memByte[501321] = 0;        // mov diyCupLookOnly, 0
    *(word *)&g_memByte[501323] = 0;        // mov diyCupSelectTeams, 0
    A6 = 499229;                            // mov A6, offset designDiyCupMenu
    SWOS::ShowMenu();                       // call ShowMenu
}

// =============== S U B R O U T I N E =======================================
//
void ShowCupInfo()
{
    *(word *)&g_memByte[501321] = 1;        // mov diyCupLookOnly, 1
    *(word *)&g_memByte[501323] = 0;        // mov diyCupSelectTeams, 0
    A6 = 499229;                            // mov A6, offset designDiyCupMenu
    SWOS::ShowMenu();                       // call ShowMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_45B51()
{
    *(word *)&g_memByte[378422] = 1;        // mov writeOnlyVar01, 1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[501289] = ax;       // mov dseg_1773AC, ax
    *(word *)&g_memByte[501285] = ax;       // mov dseg_1773A8, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[501287] = ax;       // mov dseg_1773AA, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[501291] = ax;       // mov dseg_1773AE, ax
    ax = *(word *)&g_memByte[317174];       // mov ax, inCareerSeasonUpdate
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_45BA5;                    // jz short cseg_45BA5

cseg_45B95:;
    SWOS::MenuCheckControls();              // call MenuCheckControls
    ax = *(word *)&g_memByte[252384];       // mov ax, fire
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_45B95;                    // jnz short cseg_45B95

cseg_45BA5:;
    A6 = 501325;                            // mov A6, offset DIY_cupMenu
    SWOS::ShowMenu();                       // call ShowMenu
    *(word *)&g_memByte[378422] = 0;        // mov writeOnlyVar01, 0
}

// =============== S U B R O U T I N E =======================================
//
void DIYCupInit()
{
    *(word *)&g_memByte[501283] = 0;        // mov dseg_1773A6, 0
    ax = *(word *)&g_memByte[501289];       // mov ax, dseg_1773AC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_45BF8;                    // jz short cseg_45BF8

    *(word *)&g_memByte[318716] = 0;        // mov dseg_10EEF2, 0
    ax = *(word *)&g_memByte[318726];       // mov ax, dseg_10EEFC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_45BF8;                    // jz short cseg_45BF8

    *(word *)&g_memByte[318716] = 6;        // mov dseg_10EEF2, 6
    *(word *)&g_memByte[501285] = 0;        // mov dseg_1773A8, 0

cseg_45BF8:;
    ax = *(word *)&g_memByte[318728];       // mov ax, dseg_10EEFE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_45C20;                    // jz short cseg_45C20

    ax = *(word *)&g_memByte[318714];       // mov ax, dseg_10EEF0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_45C20;                    // jnz short cseg_45C20

    *(word *)&g_memByte[501285] = 0;        // mov dseg_1773A8, 0
    *(word *)&g_memByte[318716] = 6;        // mov dseg_10EEF2, 6

cseg_45C20:;
    ax = *(word *)&g_memByte[501287];       // mov ax, dseg_1773AA
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_45C42;                    // jz short cseg_45C42

    *(word *)&g_memByte[501285] = 0;        // mov dseg_1773A8, 0
    *(word *)&D0 = 10;                      // mov word ptr D0, 0Ah
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

cseg_45C42:;
    *(word *)&g_memByte[318645] = 1;        // mov dseg_10EEAB, 1
    *(word *)&g_memByte[501301] = 0;        // mov dseg_1773B8, 0
    ax = *(word *)&g_memByte[317174];       // mov ax, inCareerSeasonUpdate
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_45CAA;                    // jz short cseg_45CAA

    *(word *)&g_memByte[501285] = 0;        // mov dseg_1773A8, 0
    *(word *)&D0 = 66;                      // mov word ptr D0, 42h
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 10;                      // mov word ptr D0, 0Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1

cseg_45CAA:;

    DIYCupFinish();
}

// =============== S U B R O U T I N E =======================================
//
void DIYCupFinish()
{
    {
        word src = *(word *)&g_memByte[318716];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10EEF2, 6
    if (flags.zero)
        goto cseg_45CDC;                    // jz short cseg_45CDC

    ax = *(word *)&g_memByte[501285];       // mov ax, dseg_1773A8
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_45CDC;                    // jz short cseg_45CDC

    ax = *(word *)&g_memByte[501285];       // mov ax, dseg_1773A8
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_45CDC;                    // jz short cseg_45CDC

    if (flags.sign)
        goto cseg_45CD5;                    // js short cseg_45CD5

    cseg_462F7();                           // call cseg_462F7
    goto cseg_45CE1;                        // jmp short cseg_45CE1

cseg_45CD5:;
    cseg_4766F();                           // call cseg_4766F
    goto cseg_45CE1;                        // jmp short cseg_45CE1

cseg_45CDC:;
    cseg_46515();                           // call cseg_46515

cseg_45CE1:;
    cseg_45D00();                           // call cseg_45D00
    cseg_46E9B();                           // call cseg_46E9B
    cseg_46589();                           // call cseg_46589
    cseg_463E6();                           // call cseg_463E6
    cseg_45D92();                           // call cseg_45D92
}

// =============== S U B R O U T I N E =======================================
//
void jmp_SetExitMenuFlag_5()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void cseg_45D00()
{
    ax = *(word *)&g_memByte[318724];       // mov ax, dseg_10EEFA
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[501301];       // mov ax, dseg_1773B8
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_45D1E;                    // jz short cseg_45D1E

    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1

cseg_45D1E:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 6
    if (!flags.carry && !flags.zero)
        goto cseg_45D5D;                    // ja short cseg_45D5D

    *(word *)&D0 = 16;                      // mov word ptr D0, 10h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 17;                      // mov word ptr D0, 11h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    return;                                 // retn

cseg_45D5D:;
    *(word *)&D0 = 16;                      // mov word ptr D0, 10h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 17;                      // mov word ptr D0, 11h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_45D92()
{
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4
    A0 = eax;                               // mov A0, eax
    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 32);                // mov byte ptr [esi], 20h
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_45E81;                    // jz short cseg_45E81

    A0 = 317588;                            // mov A0, offset diyFileBufferCopy
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        word res = *(word *)&D3 << 1;
        flags.carry = ((word)*(word *)&D3 >> 15) & 1;
        *(word *)&D3 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D3, 1
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 345, 2);    // mov ax, [esi+159h]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    cseg_284AB();                           // call cseg_284AB
    StringCopy();                           // call StringCopy
    goto cseg_45F1B;                        // jmp cseg_45F1B

cseg_45E81:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[501301];       // mov ax, dseg_1773B8
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_45EF1;                    // jz short cseg_45EF1

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 91, 2);     // mov ax, [esi+5Bh]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    cseg_28049();                           // call cseg_28049
    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 32);                // mov byte ptr [esi], 20h
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    A0 = 16227;                             // mov A0, offset aDraw
    StringCopy();                           // call StringCopy
    goto cseg_46008;                        // jmp cseg_46008

cseg_45EF1:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 91, 2);     // mov ax, [esi+5Bh]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    cseg_28049();                           // call cseg_28049
    StringCopy();                           // call StringCopy

cseg_45F1B:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_45FC0;                    // jz cseg_45FC0

    A0 = 16239;                             // mov A0, offset aReplay
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 3
    if (flags.carry || flags.zero)
        goto cseg_45F64;                    // jbe short cseg_45F64

    {
        word src = (word)readMemory(esi + 81, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+51h], 1
    if (flags.zero)
        goto cseg_45FAA;                    // jz short cseg_45FAA

    A0 = 16251;                             // mov A0, offset aReplays
    goto cseg_45FAA;                        // jmp short cseg_45FAA

cseg_45F64:;
    A0 = 332056;                            // mov A0, offset dseg_1139FA
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 81, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+51h], 1
    if (flags.zero)
        goto cseg_45F85;                    // jz short cseg_45F85

    A0 = 332068;                            // mov A0, offset dseg_113A06

cseg_45F85:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax

cseg_45FAA:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 32);                // mov byte ptr [esi], 20h
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    StringCopy();                           // call StringCopy
    goto cseg_46008;                        // jmp short cseg_46008

cseg_45FC0:;
    A0 = 17793;                             // mov A0, offset a2ndLeg
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 329, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+149h], 1
    if (flags.zero)
        goto cseg_45FF4;                    // jz short cseg_45FF4

    {
        word src = (word)readMemory(esi + 331, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+14Bh], 2
    if (!flags.zero)
        goto cseg_46008;                    // jnz short cseg_46008

    A0 = 17785;                             // mov A0, offset a1stLeg

cseg_45FF4:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 32);                // mov byte ptr [esi], 20h
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    StringCopy();                           // call StringCopy

cseg_46008:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
}

// =============== S U B R O U T I N E =======================================
//
void DIYCupOnSelect10()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_46074;                    // jz short cseg_46074

    {
        word src = (word)readMemory(esi + 71, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+47h], 2
    if (!flags.zero)
        goto cseg_46054;                    // jnz short cseg_46054

    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+55h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_46054;                    // jz short cseg_46054

    ax = *(word *)&g_memByte[501287];       // mov ax, dseg_1773AA
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4606F;                    // jnz short cseg_4606F

    goto cseg_4606F;                        // jmp short cseg_4606F

cseg_46054:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4606F;                    // jz short cseg_4606F

    writeMemory(esi + 71, 2, 65535);        // mov word ptr [esi+47h], 0FFFFh

cseg_4606F:;
    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

cseg_46074:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+55h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_46054;                    // jz short cseg_46054

    writeMemory(esi + 2, 2, 2);             // mov word ptr [esi+2], 2
    ax = *(word *)&g_memByte[501287];       // mov ax, dseg_1773AA
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void DIYCupOnSelect9()
{
    cseg_33E38();                           // jmp cseg_33E38
}

// =============== S U B R O U T I N E =======================================
//
void DIYCupOnSelect16()
{
    ax = *(word *)&g_memByte[501283];       // mov ax, dseg_1773A6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_460C1

    {
        word src = *(word *)&g_memByte[501283];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[501283] = src;
    }                                       // sub dseg_1773A6, 1
    cseg_46589();                           // call cseg_46589
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void DIYCupOnSelect17()
{
    ax = *(word *)&g_memByte[501283];       // mov ax, dseg_1773A6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 6;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 6
    ax = *(word *)&g_memByte[318724];       // mov ax, dseg_10EEFA
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[501301];       // mov ax, dseg_1773B8
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_460F7;                    // jz short cseg_460F7

    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1

cseg_460F7:;
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        return;                             // jnb short cseg_46118

    {
        word src = *(word *)&g_memByte[501283];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[501283] = src;
    }                                       // add dseg_1773A6, 1
    cseg_46589();                           // call cseg_46589
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void DIYCupOnSelect1()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    *(word *)&g_memByte[501301] = 0;        // mov dseg_1773B8, 0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 73, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+49h], 1
    if (flags.zero)
        goto cseg_4617E;                    // jz short cseg_4617E

    {
        word src = (word)readMemory(esi + 73, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+49h], 2
    if (flags.zero)
        goto cseg_46194;                    // jz short cseg_46194

    {
        word src = (word)readMemory(esi + 73, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+49h], 3
    if (flags.zero)
        goto cseg_461F8;                    // jz cseg_461F8

    {
        word src = (word)readMemory(esi + 73, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+49h], 4
    if (flags.zero)
        goto cseg_4620B;                    // jz cseg_4620B

    {
        word src = (word)readMemory(esi + 73, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+49h], 5
    if (flags.zero)
        goto cseg_4621E;                    // jz cseg_4621E

    goto cseg_4622F;                        // jmp cseg_4622F

cseg_4617E:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 73, 2, 0);            // mov word ptr [esi+49h], 0
    cseg_284D8();                           // call cseg_284D8
    goto cseg_46247;                        // jmp cseg_46247

cseg_46194:;
    *(word *)&g_memByte[501301] = 1;        // mov dseg_1773B8, 1
    push(A0);                               // push A0
    cseg_45D00();                           // call cseg_45D00
    pop(A0);                                // pop A0
    ax = *(word *)&g_memByte[501289];       // mov ax, dseg_1773AC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_461CA;                    // jz short cseg_461CA

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 73, 2, 6);            // mov word ptr [esi+49h], 6
    goto cseg_46247;                        // jmp cseg_46247

cseg_461CA:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 813, 2);    // mov ax, [esi+32Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_461EA;                    // jz short cseg_461EA

    writeMemory(esi + 73, 2, 3);            // mov word ptr [esi+49h], 3
    goto cseg_46247;                        // jmp short cseg_46247

cseg_461EA:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 73, 2, 4);            // mov word ptr [esi+49h], 4
    goto cseg_46247;                        // jmp short cseg_46247

cseg_461F8:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 73, 2, 0);            // mov word ptr [esi+49h], 0
    cseg_284D8();                           // call cseg_284D8
    goto cseg_46247;                        // jmp short cseg_46247

cseg_4620B:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 73, 2, 0);            // mov word ptr [esi+49h], 0
    cseg_284D8();                           // call cseg_284D8
    goto cseg_46247;                        // jmp short cseg_46247

cseg_4621E:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 2, 2, 2);             // mov word ptr [esi+2], 2
    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

cseg_4622F:;
    *(word *)&g_memByte[501285] = 1;        // mov dseg_1773A8, 1
    cseg_463D9();                           // call cseg_463D9
    cseg_46269();                           // call cseg_46269
    { cseg_46E4D(); return; }               // jmp cseg_46E4D

cseg_46247:;
    cseg_45D92();                           // call cseg_45D92
    cseg_46515();                           // call cseg_46515
    *(word *)&g_memByte[501283] = 0;        // mov dseg_1773A6, 0
    cseg_46589();                           // call cseg_46589
    cseg_46E9B();                           // call cseg_46E9B
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_46269()
{
    cseg_462F7();                           // call cseg_462F7
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 0Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CallDrawMultipleItems();                // jmp CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void cseg_462F7()
{
    cseg_288E2();                           // call cseg_288E2
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 0Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    writeMemory(esi + 38, 4, 17225);        // mov dword ptr [esi+26h], offset aV
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 835, 4);         // mov eax, [esi+343h]
    A3 = eax;                               // mov A3, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, eax
    eax = A3;                               // mov eax, A3
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 835, 4);         // mov eax, [esi+343h]
    A3 = eax;                               // mov A3, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, eax
    eax = A3;                               // mov eax, A3
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_463D9()
{
    cseg_463E6();                           // call cseg_463E6
    if (flags.zero)
        return;                             // jz short cseg_463E5

    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_463E6()
{
    ax = *(word *)&g_memByte[501301];       // mov ax, dseg_1773B8
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_463FF;                    // jz short cseg_463FF

    *(word *)&g_memByte[501283] = 0;        // mov dseg_1773A6, 0
    goto cseg_464FF;                        // jmp cseg_464FF

cseg_463FF:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax = *(word *)&g_memByte[501285];       // mov ax, dseg_1773A8
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_46451;                    // jz short cseg_46451

    {
        word src = *(word *)&g_memByte[318724];
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10EEFA, 6
    if (flags.carry || flags.zero)
        goto cseg_46451;                    // jbe short cseg_46451

    ax = *(word *)&g_memByte[318742];       // mov ax, diyLeagueMinSubstitutes
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word src = *(word *)&g_memByte[501285];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_1773A8, 1
    if (flags.zero)
        goto cseg_46451;                    // jz short cseg_46451

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    if (!flags.sign)
        goto cseg_46451;                    // jns short cseg_46451

    ax = *(word *)&g_memByte[318724];       // mov ax, dseg_10EEFA
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_46451:;
    *(word *)&D2 = 0;                       // mov word ptr D2, 0

cseg_4645A:;
    ax = *(word *)&g_memByte[501283];       // mov ax, dseg_1773A6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 3
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_4649B;                    // jnb short cseg_4649B

    ax = *(word *)&g_memByte[501283];       // mov ax, dseg_1773A6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4649B;                    // jz short cseg_4649B

    {
        word src = *(word *)&g_memByte[501283];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[501283] = src;
    }                                       // sub dseg_1773A6, 1
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    goto cseg_4645A;                        // jmp short cseg_4645A

cseg_4649B:;
    ax = *(word *)&g_memByte[501283];       // mov ax, dseg_1773A6
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 3
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry || flags.zero)
        goto cseg_464F4;                    // jbe short cseg_464F4

    ax = *(word *)&g_memByte[318724];       // mov ax, dseg_10EEFA
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 6
    ax = *(word *)&g_memByte[501283];       // mov ax, dseg_1773A6
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        goto cseg_464F4;                    // jz short cseg_464F4

    {
        word src = *(word *)&g_memByte[501283];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[501283] = src;
    }                                       // add dseg_1773A6, 1
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    goto cseg_4649B;                        // jmp short cseg_4649B

cseg_464F4:;
    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_46514

cseg_464FF:;
    cseg_46589();                           // call cseg_46589
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_46515()
{
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 0Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 38h
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_46589()
{
    ax = *(word *)&g_memByte[501301];       // mov ax, dseg_1773B8
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_46ACF;                    // jnz cseg_46ACF

    A4 = 318643;                            // mov A4, offset DIY_competitionStart
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 12h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 137;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 89h
    A5 = eax;                               // mov A5, eax
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A6 = eax;                               // mov A6, eax
    ax = *(word *)&g_memByte[501283];       // mov ax, dseg_1773A6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A6;                               // mov eax, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A6 = eax;                               // mov A6, eax
    ax = *(word *)&g_memByte[501283];       // mov ax, dseg_1773A6
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)&D5 = 5;                       // mov word ptr D5, 5

cseg_4665F:;
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (!flags.carry)
        goto cseg_46A13;                    // jnb cseg_46A13

    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    {
        word res = *(word *)&D4 << 1;
        *(word *)&D4 = res;
    }                                       // shl word ptr D4, 1
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 38, 4, 17225);        // mov dword ptr [esi+26h], offset aV
    esi = A5;                               // mov esi, A5
    {
        byte src = (byte)readMemory(esi, 1);
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi], 80h
    if (flags.zero)
        goto cseg_466AD;                    // jz short cseg_466AD

    esi = A3;                               // mov esi, A3
    writeMemory(esi + 38, 4, 17229);        // mov dword ptr [esi+26h], offset aMinus

cseg_466AD:;
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 4;                                 // mov bx, 4
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 835;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 343h
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, eax
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[501293] = eax;     // mov dseg_1773B0, eax
    esi = A3;                               // mov esi, A3
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 4;                                 // mov bx, 4
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 835;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 343h
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[501297] = eax;     // mov dseg_1773B4, eax
    esi = A3;                               // mov esi, A3
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    StringCopy();                           // call StringCopy
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A5;                               // mov esi, A5
    {
        byte src = (byte)readMemory(esi, 1);
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi], 80h
    if (flags.zero)
        goto cseg_468D9;                    // jz cseg_468D9

    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 201;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0C9h
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx + 1, 1); // mov al, [esi+ebx+1]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 201;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0C9h
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A3 = res;
    }                                       // add A3, 38h
    goto cseg_468FF;                        // jmp short cseg_468FF

cseg_468D9:;
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h

cseg_468FF:;
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A1);                               // push A1
    push(A2);                               // push A2
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 461;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 1CDh
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 333;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 14Dh
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 201;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 0C9h
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    eax = *(dword *)&g_memByte[501293];     // mov eax, dseg_1773B0
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[501297];     // mov eax, dseg_1773B4
    A2 = eax;                               // mov A2, eax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    cseg_289AC();                           // call cseg_289AC
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    StringCopy();                           // call StringCopy
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A3 = res;
    }                                       // add A3, 38h
    goto cseg_46AAB;                        // jmp cseg_46AAB

cseg_46A13:;
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h

cseg_46AAB:;
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 2
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 1
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    (*(int16_t *)&D5)--;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto cseg_4665F;                    // jns cseg_4665F

    return;                                 // retn

cseg_46ACF:;
    A4 = 318643;                            // mov A4, offset DIY_competitionStart
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 12h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        word res = *(word *)&D7 >> 1;
        *(word *)&D7 = res;
    }                                       // shr word ptr D7, 1
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A2 = eax;                               // mov A2, eax
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 781;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 30Dh
    A5 = eax;                               // mov A5, eax
    ax = *(word *)&g_memByte[501283];       // mov ax, dseg_1773A6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 137;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 89h
    A6 = eax;                               // mov A6, eax
    ax = *(word *)&g_memByte[501283];       // mov ax, dseg_1773A6
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    *(word *)&D5 = 5;                       // mov word ptr D5, 5

cseg_46B93:;
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (!flags.carry)
        goto cseg_46D00;                    // jnb cseg_46D00

    esi = A3;                               // mov esi, A3
    writeMemory(esi + 38, 4, 17225);        // mov dword ptr [esi+26h], offset aV
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    *(word *)&D3 = 1;                       // mov word ptr D3, 1

cseg_46BCF:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D4 << 1;
        *(word *)&D4 = res;
    }                                       // shl word ptr D4, 1
    {
        word res = *(word *)&D0 & 2;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D0, 2
    if (flags.zero)
        goto cseg_46C80;                    // jz short cseg_46C80

    {
        word res = *(word *)&D0 & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D0, 1
    if (!flags.zero)
        goto cseg_46C50;                    // jnz short cseg_46C50

    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_46DCD();                           // call cseg_46DCD
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A3 = res;
    }                                       // add A3, 38h
    goto cseg_46CB5;                        // jmp short cseg_46CB5

cseg_46C50:;
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx + 1, 1); // mov al, [esi+ebx+1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_46DCD();                           // call cseg_46DCD
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A3 = res;
    }                                       // add A3, 38h
    goto cseg_46CB5;                        // jmp short cseg_46CB5

cseg_46C80:;
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_46DCD();                           // call cseg_46DCD
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx + 1, 1); // mov al, [esi+ebx+1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_46DAE();                           // call cseg_46DAE

cseg_46CB5:;
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_46BCF;                    // jns cseg_46BCF

    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A3 = res;
    }                                       // add A3, 38h
    goto cseg_46D98;                        // jmp cseg_46D98

cseg_46D00:;
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h

cseg_46D98:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    (*(int16_t *)&D5)--;
    flags.sign = (*(int16_t *)&D5 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D5 == 0;      // dec word ptr D5
    if (!flags.sign)
        goto cseg_46B93;                    // jns cseg_46B93
}

// =============== S U B R O U T I N E =======================================
//
void cseg_46DAE()
{
    esi = A3;                               // mov esi, A3
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax
    A0 = 15127;                             // mov A0, offset aOr
    StringCopy();                           // call StringCopy
    cseg_46DDB();                           // jmp short cseg_46DDB
}

// =============== S U B R O U T I N E =======================================
//
void cseg_46DCD()
{
    esi = A3;                               // mov esi, A3
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+26h]
    A1 = eax;                               // mov A1, eax

    cseg_46DDB();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_46DDB()
{
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 4;                                 // mov bx, 4
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 835;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 343h
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, eax
    StringCopy();                           // call StringCopy
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A3 = res;
    }                                       // add A3, 38h
}

// =============== S U B R O U T I N E =======================================
//
void cseg_46E4D()
{
    cseg_46E9B();                           // call cseg_46E9B
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    CallDrawMultipleItems();                // jmp CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void cseg_46E9B()
{
    ax = *(word *)&g_memByte[501287];       // mov ax, dseg_1773AA
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_46F28;                    // jz cseg_46F28

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 60, 2, 1);            // mov word ptr [esi+3Ch], 1
    writeMemory(esi + 116, 2, 1);           // mov word ptr [esi+74h], 1
    writeMemory(esi + 172, 2, 1);           // mov word ptr [esi+0ACh], 1
    writeMemory(esi + 228, 2, 1);           // mov word ptr [esi+0E4h], 1
    writeMemory(esi + 284, 2, 1);           // mov word ptr [esi+11Ch], 1
    writeMemory(esi + 340, 2, 1);           // mov word ptr [esi+154h], 1
    writeMemory(esi + 396, 2, 1);           // mov word ptr [esi+18Ch], 1
    return;                                 // retn

cseg_46F28:;
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 73, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+49h], 6
    if (!flags.zero)
        goto cseg_47003;                    // jnz cseg_47003

    ax = *(word *)&g_memByte[501289];       // mov ax, dseg_1773AC
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_46F72;                    // jnz short cseg_46F72

    *(word *)&g_memByte[252398] = 1;        // mov fireResetFlag, 1

cseg_46F72:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 60, 2, 1);            // mov word ptr [esi+3Ch], 1
    writeMemory(esi + 116, 2, 1);           // mov word ptr [esi+74h], 1
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 60, 2, 1);            // mov word ptr [esi+3Ch], 1
    writeMemory(esi + 116, 2, 1);           // mov word ptr [esi+74h], 1
    *(word *)&D0 = 10;                      // mov word ptr D0, 0Ah
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    goto cseg_4738B;                        // jmp cseg_4738B

cseg_47003:;
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 73, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+49h], 0
    if (!flags.zero)
        goto cseg_47020;                    // jnz short cseg_47020

    ax = *(word *)&g_memByte[501285];       // mov ax, dseg_1773A8
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_47074;                    // jle short cseg_47074

    goto cseg_47172;                        // jmp cseg_47172

cseg_47020:;
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 73, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+49h], 1
    if (flags.zero)
        goto cseg_470B3;                    // jz cseg_470B3

    {
        word src = (word)readMemory(esi + 73, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+49h], 2
    if (flags.zero)
        goto cseg_470CB;                    // jz cseg_470CB

    {
        word src = (word)readMemory(esi + 73, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+49h], 3
    if (flags.zero)
        goto cseg_4709B;                    // jz short cseg_4709B

    {
        word src = (word)readMemory(esi + 73, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+49h], 4
    if (flags.zero)
        goto cseg_47083;                    // jz short cseg_47083

    *(word *)&g_memByte[252398] = 1;        // mov fireResetFlag, 1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 16137);        // mov dword ptr [esi+26h], offset aNextRound
    goto cseg_470E1;                        // jmp short cseg_470E1

cseg_47074:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17361);        // mov dword ptr [esi+26h], offset aNextMatch
    goto cseg_470E1;                        // jmp short cseg_470E1

cseg_47083:;
    *(word *)&g_memByte[252398] = 1;        // mov fireResetFlag, 1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 16137);        // mov dword ptr [esi+26h], offset aNextRound
    goto cseg_470E1;                        // jmp short cseg_470E1

cseg_4709B:;
    *(word *)&g_memByte[252398] = 1;        // mov fireResetFlag, 1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 16167);        // mov dword ptr [esi+26h], offset aPlayReplays
    goto cseg_470E1;                        // jmp short cseg_470E1

cseg_470B3:;
    *(word *)&g_memByte[252398] = 1;        // mov fireResetFlag, 1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 16197);        // mov dword ptr [esi+26h], offset a2ndLegRound
    goto cseg_470E1;                        // jmp short cseg_470E1

cseg_470CB:;
    *(word *)&g_memByte[252398] = 1;        // mov fireResetFlag, 1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 16107);        // mov dword ptr [esi+26h], offset aNextRoundDraw

cseg_470E1:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 60, 2, 1);            // mov word ptr [esi+3Ch], 1
    writeMemory(esi + 116, 2, 1);           // mov word ptr [esi+74h], 1
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 60, 2, 1);            // mov word ptr [esi+3Ch], 1
    writeMemory(esi + 116, 2, 1);           // mov word ptr [esi+74h], 1
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    goto cseg_4738B;                        // jmp cseg_4738B

cseg_47172:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    cseg_28DC6();                           // call cseg_28DC6
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_47240;                    // jz cseg_47240

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto cseg_47240;                    // jz cseg_47240

    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    writeMemory(esi + 60, 2, 0);            // mov word ptr [esi+3Ch], 0
    writeMemory(esi + 116, 2, 0);           // mov word ptr [esi+74h], 0
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 60, 2, 1);            // mov word ptr [esi+3Ch], 1
    writeMemory(esi + 116, 2, 1);           // mov word ptr [esi+74h], 1
    esi = 318643;                           // mov esi, offset DIY_competitionStart
    ax = (word)readMemory(esi + 61, 2);     // mov ax, [esi+3Dh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    goto cseg_47386;                        // jmp cseg_47386

cseg_47240:;
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    writeMemory(esi + 60, 2, 0);            // mov word ptr [esi+3Ch], 0
    writeMemory(esi + 116, 2, 0);           // mov word ptr [esi+74h], 0
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    writeMemory(esi + 60, 2, 1);            // mov word ptr [esi+3Ch], 1
    writeMemory(esi + 116, 2, 1);           // mov word ptr [esi+74h], 1
    ax = *(word *)&g_memByte[129476];       // mov ax, dseg_E0052
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_47377;                    // jz cseg_47377

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+14h]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 20, 2, ax);           // mov [esi+14h], ax
    writeMemory(esi + 24, 2, 202);          // mov word ptr [esi+18h], 0CAh

cseg_47377:;
    esi = 318643;                           // mov esi, offset DIY_competitionStart
    ax = (word)readMemory(esi + 65, 2);     // mov ax, [esi+41h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_47386:;
    { SWOS::SetCurrentEntry(); return; }    // jmp SetCurrentEntry

cseg_4738B:;
    ax = *(word *)&g_memByte[501291];       // mov ax, dseg_1773AE
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_473B6

    *(word *)&g_memByte[501291] = 0;        // mov dseg_1773AE, 0
    *(word *)&g_memByte[252398] = 0;        // mov fireResetFlag, 0
    *(word *)&D0 = 10;                      // mov word ptr D0, 0Ah
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void DIYCupOnSelect3()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&g_memByte[318704] = ax;       // mov diySelectedButtonOrd, ax
    *(word *)&D7 = 2;                       // mov word ptr D7, 2
    DIYCupOnSelectCommon();                 // jmp DIYCupOnSelectCommon
}

// =============== S U B R O U T I N E =======================================
//
void DIYCupOnSelect4()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&g_memByte[318704] = ax;       // mov diySelectedButtonOrd, ax
    *(word *)&D7 = 3;                       // mov word ptr D7, 3
    DIYCupOnSelectCommon();                 // jmp short DIYCupOnSelectCommon
}

// =============== S U B R O U T I N E =======================================
//
void DIYCupOnSelect5()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&g_memByte[318704] = ax;       // mov diySelectedButtonOrd, ax
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    DIYCupOnSelectCommon();                 // jmp short DIYCupOnSelectCommon
}

// =============== S U B R O U T I N E =======================================
//
void DIYCupOnSelect6()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&g_memByte[318708] = ax;       // mov diySavedEntryOrd, ax
    *(word *)&D7 = 1;                       // mov word ptr D7, 1
    DIYCupOnSelectCommon();                 // jmp short DIYCupOnSelectCommon
}

// =============== S U B R O U T I N E =======================================
//
void DIYCupOnSelect7()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&g_memByte[318708] = ax;       // mov diySavedEntryOrd, ax
    *(word *)&D7 = 3;                       // mov word ptr D7, 3
    DIYCupOnSelectCommon();                 // jmp short DIYCupOnSelectCommon
}

// =============== S U B R O U T I N E =======================================
//
void DIYCupOnSelect8()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&g_memByte[318708] = ax;       // mov diySavedEntryOrd, ax
    *(word *)&D7 = 0;                       // mov word ptr D7, 0

    DIYCupOnSelectCommon();
}

// =============== S U B R O U T I N E =======================================
//
void DIYCupOnSelectCommon()
{
    *(word *)&g_memByte[485386] = 0;        // mov dseg_16FE54, 0
    cseg_28E76();                           // call cseg_28E76
    if (!flags.zero)
        return;                             // jnz cseg_4766E

    eax = A1;                               // mov eax, A1
    *(dword *)&g_memByte[501303] = eax;     // mov dseg_1773BA, eax
    eax = A2;                               // mov eax, A2
    *(dword *)&g_memByte[501307] = eax;     // mov dseg_1773BE, eax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[501311] = ax;       // mov dseg_1773C2, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[501313] = ax;       // mov dseg_1773C4, ax
    *(word *)&g_memByte[501285] = 65535;    // mov dseg_1773A8, 0FFFFh
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4763A;                    // jz cseg_4763A

    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_474DE;                    // jz short cseg_474DE

    ax = *(word *)&g_memByte[501289];       // mov ax, dseg_1773AC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_47613;                    // jnz cseg_47613

cseg_474DE:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 329, 2);    // mov ax, [esi+149h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_47520;                    // jnz short cseg_47520

    {
        word src = (word)readMemory(esi + 331, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+14Bh], 2
    if (!flags.zero)
        goto cseg_47520;                    // jnz short cseg_47520

    ax = *(word *)&g_memByte[501289];       // mov ax, dseg_1773AC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_47613;                    // jnz cseg_47613

    writeMemory(esi + 73, 2, 1);            // mov word ptr [esi+49h], 1
    goto cseg_4763A;                        // jmp cseg_4763A

cseg_47520:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 813, 2);    // mov ax, [esi+32Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_47588;                    // jnz short cseg_47588

    ax = *(word *)&g_memByte[318714];       // mov ax, dseg_10EEF0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_47621;                    // jnz cseg_47621

    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_475FA;                    // jnz cseg_475FA

    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_475FA;                    // jz short cseg_475FA

    goto cseg_475EC;                        // jmp short cseg_475EC

cseg_47588:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_475DE;                    // jnz short cseg_475DE

    ax = *(word *)&g_memByte[318714];       // mov ax, dseg_10EEF0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_475DE;                    // jnz short cseg_475DE

    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_475EC;                    // jnz short cseg_475EC

    ax = *(word *)&g_memByte[501289];       // mov ax, dseg_1773AC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_47613;                    // jnz short cseg_47613

cseg_475DE:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 73, 2, 3);            // mov word ptr [esi+49h], 3
    goto cseg_4763A;                        // jmp short cseg_4763A

cseg_475EC:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 73, 2, 2);            // mov word ptr [esi+49h], 2
    goto cseg_4763A;                        // jmp short cseg_4763A

cseg_475FA:;
    ax = *(word *)&g_memByte[501289];       // mov ax, dseg_1773AC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_47613;                    // jnz short cseg_47613

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 73, 2, 4);            // mov word ptr [esi+49h], 4
    goto cseg_4763A;                        // jmp short cseg_4763A

cseg_47613:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 73, 2, 6);            // mov word ptr [esi+49h], 6
    goto cseg_4763A;                        // jmp short cseg_4763A

cseg_47621:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 73, 2, 5);            // mov word ptr [esi+49h], 5
    {
        word src = (word)readMemory(esi + 71, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+47h], 2
    if (!flags.zero)
        goto cseg_47655;                    // jnz short cseg_47655

cseg_4763A:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+55h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_47655;                    // jz short cseg_47655

    writeMemory(esi + 73, 2, 6);            // mov word ptr [esi+49h], 6

cseg_47655:;
    cseg_4766F();                           // call cseg_4766F
    cseg_463E6();                           // call cseg_463E6
    cseg_46E9B();                           // call cseg_46E9B
    cseg_46589();                           // call cseg_46589
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4766F()
{
    eax = *(dword *)&g_memByte[501303];     // mov eax, dseg_1773BA
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[501307];     // mov eax, dseg_1773BE
    A2 = eax;                               // mov A2, eax
    ax = *(word *)&g_memByte[501311];       // mov ax, dseg_1773C2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[501313];       // mov ax, dseg_1773C4
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 0Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    writeMemory(esi + 38, 4, 17229);        // mov dword ptr [esi+26h], offset aMinus
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    A0 = eax;                               // mov A0, eax
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 38h
    ax = D1;                                // mov ax, word ptr D1
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A3 = res;
    }                                       // add A3, 38h
    ax = D2;                                // mov ax, word ptr D2
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 38, 2, ax);           // mov [esi+26h], ax
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYLeagueInit()
{
    ax = *(word *)&g_memByte[379886];       // mov ax, diyLeagueSelectTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_477A8;                    // jz short cseg_477A8

    SetNumberOfTeamsToSelect();             // call SetNumberOfTeamsToSelect

cseg_477A8:;

    DesignDIYLeagueFinish();
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYLeagueFinish()
{
    {
        word src = *(word *)&g_memByte[131708];
        int16_t dstSigned = src;
        int16_t srcSigned = 65534;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_pitchType, SEASONAL
    if (flags.zero)
        goto l_pitch_seasonal;              // jz @@pitch_seasonal

    *(word *)&g_memByte[318694] = 0;        // mov diyPitchTypeOrSeason_2, 0
    ax = *(word *)&g_memByte[131708];       // mov ax, g_pitchType
    *(word *)&g_memByte[318696] = ax;       // mov diyLeaguePitchType, ax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1
    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1

l_pitch_seasonal:;
    DIYSetMonthsOrPitchTypeEntries();       // call DIYSetMonthsOrPitchTypeEntries
    DIYLeagueSetVariousFields();            // call DIYLeagueSetVariousFields
    ax = *(word *)&g_memByte[379884];       // mov ax, diyLeagueLookOnly
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4791B;                    // jnz cseg_4791B

    ax = *(word *)&g_memByte[379886];       // mov ax, diyLeagueSelectTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_478EE;                    // jnz short cseg_478EE

    *(word *)&D0 = 20;                      // mov word ptr D0, 20
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 21;                      // mov word ptr D0, 21
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 23;                      // mov word ptr D0, 23
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    return;                                 // retn

cseg_478EE:;
    DIYLeagueOKSelected();                  // call DIYLeagueOKSelected
    *(word *)&D0 = 21;                      // mov word ptr D0, 21
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 20;                      // mov word ptr D0, 20
    { SWOS::SetCurrentEntry(); return; }    // jmp SetCurrentEntry

cseg_4791B:;
    cseg_47981();                           // call cseg_47981
    DIYLeagueOKSelected();                  // call DIYLeagueOKSelected
    *(word *)&D0 = 20;                      // mov word ptr D0, 20
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 21;                      // mov word ptr D0, 21
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 23;                      // mov word ptr D0, 23
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 22;                      // mov word ptr D0, 22
    SWOS::SetCurrentEntry();                // jmp SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void cseg_47981()
{
    A6 = 318643;                            // mov A6, offset DIY_competitionStart
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 301, 1);    // mov al, [esi+301]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 80
    if (flags.carry)
        goto cseg_47A07;                    // jb short cseg_47A07

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 85;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 85
    if (!flags.carry && !flags.zero)
        goto cseg_47A07;                    // ja short cseg_47A07

    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+83]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 4724;                              // mov A0, offset aWinnerQualifie
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto cseg_47A48;                    // jz short cseg_47A48

    A0 = 4741;                              // mov A0, offset aTop0Qualify
    goto cseg_47A48;                        // jmp short cseg_47A48

cseg_47A07:;
    A0 = 8923;                              // mov A0, offset aTeamsPromoted0
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+83]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+85]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    if (!flags.zero)
        goto cseg_47A48;                    // jnz short cseg_47A48

    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_47A69;                    // jz short cseg_47A69

    A0 = 8893;                              // mov A0, offset aTeamsPromote_0

cseg_47A48:;
    PrintFormatted();                       // call PrintFormatted
    *(word *)&D0 = 18;                      // mov word ptr D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    goto cseg_47AD3;                        // jmp short cseg_47AD3

cseg_47A69:;
    push(D0);                               // push D0
    D0 = 18;                                // mov D0, 18
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+22]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 22, 2, ax);           // mov [esi+22], ax

cseg_47AD3:;
    push(D0);                               // push D0
    D0 = 19;                                // mov D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+38]
    A1 = eax;                               // mov A1, eax
    A0 = 9003;                              // mov A0, offset aTeamsRelegated
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+87]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+89]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_47B40;                    // jnz short cseg_47B40

    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    A0 = 8970;                              // mov A0, offset aTeamsRelegat_0

cseg_47B40:;
    PrintFormatted();                       // call PrintFormatted
    *(word *)&D0 = 19;                      // mov word ptr D0, 19
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueSetVariousFields()
{
    al = g_memByte[318698];                 // mov al, diyLeagueStartMonth
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 96
    if (flags.carry)
        goto l_start_month_truncate;        // jb short @@start_month_truncate

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 96

l_start_month_truncate:;
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 8;                                 // mov bx, 8
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[379880] = ax;       // mov diyLeagueStartingMonth, ax
    al = g_memByte[318699];                 // mov al, diyLeagueEndMonth
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 96
    if (flags.carry)
        goto l_end_month_truncate;          // jb short @@end_month_truncate

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 96

l_end_month_truncate:;
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 8;                                 // mov bx, 8
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[379882] = ax;       // mov diyLeagueEndingMonth, ax
    push(D0);                               // push D0
    D0 = 13;                                // mov D0, 13
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[318692];       // mov ax, diyLeagueNumTeams
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 14;                                // mov D0, 14
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    SetPlayEachTeamString();                // call SetPlayEachTeamString
    push(D0);                               // push D0
    D0 = 15;                                // mov D0, 15
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[318740];       // mov ax, diyPointsForAWin
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    ConvertMinMaxSubstitutesNumbers();      // call ConvertMinMaxSubstitutesNumbers
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueOKSelected()
{
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D1 = 16;                      // mov word ptr D1, 16

l_disable_entries_loop:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 28, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+MenuEntry.background], ENTRY_FRAME_AND_BACK_COLOR
    if (!flags.zero)
        goto l_next_entry;                  // jnz short @@next_entry

    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Fh
    if (flags.zero)
        goto l_next_entry;                  // jz short @@next_entry

    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    writeMemory(esi + 6, 2, 1);             // mov [esi+MenuEntry.isDisabled], 1

l_next_entry:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_disable_entries_loop;        // jns short @@disable_entries_loop

    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYLeagueOK()
{
    *(word *)&g_memByte[379886] = 1;        // mov diyLeagueSelectTeams, 1
    A6 = 502769;                            // mov A6, offset designDiyLeagueMenu
    SWOS::ActivateMenu();                   // jmp ActivateMenu
}

// =============== S U B R O U T I N E =======================================
//
void jmp_SetExitMenuFlag_6()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYLeagueSetName()
{
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 25;                      // mov word ptr D0, 25
    SWOS::InputText();                      // jmp InputText
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYLeagueChooseTeams()
{
    ax = *(word *)&g_memByte[318692];       // mov ax, diyLeagueNumTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 318647;                            // mov A0, offset diyLeagueName
    A1 = 15998;                             // mov A1, offset aPlayLeague
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    *(word *)&D3 = 1;                       // mov word ptr D3, 1
    *(word *)&D4 = 1;                       // mov word ptr D4, 1
    GoGetTeamsForPlay();                    // call GoGetTeamsForPlay
    ax = *(word *)&g_memByte[330694];       // mov ax, chooseTeamsResult
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        { jmp_SetExitMenuFlag_6(); return; } // jz short jmp_SetExitMenuFlag_6

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CareerInitVars();                       // call CareerInitVars
    A0 = 318944;                            // mov A0, offset dseg_10EFD6
    ax = *(word *)&g_memByte[318692];       // mov ax, diyLeagueNumTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_87D60();                           // call cseg_87D60
    cseg_2653B();                           // call cseg_2653B
    cseg_28243();                           // call cseg_28243
    InitTeams();                            // call InitTeams
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    ShowDiyLeaguesTournamentMenu();         // call ShowDiyLeaguesTournamentMenu
    RestoreDIYLeague();                     // call RestoreDIYLeague
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void DIYSetMonthsOrPitchTypeEntries()
{
    ax = *(word *)&g_memByte[318694];       // mov ax, diyPitchTypeOrSeason_2
    *(word *)&g_memByte[379878] = ax;       // mov diyPitchTypeOrSeason_1, ax
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_PRESET_COMPETITION
    if (flags.zero)
        goto l_preset_or_season;            // jz short @@preset_or_season

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_SEASON
    if (flags.zero)
        goto l_preset_or_season;            // jz short @@preset_or_season

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto l_make_months_invisible;       // jnz short @@make_months_invisible

l_preset_or_season:;
    *(word *)&g_memByte[379878] = 1;        // mov diyPitchTypeOrSeason_1, 1

l_make_months_invisible:;
    ax = *(word *)&g_memByte[379878];       // mov ax, diyPitchTypeOrSeason_1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_make_pitch_type_invisible;   // jnz short @@make_pitch_type_invisible

    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 60, 2, 1);            // mov [esi+(MenuEntry.isInvisible+38h)], 1
    writeMemory(esi + 116, 2, 1);           // mov [esi+(MenuEntry.isInvisible+70h)], 1
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    return;                                 // retn

l_make_pitch_type_invisible:;
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    writeMemory(esi + 60, 2, 0);            // mov [esi+(MenuEntry.isInvisible+38h)], 0
    writeMemory(esi + 116, 2, 0);           // mov [esi+(MenuEntry.isInvisible+70h)], 0
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueChangePitchTypeOrSeason()
{
    {
        word src = *(word *)&g_memByte[318694];
        src ^= 1;
        *(word *)&g_memByte[318694] = src;
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor diyPitchTypeOrSeason_2, 1
    DIYSetMonthsOrPitchTypeEntries();       // call DIYSetMonthsOrPitchTypeEntries
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CallDrawMultipleItems();                // call CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYLeagueChangePitchType()
{
    {
        word src = *(word *)&g_memByte[318696];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[318696] = src;
    }                                       // add diyLeaguePitchType, 1
    {
        word src = *(word *)&g_memByte[318696];
        int16_t dstSigned = src;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp diyLeaguePitchType, 7
    if (!flags.zero)
        goto l_no_overflow;                 // jnz short @@no_overflow

    *(word *)&g_memByte[318696] = -1;       // mov diyLeaguePitchType, -1

l_no_overflow:;
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYLeagueChangeStartMonth()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 55, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 8;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 55, 1, src);
    }                                       // add [esi+DIYLeague.startingMonth], 8
    al = (byte)readMemory(esi + 55, 1);     // mov al, [esi+DIYLeague.startingMonth]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 96
    if (!flags.zero)
        goto l_not_overflow;                // jnz short @@not_overflow

    writeMemory(esi + 55, 1, 0);            // mov [esi+DIYLeague.startingMonth], 0
    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0

l_not_overflow:;
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 8;                                 // mov bx, 8
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[379880] = ax;       // mov diyLeagueStartingMonth, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYLeagueChangeEndMonth()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 56, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 8;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 56, 1, src);
    }                                       // add [esi+DIYLeague.endingMonth], 8
    al = (byte)readMemory(esi + 56, 1);     // mov al, [esi+DIYLeague.endingMonth]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 96
    if (!flags.zero)
        goto l_not_overflow;                // jnz short @@not_overflow

    writeMemory(esi + 56, 1, 0);            // mov [esi+DIYLeague.endingMonth], 0
    *(byte *)&D0 = 0;                       // mov byte ptr D0, 0

l_not_overflow:;
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 8;                                 // mov bx, 8
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[379882] = ax;       // mov diyLeagueEndingMonth, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYLeagueChangeNumberOfTeams()
{
    ax = *(word *)&g_memByte[318692];       // mov ax, diyLeagueNumTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word src = *(word *)&g_memByte[318692];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[318692] = src;
    }                                       // add diyLeagueNumTeams, 1
    {
        word src = *(word *)&g_memByte[318692];
        int16_t dstSigned = src;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp diyLeagueNumTeams, 25
    if (flags.carry)
        goto l_not_overflow;                // jb short @@not_overflow

    *(word *)&g_memByte[318692] = 2;        // mov diyLeagueNumTeams, 2

l_not_overflow:;
    ax = *(word *)&g_memByte[318692];       // mov ax, diyLeagueNumTeams
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYLeagueChangePlayEachTeam()
{
    {
        word src = *(word *)&g_memByte[318736];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[318736] = src;
    }                                       // add diyLeaguePlayEachTeam, 1
    {
        word src = *(word *)&g_memByte[318736];
        int16_t dstSigned = src;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp diyLeaguePlayEachTeam, 11
    if (!flags.zero)
        goto l_not_overflow;                // jnz short @@not_overflow

    *(word *)&g_memByte[318736] = 1;        // mov diyLeaguePlayEachTeam, 1

l_not_overflow:;
    SetPlayEachTeamString();                // call SetPlayEachTeamString
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================

// in:
//      A5 -> play each team entry
//
void SetPlayEachTeamString()
{
    ax = *(word *)&g_memByte[318736];       // mov ax, diyLeaguePlayEachTeam
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 17762;                             // mov A0, offset aX0
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    PrintFormatted();                       // call PrintFormatted
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYLeagueChangeNumPointsForWin()
{
    {
        word src = *(word *)&g_memByte[318740];
        src ^= 1;
        *(word *)&g_memByte[318740] = src;
        flags.carry = false;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
    }                                       // xor diyPointsForAWin, 1
    ax = *(word *)&g_memByte[318740];       // mov ax, diyPointsForAWin
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void ConvertMinMaxSubstitutesNumbers()
{
    push(D0);                               // push D0
    D0 = 16;                                // mov D0, 16
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[318742];       // mov ax, diyLeagueMinSubstitutes
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SWOS::Int2Ascii();                      // call Int2Ascii
    push(D0);                               // push D0
    D0 = 17;                                // mov D0, 17
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[318744];       // mov ax, diyLeagueMaxSubstitutes
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SWOS::Int2Ascii();                      // call Int2Ascii
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYLeagueChangeMinSubstitutes()
{
    ax = *(word *)&g_memByte[318744];       // mov ax, diyLeagueMaxSubstitutes
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        word src = *(word *)&g_memByte[318742];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[318742] = src;
    }                                       // add diyLeagueMinSubstitutes, 1
    ax = *(word *)&g_memByte[318742];       // mov ax, diyLeagueMinSubstitutes
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto l_not_underflow;               // jnb short @@not_underflow

    *(word *)&g_memByte[318742] = 1;        // mov diyLeagueMinSubstitutes, 1

l_not_underflow:;
    ConvertMinMaxSubstitutesNumbers();      // call ConvertMinMaxSubstitutesNumbers
    CallDrawMenuItem();                     // jmp CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void DesignDIYLeagueChangeMaxSubstitutes()
{
    {
        word src = *(word *)&g_memByte[318744];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[318744] = src;
    }                                       // add diyLeagueMaxSubstitutes, 1
    {
        word src = *(word *)&g_memByte[318744];
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp diyLeagueMaxSubstitutes, 5
    if (flags.carry || flags.zero)
        goto l_substitutes_enabled;         // jbe short @@substitutes_enabled

    *(word *)&g_memByte[318744] = 0;        // mov diyLeagueMaxSubstitutes, 0
    *(word *)&g_memByte[318742] = 0;        // mov diyLeagueMinSubstitutes, 0

l_substitutes_enabled:;
    {
        word src = *(word *)&g_memByte[318744];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp diyLeagueMaxSubstitutes, 1
    if (!flags.zero)
        goto l_not_max_one_substitute;      // jnz short @@not_max_one_substitute

    *(word *)&g_memByte[318742] = 1;        // mov diyLeagueMinSubstitutes, 1

l_not_max_one_substitute:;
    ConvertMinMaxSubstitutesNumbers();      // call ConvertMinMaxSubstitutesNumbers
    CallDrawMenuItem();                     // call CallDrawMenuItem
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 16;                                // mov D0, 16
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    CallDrawMenuItem();                     // call CallDrawMenuItem
}

// =============== S U B R O U T I N E =======================================
//
void SetNumberOfTeamsToSelect()
{
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 23;                                // mov D0, 23
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[318692];       // mov ax, diyLeagueNumTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 16324;                             // mov A0, offset aSelect0Teams
    PrintFormatted();                       // call PrintFormatted
}

// =============== S U B R O U T I N E =======================================
//
void ShowDesignDIYLeagueMenu()
{
    SaveDIYLeague();                        // call SaveDIYLeague
    cseg_26395();                           // call cseg_26395
    *(word *)&g_memByte[379884] = 0;        // mov diyLeagueLookOnly, 0
    *(word *)&g_memByte[379886] = 0;        // mov diyLeagueSelectTeams, 0
    A6 = 502769;                            // mov A6, offset designDiyLeagueMenu
    SWOS::ShowMenu();                       // jmp ShowMenu
}

// =============== S U B R O U T I N E =======================================
//
void ShowLeagueInfo()
{
    *(word *)&g_memByte[379884] = 1;        // mov diyLeagueLookOnly, 1
    *(word *)&g_memByte[379886] = 0;        // mov diyLeagueSelectTeams, 0
    A6 = 502769;                            // mov A6, offset designDiyLeagueMenu
    SWOS::ShowMenu();                       // jmp ShowMenu
}

// =============== S U B R O U T I N E =======================================
//
void ShowDiyLeaguesTournamentMenu()
{
    *(word *)&g_memByte[378422] = 1;        // mov writeOnlyVar01, 1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[379902] = ax;       // mov dseg_11F9E6, ax
    *(word *)&g_memByte[379898] = ax;       // mov dseg_11F9E2, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[379900] = ax;       // mov dseg_11F9E4, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[379904] = ax;       // mov dseg_11F9E8, ax
    cseg_883DD();                           // call cseg_883DD
    ax = *(word *)&g_memByte[317174];       // mov ax, inCareerSeasonUpdate
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4839A;                    // jz short cseg_4839A

l_wait_for_fire_loop:;
    SWOS::MenuCheckControls();              // call MenuCheckControls
    ax = *(word *)&g_memByte[252384];       // mov ax, fire
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_wait_for_fire_loop;          // jnz short @@wait_for_fire_loop

cseg_4839A:;
    A6 = 503647;                            // mov A6, offset DIY_leagueTournamentMenu
    SWOS::ShowMenu();                       // call ShowMenu
    *(word *)&g_memByte[378422] = 0;        // mov writeOnlyVar01, 0
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournamentInit()
{
    *(word *)&g_memByte[379896] = 0;        // mov currentDiyLine, 0
    *(word *)&g_memByte[379906] = 0;        // mov dseg_11F9EA, 0
    cseg_48CA1();                           // call cseg_48CA1
    ax = *(word *)&g_memByte[318738];       // mov ax, diyMinSubstitutes
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_483F2;                    // jnz short cseg_483F2

    ax = *(word *)&g_memByte[318714];       // mov ax, dseg_10EEF0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_483F2;                    // jnz short cseg_483F2

    *(word *)&g_memByte[379906] = 1;        // mov dseg_11F9EA, 1
    *(word *)&g_memByte[379898] = 0;        // mov dseg_11F9E2, 0

cseg_483F2:;
    ax = *(word *)&g_memByte[379900];       // mov ax, dseg_11F9E4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_48414;                    // jz short cseg_48414

    *(word *)&g_memByte[379898] = 0;        // mov dseg_11F9E2, 0
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

cseg_48414:;
    *(word *)&g_memByte[318645] = 1;        // mov dseg_10EEAB, 1
    ax = *(word *)&g_memByte[317174];       // mov ax, inCareerSeasonUpdate
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_48473;                    // jz short cseg_48473

    *(word *)&g_memByte[379898] = 0;        // mov dseg_11F9E2, 0
    *(word *)&D0 = 42;                      // mov word ptr D0, 42
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

cseg_48473:;

    DIYLeagueTournamentOnRestore();
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournamentOnRestore()
{
    {
        word src = *(word *)&g_memByte[318722];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10EEF8, 1
    if (!flags.zero)
        goto cseg_484C4;                    // jnz short cseg_484C4

    push(D0);                               // push D0
    D0 = 16;                                // mov D0, 16
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

cseg_484C4:;
    ax = *(word *)&g_memByte[379898];       // mov ax, dseg_11F9E2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_484E2;                    // jz short cseg_484E2

    if (flags.sign)
        goto cseg_484DB;                    // js short cseg_484DB

    cseg_49181();                           // call cseg_49181
    goto cseg_48555;                        // jmp short cseg_48555

cseg_484DB:;
    DIYSetTeamNamesAndResults();            // call DIYSetTeamNamesAndResults
    goto cseg_48555;                        // jmp short cseg_48555

cseg_484E2:;
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

cseg_48555:;
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4
    A0 = eax;                               // mov A0, eax
    StringCopy();                           // call StringCopy
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+71]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4862B;                    // jz short cseg_4862B

    esi = A1;                               // mov esi, A1
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 73, 2);     // mov ax, [esi+73]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+79]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 75, 2);     // mov ax, [esi+75]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+49]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    cseg_284AB();                           // call cseg_284AB
    StringCopy();                           // call StringCopy

cseg_4862B:;
    A6 = 318643;                            // mov A6, offset DIY_competitionStart
    push(D0);                               // push D0
    D0 = 16;                                // mov D0, 16
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D0 = 7;                       // mov word ptr D0, 7

cseg_48659:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 38h
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_48659;                    // jns short cseg_48659

    *(word *)&g_memByte[379890] = 6;        // mov dseg_11F9DA, 6
    *(word *)&g_memByte[379892] = 7;        // mov dseg_11F9DC, 7
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 81, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 22;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+51h], 16h
    if (flags.carry || flags.zero)
        goto cseg_4882A;                    // jbe cseg_4882A

    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 26, 2, 9);            // mov word ptr [esi+1Ah], 9
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D0 = 7;                       // mov word ptr D0, 7

cseg_486E3:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+16h], 5
    {
        word src = (word)readMemory(esi + 26, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 26, 2, src);
    }                                       // sub word ptr [esi+1Ah], 5
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 38h
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_486E3;                    // jns short cseg_486E3

    push(D0);                               // push D0
    D0 = 9;                                 // mov D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+16h], 5
    {
        word src = (word)readMemory(esi + 26, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 26, 2, src);
    }                                       // sub word ptr [esi+1Ah], 5
    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 0Ah
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+16h], 5
    {
        word src = (word)readMemory(esi + 26, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 26, 2, src);
    }                                       // sub word ptr [esi+1Ah], 5
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 0Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D0 = 4;                       // mov word ptr D0, 4

cseg_4878F:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 6;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add word ptr [esi+16h], 6
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 38h
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_4878F;                    // jns short cseg_4878F

    push(D0);                               // push D0
    D0 = 24;                                // mov D0, 18h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D0 = 6;                       // mov word ptr D0, 6

cseg_487CE:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 26, 2, 7);            // mov word ptr [esi+1Ah], 7
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 38h
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_487CE;                    // jns short cseg_487CE

    push(D0);                               // push D0
    D0 = 16;                                // mov D0, 10h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D0 = 7;                       // mov word ptr D0, 7

cseg_4880E:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 26, 2, 7);            // mov word ptr [esi+1Ah], 7
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 38h
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_4880E;                    // jns short cseg_4880E

cseg_4882A:;
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 0Bh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+1Ah]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    {
        word src = *(word *)&g_memByte[379892];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
        flags.carry = dx != 0 != 0;
    }                                       // mul dseg_11F9DC
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    *(word *)((byte *)&D3 + 2) = dx;        // mov word ptr D3+2, dx
    push(D0);                               // push D0
    D0 = 16;                                // mov D0, 10h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+1Ah]
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 1
    ax = D1;                                // mov ax, word ptr D1
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D3);
        word rem = (word)(dividend % *(word *)&D3);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry || flags.zero)
        goto cseg_48958;                    // jbe short cseg_48958

    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_48958:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[379894] = ax;       // mov numDiyResults, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        word src = *(word *)&g_memByte[379894];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul numDiyResults
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)((byte *)&D4 + 2) = dx;        // mov word ptr D4+2, dx
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, ax
    ax = D5;                                // mov ax, word ptr D5
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D5 = eax;                               // mov D5, eax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = D5;                                // mov ax, word ptr D5
    dx = *(word *)((byte *)&D5 + 2);        // mov dx, word ptr D5+2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D0);
        word rem = (word)(dividend % *(word *)&D0);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D0
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    *(word *)((byte *)&D5 + 2) = dx;        // mov word ptr D5+2, dx
    push(D0);                               // push D0
    D0 = 16;                                // mov D0, 16
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[379894];       // mov ax, numDiyResults
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_48A13:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_48A13;                    // jns short cseg_48A13

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+79]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[379894];       // mov ax, numDiyResults
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_48AAF;                    // jnz short cseg_48AAF

    *(word *)&D0 = 40;                      // mov word ptr D0, 40
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 41;                      // mov word ptr D0, 41
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

cseg_48AAF:;
    ax = *(word *)&g_memByte[318746];       // mov ax, dseg_10EF10
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_48BFA;                    // jz cseg_48BFA

    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D0 = 4;                       // mov word ptr D0, 4

cseg_48AE2:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 80;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub [esi+MenuEntry.y], 80
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_48AE2;                    // jns short cseg_48AE2

    *(word *)&D0 = 31;                      // mov word ptr D0, 31
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 60, 2, 1);            // mov [esi+(MenuEntry.isInvisible+38h)], 1
    writeMemory(esi + 116, 2, 1);           // mov [esi+(MenuEntry.isInvisible+70h)], 1
    writeMemory(esi + 172, 2, 1);           // mov [esi+(MenuEntry.isInvisible+0A8h)], 1
    writeMemory(esi + 228, 2, 1);           // mov [esi+(MenuEntry.isInvisible+0E0h)], 1
    writeMemory(esi + 284, 2, 1);           // mov [esi+(MenuEntry.isInvisible+118h)], 1
    writeMemory(esi + 340, 2, 1);           // mov [esi+(MenuEntry.isInvisible+150h)], 1
    writeMemory(esi + 396, 2, 1);           // mov [esi+(MenuEntry.isInvisible+188h)], 1
    writeMemory(esi + 452, 2, 1);           // mov [esi+(MenuEntry.isInvisible+1C0h)], 1
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 24, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 25;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 24, 2, src);
    }                                       // add [esi+MenuEntry.dwWidth], 25
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 20, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 25;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 20, 2, src);
    }                                       // add [esi+MenuEntry.x], 25
    {
        word src = (word)readMemory(esi + 24, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 25;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 24, 2, src);
    }                                       // add [esi+MenuEntry.dwWidth], 25

cseg_48BFA:;
    cseg_492AF();                           // call cseg_492AF
    nullsub_14();                           // call nullsub_14
    cseg_49F01();                           // call cseg_49F01
}

// =============== S U B R O U T I N E =======================================
//
void jmp_SetExitMenuFlag_7()
{
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournamentStats()
{
    cseg_33E38();                           // jmp cseg_33E38
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournamentExit()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+71]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_48C76;                    // jz short cseg_48C76

    {
        word src = (word)readMemory(esi + 71, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+47h], 2
    if (!flags.zero)
        goto cseg_48C56;                    // jnz short cseg_48C56

    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+5Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_48C56;                    // jnz short cseg_48C56

    ax = *(word *)&g_memByte[379900];       // mov ax, dseg_11F9E4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_48C71;                    // jnz short cseg_48C71

    goto cseg_48C71;                        // jmp short cseg_48C71

cseg_48C56:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_48C71;                    // jz short cseg_48C71

    writeMemory(esi + 71, 2, 65535);        // mov word ptr [esi+47h], 0FFFFh

cseg_48C71:;
    { SetExitMenuFlag(); return; }          // jmp SetExitMenuFlag

cseg_48C76:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+5Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_48C56;                    // jnz short cseg_48C56

    writeMemory(esi + 2, 2, 2);             // mov word ptr [esi+2], 2
    ax = *(word *)&g_memByte[379900];       // mov ax, dseg_11F9E4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    SetExitMenuFlag();                      // jmp SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void cseg_48CA1()
{
    *(word *)&g_memByte[379888] = 0;        // mov dseg_11F9D8, 0
    ax = *(word *)&g_memByte[318714];       // mov ax, dseg_10EEF0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_48D1B;                    // jnz short cseg_48D1B

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        return;                             // jnz short @@out

    al = g_memByte[318944];                 // mov al, byte ptr dseg_10EFD6
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 80
    if (flags.carry)
        goto cseg_48CDB;                    // jb short cseg_48CDB

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 85;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 85
    if (flags.carry || flags.zero)
        goto cseg_48D1B;                    // jbe short cseg_48D1B

cseg_48CDB:;
    ax = *(word *)&g_memByte[319094];       // mov ax, dseg_10F06C
    bx = 3;                                 // mov bx, 3
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    ax = *(word *)&g_memByte[319092];       // mov ax, dseg_10F06A
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry && !flags.zero)
        return;                             // ja short @@out

cseg_48D1B:;
    *(word *)&g_memByte[379888] = 1;        // mov dseg_11F9D8, 1
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournamentMatch()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&g_memByte[318704] = ax;       // mov diySelectedButtonOrd, ax
    *(word *)&D7 = 2;                       // mov word ptr D7, 2
    DIYLeagueTournamentMatchCommon();       // jmp DIYLeagueTournamentMatchCommon
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournamentOnSelect4()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&g_memByte[318704] = ax;       // mov diySelectedButtonOrd, ax
    *(word *)&D7 = 3;                       // mov word ptr D7, 3
    DIYLeagueTournamentMatchCommon();       // jmp short DIYLeagueTournamentMatchCommon
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournamentResult()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&g_memByte[318704] = ax;       // mov diySelectedButtonOrd, ax
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    DIYLeagueTournamentMatchCommon();       // jmp short DIYLeagueTournamentMatchCommon
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournamentViewMatch()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&g_memByte[318708] = ax;       // mov diySavedEntryOrd, ax
    *(word *)&D7 = 1;                       // mov word ptr D7, 1
    DIYLeagueTournamentMatchCommon();       // jmp short DIYLeagueTournamentMatchCommon
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournamentViewHighlights()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&g_memByte[318708] = ax;       // mov diySavedEntryOrd, ax
    *(word *)&D7 = 3;                       // mov word ptr D7, 3
    DIYLeagueTournamentMatchCommon();       // jmp short DIYLeagueTournamentMatchCommon
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournamentViewResult()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&g_memByte[318708] = ax;       // mov diySavedEntryOrd, ax
    *(word *)&D7 = 0;                       // mov word ptr D7, 0

    DIYLeagueTournamentMatchCommon();
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournamentMatchCommon()
{
    *(word *)&g_memByte[485386] = 0;        // mov dseg_16FE54, 0
    cseg_88A12();                           // call cseg_88A12
    if (!flags.zero)
        return;                             // jnz @@out

    cseg_48CA1();                           // call cseg_48CA1
    *(word *)&g_memByte[379898] = -1;       // mov dseg_11F9E2, -1
    push(D7);                               // push D7
    nullsub_14();                           // call nullsub_14
    pop(D7);                                // pop D7
    eax = A1;                               // mov eax, A1
    *(dword *)&g_memByte[379908] = eax;     // mov diyLeftTeamPtr, eax
    eax = A2;                               // mov eax, A2
    *(dword *)&g_memByte[379912] = eax;     // mov diyRightTeamPtr, eax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[379916] = ax;       // mov diyLeftTeamResult, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[379918] = ax;       // mov diyRightTeamResult, ax
    ax = *(word *)&g_memByte[318746];       // mov ax, dseg_10EF10
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_48E5C;                    // jz short cseg_48E5C

    push(D0);                               // push D0
    D0 = 10;                                // mov D0, 10
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 20, 2, 135);          // mov [esi+MenuEntry.x], 135
    goto cseg_48E9F;                        // jmp short cseg_48E9F

cseg_48E5C:;
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    ax = *(word *)&g_memByte[379902];       // mov ax, dseg_11F9E6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_48E83;                    // jz short cseg_48E83

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 447, 2);    // mov ax, [esi+447]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_48E9F;                    // jnz short cseg_48E9F

cseg_48E83:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+5Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_48EA8;                    // jnz short cseg_48EA8

    {
        word src = (word)readMemory(esi + 71, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+47h], 1
    if (flags.zero)
        goto cseg_48EA8;                    // jz short cseg_48EA8

cseg_48E9F:;
    *(word *)&g_memByte[379906] = 1;        // mov dseg_11F9EA, 1

cseg_48EA8:;
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_883DD();                           // call cseg_883DD
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    DIYSetTeamNamesAndResults();            // call DIYSetTeamNamesAndResults
    cseg_49F01();                           // call cseg_49F01
    cseg_492AF();                           // call cseg_492AF
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void DIYSetTeamNamesAndResults()
{
    eax = *(dword *)&g_memByte[379908];     // mov eax, diyLeftTeamPtr
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[379912];     // mov eax, diyRightTeamPtr
    A2 = eax;                               // mov A2, eax
    ax = *(word *)&g_memByte[379916];       // mov ax, diyLeftTeamResult
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[379918];       // mov ax, diyRightTeamResult
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    writeMemory(esi + 38, 4, 17229);        // mov [esi+MenuEntry.fg.string], offset aMinus
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 56
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 56
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A0 = eax;                               // mov A0, eax
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 56
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    ax = D1;                                // mov ax, word ptr D1
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A3 = res;
    }                                       // add A3, 56
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournamentNextMatch()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+95]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_490C4;                    // jnz short cseg_490C4

    writeMemory(esi + 2, 2, 2);             // mov word ptr [esi+2], 2
    SetExitMenuFlag();                      // jmp SetExitMenuFlag

l_out:;
    return;                                 // retn

cseg_490C4:;
    {
        word src = *(word *)&g_memByte[379898];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_11F9E2, 1
    if (flags.zero)
        return;                             // jz short @@out

    *(word *)&g_memByte[379898] = 1;        // mov dseg_11F9E2, 1
    cseg_49EF4();                           // call cseg_49EF4
    cseg_490E6();                           // call cseg_490E6
    cseg_49261();                           // jmp cseg_49261
}

// =============== S U B R O U T I N E =======================================
//
void cseg_490E6()
{
    cseg_49181();                           // call cseg_49181
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 4, 17344);        // mov [esi+MenuEntry.fg.string], offset aPlayMatch_0
    CallDrawMenuItem();                     // call CallDrawMenuItem
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 5;                       // mov word ptr D0, 5
    CallDrawMultipleItems();                // jmp CallDrawMultipleItems
}

// =============== S U B R O U T I N E =======================================
//
void cseg_49181()
{
    cseg_89758();                           // call cseg_89758
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    writeMemory(esi + 38, 4, 17225);        // mov [esi+MenuEntry.fg.string], offset aV
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+691]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    eax = A1;                               // mov eax, A1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+691]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    eax = A1;                               // mov eax, A1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_49261()
{
    cseg_492AF();                           // call cseg_492AF
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 8;                       // mov word ptr D0, 8
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_492AF()
{
    ax = *(word *)&g_memByte[379900];       // mov ax, dseg_11F9E4
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4933C;                    // jz cseg_4933C

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 60, 2, 1);            // mov [esi+(MenuEntry.isInvisible+38h)], 1
    writeMemory(esi + 116, 2, 1);           // mov [esi+(MenuEntry.isInvisible+70h)], 1
    writeMemory(esi + 172, 2, 1);           // mov [esi+(MenuEntry.isInvisible+0A8h)], 1
    writeMemory(esi + 228, 2, 1);           // mov [esi+(MenuEntry.isInvisible+0E0h)], 1
    writeMemory(esi + 284, 2, 1);           // mov [esi+(MenuEntry.isInvisible+118h)], 1
    writeMemory(esi + 340, 2, 1);           // mov [esi+(MenuEntry.isInvisible+150h)], 1
    writeMemory(esi + 396, 2, 1);           // mov [esi+(MenuEntry.isInvisible+188h)], 1
    return;                                 // retn

cseg_4933C:;
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    ax = *(word *)&g_memByte[379906];       // mov ax, dseg_11F9EA
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_49410;                    // jz cseg_49410

    ax = *(word *)&g_memByte[379902];       // mov ax, dseg_11F9E6
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_49384;                    // jnz short cseg_49384

    *(word *)&g_memByte[252398] = 1;        // mov fireResetFlag, 1

cseg_49384:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 60, 2, 1);            // mov [esi+(MenuEntry.isInvisible+38h)], 1
    writeMemory(esi + 116, 2, 1);           // mov [esi+(MenuEntry.isInvisible+70h)], 1
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 60, 2, 1);            // mov [esi+(MenuEntry.isInvisible+38h)], 1
    writeMemory(esi + 116, 2, 1);           // mov [esi+(MenuEntry.isInvisible+70h)], 1
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    { SWOS::SetCurrentEntry(); return; }    // jmp SetCurrentEntry

cseg_49410:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+95]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4942F;                    // jz short cseg_4942F

    ax = *(word *)&g_memByte[379898];       // mov ax, dseg_11F9E2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_49447;                    // jle short cseg_49447

    goto cseg_49502;                        // jmp cseg_49502

cseg_4942F:;
    *(word *)&g_memByte[252398] = 1;        // mov fireResetFlag, 1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 16137);        // mov [esi+MenuEntry.fg.string], offset aNextRound
    goto cseg_49454;                        // jmp short cseg_49454

cseg_49447:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17361);        // mov [esi+MenuEntry.fg.string], offset aNextMatch

cseg_49454:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 60, 2, 1);            // mov [esi+(MenuEntry.isInvisible+38h)], 1
    writeMemory(esi + 116, 2, 1);           // mov [esi+(MenuEntry.isInvisible+70h)], 1
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 60, 2, 1);            // mov [esi+(MenuEntry.isInvisible+38h)], 1
    writeMemory(esi + 116, 2, 1);           // mov [esi+(MenuEntry.isInvisible+70h)], 1
    ax = *(word *)&g_memByte[379904];       // mov ax, dseg_11F9E8
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_494F4;                    // jz short cseg_494F4

    *(word *)&g_memByte[379904] = 0;        // mov dseg_11F9E8, 0
    *(word *)&D0 = 10;                      // mov word ptr D0, 10
    { SWOS::SetCurrentEntry(); return; }    // jmp SetCurrentEntry

cseg_494F4:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    { SWOS::SetCurrentEntry(); return; }    // jmp SetCurrentEntry

cseg_49502:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    cseg_88961();                           // call cseg_88961
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_495CD;                    // jz cseg_495CD

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto cseg_495CD;                    // jz cseg_495CD

    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    writeMemory(esi + 60, 2, 0);            // mov [esi+(MenuEntry.isInvisible+38h)], 0
    writeMemory(esi + 116, 2, 0);           // mov [esi+(MenuEntry.isInvisible+70h)], 0
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 60, 2, 1);            // mov [esi+(MenuEntry.isInvisible+38h)], 1
    writeMemory(esi + 116, 2, 1);           // mov [esi+(MenuEntry.isInvisible+70h)], 1
    ax = *(word *)&g_memByte[318704];       // mov ax, diySelectedButtonOrd
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    goto cseg_496F6;                        // jmp cseg_496F6

cseg_495CD:;
    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    writeMemory(esi + 60, 2, 0);            // mov [esi+(MenuEntry.isInvisible+38h)], 0
    writeMemory(esi + 116, 2, 0);           // mov [esi+(MenuEntry.isInvisible+70h)], 0
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    writeMemory(esi + 60, 2, 1);            // mov [esi+(MenuEntry.isInvisible+38h)], 1
    writeMemory(esi + 116, 2, 1);           // mov [esi+(MenuEntry.isInvisible+70h)], 1
    ax = *(word *)&g_memByte[129476];       // mov ax, dseg_E0052
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_496EA;                    // jz cseg_496EA

    *(word *)&D0 = 6;                       // mov word ptr D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1
    push(D0);                               // push D0
    D0 = 6;                                 // mov D0, 6
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 8;                                 // mov D0, 8
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A1;
        A1 = eax;
        eax = tmp;
    }                                       // xchg eax, A1
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 20, 2);     // mov ax, [esi+MenuEntry.x]
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 20, 2, ax);           // mov [esi+MenuEntry.x], ax
    writeMemory(esi + 24, 2, 202);          // mov [esi+MenuEntry.dwWidth], 202

cseg_496EA:;
    ax = *(word *)&g_memByte[318708];       // mov ax, diySavedEntryOrd
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_496F6:;
    SWOS::SetCurrentEntry();                // jmp SetCurrentEntry
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournament16BeforeDraw()
{
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 16
    ax = *(word *)&g_memByte[379896];       // mov ax, currentDiyLine
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, ax
    A6 = 318643;                            // mov A6, offset DIY_competitionStart
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 79, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+4Fh], 1
    if (flags.zero)
        goto cseg_4976E;                    // jz short cseg_4976E

    A0 = 3395;                              // mov A0, offset cseg_49E7A
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 4, eax);          // mov [esi+26h], eax

cseg_4976E:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+16h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    push(D0);                               // push D0
    D0 = 24;                                // mov D0, 24
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D0 = 6;                       // mov word ptr D0, 6

cseg_497A2:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov word ptr [esi+4], 0
    ax = *(word *)&g_memByte[318746];       // mov ax, dseg_10EF10
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_497C5;                    // jz short cseg_497C5

    writeMemory(esi + 4, 2, 1);             // mov word ptr [esi+4], 1

cseg_497C5:;
    ax = D2;                                // mov ax, word ptr D2
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+16h], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 38h
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_497A2;                    // jns short cseg_497A2

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 24;                                // mov D0, 18h
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    push(D2);                               // push D2
    push(D7);                               // push D7
    push(A6);                               // push A6
    SWOS::DrawMultipleItems();              // call DrawMultipleItems
    pop(A6);                                // pop A6
    pop(D7);                                // pop D7
    pop(D2);                                // pop D2
    push(D0);                               // push D0
    D0 = 24;                                // mov D0, 24
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+MenuEntry.dwHeight]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    ax = *(word *)&g_memByte[379890];       // mov ax, dseg_11F9DA
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = D7;                                // mov ax, word ptr D7
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 81, 2);
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul word ptr [esi+51h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    {
        word res = *(word *)&D7 << 1;
        flags.carry = ((word)*(word *)&D7 >> 15) & 1;
        *(word *)&D7 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D7, 1
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 31;                                // mov D0, 1Fh
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D5 = 1;                       // mov word ptr D5, 1

cseg_498FA:;
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    ax = (word)readMemory(esi + ebx + 109, 2); // mov ax, [esi+ebx+6Dh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A6;                               // mov eax, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A4 = eax;                               // mov A4, eax
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    ax = D5;                                // mov ax, word ptr D5
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, size MenuEntry
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    ax = D4;                                // mov ax, word ptr D4
    writeMemory(esi + 26, 2, ax);           // mov [esi+MenuEntry.dwHeight], ax
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+2B3h]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 2, 10);           // mov [esi+MenuEntry.bg.backAndFrameColor], COLOR_RED
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], 1
    if (flags.zero)
        goto l_set_team_name;               // jz short @@set_team_name

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 2, 11);           // mov [esi+MenuEntry.bg.backAndFrameColor], COLOR_PURPLISH
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], 2
    if (flags.zero)
        goto l_set_team_name;               // jz short @@set_team_name

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 2, 13);           // mov [esi+MenuEntry.bg.backAndFrameColor], COLOR_LIGHT_BLUE
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], 3
    if (flags.zero)
        goto l_set_team_name;               // jz short @@set_team_name

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 2, 6);            // mov [esi+MenuEntry.bg.backAndFrameColor], COLOR_ORANGE

l_set_team_name:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, TeamFile.teamName
    A0 = eax;                               // mov A0, eax
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    ax = *(word *)&g_memByte[379888];       // mov ax, dseg_11F9D8
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_49B48;                    // jz cseg_49B48

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+55h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    if (flags.zero)
        goto cseg_49B48;                    // jz cseg_49B48

    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (!flags.carry && !flags.zero)
        goto cseg_49A86;                    // ja short cseg_49A86

    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+55h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_49B21;                    // jz cseg_49B21

    goto cseg_49B16;                        // jmp cseg_49B16

cseg_49A86:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+55h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (flags.carry || flags.zero)
        goto cseg_49B21;                    // jbe short cseg_49B21

    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (flags.carry || flags.zero)
        goto cseg_49AEB;                    // jbe short cseg_49AEB

    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_49B21;                    // jz short cseg_49B21

    goto cseg_49B16;                        // jmp short cseg_49B16

cseg_49AEB:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (!flags.carry && !flags.zero)
        goto cseg_49B21;                    // ja short cseg_49B21

    *(word *)&D3 = 7;                       // mov word ptr D3, 7
    goto cseg_49B65;                        // jmp short cseg_49B65

cseg_49B16:;
    *(word *)&D3 = 7;                       // mov word ptr D3, 7
    goto cseg_49B2A;                        // jmp short cseg_49B2A

cseg_49B21:;
    *(word *)&D3 = 13;                      // mov word ptr D3, 0Dh

cseg_49B2A:;
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (!flags.zero)
        goto cseg_49B65;                    // jnz short cseg_49B65

    ax = D3;                                // mov ax, word ptr D3
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    goto cseg_49B65;                        // jmp short cseg_49B65

cseg_49B48:;
    *(word *)&D3 = 7;                       // mov word ptr D3, 7
    {
        word res = *(word *)&D5 & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D5, 1
    if (flags.zero)
        goto cseg_49B65;                    // jz short cseg_49B65

    *(word *)&D3 = 9;                       // mov word ptr D3, 9

cseg_49B65:;
    ax = *(word *)&g_memByte[378420];       // mov ax, viewTeamIndex
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_49B92;                    // jnz short cseg_49B92

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 30, 2, 12);           // mov word ptr [esi+1Eh], 0Ch

cseg_49B92:;
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, size MenuEntry
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    ax = D4;                                // mov ax, word ptr D4
    writeMemory(esi + 26, 2, ax);           // mov [esi+MenuEntry.dwHeight], ax
    ax = D3;                                // mov ax, word ptr D3
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 695, 2);    // mov ax, [esi+2B7h]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, size MenuEntry
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    ax = D4;                                // mov ax, word ptr D4
    writeMemory(esi + 26, 2, ax);           // mov [esi+MenuEntry.dwHeight], ax
    ax = D3;                                // mov ax, word ptr D3
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 697, 2);    // mov ax, [esi+2B9h]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, size MenuEntry
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    ax = D4;                                // mov ax, word ptr D4
    writeMemory(esi + 26, 2, ax);           // mov [esi+MenuEntry.dwHeight], ax
    ax = D3;                                // mov ax, word ptr D3
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 699, 2);    // mov ax, [esi+2BBh]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, size MenuEntry
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    ax = D4;                                // mov ax, word ptr D4
    writeMemory(esi + 26, 2, ax);           // mov [esi+MenuEntry.dwHeight], ax
    ax = D3;                                // mov ax, word ptr D3
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 701, 2);    // mov ax, [esi+2BDh]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, size MenuEntry
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    ax = D4;                                // mov ax, word ptr D4
    writeMemory(esi + 26, 2, ax);           // mov [esi+MenuEntry.dwHeight], ax
    ax = D3;                                // mov ax, word ptr D3
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 703, 2);    // mov ax, [esi+2BFh]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, size MenuEntry
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    ax = D4;                                // mov ax, word ptr D4
    writeMemory(esi + 26, 2, ax);           // mov [esi+MenuEntry.dwHeight], ax
    ax = D3;                                // mov ax, word ptr D3
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 705, 2);    // mov ax, [esi+2C1h]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A5 = res;
    }                                       // add A5, size MenuEntry
    ax = D2;                                // mov ax, word ptr D2
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    ax = D4;                                // mov ax, word ptr D4
    writeMemory(esi + 26, 2, ax);           // mov [esi+MenuEntry.dwHeight], ax
    ax = D3;                                // mov ax, word ptr D3
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 707, 2);    // mov ax, [esi+2C3h]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 38, 2, ax);           // mov [esi+MenuEntry.fg.number], ax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 31;                                // mov D0, 31
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 9;                       // mov word ptr D0, 9
    push(D2);                               // push D2
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D7);                               // push D7
    push(A5);                               // push A5
    push(A6);                               // push A6
    SWOS::DrawMultipleItems();              // call DrawMultipleItems
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(D7);                                // pop D7
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D2);                                // pop D2
    ax = *(word *)&g_memByte[379892];       // mov ax, dseg_11F9DC
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 2
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 1
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, ax
    if (flags.carry || flags.zero)
        goto cseg_498FA;                    // jbe cseg_498FA
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournamentScrollUp()
{
    ax = *(word *)&g_memByte[379896];       // mov ax, currentDiyLine
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    {
        word src = *(word *)&g_memByte[379896];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[379896] = src;
    }                                       // sub currentDiyLine, 1
    nullsub_14();                           // call nullsub_14
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void DIYLeagueTournamentScrollDown()
{
    ax = *(word *)&g_memByte[379896];       // mov ax, currentDiyLine
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[379894];       // mov ax, numDiyResults
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = *(word *)&g_memByte[318722];       // mov ax, dseg_10EEF8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        return;                             // jnb short cseg_49EF2

    {
        word src = *(word *)&g_memByte[379896];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[379896] = src;
    }                                       // add currentDiyLine, 1
    nullsub_14();                           // call nullsub_14
    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_14()
{
}

// =============== S U B R O U T I N E =======================================
//
void cseg_49EF4()
{
    cseg_49F01();                           // call cseg_49F01
    if (flags.zero)
        return;                             // jz short cseg_49F00

    SWOS::DrawMenu();                       // jmp DrawMenu
}

// =============== S U B R O U T I N E =======================================
//
void cseg_49F01()
{
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax = *(word *)&g_memByte[379898];       // mov ax, dseg_11F9E2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_49F49;                    // jz short cseg_49F49

    ax = *(word *)&g_memByte[318734];       // mov ax, dseg_10EF04
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word src = *(word *)&g_memByte[379898];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_11F9E2, 1
    if (flags.zero)
        goto cseg_49F49;                    // jz short cseg_49F49

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    if (!flags.sign)
        goto cseg_49F49;                    // jns short cseg_49F49

    ax = *(word *)&g_memByte[318722];       // mov ax, dseg_10EEF8
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_49F49:;
    *(word *)&D2 = 0;                       // mov word ptr D2, 0

cseg_49F52:;
    ax = *(word *)&g_memByte[379896];       // mov ax, currentDiyLine
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.carry)
        goto cseg_49F74;                    // jnb short cseg_49F74

    {
        word src = *(word *)&g_memByte[379896];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[379896] = src;
    }                                       // sub currentDiyLine, 1
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    goto cseg_49F52;                        // jmp short cseg_49F52

cseg_49F74:;
    ax = *(word *)&g_memByte[379896];       // mov ax, currentDiyLine
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[379894];       // mov ax, numDiyResults
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto cseg_49FAF;                    // jb short cseg_49FAF

    {
        word src = *(word *)&g_memByte[379896];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[379896] = src;
    }                                       // add currentDiyLine, 1
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    goto cseg_49F74;                        // jmp short cseg_49F74

cseg_49FAF:;
    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> game type string
//      A1 -> play what string
//      D0 =  num of teams needed
//      D2 =  show club teams flag
//      D3 =  show national teams flag
//      D4 =  show original custom teams flag
// out:
//      global var chooseTeamsResult: 0 = nothing selected, !0 = choice made
//
void GoGetTeamsForPlay()
{
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[330640] = ax;       // mov showClubTeams, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[330642] = ax;       // mov showNationalTeams, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&g_memByte[330644] = ax;       // mov showOrigCustomTeams, ax
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[330202] = eax;     // mov gameTypeStr, eax
    eax = A1;                               // mov eax, A1
    *(dword *)&g_memByte[330654] = eax;     // mov playWhatStr, eax
    *(dword *)&g_memByte[330658] = 0;       // mov chooseTeamsHeader1stPart, 0
    *(word *)&g_memByte[131757] = 0;        // mov g_numSelectedTeams, 0
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[330674] = ax;       // mov numNeededTeams, ax
    *(dword *)&g_memByte[330666] = 0;       // mov chooseTeamsFunc, 0
    *(word *)&g_memByte[330670] = 0;        // mov dseg_113491, 0
    *(word *)&g_memByte[330672] = 0;        // mov selectTamsNoLimit, 0
    A6 = 504785;                            // mov A6, offset chooseTeamsMenu
    SWOS::ShowMenu();                       // call ShowMenu
    ax = *(word *)&g_memByte[330638];       // mov ax, teamsType
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js short @@out

    *(word *)&g_memByte[330630] = 1;        // mov loadTeam, 1
    *(word *)&g_memByte[330632] = 0;        // mov showCupsAndOther, 0
    *(word *)&g_memByte[330634] = 0;        // mov playSeason, 0
    *(word *)&g_memByte[330636] = 0;        // mov dseg_11346F, 0
    *(byte *)&D0 = 255;                     // mov byte ptr D0, 255
    SelectTeamsFinalMenu();                 // call SelectTeamsFinalMenu
    A0 = 0;                                 // mov A0, 0
    SetZeroFlag();                          // call SetZeroFlag
}

// =============== S U B R O U T I N E =======================================

// in:
//     showClubTeams, showNationalTeams, showOrigCustomTeams
//     chooseTeamsHeader1stPart, gameTypeStr
// out:
//     output of the entire menu:
//         teamsType: 0 = national teams, 1 = club teams,
//                    2 = original custom teams, 3 = edited custom teams,
//                   -1 = none
//
// Sets up a menu to choose category of teams to further choose from. Lays out items according to
// given flags. If only one category is requested, jumps directly to the next menu for that category.
// This single category can only be club or national teams. And finally sets up the custom menu
// title: first part, if given, if not "CHOOSE TEAMS FOR" + game type string (if given).
//
void ChooseTeamsInit()
{
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    {
        word res = *(word *)&D7 >> 1;
        *(word *)&D7 = res;
    }                                       // shr word ptr D7, 1
    *(word *)&D6 = 4;                       // mov word ptr D6, 4
    ax = *(word *)&g_memByte[330640];       // mov ax, showClubTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_no_club_teams;               // jnz @@no_club_teams

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub [esi+MenuEntry.y], ax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub [esi+MenuEntry.y], ax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub [esi+MenuEntry.y], ax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

l_no_club_teams:;
    ax = *(word *)&g_memByte[330642];       // mov ax, showNationalTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_no_national_teams;           // jnz @@no_national_teams

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+MenuEntry.y], ax
    push(D0);                               // push D0
    D0 = 2;                                 // mov D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub [esi+MenuEntry.y], ax
    push(D0);                               // push D0
    D0 = 3;                                 // mov D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // sub [esi+MenuEntry.y], ax
    ax = *(word *)&g_memByte[330640];       // mov ax, showClubTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_no_national_teams;           // jnz short @@no_national_teams

    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

l_no_national_teams:;
    ax = *(word *)&g_memByte[330644];       // mov ax, showOrigCustomTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_no_org_cust_teams;           // jnz @@no_org_cust_teams

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 2
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+MenuEntry.y], ax
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+MenuEntry.y], ax
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+MenuEntry.y], ax
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+MenuEntry.y], ax

l_no_org_cust_teams:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, 1
    if (!flags.zero)
        goto l_choose_teams;                // jnz short @@choose_teams

    ax = *(word *)&g_memByte[330640];       // mov ax, showClubTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { ClubTeams(); return; }            // jnz short ClubTeams

    { NationalTeams(); return; }            // jmp NationalTeams

l_choose_teams:;
    push(D0);                               // push D0
    D0 = 5;                                 // mov D0, 5
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[330658];     // mov eax, chooseTeamsHeader1stPart
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (!flags.zero)
        goto l_has_str;                     // jnz short @@has_str

    A0 = 16545;                             // mov A0, offset aChooseTeamsFor

l_has_str:;
    StringCopy();                           // call StringCopy
    eax = *(dword *)&g_memByte[330202];     // mov eax, gameTypeStr
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        return;                             // jz short @@out

    StringCopy();                           // call StringCopy
}

// =============== S U B R O U T I N E =======================================
//
void ClubTeams()
{
    *(word *)&g_memByte[330638] = 1;        // mov teamsType, CLUB_TEAMS
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
    *(word *)&g_memByte[330698] = 0;        // mov viewSelectedTeams, 0
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    *(word *)&g_memByte[330700] = 0;        // mov abortSelectTeams, 0
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void NationalTeams()
{
    *(word *)&g_memByte[330638] = 0;        // mov teamsType, NATIONAL_TEAMS
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
    *(word *)&g_memByte[330698] = 0;        // mov viewSelectedTeams, 0
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    *(word *)&g_memByte[330700] = 0;        // mov abortSelectTeams, 0
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void OriginalCustomTeams()
{
    *(word *)&g_memByte[330638] = 2;        // mov teamsType, ORIGINAL_CUSTOM_TEAMS
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
    *(word *)&g_memByte[330698] = 0;        // mov viewSelectedTeams, 0
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    *(word *)&g_memByte[330700] = 0;        // mov abortSelectTeams, 0
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void EditedCustomTeams()
{
    *(word *)&g_memByte[330638] = 3;        // mov teamsType, EDITED_CUSTOM_TEAMS
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
    *(word *)&g_memByte[330698] = 0;        // mov viewSelectedTeams, 0
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    *(word *)&g_memByte[330700] = 0;        // mov abortSelectTeams, 0
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ExitChooseTeams()
{
    *(word *)&g_memByte[330638] = -1;       // mov teamsType, -1
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
    *(word *)&g_memByte[330698] = 0;        // mov viewSelectedTeams, 0
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    *(word *)&g_memByte[330700] = 1;        // mov abortSelectTeams, 1
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void SelectTeamsInit()
{
    SelectTeamsReinit();                    // call SelectTeamsReinit
    ax = *(word *)&g_memByte[330648];       // mov ax, stayInSelectTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_out;                         // jz short @@out

    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    { SelectLeaguesCommon(); return; }      // jmp SelectLeaguesCommon

l_out:;
    ax = *(word *)&g_memByte[330650];       // mov ax, exitFlag
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        ExitSelectTeams();                  // jnz ExitSelectTeams
}

// =============== S U B R O U T I N E =======================================
//
void SelectTeamsReinit()
{
    ax = *(word *)&g_memByte[330508];       // mov ax, chooseTeamsNumTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 2
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 3;                                 // mov bx, 3
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    ax = *(word *)&g_memByte[330506];       // mov ax, numLeaguesInCountry
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 18;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 18
    if (flags.carry || flags.zero)
        goto l_less_than_18;                // jbe @@less_than_18

    *(word *)&D1 = 10;                      // mov word ptr D1, 10
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 19;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 19
    if (flags.zero)
        goto l_equ_19;                      // jz short @@equ_19

    *(word *)&D1 = 15;                      // mov word ptr D1, 15

l_equ_19:;
    push(D0);                               // push D0
    D0 = 87;                                // mov D0, 87
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+MenuEntry.y], ax
    push(D0);                               // push D0
    D0 = 88;                                // mov D0, 88
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+MenuEntry.y], ax
    push(D0);                               // push D0
    D0 = 89;                                // mov D0, 89
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+MenuEntry.y], ax
    push(D0);                               // push D0
    D0 = 90;                                // mov D0, 90
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 22, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 22, 2, src);
    }                                       // add [esi+MenuEntry.y], ax

l_less_than_18:;
    ax = *(word *)&g_memByte[330524];       // mov ax, numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[330526];       // mov ax, topOfStackMark
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_not_on_stack_top;            // jnz short @@not_on_stack_top

    push(D0);                               // push D0
    D0 = 88;                                // mov D0, 88
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, 17196);        // mov [esi+MenuEntry.fg.string], offset aAbort
    ax = (word)readMemory(esi + 30, 2);     // mov ax, [esi+MenuEntry.bg.backAndFrameColor]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 65520;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFF0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, RED_10
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 30, 2, ax);           // mov [esi+MenuEntry.bg.backAndFrameColor], ax

l_not_on_stack_top:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[330658];     // mov eax, chooseTeamsHeader1stPart
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (!flags.zero)
        goto l_has_header_value;            // jnz short @@has_header_value

    A0 = 16545;                             // mov A0, offset aChooseTeamsFor
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[330674];       // mov ax, numNeededTeams
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_has_header_value;            // jnz short @@has_header_value

    A0 = 16563;                             // mov A0, offset aChangeTeamsFor

l_has_header_value:;
    StringCopy();                           // call StringCopy
    eax = *(dword *)&g_memByte[330202];     // mov eax, gameTypeStr
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 0
    if (flags.zero)
        goto l_no_game_type_str;            // jz short @@no_game_type_str

    StringCopy();                           // call StringCopy

l_no_game_type_str:;
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A0 = eax;                               // mov A0, eax
    GetStringLength();                      // call GetStringLength
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    eax = *(dword *)&g_memByte[330206];     // mov eax, curCountryStr
    A0 = eax;                               // mov A0, eax
    GetStringLength();                      // call GetStringLength
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 47;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 47
    if (!flags.carry && !flags.zero)
        goto l_not_enough_space;            // ja short @@not_enough_space

    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, '-');               // mov byte ptr [esi], '-'
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    eax = *(dword *)&g_memByte[330206];     // mov eax, curCountryStr
    A0 = eax;                               // mov A0, eax
    StringCopy();                           // call StringCopy

l_not_enough_space:;
    *(word *)&g_memByte[330510] = 0;        // mov startingTeamIndex, 0
    *(word *)&g_memByte[330512] = 0;        // mov teamsLowerBound, 0
    {
        word src = *(word *)&g_memByte[330508];
        int16_t dstSigned = src;
        int16_t srcSigned = 66;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp chooseTeamsNumTeams, 66
    if (flags.carry)
        goto l_less_than_66;                // jb short @@less_than_66

    *(word *)&g_memByte[330514] = 22;       // mov numTeamsColumn1, 22
    *(word *)&g_memByte[330516] = 21;       // mov numTeamsColumn2, 21
    *(word *)&g_memByte[330518] = 21;       // mov numTeamsColumn3, 21
    goto l_columns_calculated;              // jmp @@columns_calculated

l_less_than_66:;
    {
        word src = *(word *)&g_memByte[330508];
        int16_t dstSigned = src;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp chooseTeamsNumTeams, 8
    if (!flags.carry && !flags.zero)
        goto l_teams_between_8_and_66;      // ja short @@teams_between_8_and_66

    *(word *)&g_memByte[330514] = 0;        // mov numTeamsColumn1, 0
    ax = *(word *)&g_memByte[330508];       // mov ax, chooseTeamsNumTeams
    *(word *)&g_memByte[330516] = ax;       // mov numTeamsColumn2, ax
    *(word *)&g_memByte[330518] = 0;        // mov numTeamsColumn3, 0
    goto l_columns_calculated;              // jmp @@columns_calculated

l_teams_between_8_and_66:;
    ax = *(word *)&g_memByte[330508];       // mov ax, chooseTeamsNumTeams
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 3;                                 // mov bx, 3
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[330514] = ax;       // mov numTeamsColumn1, ax
    *(word *)&g_memByte[330516] = ax;       // mov numTeamsColumn2, ax
    *(word *)&g_memByte[330518] = ax;       // mov numTeamsColumn3, ax
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto l_not_one_team_remaining;      // jnz short @@not_one_team_remaining

    {
        word src = *(word *)&g_memByte[330508];
        int16_t dstSigned = src;
        int16_t srcSigned = 64;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp chooseTeamsNumTeams, 64
    if (!flags.zero)
        goto l_not_64_teams;                // jnz short @@not_64_teams

    {
        word src = *(word *)&g_memByte[330514];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[330514] = src;
    }                                       // add numTeamsColumn1, 1
    goto l_columns_calculated;              // jmp short @@columns_calculated

l_not_64_teams:;
    {
        word src = *(word *)&g_memByte[330516];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[330516] = src;
    }                                       // add numTeamsColumn2, 1
    goto l_columns_calculated;              // jmp short @@columns_calculated

l_not_one_team_remaining:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (!flags.zero)
        goto l_columns_calculated;          // jnz short @@columns_calculated

    {
        word src = *(word *)&g_memByte[330514];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[330514] = src;
    }                                       // add numTeamsColumn1, 1
    {
        word src = *(word *)&g_memByte[330516];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[330516] = src;
    }                                       // add numTeamsColumn2, 1

l_columns_calculated:;
    SetTeamsCoordinates();                  // call SetTeamsCoordinates
    SetLeagueNames();                       // call SetLeagueNames
    SetCountryNames();                      // call SetCountryNames
    ax = *(word *)&g_memByte[330200];       // mov ax, prevSelectedTeamEntry
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -1
    if (flags.zero)
        goto l_check_leagues_default_entry; // jz short @@check_leagues_default_entry

    push(D0);                               // push D0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 4, 2);      // mov ax, [esi+MenuEntry.isInvisible]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_set_default_entry;           // jz short @@set_default_entry

    *(word *)&D0 = -1;                      // mov word ptr D0, -1
    goto l_check_leagues_default_entry;     // jmp short @@check_leagues_default_entry

l_set_default_entry:;
    SWOS::SetCurrentEntry();                // call SetCurrentEntry
    goto l_out;                             // jmp short @@out

l_check_leagues_default_entry:;
    ax = *(word *)&g_memByte[330508];       // mov ax, chooseTeamsNumTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_out;                         // jnz short @@out

    *(word *)&D0 = 11;                      // mov word ptr D0, 11
    SWOS::SetCurrentEntry();                // call SetCurrentEntry

l_out:;
    CheckNumberOfTeams();                   // jmp CheckNumberOfTeams
}

// =============== S U B R O U T I N E =======================================
//
void SetLeagueNames()
{
    ax = *(word *)&g_memByte[330506];       // mov ax, numLeaguesInCountry
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    A1 = 330210;                            // mov A1, offset teamNames
    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[330508];       // mov ax, chooseTeamsNumTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[330506];       // mov ax, numLeaguesInCountry
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

l_entries_loop:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A2 = eax;                               // mov A2, eax
    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '.';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], '.'
    if (!flags.zero)
        goto l_next;                        // jnz short @@next

    esi = A0;                               // mov esi, A0
    writeMemory(esi + 30, 2, 7);            // mov [esi+MenuEntry.bg.backAndFrameColor], PINK_TO_BROWN_7

l_next:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_entries_loop;                // jns short @@entries_loop
}

// =============== S U B R O U T I N E =======================================

// Also make non showing team entries invisible.
//
void SetCountryNames()
{
    A1 = 330250;                            // mov A1, offset countryNames
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 21;                                // mov D0, 21
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[330510];       // mov ax, startingTeamIndex
    *(word *)&D6 = ax;                      // mov word ptr D6, ax

l_team_entries_loop:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    ax = *(word *)&g_memByte[330508];       // mov ax, chooseTeamsNumTeams
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D6, ax
    if (!flags.carry && !flags.zero)
        goto l_next;                        // ja @@next

    ax = *(word *)&g_memByte[330512];       // mov ax, teamsLowerBound
    *(word *)&D2 = ax;                      // mov word ptr D2, ax

l_calc_next_team:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 21;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 21
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 22;                                // mov bx, 22
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_not_first_column;            // jnz short @@not_first_column

    ax = *(word *)&g_memByte[330514];       // mov ax, numTeamsColumn1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    goto l_check_if_showing_this_team;      // jmp short @@check_if_showing_this_team

l_not_first_column:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (!flags.zero)
        goto l_third_column;                // jnz short @@third_column

    ax = *(word *)&g_memByte[330516];       // mov ax, numTeamsColumn2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    goto l_check_if_showing_this_team;      // jmp short @@check_if_showing_this_team

l_third_column:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[330518];       // mov ax, numTeamsColumn3
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax

l_check_if_showing_this_team:;
    ax = D0;                                // mov ax, word ptr D0
    {
        word tmp = *(word *)((byte *)&D0 + 2);
        *(word *)((byte *)&D0 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D0+2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto l_make_entry_invisible;        // jb short @@make_entry_invisible

    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry)
        goto l_show_entry;                  // jb short @@show_entry

l_make_entry_invisible:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 56
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 87;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+MenuEntry.ordinal], 87
    if (flags.zero)
        return;                             // jz short @@out

    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    goto l_calc_next_team;                  // jmp @@calc_next_team

l_show_entry:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = '.';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], '.'
    if (!flags.zero)
        goto l_next;                        // jnz short @@next

    esi = A2;                               // mov esi, A2
    writeMemory(esi + 30, 2, 7);            // mov [esi+MenuEntry.bg.backAndFrameColor], PINK_TO_BROWN_7

l_next:;
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 56
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 2, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 87;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+MenuEntry.ordinal], 87
    if (flags.zero)
        return;                             // jz short @@out

    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    goto l_team_entries_loop;               // jmp @@team_entries_loop
}

// =============== S U B R O U T I N E =======================================
//
void ViewSelectedTeams()
{
    *(word *)&g_memByte[330698] = 1;        // mov viewSelectedTeams, 1
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    *(word *)&g_memByte[330700] = 0;        // mov abortSelectTeams, 0
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ChooseTeamsPlayGame()
{
    *(word *)&g_memByte[330186] = -1;       // mov selectedTeamIndex, -1
    *(word *)&g_memByte[330188] = -1;       // mov selectedLeagueIndex, -1
    *(word *)&g_memByte[330694] = 1;        // mov chooseTeamsResult, 1
    *(word *)&g_memByte[330698] = 0;        // mov viewSelectedTeams, 0
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    *(word *)&g_memByte[330700] = 0;        // mov abortSelectTeams, 0
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void ExitSelectTeams()
{
    *(word *)&g_memByte[330186] = -1;       // mov selectedTeamIndex, -1
    *(word *)&g_memByte[330188] = -1;       // mov selectedLeagueIndex, -1
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
    *(word *)&g_memByte[330698] = 0;        // mov viewSelectedTeams, 0
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    ax = *(word *)&g_memByte[330524];       // mov ax, numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_sel_teams_stack_empty;       // jz short @@sel_teams_stack_empty

    ax = *(word *)&g_memByte[330526];       // mov ax, topOfStackMark
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_sel_teams_stack_empty;       // jz short @@sel_teams_stack_empty

    *(word *)&g_memByte[330702] = 1;        // mov exitSelectTeams, 1
    *(word *)&g_memByte[330700] = 0;        // mov abortSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
    return;                                 // retn

l_sel_teams_stack_empty:;
    *(word *)&g_memByte[330700] = 1;        // mov abortSelectTeams, 1
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void SelectTeamsCommon()
{
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = ' ';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], ' '
    if (flags.zero)
        return;                             // jz @@out

    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[330184] = ax;       // mov lastSelectedTeam, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 21;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 21
    ax = *(word *)&g_memByte[330510];       // mov ax, startingTeamIndex
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 22;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 22
    if (flags.carry)
        goto l_first_column;                // jb short @@first_column

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 44;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 44
    if (flags.carry)
        goto l_second_column;               // jb short @@second_column

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 22;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 22
    ax = *(word *)&g_memByte[330516];       // mov ax, numTeamsColumn2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax

l_second_column:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 22;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 22
    ax = *(word *)&g_memByte[330514];       // mov ax, numTeamsColumn1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax

l_first_column:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[330186] = ax;       // mov selectedTeamIndex, ax
    *(word *)&g_memByte[330188] = -1;       // mov selectedLeagueIndex, -1
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    *(dword *)&g_memByte[330190] = eax;     // mov selectedTeamText, eax
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
    *(word *)&g_memByte[330698] = 0;        // mov viewSelectedTeams, 0
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    *(word *)&g_memByte[330700] = 0;        // mov abortSelectTeams, 0
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================
//
void SelectLeaguesCommon()
{
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = ' ';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], ' '
    if (flags.zero)
        return;                             // jz @@out

    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+MenuEntry.ordinal]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[330184] = ax;       // mov lastSelectedTeam, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 10
    if (flags.carry)
        goto cseg_4AE5B;                    // jb short cseg_4AE5B

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 10

cseg_4AE5B:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[330188] = ax;       // mov selectedLeagueIndex, ax
    *(word *)&g_memByte[330186] = -1;       // mov selectedTeamIndex, -1
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    *(dword *)&g_memByte[330190] = eax;     // mov selectedTeamText, eax
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
    *(word *)&g_memByte[330698] = 0;        // mov viewSelectedTeams, 0
    *(word *)&g_memByte[330696] = 0;        // mov changeTeams, 0
    *(word *)&g_memByte[330700] = 0;        // mov abortSelectTeams, 0
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    SetExitMenuFlag();                      // call SetExitMenuFlag
}

// =============== S U B R O U T I N E =======================================

// Set y coordinates based on columns.
// Also sets coordinates for leagues (whatever is shown).
//
void SetTeamsCoordinates()
{
    ax = *(word *)&g_memByte[330514];       // mov ax, numTeamsColumn1
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[330516];       // mov ax, numTeamsColumn2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry && !flags.zero)
        goto l_column1_max;                 // ja short @@column1_max

    ax = *(word *)&g_memByte[330516];       // mov ax, numTeamsColumn2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_column1_max:;
    ax = *(word *)&g_memByte[330518];       // mov ax, numTeamsColumn3
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.carry && !flags.zero)
        goto l_column3_smaller;             // ja short @@column3_smaller

    ax = *(word *)&g_memByte[330518];       // mov ax, numTeamsColumn3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

l_column3_smaller:;
    ax = *(word *)&g_memByte[330506];       // mov ax, numLeaguesInCountry
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    push(D0);                               // push D0
    D0 = 0;                                 // mov D0, 0
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 26, 2);     // mov ax, [esi+MenuEntry.dwHeight]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[330520] = ax;       // mov headerYPlusHeight, ax
    push(D0);                               // push D0
    D0 = 88;                                // mov D0, 88
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 22, 2);     // mov ax, [esi+MenuEntry.y]
    *(word *)&g_memByte[330522] = ax;       // mov exitY, ax
    ax = D1;                                // mov ax, word ptr D1
    bx = 9;                                 // mov bx, 9
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    ax = *(word *)&g_memByte[330522];       // mov ax, exitY
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[330520];       // mov ax, headerYPlusHeight
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1
    ax = *(word *)&g_memByte[330520];       // mov ax, headerYPlusHeight
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, ax
    ax = *(word *)&g_memByte[330506];       // mov ax, numLeaguesInCountry
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_leagues;                  // jz @@no_leagues

    ax = *(word *)&g_memByte[330508];       // mov ax, chooseTeamsNumTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    push(D0);                               // push D0
    D0 = 11;                                // mov D0, 11
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[330506];       // mov ax, numLeaguesInCountry
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

l_set_remaining_entries_loop:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 9
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto l_set_remaining_entries_loop;  // jns short @@set_remaining_entries_loop

    goto l_no_leagues;                      // jmp @@no_leagues

    push(D0);                               // push D0
    D0 = 1;                                 // mov D0, 1
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[330506];       // mov ax, numLeaguesInCountry
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    {
        word res = *(word *)&D2 >> 1;
        *(word *)&D2 = res;
    }                                       // shr word ptr D2, 1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_4B091:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 56
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 9
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_4B091;                    // jns short cseg_4B091

l_no_leagues:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 2
    push(D0);                               // push D0
    D0 = 21;                                // mov D0, 21
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    *(word *)&D2 = 2;                       // mov word ptr D2, 2

l_next_column:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D3 = 21;                      // mov word ptr D3, 21

l_next_team:;
    ax = D0;                                // mov ax, word ptr D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 2, ax);           // mov [esi+MenuEntry.y], ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 9;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 9
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 56;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 56
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto l_next_team;                   // jns short @@next_team

    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto l_next_column;                 // jns short @@next_column
}

// =============== S U B R O U T I N E =======================================

// Set field of select n more teams if needed.
//
// [select_teams_menu proc]
//
void CheckNumberOfTeams()
{
    ax = *(word *)&g_memByte[330672];       // mov ax, selectTamsNoLimit
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_honour_limitation;           // jz short @@honour_limitation

    push(D0);                               // push D0
    D0 = 89;                                // mov D0, 89
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    push(D0);                               // push D0
    D0 = 90;                                // mov D0, 90
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    push(D0);                               // push D0
    D0 = 87;                                // mov D0, 87
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    return;                                 // retn

l_honour_limitation:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 89;                                // mov D0, 89
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 90;                                // mov D0, 90
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[330674];       // mov ax, numNeededTeams
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_enough_teams_selected;       // jz short @@enough_teams_selected

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    goto l_set_view_selected_teams_field;   // jmp short @@set_view_selected_teams_field

l_enough_teams_selected:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 34, 2, 2);            // mov [esi+MenuEntry.content], ENTRY_STRING
    eax = *(dword *)&g_memByte[330654];     // mov eax, playWhatStr
    writeMemory(esi + 38, 4, eax);          // mov [esi+MenuEntry.fg.string], eax

l_set_view_selected_teams_field:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 87;                                // mov D0, 87
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 4, 2, 0);             // mov [esi+MenuEntry.isInvisible], 0
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_some_teams_selected;         // jnz short @@some_teams_selected

    writeMemory(esi + 4, 2, 1);             // mov [esi+MenuEntry.isInvisible], 1

l_some_teams_selected:;
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    D0 = 90;                                // mov D0, 90
    CalcMenuEntryAddress();                 // call CalcMenuEntryAddress
    pop(D0);                                // pop D0
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A5;
        A5 = eax;
        eax = tmp;
    }                                       // xchg eax, A5
    A0 = eax;                               // mov A0, eax
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 38, 4);          // mov eax, [esi+MenuEntry.fg.string]
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[330674];       // mov ax, numNeededTeams
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    if (flags.zero)
        goto l_error;                       // jz short @@error

    if (!flags.sign)
        goto l_too_many_teams;              // jns short @@too_many_teams

    *(int16_t *)&D0 = -*(int16_t *)&D0;     // neg word ptr D0
    A0 = 16368;                             // mov A0, offset aSelect1MoreTea
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto l_copy;                        // jz short @@copy

    A0 = 16346;                             // mov A0, offset aSelect0MoreTea
    goto l_printf_it;                       // jmp short @@printf_it

l_too_many_teams:;
    A0 = 16412;                             // mov A0, offset aSelect1LessTea
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1
    if (flags.zero)
        goto l_copy;                        // jz short @@copy

    A0 = 16390;                             // mov A0, offset aSelect0LessTea

l_printf_it:;
    PrintFormatted();                       // call PrintFormatted
    return;                                 // retn

l_error:;
    A0 = 331620;                            // mov A0, offset aError

l_copy:;
    StringCopy();                           // call StringCopy
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team file number
//
// Also reads teamsType.
//
void SelectTeamsFinalMenu()
{
    *(word *)&g_memByte[330652] = 0;        // mov leagueNumber, 0
    A0 = 32735;                             // mov A0, offset customsLeague
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 9, 1, 3);             // mov byte ptr [esi+9], 3
    writeMemory(esi + 13, 1, 20);           // mov byte ptr [esi+13], 20
    {
        word src = *(word *)&g_memByte[330638];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamsType, EDITED_CUSTOM_TEAMS
    if (!flags.zero)
        goto l_not_edited_custom_teams;     // jnz short @@not_edited_custom_teams

    push(D0);                               // push D0
    *(word *)&D0 = 100;                     // mov word ptr D0, 100
    LoadTeamFile();                         // call LoadTeamFile
    pop(D0);                                // pop D0
    if (!flags.zero)
        goto l_err_out;                     // jnz @@err_out

    ax = *(word *)&g_memByte[252466];       // mov ax, word ptr teamFileBuffer
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    {
        int16_t dstSigned = ax;
        int16_t srcSigned = 48;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp ax, 48
    if (!flags.zero)
        goto l_not_edited_custom_teams;     // jnz short @@not_edited_custom_teams

    A0 = 32735;                             // mov A0, offset customsLeague
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 9, 1, 1);             // mov byte ptr [esi+9], 1
    writeMemory(esi + 13, 1, 48);           // mov byte ptr [esi+13], 48

l_not_edited_custom_teams:;
    A0 = 32735;                             // mov A0, offset customsLeague
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 9, 1, 1);             // mov byte ptr [esi+9], 1
    writeMemory(esi + 13, 1, 48);           // mov byte ptr [esi+13], 48
    *(word *)&g_memByte[330702] = 0;        // mov exitSelectTeams, 0
    *(word *)&g_memByte[330624] = 0;        // mov isCountryNumber, 0
    *(word *)&g_memByte[330622] = 0;        // mov isContestContinentalCup, 0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 255;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 255
    if (flags.zero)
        goto l_ext_255;                     // jz short @@ext_255

    al = D0;                                // mov al, byte ptr D0
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    {
        word res = *(word *)&D6 & 255;
        *(word *)&D6 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D6, 0FFh
    al = D6;                                // mov al, byte ptr D6
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    *(word *)&g_memByte[330524] = 2;        // mov numSelectedTeams, 2
    *(word *)&g_memByte[330526] = 2;        // mov topOfStackMark, 2
    goto cseg_4B4F1;                        // jmp short cseg_4B4F1

l_ext_255:;
    *(word *)&D6 = 254;                     // mov word ptr D6, 254
    {
        word src = *(word *)&g_memByte[330638];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamsType, EDITED_CUSTOM_TEAMS
    if (flags.zero)
        goto l_edited_custom_teams;         // jz short @@edited_custom_teams

    {
        word src = *(word *)&g_memByte[330638];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamsType, ORIGINAL_CUSTOM_TEAMS
    if (!flags.zero)
        goto l_init_team_number_and_stack;  // jnz short @@init_team_number_and_stack

    *(word *)&D6 = 72;                      // mov word ptr D6, 72
    goto l_init_team_number_and_stack;      // jmp short @@init_team_number_and_stack

l_edited_custom_teams:;
    *(word *)&D6 = 100;                     // mov word ptr D6, 100

l_init_team_number_and_stack:;
    al = D6;                                // mov al, byte ptr D6
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    *(word *)&g_memByte[330526] = 0;        // mov topOfStackMark, 0
    *(word *)&g_memByte[330524] = 0;        // mov numSelectedTeams, 0

cseg_4B4F1:;
    SetSelectedTeamsStackTop();             // call SetSelectedTeamsStackTop
    *(dword *)&g_memByte[330528] = 330532;  // mov countryStackPtr, offset countriesStack

cseg_4B500:;
    {
        word res = *(word *)&D7 & 255;
        *(word *)&D7 = res;
    }                                       // and word ptr D7, 0FFh
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[330624];       // mov ax, isCountryNumber
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4B52C;                    // jz short cseg_4B52C

    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_4B52C:;
    GetCountryName();                       // call GetCountryName
    *(word *)&g_memByte[330628] = 0;        // mov gotCountryName, 0
    {
        word src = *(word *)&g_memByte[330524];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numSelectedTeams, 2
    if (!flags.zero)
        goto l_get_comp_table_ptr;          // jnz short @@get_comp_table_ptr

    ax = *(word *)&g_memByte[330624];       // mov ax, isCountryNumber
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_get_comp_table_ptr;          // jnz short @@get_comp_table_ptr

    *(word *)&g_memByte[330628] = 1;        // mov gotCountryName, 1

l_get_comp_table_ptr:;
    *(word *)&g_memByte[330646] = 0;        // mov numberOfLeagues, 0
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A4 = 33933;                             // mov A4, offset competitionsTable
    esi = A4;                               // mov esi, A4
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    A4 = eax;                               // mov A4, eax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, 0
    if (!flags.zero)
        goto l_got_pointer_ok;              // jnz short @@got_pointer_ok

    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop

l_got_pointer_ok:;
    A2 = 330210;                            // mov A2, offset teamNames
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    eax = A4;                               // mov eax, A4
    A5 = eax;                               // mov A5, eax
    A3 = 330562;                            // mov A3, offset leaguesPtrTable
    A4 = 330602;                            // mov A4, offset leagueNumbersTable

l_cur_country_table_next_competition_ptr:;
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 4
    A1 = eax;                               // mov A1, eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, -1
    if (flags.zero)
        goto l_no_more_competition_ptrs_for_country; // jz @@no_more_competition_ptrs_for_country

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = -2;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, -2
    if (!flags.zero)
        goto l_test_pointer;                // jnz short @@test_pointer

    ax = *(word *)&g_memByte[330632];       // mov ax, showCupsAndOther
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_more_competition_ptrs_for_country; // jz @@no_more_competition_ptrs_for_country

    goto l_cur_country_table_next_competition_ptr; // jmp short @@cur_country_table_next_competition_ptr

l_test_pointer:;
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto l_test_is_euro_champions;      // jnz @@test_is_euro_champions

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 29691;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset africanNationsCup
    if (!flags.zero)
        goto l_not_african_nations_cup;     // jnz short @@not_african_nations_cup

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 81;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, CN_AFRICA
    if (!flags.zero)
        goto l_cur_country_table_next_competition_ptr; // jnz short @@cur_country_table_next_competition_ptr

    goto l_continent;                       // jmp short @@continent

l_not_african_nations_cup:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 29621;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset copaAmerica
    if (!flags.zero)
        goto l_not_copa_america;            // jnz short @@not_copa_america

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 82;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, CN_SOUTH_AMERICA
    if (!flags.zero)
        goto l_cur_country_table_next_competition_ptr; // jnz short @@cur_country_table_next_competition_ptr

    goto l_continent;                       // jmp short @@continent

l_not_copa_america:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 29739;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset northAmericanCup
    if (!flags.zero)
        goto l_not_north_american_cup;      // jnz short @@not_north_american_cup

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 83;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, CN_NORTH_AMERICA
    if (!flags.zero)
        goto l_cur_country_table_next_competition_ptr; // jnz @@cur_country_table_next_competition_ptr

    goto l_continent;                       // jmp short @@continent

l_not_north_american_cup:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 29785;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset asianCup
    if (!flags.zero)
        goto l_not_asian_cup;               // jnz short @@not_asian_cup

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 84;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, CN_ASIA
    if (!flags.zero)
        goto l_cur_country_table_next_competition_ptr; // jnz @@cur_country_table_next_competition_ptr

    goto l_continent;                       // jmp short @@continent

l_not_asian_cup:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 29833;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset oceaniaCup
    if (!flags.zero)
        goto l_test_is_euro_champions;      // jnz short @@test_is_euro_champions

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 85;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, CN_OCEANIA
    if (!flags.zero)
        goto l_cur_country_table_next_competition_ptr; // jnz @@cur_country_table_next_competition_ptr

l_continent:;
    {
        byte src = g_memByte[91678];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 2
    if (flags.zero)
        goto l_cur_country_table_next_competition_ptr; // jz @@cur_country_table_next_competition_ptr

l_test_is_euro_champions:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 29227;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset europeanChampionships
    if (!flags.zero)
        goto l_not_european_championships;  // jnz short @@not_european_championships

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto l_not_european_championships;  // jnz short @@not_european_championships

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, CN_EUROPE
    if (!flags.zero)
        goto l_cur_country_table_next_competition_ptr; // jnz @@cur_country_table_next_competition_ptr

    {
        byte src = g_memByte[91678];
        byte res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 1
    if (!flags.zero)
        goto l_not_european_championships;  // jnz short @@not_european_championships

    {
        byte src = g_memByte[91678];
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 2
    if (flags.zero)
        goto l_cur_country_table_next_competition_ptr; // jz @@cur_country_table_next_competition_ptr

l_not_european_championships:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 252;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, 252
    if (flags.zero)
        goto l_world_cup_qualifications;    // jz short @@world_cup_qualifications

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 28645;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset northAmericaWorldCupQualification
    if (flags.zero)
        goto l_world_cup_qualifications;    // jz short @@world_cup_qualifications

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 28717;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset southAmericaWorldCupQualification
    if (flags.zero)
        goto l_world_cup_qualifications;    // jz short @@world_cup_qualifications

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 28781;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset africaWorldCupQualification
    if (flags.zero)
        goto l_world_cup_qualifications;    // jz short @@world_cup_qualifications

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 28893;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset asiaWorldCupQualification
    if (flags.zero)
        goto l_world_cup_qualifications;    // jz short @@world_cup_qualifications

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 29001;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset oceaniaWorldCupQualification
    if (!flags.zero)
        goto l_not_world_cup_qualifications; // jnz short @@not_world_cup_qualifications

l_world_cup_qualifications:;
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto l_cur_country_table_next_competition_ptr; // jnz @@cur_country_table_next_competition_ptr

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_cur_country_table_next_competition_ptr; // jz @@cur_country_table_next_competition_ptr

    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto l_cur_country_table_next_competition_ptr; // jz @@cur_country_table_next_competition_ptr

l_not_world_cup_qualifications:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 28229;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset worldCup
    if (!flags.zero)
        goto l_not_world_cup;               // jnz short @@not_world_cup

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto l_not_world_cup;               // jnz short @@not_world_cup

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_cur_country_table_next_competition_ptr; // jz @@cur_country_table_next_competition_ptr

    {
        byte src = g_memByte[91678];
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 80h
    if (flags.zero)
        goto l_cur_country_table_next_competition_ptr; // jz @@cur_country_table_next_competition_ptr

l_not_world_cup:;
    ax = *(word *)&g_memByte[330632];       // mov ax, showCupsAndOther
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_check_if_its_pointer;        // jnz short @@check_if_its_pointer

    {
        word src = *(word *)&g_memByte[330638];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamsType, ORIGINAL_CUSTOM_TEAMS
    if (flags.zero)
        goto l_check_if_its_pointer;        // jz short @@check_if_its_pointer

    {
        word src = *(word *)&g_memByte[330638];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamsType, EDITED_CUSTOM_TEAMS
    if (flags.zero)
        goto l_check_if_its_pointer;        // jz short @@check_if_its_pointer

    {
        word src = *(word *)&g_memByte[330524];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numSelectedTeams, 2
    if (!flags.zero)
        goto l_cur_country_table_next_competition_ptr; // jnz @@cur_country_table_next_competition_ptr

l_check_if_its_pointer:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 256;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, 256
    if (!flags.carry)
        goto l_its_a_pointer;               // jnb @@its_a_pointer

    eax = A1;                               // mov eax, A1
    D0 = eax;                               // mov D0, eax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 24755;                             // mov A0, offset countriesTable
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 1
    A0 = eax;                               // mov A0, eax
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 4
    eax = A1;                               // mov eax, A1
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 4
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 2, -1);                // mov word ptr [esi], -1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    goto l_cur_country_table_next_competition_ptr; // jmp @@cur_country_table_next_competition_ptr

l_its_a_pointer:;
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 0
    if (flags.zero)
        goto l_its_a_division;              // jz short @@its_a_division

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 1
    if (flags.zero)
        goto l_its_a_cup;                   // jz @@its_a_cup

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 2
    if (flags.zero)
        goto l_its_a_competition;           // jz @@its_a_competition

l_its_a_division:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0

l_next_competition:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_custom_division_name;        // jnz short @@custom_division_name

    A0 = 331832;                            // mov A0, offset divisionsTable
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    A0 = eax;                               // mov A0, eax
    {
        word res = *(word *)&D0 >> 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 2
    goto l_got_competition_name;            // jmp short @@got_competition_name

l_custom_division_name:;
    al = D2;                                // mov al, byte ptr D2
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    {
        word res = *(word *)&D0 << 3;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 3
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, offset aChairmanScenes
    A0 = eax;                               // mov A0, eax
    {
        word res = *(word *)&D0 >> 3;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 3

l_got_competition_name:;
    eax = A0;                               // mov eax, A0
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 4
    eax = A1;                               // mov eax, A1
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 4
    ax = D0;                                // mov ax, word ptr D0
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 9, 1);      // mov al, [esi+9]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto l_next_competition;            // jnz @@next_competition

    al = (byte)readMemory(esi + 9, 1);      // mov al, [esi+9]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[330646] = ax;       // mov numberOfLeagues, ax
    goto l_cur_country_table_next_competition_ptr; // jmp @@cur_country_table_next_competition_ptr

l_its_a_cup:;
    A0 = 18110;                             // mov A0, offset aCup
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_no_custom_cup_name;          // jz short @@no_custom_cup_name

    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, offset aChairmanScenes
    A0 = eax;                               // mov A0, eax

l_no_custom_cup_name:;
    eax = A0;                               // mov eax, A0
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 4
    eax = A1;                               // mov eax, A1
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 4
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 2, -1);                // mov word ptr [esi], -1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    goto l_cur_country_table_next_competition_ptr; // jmp @@cur_country_table_next_competition_ptr

l_its_a_competition:;
    A0 = 18143;                             // mov A0, offset aLeague
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto l_no_custom_league_name;       // jz short @@no_custom_league_name

    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, offset aChairmanScenes
    A0 = eax;                               // mov A0, eax

l_no_custom_league_name:;
    eax = A0;                               // mov eax, A0
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 4
    eax = A1;                               // mov eax, A1
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 4
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 2, -1);                // mov word ptr [esi], -1
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    goto l_cur_country_table_next_competition_ptr; // jmp @@cur_country_table_next_competition_ptr

l_no_more_competition_ptrs_for_country:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[330506] = ax;       // mov numLeaguesInCountry, ax
    A2 = 330250;                            // mov A2, offset countryNames
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 254;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 254
    if (flags.zero)
        goto l_world;                       // jz short @@world

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 80;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, CN_EUROPE
    if (flags.carry)
        goto l_last_continent_country;      // jb @@last_continent_country

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 85;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, CN_OCEANIA
    if (!flags.carry && !flags.zero)
        goto l_last_continent_country;      // ja @@last_continent_country

l_world:;
    eax = A5;                               // mov eax, A5
    A0 = eax;                               // mov A0, eax

l_read_continent_countries:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 255;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 255
    if (flags.zero)
        goto l_last_continent_country;      // jz short @@last_continent_country

    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A1 = 24755;                             // mov A1, offset countriesTable
    esi = A1;                               // mov esi, A1
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 1
    A1 = eax;                               // mov A1, eax
    esi = A2;                               // mov esi, A2
    writeMemory(esi, 4, eax);               // mov [esi], eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 4
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    goto l_read_continent_countries;        // jmp short @@read_continent_countries

l_last_continent_country:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[330508] = ax;       // mov chooseTeamsNumTeams, ax
    *(word *)&g_memByte[330648] = 0;        // mov stayInSelectTeams, 0
    *(word *)&g_memByte[330650] = 0;        // mov exitFlag, 0
    ax = *(word *)&g_memByte[330632];       // mov ax, showCupsAndOther
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_finished_show_menu;          // jnz short @@finished_show_menu

    ax = *(word *)&g_memByte[330508];       // mov ax, chooseTeamsNumTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_finished_show_menu;          // jnz short @@finished_show_menu

    {
        word src = *(word *)&g_memByte[330506];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numLeaguesInCountry, 1
    if (!flags.zero)
        goto l_finished_show_menu;          // jnz short @@finished_show_menu

    ax = *(word *)&g_memByte[330702];       // mov ax, exitSelectTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4BBF2;                    // jz short cseg_4BBF2

    *(word *)&g_memByte[330650] = 1;        // mov exitFlag, 1
    goto l_finished_show_menu;              // jmp short @@finished_show_menu

cseg_4BBF2:;
    *(word *)&g_memByte[330648] = 1;        // mov stayInSelectTeams, 1

l_finished_show_menu:;
    GetSelectedTeamsStackTop();             // call GetSelectedTeamsStackTop
    A6 = 504995;                            // mov A6, offset selectTeamsMenu
    push(D7);                               // push D7
    push(A4);                               // push A4
    push(A5);                               // push A5
    SWOS::ShowMenu();                       // call ShowMenu
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(D7);                                // pop D7
    ax = *(word *)&g_memByte[330694];       // mov ax, chooseTeamsResult
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[330700];       // mov ax, abortSelectTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    ax = *(word *)&g_memByte[330698];       // mov ax, viewSelectedTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_view_selected_teams;         // jnz @@view_selected_teams

    ax = *(word *)&g_memByte[330186];       // mov ax, selectedTeamIndex
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto l_team_selected;               // jns short @@team_selected

    ax = *(word *)&g_memByte[330188];       // mov ax, selectedLeagueIndex
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_no_league_selected;          // js short @@no_league_selected

    PushLastSelectedTeam();                 // call PushLastSelectedTeam
    ax = *(word *)&g_memByte[330630];       // mov ax, loadTeam
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_load_team;                   // jnz @@load_team

    ax = *(word *)&g_memByte[330634];       // mov ax, playSeason
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4BD6D;                    // jnz cseg_4BD6D

    goto cseg_4BF2A;                        // jmp cseg_4BF2A

l_no_league_selected:;
    ax = *(word *)&g_memByte[330524];       // mov ax, numSelectedTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    *(word *)&g_memByte[330624] = 0;        // mov isCountryNumber, 0
    PopContinent();                         // call PopContinent
    goto cseg_4B500;                        // jmp cseg_4B500

l_team_selected:;
    PushLastSelectedTeam();                 // call PushLastSelectedTeam
    ax = *(word *)&g_memByte[330632];       // mov ax, showCupsAndOther
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_show_cups_and_other;         // jnz short @@show_cups_and_other

    ax = *(word *)&g_memByte[330634];       // mov ax, playSeason
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_show_cups_and_other;         // jnz short @@show_cups_and_other

    ax = *(word *)&g_memByte[330638];       // mov ax, teamsType
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_national_teams;              // jz short @@national_teams

l_show_cups_and_other:;
    PushContinent();                        // call PushContinent
    esi = A5;                               // mov esi, A5
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    SetSelectedTeamsStackTop();             // call SetSelectedTeamsStackTop
    goto cseg_4B500;                        // jmp cseg_4B500

l_national_teams:;
    esi = A5;                               // mov esi, A5
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0FFh
    GetCountryName();                       // call GetCountryName
    *(word *)&g_memByte[330652] = 0;        // mov leagueNumber, 0
    esi = A5;                               // mov esi, A5
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    LoadTeamFile();                         // call LoadTeamFile
    goto cseg_4C27B;                        // jmp cseg_4C27B

cseg_4BD6D:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A3 = 330562;                            // mov A3, offset leaguesPtrTable
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    A0 = eax;                               // mov A0, eax
    *(dword *)&g_memByte[330194] = eax;     // mov selectedContest, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 0
    if (flags.zero)
        goto cseg_4BE0E;                    // jz short cseg_4BE0E

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 2

cseg_4BDC2:;
    *(word *)&g_memByte[330652] = 0;        // mov leagueNumber, 0
    *(word *)&g_memByte[330198] = 0;        // mov dseg_1132B9, 0
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_2364C();                           // call cseg_2364C
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    goto cseg_4BE8F;                        // jmp cseg_4BE8F

cseg_4BE0E:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    A3 = 330602;                            // mov A3, offset leagueNumbersTable
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[330652] = ax;       // mov leagueNumber, ax
    *(word *)&g_memByte[330198] = ax;       // mov dseg_1132B9, ax
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_23538();                           // call cseg_23538
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6

cseg_4BE8F:;
    *(dword *)&g_memByte[330654] = 16018;   // mov playWhatStr, offset aPlaySeason
    MarkSelectedTeamsStackLocation();       // call MarkSelectedTeamsStackLocation
    *(word *)&g_memByte[330672] = 0;        // mov selectTamsNoLimit, 0
    *(word *)&g_memByte[330634] = 0;        // mov playSeason, 0
    *(word *)&g_memByte[330630] = 1;        // mov loadTeam, 1
    *(dword *)&g_memByte[330658] = 0;       // mov chooseTeamsHeader1stPart, 0
    *(word *)&g_memByte[330638] = 1;        // mov teamsType, CLUB_TEAMS
    eax = *(dword *)&g_memByte[330190];     // mov eax, selectedTeamText
    *(dword *)&g_memByte[330202] = eax;     // mov gameTypeStr, eax
    *(word *)&g_memByte[330698] = 3;        // mov viewSelectedTeams, 3
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetCountryName();                       // call GetCountryName
    goto l_view_selected_teams;             // jmp @@view_selected_teams

cseg_4BEF5:;
    ax = A0;                                // mov ax, word ptr A0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    PushLastSelectedTeam();                 // call PushLastSelectedTeam
    PushContinent();                        // call PushContinent
    SetSelectedTeamsStackTop();             // call SetSelectedTeamsStackTop
    *(word *)&g_memByte[330624] = 1;        // mov isCountryNumber, 1
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&g_memByte[330626] = ax;       // mov countryNumber, ax
    goto cseg_4B500;                        // jmp cseg_4B500

cseg_4BF2A:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A3 = 330562;                            // mov A3, offset leaguesPtrTable
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    A0 = eax;                               // mov A0, eax
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto cseg_4BFA7;                    // jnz short cseg_4BFA7

    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 29227;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset europeanChampionships
    if (!flags.zero)
        goto cseg_4BF88;                    // jnz short cseg_4BF88

    {
        byte src = g_memByte[91678];
        byte res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 1
    if (flags.zero)
        goto cseg_4BF88;                    // jz short cseg_4BF88

    A0 = 253;                               // mov A0, 253
    goto cseg_4BFA7;                        // jmp short cseg_4BFA7

cseg_4BF88:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 28229;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset worldCup
    if (!flags.zero)
        goto cseg_4BFA7;                    // jnz short cseg_4BFA7

    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        goto cseg_4BFA7;                    // jz short cseg_4BFA7

    A0 = 252;                               // mov A0, 252

cseg_4BFA7:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 256;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, 256
    if (flags.carry)
        goto cseg_4BEF5;                    // jb cseg_4BEF5

    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[330194] = eax;     // mov selectedContest, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 0
    if (flags.zero)
        goto cseg_4C155;                    // jz cseg_4C155

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 1
    if (flags.zero)
        goto cseg_4C09C;                    // jz cseg_4C09C

cseg_4BFE3:;
    ax = *(word *)&g_memByte[330636];       // mov ax, dseg_11346F
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4C08E;                    // jnz cseg_4C08E

    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_2364C();                           // call cseg_2364C
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    *(dword *)&g_memByte[330654] = 15958;   // mov playWhatStr, offset aPlayTournament
    cseg_4C599();                           // call cseg_4C599
    IsContestContinentalCup();              // call IsContestContinentalCup
    MarkSelectedTeamsStackLocation();       // call MarkSelectedTeamsStackLocation
    *(word *)&g_memByte[330672] = 0;        // mov selectTamsNoLimit, 0
    *(word *)&g_memByte[330632] = 0;        // mov showCupsAndOther, 0
    *(word *)&g_memByte[330630] = 1;        // mov loadTeam, 1
    *(dword *)&g_memByte[330658] = 0;       // mov chooseTeamsHeader1stPart, 0
    eax = *(dword *)&g_memByte[330190];     // mov eax, selectedTeamText
    *(dword *)&g_memByte[330202] = eax;     // mov gameTypeStr, eax
    *(word *)&g_memByte[330698] = 2;        // mov viewSelectedTeams, 2
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetCountryName();                       // call GetCountryName
    goto l_view_selected_teams;             // jmp @@view_selected_teams

cseg_4C08E:;
    *(word *)&g_memByte[330694] = 1;        // mov chooseTeamsResult, 1
    return;                                 // jmp @@out

cseg_4C09C:;
    ax = *(word *)&g_memByte[330636];       // mov ax, dseg_11346F
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4C147;                    // jnz cseg_4C147

    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_235E4();                           // call cseg_235E4
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    *(dword *)&g_memByte[330654] = 15978;   // mov playWhatStr, offset aPlayCup
    cseg_4C599();                           // call cseg_4C599
    IsContestContinentalCup();              // call IsContestContinentalCup
    MarkSelectedTeamsStackLocation();       // call MarkSelectedTeamsStackLocation
    *(word *)&g_memByte[330672] = 0;        // mov selectTamsNoLimit, 0
    *(word *)&g_memByte[330632] = 0;        // mov showCupsAndOther, 0
    *(word *)&g_memByte[330630] = 1;        // mov loadTeam, 1
    *(dword *)&g_memByte[330658] = 0;       // mov chooseTeamsHeader1stPart, 0
    eax = *(dword *)&g_memByte[330190];     // mov eax, selectedTeamText
    *(dword *)&g_memByte[330202] = eax;     // mov gameTypeStr, eax
    *(word *)&g_memByte[330698] = 2;        // mov viewSelectedTeams, 2
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetCountryName();                       // call GetCountryName
    goto l_view_selected_teams;             // jmp @@view_selected_teams

cseg_4C147:;
    *(word *)&g_memByte[330694] = 1;        // mov chooseTeamsResult, 1
    return;                                 // jmp @@out

cseg_4C155:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    A3 = 330602;                            // mov A3, offset leagueNumbersTable
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[330652] = ax;       // mov leagueNumber, ax
    *(word *)&g_memByte[330198] = ax;       // mov dseg_1132B9, ax
    ax = *(word *)&g_memByte[330636];       // mov ax, dseg_11346F
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4C24C;                    // jnz cseg_4C24C

    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_23538();                           // call cseg_23538
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    *(dword *)&g_memByte[330654] = 15998;   // mov playWhatStr, offset aPlayLeague
    cseg_4C599();                           // call cseg_4C599
    IsContestContinentalCup();              // call IsContestContinentalCup
    MarkSelectedTeamsStackLocation();       // call MarkSelectedTeamsStackLocation
    *(word *)&g_memByte[330672] = 0;        // mov selectTamsNoLimit, 0
    *(word *)&g_memByte[330632] = 0;        // mov showCupsAndOther, 0
    *(word *)&g_memByte[330630] = 1;        // mov loadTeam, 1
    *(dword *)&g_memByte[330658] = 0;       // mov chooseTeamsHeader1stPart, 0
    eax = *(dword *)&g_memByte[330190];     // mov eax, selectedTeamText
    *(dword *)&g_memByte[330202] = eax;     // mov gameTypeStr, eax
    *(word *)&g_memByte[330698] = 2;        // mov viewSelectedTeams, 2
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetCountryName();                       // call GetCountryName
    goto l_view_selected_teams;             // jmp @@view_selected_teams

cseg_4C24C:;
    *(word *)&g_memByte[330694] = 1;        // mov chooseTeamsResult, 1
    return;                                 // jmp @@out

l_load_team:;
    al = D6;                                // mov al, byte ptr D6
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&g_memByte[330652] = ax;       // mov leagueNumber, ax
    LoadTeamFile();                         // call LoadTeamFile
    if (!flags.zero)
        goto l_err_out;                     // jnz @@err_out

cseg_4C27B:;
    eax = *(dword *)&g_memByte[330190];     // mov eax, selectedTeamText
    *(dword *)&g_memByte[330662] = eax;     // mov entryText2, eax
    A6 = 506817;                            // mov A6, offset chooseTeamsFriendlyMenu
    *(word *)&D0 = -1;                      // mov word ptr D0, -1
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A4);                               // push A4
    push(A5);                               // push A5
    SWOS::ShowMenu();                       // call ShowMenu
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    ax = *(word *)&g_memByte[330698];       // mov ax, viewSelectedTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_view_selected_teams;         // jnz short @@view_selected_teams

    ax = *(word *)&g_memByte[330700];       // mov ax, abortSelectTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[330694];       // mov ax, chooseTeamsResult
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

cseg_4C2F6:;
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    goto cseg_4B500;                        // jmp cseg_4B500

l_view_selected_teams:;
    ax = *(word *)&g_memByte[330624];       // mov ax, isCountryNumber
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4C323;                    // jz short cseg_4C323

    ax = *(word *)&g_memByte[330626];       // mov ax, countryNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetCountryName();                       // call GetCountryName

cseg_4C323:;
    eax = *(dword *)&g_memByte[330190];     // mov eax, selectedTeamText
    *(dword *)&g_memByte[330662] = eax;     // mov entryText2, eax
    A6 = 492519;                            // mov A6, offset chooseTeamsFriendly
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A4);                               // push A4
    push(A5);                               // push A5
    SWOS::ShowMenu();                       // call ShowMenu
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    ax = *(word *)&g_memByte[330700];       // mov ax, abortSelectTeams
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    ax = *(word *)&g_memByte[330694];       // mov ax, chooseTeamsResult
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    ax = *(word *)&g_memByte[330624];       // mov ax, isCountryNumber
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4C3AF;                    // jz short cseg_4C3AF

    *(word *)&g_memByte[330624] = 0;        // mov isCountryNumber, 0
    PopContinent();                         // call PopContinent
    ax = *(word *)&g_memByte[330622];       // mov ax, isContestContinentalCup
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4C27B;                    // jnz cseg_4C27B

    goto cseg_4B500;                        // jmp cseg_4B500

cseg_4C3AF:;
    ax = *(word *)&g_memByte[330622];       // mov ax, isContestContinentalCup
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4C27B;                    // jnz cseg_4C27B

    goto cseg_4C2F6;                        // jmp cseg_4C2F6

l_err_out:;
    *(word *)&g_memByte[330694] = 0;        // mov chooseTeamsResult, 0
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - team country number
// out:
//      A0,
//      curCountryStr -> country string
//
void GetCountryName()
{
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 24755;                             // mov A0, offset countriesTable
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 1
    A0 = eax;                               // mov A0, eax
    *(dword *)&g_memByte[330206] = eax;     // mov curCountryStr, eax
}

// =============== S U B R O U T I N E =======================================

// in:
//     D6 - country number
//
void PushContinent()
{
    eax = *(dword *)&g_memByte[330528];     // mov eax, countryStackPtr
    A0 = eax;                               // mov A0, eax
    al = D6;                                // mov al, byte ptr D6
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[330528] = eax;     // mov countryStackPtr, eax
    {
        word src = *(word *)&g_memByte[330524];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[330524] = src;
    }                                       // add numSelectedTeams, 1
}

// =============== S U B R O U T I N E =======================================

// out:
//     D7 - country number
//
void PopContinent()
{
    eax = *(dword *)&g_memByte[330528];     // mov eax, countryStackPtr
    A0 = eax;                               // mov A0, eax
    (*(int32_t *)&A0)--;                    // dec A0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    writeMemory(esi, 1, 85);                // mov byte ptr [esi], CN_OCEANIA
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[330528] = eax;     // mov countryStackPtr, eax
    {
        word src = *(word *)&g_memByte[330524];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[330524] = src;
    }                                       // sub numSelectedTeams, 1
}

// =============== S U B R O U T I N E =======================================
//
void SetSelectedTeamsStackTop()
{
    ax = *(word *)&g_memByte[330524];       // mov ax, numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    A0 = 330542;                            // mov A0, offset selectedTeamsStack
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    writeMemory(esi + eax, 2, -1);          // mov word ptr [esi+eax], -1
}

// =============== S U B R O U T I N E =======================================
//
void PushLastSelectedTeam()
{
    ax = *(word *)&g_memByte[330524];       // mov ax, numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    A0 = 330542;                            // mov A0, offset selectedTeamsStack
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    bx = *(word *)&g_memByte[330184];       // mov bx, lastSelectedTeam
    writeMemory(esi + eax, 2, bx);          // mov [esi+eax], bx
}

// =============== S U B R O U T I N E =======================================
//
void GetSelectedTeamsStackTop()
{
    ax = *(word *)&g_memByte[330524];       // mov ax, numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    A0 = 330542;                            // mov A0, offset selectedTeamsStack
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    *(word *)&g_memByte[330200] = ax;       // mov prevSelectedTeamEntry, ax
}

// =============== S U B R O U T I N E =======================================
//
void MarkSelectedTeamsStackLocation()
{
    ax = *(word *)&g_memByte[330524];       // mov ax, numSelectedTeams
    *(word *)&g_memByte[330526] = ax;       // mov topOfStackMark, ax
    ax = *(word *)&g_memByte[330624];       // mov ax, isCountryNumber
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4C530;                    // jz short cseg_4C530

    {
        word src = *(word *)&g_memByte[330526];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        *(word *)&g_memByte[330526] = src;
    }                                       // sub topOfStackMark, 1

cseg_4C530:;
    ax = *(word *)&g_memByte[330628];       // mov ax, gotCountryName
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_4C54F;                    // jz short cseg_4C54F

    {
        word src = *(word *)&g_memByte[330646];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numberOfLeagues, 1
    if (!flags.zero)
        goto cseg_4C54F;                    // jnz short cseg_4C54F

cseg_4C545:;
    *(word *)&g_memByte[330526] = -1;       // mov topOfStackMark, -1
    return;                                 // retn

cseg_4C54F:;
    ax = *(word *)&g_memByte[330622];       // mov ax, isContestContinentalCup
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_4C545;                    // jnz short cseg_4C545
}

// =============== S U B R O U T I N E =======================================
//
void IsContestContinentalCup()
{
    A0 = 27091;                             // mov A0, offset continental_cups

l_next_cup:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    A2 = eax;                               // mov A2, eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, -1
    if (flags.zero)
        return;                             // jz short @@out

    eax = *(dword *)&g_memByte[330194];     // mov eax, selectedContest
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, eax
    if (!flags.zero)
        goto l_next_cup;                    // jnz short @@next_cup

    *(word *)&g_memByte[330622] = 1;        // mov isContestContinentalCup, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4C599()
{
    *(word *)&g_memByte[330638] = 1;        // mov teamsType, CLUB_TEAMS
    eax = *(dword *)&g_memByte[330194];     // mov eax, selectedContest
    A1 = eax;                               // mov A1, eax
    cseg_4C5BD();                           // call cseg_4C5BD
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&g_memByte[330638] = 0;        // mov teamsType, 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4C5BD()
{
    A0 = 26935;                             // mov A0, offset dseg_C6FC6

cseg_4C5C7:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], -1
    if (flags.zero)
        goto cseg_4C5F7;                    // jz short cseg_4C5F7

    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, eax
    if (!flags.zero)
        goto cseg_4C5C7;                    // jnz short cseg_4C5C7

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

cseg_4C5F7:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void ChooseCompetitionMenu()
{
    *(dword *)&g_memByte[330202] = 0;       // mov gameTypeStr, 0
    *(dword *)&g_memByte[330658] = 16450;   // mov chooseTeamsHeader1stPart, offset aChooseCompetit
    *(dword *)&g_memByte[330666] = 0;       // mov chooseTeamsFunc, 0
    *(word *)&g_memByte[330670] = 0;        // mov dseg_113491, 0
    *(word *)&g_memByte[330672] = 1;        // mov selectTamsNoLimit, 1
    *(word *)&g_memByte[330638] = -1;       // mov teamsType, -1
    *(word *)&g_memByte[330630] = 0;        // mov loadTeam, 0
    *(word *)&g_memByte[330632] = 1;        // mov showCupsAndOther, 1
    *(word *)&g_memByte[330634] = 0;        // mov playSeason, 0
    *(word *)&g_memByte[330636] = 1;        // mov dseg_11346F, 1
    *(byte *)&D0 = 255;                     // mov byte ptr D0, 255
    SelectTeamsFinalMenu();                 // call SelectTeamsFinalMenu
}

// =============== S U B R O U T I N E =======================================
//
void SelectTeamsForPresetCompetition()
{
    *(dword *)&g_memByte[330202] = 0;       // mov gameTypeStr, 0
    *(dword *)&g_memByte[330658] = 16473;   // mov chooseTeamsHeader1stPart, offset aChoosePresetCo
    *(dword *)&g_memByte[330666] = 0;       // mov chooseTeamsFunc, 0
    *(word *)&g_memByte[330670] = 0;        // mov dseg_113491, 0
    *(word *)&g_memByte[330672] = 1;        // mov selectTamsNoLimit, 1
    *(word *)&g_memByte[330638] = 65535;    // mov teamsType, 0FFFFh
    *(word *)&g_memByte[330630] = 0;        // mov loadTeam, 0
    *(word *)&g_memByte[330632] = 1;        // mov showCupsAndOther, 1
    *(word *)&g_memByte[330634] = 0;        // mov playSeason, 0
    *(word *)&g_memByte[330636] = 0;        // mov dseg_11346F, 0
    *(word *)&g_memByte[467196] = 1;        // mov choosingPreset, 1
    *(byte *)&D0 = 255;                     // mov byte ptr D0, 255
    SelectTeamsFinalMenu();                 // call SelectTeamsFinalMenu
    *(word *)&g_memByte[467196] = 0;        // mov choosingPreset, 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_4C6EE()
{
    *(dword *)&g_memByte[330202] = 0;       // mov gameTypeStr, 0
    *(dword *)&g_memByte[330658] = 16499;   // mov chooseTeamsHeader1stPart, offset aChooseSeason
    *(dword *)&g_memByte[330666] = 0;       // mov chooseTeamsFunc, 0
    *(word *)&g_memByte[330670] = 0;        // mov dseg_113491, 0
    *(word *)&g_memByte[330672] = 1;        // mov selectTamsNoLimit, 1
    *(word *)&g_memByte[330638] = 65535;    // mov teamsType, 0FFFFh
    *(word *)&g_memByte[330630] = 0;        // mov loadTeam, 0
    *(word *)&g_memByte[330632] = 0;        // mov showCupsAndOther, 0
    *(word *)&g_memByte[330634] = 1;        // mov playSeason, 1
    *(word *)&g_memByte[330636] = 0;        // mov dseg_11346F, 0
    *(byte *)&D0 = 255;                     // mov byte ptr D0, 255
    SelectTeamsFinalMenu();                 // call SelectTeamsFinalMenu
}

// =============== S U B R O U T I N E =======================================

// in:
//      D2 -  show club teams
//      D3 -  show national teams
//      D4 -  show original custom teams
//      A0 -> title
//      A1 -> function to call when teams are selected
//            (on entry A0 -> selected team)
// out:
//      D0 -  selected team country number (-1 if aborted)
//      A0 -> selected team
//
// Choose teams selector. First you select teams category from which to select teams (club, national, etc.)
//
void ChooseTeamsDialog()
{
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[330640] = ax;       // mov showClubTeams, ax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&g_memByte[330642] = ax;       // mov showNationalTeams, ax
    ax = D4;                                // mov ax, word ptr D4
    *(word *)&g_memByte[330644] = ax;       // mov showOrigCustomTeams, ax
    *(dword *)&g_memByte[330202] = 0;       // mov gameTypeStr, 0
    eax = A0;                               // mov eax, A0
    *(dword *)&g_memByte[330658] = eax;     // mov chooseTeamsHeader1stPart, eax
    eax = A1;                               // mov eax, A1
    *(dword *)&g_memByte[330666] = eax;     // mov chooseTeamsFunc, eax
    *(word *)&g_memByte[330670] = 0;        // mov dseg_113491, 0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, 0
    if (!flags.zero)
        goto l_have_func;                   // jnz short @@have_func

    g_memByte[330670] = 255;                // mov byte ptr dseg_113491, 255

l_have_func:;
    *(dword *)&g_memByte[330654] = 18712;   // mov playWhatStr, offset aStatistics
    *(word *)&g_memByte[330674] = 1;        // mov numNeededTeams, 1
    *(word *)&g_memByte[330672] = 1;        // mov selectTamsNoLimit, 1
    *(word *)&g_memByte[330692] = -1;       // mov selectedTeamCountryNumber, -1
    *(dword *)&g_memByte[330688] = 0;       // mov selectedTeamPtr, 0
    A6 = 504785;                            // mov A6, offset chooseTeamsMenu
    SWOS::ShowMenu();                       // call ShowMenu
    ax = *(word *)&g_memByte[330638];       // mov ax, teamsType
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto l_out;                         // js short @@out

    *(word *)&g_memByte[330630] = 1;        // mov loadTeam, 1
    *(word *)&g_memByte[330632] = 0;        // mov showCupsAndOther, 0
    *(word *)&g_memByte[330634] = 0;        // mov playSeason, 0
    *(byte *)&D0 = 255;                     // mov byte ptr D0, 255
    SelectTeamsFinalMenu();                 // call SelectTeamsFinalMenu

l_out:;
    ax = *(word *)&g_memByte[330692];       // mov ax, selectedTeamCountryNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(dword *)&g_memByte[330688];     // mov eax, selectedTeamPtr
    A0 = eax;                               // mov A0, eax
}

