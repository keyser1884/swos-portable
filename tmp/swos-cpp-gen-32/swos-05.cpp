// automatically generated by ida2asm, do not edit!

#include "vm.h"
#include "defs.h"

#ifdef _MSC_VER
# pragma warning(disable: 4309 4146 4333 4805 4102)
#endif

using namespace SwosVM;

extern void SetupPlayers();
extern void cseg_31A2B();
extern void cseg_88688();
extern void cseg_2A71E();
extern void cseg_883DD();
extern void FadeAndPlayWinMatchAnimation();
extern void FadeAndPlayLoseMatchAnimation();
extern void cseg_284AB();
extern void InitializeInGameTeamsAndStartGame();
extern void cseg_258E4();
extern void cseg_28139();
extern void InitTeams();
extern void cseg_87D60();
extern void cseg_31F58();
extern void cseg_883B8();
extern void cseg_31B94();
extern void cseg_280C0();
extern void cseg_283BD();
extern void CareerInitVars();
extern void CalculateStartingBalance();
extern void cseg_5DB56();
extern void LoadSomeEuroCup();
extern void StringCopy();
extern void GetNationalityAndTeamFile();
extern void cseg_664BB();
extern void GetCurrentSeasonPointer();
extern void cseg_5DEB9();
extern void cseg_3D204();
extern void cseg_64A65();
extern void cseg_5CDF2();
extern void GetNationalTeamNumber();
extern void cseg_5C46D();
extern void LoadFile();
extern void GetPlayerAtIndex();
extern void GetPlayer();
extern void cseg_2484B();
extern void cseg_31C4C();
extern void cseg_39392();
extern void cseg_32E15();
extern void cseg_27436();
extern void cseg_288E2();
extern void cseg_28E76();
extern void cseg_284D8();
extern void cseg_26395();
extern void cseg_2653B();
extern void cseg_28243();
extern void GetNumberOfAvailablePlayers();
extern void IsPlayerInjured();
extern void Rand2();
extern void Rand();
extern void Rand();
extern void ShowChairmanMessage();
extern void ShowChairmanOpinionAboutTheSeason();
extern void PlayNewSeasonAnimations();
extern void cseg_3934F();
extern void cseg_3ABB2();
extern void ShowDiyLeaguesTournamentMenu();
extern void VerifyTeamLoaded();
extern void cseg_2ACAE();
extern void RestoreSelectedTeams();
extern void cseg_45B51();
extern void cseg_3ACAB();
extern void SearchTeamInTmdFile();
extern void cseg_5A6A1();
extern void GetAveragePlayerPrice();
extern void FindTeamInDIY();
extern void cseg_3B7F8();
extern void cseg_3B842();
extern void SaveSelectedTeams();
extern void cseg_3ADAE();
extern void cseg_3E608();

// first pass forward declarations
void cseg_88A12();
void cseg_89207();
void cseg_8922B();
void cseg_89381();
void cseg_89758();
void cseg_89956();
void cseg_899A0();
void cseg_899EA();
void cseg_89A34();
void cseg_89A7E();
void cseg_89AC8();
void RestoreDIYTournament();
void cseg_89B5C();
void cseg_8A147();
void cseg_8A2CE();
void cseg_8A7BF();
void cseg_8A94F();
void cseg_8AC02();
void cseg_8AC90();
void cseg_8AED0();
void InitNewSeason();
void cseg_8B2D3();
void cseg_8B6B0();
void cseg_8B6CB();
void cseg_8B6E6();
void cseg_8B701();
void cseg_8B71C();
void cseg_8B7EA();
void cseg_8B8B8();
void cseg_8B8D9();
void cseg_8BBFD();
void cseg_8BC06();
void cseg_8BEA1();
void cseg_8BF1A();
void cseg_8BF89();
void cseg_8C21C();
void cseg_8C2AE();
void cseg_8C452();
void cseg_8C516();
void cseg_8C607();
void cseg_8C623();
void cseg_8C64C();
void InitCareer();
void cseg_8CB18();
void cseg_8CC0A();
void cseg_8CC4E();
void InitializeNewSeason();
void cseg_8D661();
void cseg_8D7B4();
void cseg_8D839();
void FillForeignMarketPlayers();
void FillCareerTeamPlayers();
void cseg_8DAC3();
void AddCareerTeamPlayer();
void AddRandomForeignMarketPlayer();
void LoadPoolplyrDat();
void AddPlayerToCareerContest();
void cseg_8DF16();
void IsPlayerInCareerContest();
void AddForeignMarketPlayer();
void cseg_8E09A();
void FindForeignMarketPlayer();
void GetLowestAndHighestPlayerPrice();
void cseg_8E23A();
void FillForeignMarketPlayersData();
void GetRandomWord();
void cseg_8E3DA();
void cseg_8E469();
void cseg_8E539();
void cseg_8E796();
void cseg_8E841();
void cseg_8E94F();
void cseg_8E98E();
void cseg_8EA56();
void cseg_8EA82();
void cseg_8EC2B();
void cseg_8ECAE();
void cseg_8EF2C();
void cseg_8EF7B();
void cseg_8EFE2();
void cseg_8F048();
void cseg_8F0A2();
void cseg_8F0E6();
void cseg_8F120();
void cseg_8F1F2();
void SetupTeamSubstitutes();
void cseg_8FA09();
void GetPlayerPrice();
void CountNearnessFactor();
void cseg_903B1();
void cseg_9072A();
void cseg_908B4();
void GetTeamValueBase();
void ShowLeavingMessage();
void ShowGreetingMessage();
void ShowLastSeasonMessage();
void ShowWishYouSuccessMessage();
void ShowEnjoyLastSeasonMessage();
void cseg_90FF2();
void cseg_9111F();
void GetMoreExpensiveTeamsCount();
void ContinueCareerNextSeason();
void cseg_91428();
void cseg_9153F();
void nullsub_16();
void cseg_915ED();
void cseg_916C2();
void cseg_9178B();
void cseg_91854();
void cseg_91857();
void cseg_91AD0();
void cseg_91D4D();
void cseg_9221F();
void cseg_9228D();
void cseg_925C9();
void cseg_927A2();
void cseg_928CC();
void cseg_92A63();
void cseg_92BBF();
void cseg_92C4D();
void cseg_92D55();
void cseg_92F1C();
void cseg_9307A();
void cseg_93241();
void cseg_9339D();
void cseg_93564();
void cseg_936C0();
void cseg_93974();
void cseg_939C9();
void cseg_939FE();
void cseg_93A60();
void cseg_93B30();
void cseg_93B9C();
void cseg_93BB5();
void cseg_93BCE();
void cseg_93C19();
void cseg_93C3C();
void cseg_93C5F();
void cseg_93D0B();
void cseg_93D67();
void cseg_93DAA();
void cseg_93E36();
void cseg_93FD8();
void cseg_94193();
void cseg_9423A();
void cseg_942F2();
void cseg_943FA();
void cseg_9487A();
void cseg_94A16();
void cseg_94C7E();
void cseg_94DB1();
void cseg_94E85();
void cseg_94F6A();
void cseg_95130();
void cseg_95298();
void cseg_95401();
void cseg_956EB();
void cseg_95853();
void cseg_9590C();
void cseg_95A51();
void cseg_95ACA();
void cseg_95ACD();
void cseg_95C18();
void SetZeroFlag2();
void nullsub_9();
void SetZeroFlag();

// =============== S U B R O U T I N E =======================================

// in:
//     D7 -
//
void cseg_88A12()
{
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&g_memByte[529334] = ax;       // mov dseg_180586, ax
    *(word *)&g_memByte[318710] = 1;        // mov dseg_10EEEC, 1
    cseg_89207();                           // call cseg_89207
    cseg_89758();                           // call cseg_89758
    eax = A1;                               // mov eax, A1
    A3 = eax;                               // mov A3, eax
    eax = A2;                               // mov eax, A2
    A4 = eax;                               // mov A4, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+691]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+691]
    A2 = eax;                               // mov A2, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, eax
    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_88AF0;                    // jz short cseg_88AF0

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 1
    if (flags.zero)
        goto cseg_88AD7;                    // jz short cseg_88AD7

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 3
    if (flags.zero)
        goto cseg_88ABE;                    // jz short cseg_88ABE

    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    *(word *)&D6 = 1;                       // mov word ptr D6, 1
    cseg_89381();                           // call cseg_89381
    if (!flags.zero)
        return;                             // jnz @@out

    goto cseg_88B5C;                        // jmp cseg_88B5C

cseg_88ABE:;
    *(word *)&D7 = 1;                       // mov word ptr D7, 1
    cseg_89381();                           // call cseg_89381
    if (!flags.zero)
        return;                             // jnz @@out

    goto cseg_88B5C;                        // jmp cseg_88B5C

cseg_88AD7:;
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    cseg_89381();                           // call cseg_89381
    if (!flags.zero)
        return;                             // jnz @@out

    goto cseg_88B5C;                        // jmp short cseg_88B5C

cseg_88AF0:;
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (flags.zero)
        goto l_setup_real_game;             // jz short @@setup_real_game

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_PLAYER_COACH
    if (flags.zero)
        goto l_setup_real_game;             // jz short @@setup_real_game

    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COACH
    if (flags.zero)
        goto l_setup_real_game;             // jz short @@setup_real_game

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COACH
    if (!flags.zero)
        goto cseg_88B55;                    // jnz short cseg_88B55

l_setup_real_game:;
    ax = *(word *)&g_memByte[318744];       // mov ax, diyLeagueMaxSubstitutes
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[318702];       // mov ax, dseg_10EEE4
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    SetupPlayers();                         // call SetupPlayers
    ax = *(word *)&g_memByte[456648];       // mov ax, g_exitGameFlag
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

cseg_88B55:;
    cseg_31A2B();                           // call cseg_31A2B

cseg_88B5C:;
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    cseg_88688();                           // call cseg_88688
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D7);                               // push D7
    push(A1);                               // push A1
    push(A2);                               // push A2
    eax = A3;                               // mov eax, A3
    A1 = eax;                               // mov A1, eax
    eax = A4;                               // mov eax, A4
    A2 = eax;                               // mov A2, eax
    cseg_8922B();                           // call cseg_8922B
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_88BFE;                    // jz short cseg_88BFE

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (!flags.zero)
        goto cseg_88C10;                    // jnz short cseg_88C10

cseg_88BFE:;
    *(word *)&g_memByte[318712] = 1;        // mov dseg_10EEEE, 1
    *(word *)&g_memByte[91628] = 1;         // mov dseg_D6C7A, 1

cseg_88C10:;
    cseg_89207();                           // call cseg_89207
    ax = *(word *)&g_memByte[318686];       // mov ax, dseg_10EED4
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[129476];       // mov ax, dseg_E0052
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_88CBB;                    // jnz cseg_88CBB

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (flags.zero)
        goto cseg_88C44;                    // jz short cseg_88C44

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 3
    if (!flags.zero)
        goto cseg_88CBB;                    // jnz short cseg_88CBB

cseg_88C44:;
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    {
        word res = *(word *)&D4 << 8;
        *(word *)&D4 = res;
    }                                       // shl word ptr D4, 8
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // add word ptr D4, ax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    cseg_2A71E();                           // call cseg_2A71E
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1

cseg_88CBB:;
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 445, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 445, 2, src);
    }                                       // add word ptr [esi+1BDh], 1
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        goto cseg_88D6A;                    // jz cseg_88D6A

    if (flags.carry)
        goto cseg_88D29;                    // jb short cseg_88D29

    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 697, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 697, 2, src);
    }                                       // add word ptr [esi+2B9h], 1
    esi = A4;                               // mov esi, A4
    {
        word src = (word)readMemory(esi + 701, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 701, 2, src);
    }                                       // add word ptr [esi+2BDh], 1
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 97, 2);     // mov ax, [esi+61h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 707, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 707, 2, src);
    }                                       // add [esi+2C3h], ax
    goto cseg_88DA2;                        // jmp short cseg_88DA2

cseg_88D29:;
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 701, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 701, 2, src);
    }                                       // add word ptr [esi+2BDh], 1
    esi = A4;                               // mov esi, A4
    {
        word src = (word)readMemory(esi + 697, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 697, 2, src);
    }                                       // add word ptr [esi+2B9h], 1
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 97, 2);     // mov ax, [esi+61h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A4;                               // mov esi, A4
    {
        word src = (word)readMemory(esi + 707, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 707, 2, src);
    }                                       // add [esi+2C3h], ax
    goto cseg_88DA2;                        // jmp short cseg_88DA2

cseg_88D6A:;
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 699, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 699, 2, src);
    }                                       // add word ptr [esi+2BBh], 1
    esi = A4;                               // mov esi, A4
    {
        word src = (word)readMemory(esi + 699, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 699, 2, src);
    }                                       // add word ptr [esi+2BBh], 1
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 707, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 707, 2, src);
    }                                       // add word ptr [esi+2C3h], 1
    esi = A4;                               // mov esi, A4
    {
        word src = (word)readMemory(esi + 707, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 707, 2, src);
    }                                       // add word ptr [esi+2C3h], 1

cseg_88DA2:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 703, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 703, 2, src);
    }                                       // add [esi+2BFh], ax
    ax = D2;                                // mov ax, word ptr D2
    {
        word src = (word)readMemory(esi + 705, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 705, 2, src);
    }                                       // add [esi+2C1h], ax
    esi = A4;                               // mov esi, A4
    {
        word src = (word)readMemory(esi + 703, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 703, 2, src);
    }                                       // add [esi+2BFh], ax
    ax = D1;                                // mov ax, word ptr D1
    {
        word src = (word)readMemory(esi + 705, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 705, 2, src);
    }                                       // add [esi+2C1h], ax
    ax = *(word *)&g_memByte[318738];       // mov ax, diyMinSubstitutes
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_89147;                    // jnz cseg_89147

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_883DD();                           // call cseg_883DD
    A5 = 318643;                            // mov A5, offset DIY_competitionStart
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 301;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 12Dh
    A2 = eax;                               // mov A2, eax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 429;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 1ADh
    A3 = eax;                               // mov A3, eax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_88EB6;                    // jz short cseg_88EB6

    ax = *(word *)&g_memByte[317671];       // mov ax, dseg_10EADD
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = *(word *)&g_memByte[317669];       // mov ax, dseg_10EADB
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_88F15;                    // jnz short cseg_88F15

cseg_88EB6:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 109, 2);    // mov ax, [esi+6Dh]
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 18;                                // mov bx, 12h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 57, 2, ax);           // mov [esi+39h], ax

cseg_88F15:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_88F31;                    // jz short cseg_88F31

    {
        word src = (word)readMemory(esi + 71, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+47h], 2

cseg_88F31:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+55h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_89000;                    // jz cseg_89000

    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 109;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 6Dh
    A1 = eax;                               // mov A1, eax
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A1;                               // mov eax, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_88F8C:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 18;                                // mov bx, 12h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A3 = res;
    }                                       // add A3, 2
    (*(int16_t *)&D1)--;
    flags.overflow = (int16_t)(*(int16_t *)&D1) == INT16_MIN;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_88F8C;                    // jns short cseg_88F8C

cseg_89000:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_890ED;                    // jz cseg_890ED

    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 109;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 6Dh
    A1 = eax;                               // mov A1, eax
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A1;                               // mov eax, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_89079:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 18;                                // mov bx, 12h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A3 = res;
    }                                       // add A3, 2
    (*(int16_t *)&D1)--;
    flags.overflow = (int16_t)(*(int16_t *)&D1) == INT16_MIN;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_89079;                    // jns short cseg_89079

cseg_890ED:;
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

cseg_89147:;
    {
        word src = *(word *)&g_memByte[91720];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp selTeamNumber, -1
    if (flags.zero)
        goto l_return_zero_flag_set;        // jz @@return_zero_flag_set

    ax = *(word *)&g_memByte[529334];       // mov ax, dseg_180586
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_return_zero_flag_set;        // jz @@return_zero_flag_set

    {
        word src = *(word *)&g_memByte[317174];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10E848, 1
    if (flags.zero)
        goto l_return_zero_flag_set;        // jz @@return_zero_flag_set

    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = ax;
        int16_t srcSigned = D2;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        ax = res;
    }                                       // sub ax, word ptr D2
    if (flags.zero)
        goto l_return_zero_flag_set;        // jz short @@return_zero_flag_set

    if (flags.sign)
        goto cseg_8919F;                    // js short cseg_8919F

    {
        int16_t dstSigned = ax;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp ax, 3
    if (flags.sign != flags.overflow)
        goto l_return_zero_flag_set;        // jl short @@return_zero_flag_set

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_891B6;                    // jz short cseg_891B6

    goto cseg_891D9;                        // jmp short cseg_891D9

cseg_8919F:;
    ax = -ax;                               // neg ax
    {
        int16_t dstSigned = ax;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp ax, 3
    if (flags.sign != flags.overflow)
        goto l_return_zero_flag_set;        // jl short @@return_zero_flag_set

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (flags.zero)
        goto cseg_891B6;                    // jz short cseg_891B6

    goto cseg_891D9;                        // jmp short cseg_891D9

cseg_891B6:;
    {
        word src = *(word *)&g_memByte[529336];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_180588, -1
    if (flags.zero)
        goto l_player_won;                  // jz short @@player_won

    {
        int16_t src = *(word *)&g_memByte[529336];
        (src)--;
        flags.overflow = (int16_t)(src) == INT16_MIN;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
        *(word *)&g_memByte[529336] = src;
    }                                       // dec dseg_180588
    if (!flags.zero)
        goto l_jmp_return_zero_flag_set;    // jnz short @@jmp_return_zero_flag_set

l_player_won:;
    FadeAndPlayWinMatchAnimation();         // call FadeAndPlayWinMatchAnimation
    *(word *)&g_memByte[529336] = 3;        // mov dseg_180588, 3

l_jmp_return_zero_flag_set:;
    goto l_return_zero_flag_set;            // jmp short @@return_zero_flag_set

cseg_891D9:;
    {
        word src = *(word *)&g_memByte[529336];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_180588, -1
    if (flags.zero)
        goto l_player_lost;                 // jz short @@player_lost

    {
        int16_t src = *(word *)&g_memByte[529336];
        (src)--;
        flags.overflow = (int16_t)(src) == INT16_MIN;
        flags.sign = (src & 0x8000) != 0;
        flags.zero = src == 0;
        *(word *)&g_memByte[529336] = src;
    }                                       // dec dseg_180588
    if (!flags.zero)
        goto l_return_zero_flag_set;        // jnz short @@return_zero_flag_set

l_player_lost:;
    FadeAndPlayLoseMatchAnimation();        // call FadeAndPlayLoseMatchAnimation
    *(word *)&g_memByte[529336] = 3;        // mov dseg_180588, 3

l_return_zero_flag_set:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_89207()
{
    ax = *(word *)&g_memByte[318714];       // mov ax, dseg_10EEF0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    ax = *(word *)&g_memByte[318710];       // mov ax, dseg_10EEEC
    *(word *)&g_memByte[317655] = ax;       // mov dseg_10EACD, ax
    ax = *(word *)&g_memByte[318712];       // mov ax, dseg_10EEEE
    *(word *)&g_memByte[317657] = ax;       // mov dseg_10EACF, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8922B()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A1;                               // mov esi, A1
    {
        word src = (word)readMemory(esi + 695, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 695, 2, src);
    }                                       // add word ptr [esi+2B7h], 1
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 695, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 695, 2, src);
    }                                       // add word ptr [esi+2B7h], 1
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 447, 2);    // mov ax, [esi+1BFh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8927B;                    // jz short cseg_8927B

    writeMemory(esi + 447, 2, 0);           // mov word ptr [esi+1BFh], 0
    writeMemory(esi + 457, 2, 0);           // mov word ptr [esi+1C9h], 0

cseg_8927B:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 457, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 457, 2, src);
    }                                       // add word ptr [esi+1C9h], 1
    {
        word src = (word)readMemory(esi + 91, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 91, 2, src);
    }                                       // add word ptr [esi+5Bh], 1
    ax = (word)readMemory(esi + 91, 2);     // mov ax, [esi+5Bh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        return;                             // jnz cseg_89380

    writeMemory(esi + 91, 2, 0);            // mov word ptr [esi+5Bh], 0
    {
        word src = (word)readMemory(esi + 459, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 459, 2, src);
    }                                       // add word ptr [esi+1CBh], 1
    writeMemory(esi + 447, 2, 0);           // mov word ptr [esi+1BFh], 0
    ax = (word)readMemory(esi + 457, 2);    // mov ax, [esi+1C9h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 455, 2);    // mov ax, [esi+1C7h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_89349;                    // jnz short cseg_89349

    writeMemory(esi + 447, 2, 1);           // mov word ptr [esi+1BFh], 1
    {
        word src = (word)readMemory(esi + 449, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 449, 2, src);
    }                                       // add word ptr [esi+1C1h], 1
    ax = (word)readMemory(esi + 449, 2);    // mov ax, [esi+1C1h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 461;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 1CDh
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 46, 1, al);           // mov [esi+2Eh], al
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    g_memByte[129466] = al;                 // mov dseg_E0048, al

cseg_89349:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 107, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 107, 2, src);
    }                                       // sub word ptr [esi+6Bh], 1
    if (!flags.zero)
        return;                             // jnz short cseg_89380

    {
        word src = (word)readMemory(esi + 95, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 95, 2, src);
    }                                       // sub word ptr [esi+5Fh], 1
    if (flags.zero)
        return;                             // jz short cseg_89380

    ax = (word)readMemory(esi + 105, 2);    // mov ax, [esi+69h]
    writeMemory(esi + 107, 2, ax);          // mov [esi+6Bh], ax
    writeMemory(esi + 459, 2, 0);           // mov word ptr [esi+1CBh], 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_89381()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ax = *(word *)&g_memByte[318744];       // mov ax, diyLeagueMaxSubstitutes
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[318702];       // mov ax, dseg_10EEE4
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    SetupPlayers();                         // call SetupPlayers
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = *(word *)&g_memByte[456648];       // mov ax, g_exitGameFlag
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_896FD;                    // jnz cseg_896FD

    *(word *)&g_memByte[91626] = 0;         // mov isCareer, 0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_894DC;                    // jz short cseg_894DC

    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, offset careerTeam
    if (!flags.zero)
        goto cseg_894E5;                    // jnz short cseg_894E5

cseg_894DC:;
    *(word *)&g_memByte[91626] = 1;         // mov isCareer, 1

cseg_894E5:;
    push(D7);                               // push D7
    push(A1);                               // push A1
    push(A2);                               // push A2
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    A1 = 336284;                            // mov A1, offset gameName
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4
    A0 = eax;                               // mov A0, eax
    StringCopy();                           // call StringCopy
    g_memByte[336324] = 0;                  // mov gameRound, 0
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_89590;                    // jz short cseg_89590

    A1 = 336324;                            // mov A1, offset gameRound
    ax = (word)readMemory(esi + 73, 2);     // mov ax, [esi+73]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+79]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 75, 2);     // mov ax, [esi+75]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+49]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    cseg_284AB();                           // call cseg_284AB
    StringCopy();                           // call StringCopy

cseg_89590:;
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    A6 = 318643;                            // mov A6, offset DIY_competitionStart
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 51, 2);     // mov ax, [esi+33h]
    *(word *)&g_memByte[449290] = ax;       // mov gamePitchTypeOrSeason, ax
    al = (byte)readMemory(esi + 46, 1);     // mov al, [esi+2Eh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 60h
    if (flags.carry)
        goto cseg_895DA;                    // jb short cseg_895DA

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 96;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 60h

cseg_895DA:;
    {
        dword res = D0 & 255;
        D0 = res;
    }                                       // and D0, 0FFh
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 8;                                 // mov bx, 8
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[449294] = ax;       // mov gameSeason, ax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 53, 2);     // mov ax, [esi+35h]
    *(word *)&g_memByte[449292] = ax;       // mov gamePitchType, ax
    *(word *)&g_memByte[449312] = 0;        // mov team1GoalsFirstLeg, 0
    *(word *)&g_memByte[449314] = 0;        // mov team2GoalsFirstLeg, 0
    *(word *)&g_memByte[449308] = 0;        // mov extraTimeState, 0
    *(word *)&g_memByte[449310] = 0;        // mov penaltiesState, 0
    *(word *)&g_memByte[449288] = 0;        // mov secondLeg, 0
    *(word *)&g_memByte[449286] = 0;        // mov playing2ndGame, 0
    *(word *)&g_memByte[449284] = 0;        // mov isGameFriendly, 0
    eax = A0;                               // mov eax, A0
    A4 = eax;                               // mov A4, eax
    A5 = 0;                                 // mov A5, 0
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+2Bh]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    {
        word src = (word)readMemory(esi + 93, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+5Dh], 1
    if (!flags.zero)
        goto cseg_896A1;                    // jnz short cseg_896A1

    *(byte *)&D0 = 255;                     // mov byte ptr D0, 0FFh

cseg_896A1:;
    ax = *(word *)&g_memByte[318742];       // mov ax, diyLeagueMinSubstitutes
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[318744];       // mov ax, diyLeagueMaxSubstitutes
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = *(word *)&g_memByte[318702];       // mov ax, dseg_10EEE4
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    SWOS::InitializeInGameTeamsAndStartGame(); // call InitializeInGameTeamsAndStartGame
    if (!flags.zero)
        goto cseg_896FD;                    // jnz short cseg_896FD

    ax = *(word *)&g_memByte[336632];       // mov ax, statsTeam1GoalsCopy
    *(word *)&g_memByte[336652] = ax;       // mov dseg_114C96, ax
    ax = *(word *)&g_memByte[336634];       // mov ax, statsTeam2GoalsCopy
    *(word *)&g_memByte[336654] = ax;       // mov dseg_114C98, ax
    *(word *)&g_memByte[91626] = 0;         // mov isCareer, 0
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax = 0;                                 // mov ax, 0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax

cseg_896FD:;
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// out:
//      A1 ->
//
void cseg_89758()
{
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 91, 2);     // mov ax, [esi+91]
    {
        word src = (word)readMemory(esi + 81, 2);
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul word ptr [esi+81]
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    *(word *)((byte *)&D5 + 2) = dx;        // mov word ptr D5+2, dx
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 237;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 237
    ebx = *(word *)&D5;                     // movzx ebx, word ptr D5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    A3 = 465964;                            // mov A3, offset dseg_16AED3
    al = (byte)readMemory(esi + 45, 1);     // mov al, [esi+45]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = g_memByte[29227];                  // mov al, byte ptr europeanChampionships
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto l_european_championships;      // jz short @@european_championships

    al = g_memByte[29149];                  // mov al, european_championships2
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto l_european_championships;      // jz short @@european_championships

    A3 = 378222;                            // mov A3, offset dseg_11F356
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+81]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 2
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A3 = eax;                               // mov A3, eax

l_european_championships:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 459, 2);    // mov ax, [esi+459]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A3;                               // mov eax, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A3 = eax;                               // mov A3, eax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A3)++;                    // inc A3
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 18;                                // mov bx, 18
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A2 = eax;                               // mov A2, eax
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 18;                                // mov bx, 18
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 95, 1);
        byte res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+95], 1
    if (flags.zero)
        return;                             // jz short @@out

    eax = A1;                               // mov eax, A1
    {
        dword tmp = A2;
        A2 = eax;
        eax = tmp;
    }                                       // xchg eax, A2
    A1 = eax;                               // mov A1, eax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_89956()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    A1 = 317588;                            // mov A1, offset diyFileBufferCopy
    *(word *)&D0 = 1448;                    // mov word ptr D0, 1448

cseg_89973:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    flags.carry = false;                    // or ax, ax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_89973;                    // jns short cseg_89973
}

// =============== S U B R O U T I N E =======================================
//
void cseg_899A0()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    A1 = 317588;                            // mov A1, offset diyFileBufferCopy
    *(word *)&D0 = 1448;                    // mov word ptr D0, 1448

cseg_899BD:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    flags.carry = false;                    // or ax, ax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_899BD;                    // jns short cseg_899BD
}

// =============== S U B R O U T I N E =======================================
//
void cseg_899EA()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    *(word *)&D0 = 544;                     // mov word ptr D0, 544

cseg_89A07:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    flags.carry = false;                    // or ax, ax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_89A07;                    // jns short cseg_89A07
}

// =============== S U B R O U T I N E =======================================
//
void cseg_89A34()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    *(word *)&D0 = 544;                     // mov word ptr D0, 544

cseg_89A51:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    flags.carry = false;                    // or ax, ax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_89A51;                    // jns short cseg_89A51
}

// =============== S U B R O U T I N E =======================================
//
void cseg_89A7E()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    *(word *)&D0 = 920;                     // mov word ptr D0, 920

cseg_89A9B:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    flags.carry = false;                    // or ax, ax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_89A9B;                    // jns short cseg_89A9B
}

// =============== S U B R O U T I N E =======================================
//
void cseg_89AC8()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    *(word *)&D0 = 920;                     // mov word ptr D0, 920

cseg_89AE5:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    flags.carry = false;                    // or ax, ax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_89AE5;                    // jns short cseg_89AE5
}

// =============== S U B R O U T I N E =======================================
//
void RestoreDIYTournament()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    A1 = 317588;                            // mov A1, offset diyFileBufferCopy
    *(word *)&D0 = 1448;                    // mov word ptr D0, 1448

cseg_89B2F:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    flags.carry = false;                    // or ax, ax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_89B2F;                    // jns short cseg_89B2F
}

// =============== S U B R O U T I N E =======================================
//
void cseg_89B5C()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[337166] = ax;       // mov dseg_114E98, ax
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[337168] = ax;       // mov dseg_114E9A, ax
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[337170] = ax;       // mov dseg_114E9C, ax

cseg_89B80:;
    A2 = 317588;                            // mov A2, offset diyFileBufferCopy
    eax = A2;                               // mov eax, A2
    A3 = eax;                               // mov A3, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    bx = 118;                               // mov bx, 76h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, eax
    A4 = 318643;                            // mov A4, offset DIY_competitionStart
    A5 = 318643;                            // mov A5, offset DIY_competitionStart
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_89DE6;                    // jz cseg_89DE6

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 71, 2, 1);            // mov word ptr [esi+47h], 1
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_89C36;                    // jnz short cseg_89C36

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 71, 2, 2);            // mov word ptr [esi+47h], 2

cseg_89C36:;
    ax = *(word *)&g_memByte[337166];       // mov ax, dseg_114E98
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[337168];       // mov ax, dseg_114E9A
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[337170];       // mov ax, dseg_114E9C
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 63, 2);     // mov ax, [esi+3Fh]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 63, 2, ax);           // mov [esi+3Fh], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 61, 2);     // mov ax, [esi+3Dh]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 61, 2, ax);           // mov [esi+3Dh], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 65, 2);     // mov ax, [esi+41h]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 65, 2, ax);           // mov [esi+41h], ax
    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    ShowDiyLeaguesTournamentMenu();         // call ShowDiyLeaguesTournamentMenu
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 57, 2);     // mov ax, [esi+39h]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 57, 2, ax);           // mov [esi+39h], ax
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 67, 4);          // mov eax, [esi+43h]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 67, 4, eax);          // mov [esi+43h], eax
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi + 69, 4);          // mov eax, [esi+45h]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 69, 4, eax);          // mov [esi+45h], eax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 63, 2);     // mov ax, [esi+3Fh]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 63, 2, ax);           // mov [esi+3Fh], ax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 61, 2);     // mov ax, [esi+3Dh]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 61, 2, ax);           // mov [esi+3Dh], ax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 65, 2);     // mov ax, [esi+41h]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 65, 2, ax);           // mov [esi+41h], ax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+5Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 85, 1, 0);            // mov byte ptr [esi+55h], 0
    if (!flags.zero)
        goto cseg_89D68;                    // jnz short cseg_89D68

    writeMemory(esi + 85, 1, 255);          // mov byte ptr [esi+55h], 0FFh

cseg_89D68:;
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (flags.zero)
        return;                             // jz short cseg_89D7C

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 3
    if (!flags.zero)
        goto cseg_89D7E;                    // jnz short cseg_89D7E

cseg_89D7C:;
    return;                                 // retn

cseg_89D7E:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js cseg_8A142

    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_8A147();                           // call cseg_8A147
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_89B80;                    // jz cseg_89B80

    return;                                 // retn

cseg_89DE6:;
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 71, 2, 1);            // mov word ptr [esi+47h], 1
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_89E29;                    // jnz short cseg_89E29

    esi = A4;                               // mov esi, A4
    writeMemory(esi + 71, 2, 2);            // mov word ptr [esi+47h], 2

cseg_89E29:;
    ax = *(word *)&g_memByte[337166];       // mov ax, dseg_114E98
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[337168];       // mov ax, dseg_114E9A
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[337170];       // mov ax, dseg_114E9C
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 75, 2, ax);           // mov [esi+4Bh], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 63, 2);     // mov ax, [esi+3Fh]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 63, 2, ax);           // mov [esi+3Fh], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 61, 2);     // mov ax, [esi+3Dh]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 61, 2, ax);           // mov [esi+3Dh], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 65, 2);     // mov ax, [esi+41h]
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 65, 2, ax);           // mov [esi+41h], ax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_45B51();                           // call cseg_45B51
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 75, 2);     // mov ax, [esi+4Bh]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 71, 2, ax);           // mov [esi+47h], ax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 57, 2);     // mov ax, [esi+39h]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 57, 2, ax);           // mov [esi+39h], ax
    esi = A4;                               // mov esi, A4
    eax = readMemory(esi + 67, 4);          // mov eax, [esi+43h]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 67, 4, eax);          // mov [esi+43h], eax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 69, 2);     // mov ax, [esi+45h]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 69, 2, ax);           // mov [esi+45h], ax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 63, 2);     // mov ax, [esi+3Fh]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 63, 2, ax);           // mov [esi+3Fh], ax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 61, 2);     // mov ax, [esi+3Dh]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 61, 2, ax);           // mov [esi+3Dh], ax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 65, 2);     // mov ax, [esi+41h]
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 65, 2, ax);           // mov [esi+41h], ax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+55h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_89FF9;                    // jz short cseg_89FF9

    esi = A2;                               // mov esi, A2
    writeMemory(esi + 85, 1, 255);          // mov byte ptr [esi+55h], 0FFh

cseg_89FF9:;
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (flags.zero)
        goto cseg_8A011;                    // jz short cseg_8A011

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 3
    if (!flags.zero)
        goto cseg_8A0DE;                    // jnz cseg_8A0DE

cseg_8A011:;
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_8A0DD

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_284D8();                           // call cseg_284D8
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

cseg_8A0DD:;
    return;                                 // retn

cseg_8A0DE:;
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        return;                             // js short cseg_8A142

    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_8A147();                           // call cseg_8A147
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_89B80;                    // jz cseg_89B80

    return;                                 // retn
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8A147()
{
    A2 = 317588;                            // mov A2, offset diyFileBufferCopy
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_8A2CC

    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_8A2B4;                    // jz cseg_8A2B4

    eax = A2;                               // mov eax, A2
    A3 = eax;                               // mov A3, eax
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    bx = 118;                               // mov bx, 76h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, eax
    A4 = 318643;                            // mov A4, offset DIY_competitionStart
    A5 = 318643;                            // mov A5, offset DIY_competitionStart
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8A23B;                    // jz short cseg_8A23B

    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_8A2CE();                           // call cseg_8A2CE
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7
    goto cseg_8A27C;                        // jmp short cseg_8A27C

cseg_8A23B:;
    push(D7);                               // push D7
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_8A7BF();                           // call cseg_8A7BF
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D7);                                // pop D7

cseg_8A27C:;
    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 83, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi + 83, 2, src);
    }                                       // add word ptr [esi+53h], 1
    cseg_258E4();                           // call cseg_258E4
    ax = *(word *)&g_memByte[129476];       // mov ax, dseg_E0052
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short cseg_8A2CC

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (flags.zero)
        { cseg_8BF1A(); return; }           // jz cseg_8BF1A

    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 3
    if (flags.zero)
        cseg_8BF1A();                       // jz cseg_8BF1A

    return;                                 // retn

cseg_8A2B4:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 2, 2, 2);             // mov word ptr [esi+2], 2
    writeMemory(esi + 87, 2, 1);            // mov word ptr [esi+57h], 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8A2CE()
{
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 45, 1);     // mov al, [esi+2Dh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = g_memByte[28229];                  // mov al, worldCup
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto cseg_8A323;                    // jnz short cseg_8A323

    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_8A94F();                           // call cseg_8A94F
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    goto cseg_8A66F;                        // jmp cseg_8A66F

cseg_8A323:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 355, 2);    // mov ax, [esi+163h]
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D3 = eax;                               // mov D3, eax
    dx = *(word *)((byte *)&D3 + 2);        // mov dx, word ptr D3+2
    {
        word src = (word)readMemory(esi + 361, 2);
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / src);
        word rem = (word)(dividend % src);
        ax = quot;
        dx = rem;
    }                                       // div word ptr [esi+169h]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    *(word *)((byte *)&D3 + 2) = dx;        // mov word ptr D3+2, dx
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 109;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 6Dh
    A1 = eax;                               // mov A1, eax
    *(word *)&D5 = 32000;                   // mov word ptr D5, 7D00h
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_8A397:;
    ax = D5;                                // mov ax, word ptr D5
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)&D2 = 0;                       // mov word ptr D2, 0

cseg_8A3AC:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&A1;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        *(word *)&A1 = res;
    }                                       // add word ptr A1, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto cseg_8A405;                    // jz short cseg_8A405

    if (!flags.carry && !flags.zero)
        goto cseg_8A427;                    // ja short cseg_8A427

    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    ax = D4;                                // mov ax, word ptr D4
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 707, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 707, 2, src);
    }                                       // add [esi+2C3h], ax
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1000;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 3E8h
    goto cseg_8A427;                        // jmp short cseg_8A427

cseg_8A405:;
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 707, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2000;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 707, 2, src);
    }                                       // add word ptr [esi+2C3h], 7D0h

cseg_8A427:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_8A3AC;                    // jnz cseg_8A3AC

    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, 64h
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_8A397;                    // jns cseg_8A397

    writeMemory(esi + 79, 2, 1);            // mov word ptr [esi+4Fh], 1
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    writeMemory(esi + 81, 2, ax);           // mov [esi+51h], ax
    push(D3);                               // push D3
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_883DD();                           // call cseg_883DD
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(D3);                                // pop D3
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 281;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 119h
    A6 = eax;                               // mov A6, eax
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word tmp = *(word *)((byte *)&D3 + 2);
        *(word *)((byte *)&D3 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D3+2
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8A66F;                    // jz cseg_8A66F

    ax = D0;                                // mov ax, word ptr D0
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 361, 2);
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul word ptr [esi+169h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 109;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 6Dh
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    *(word *)&D2 = 18;                      // mov word ptr D2, 12h
    ax = D2;                                // mov ax, word ptr D2
    {
        word src = (word)readMemory(esi + 363, 2);
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul word ptr [esi+16Bh]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D3 = res;
    }                                       // sub word ptr D3, 1

cseg_8A571:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&A1;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        *(word *)&A1 = res;
    }                                       // add word ptr A1, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 18;                                // mov bx, 12h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 8;                       // mov word ptr D1, 8
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    bx = 25;                                // mov bx, 19h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 707, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        src = res;
        writeMemory(esi + 707, 2, src);
    }                                       // add [esi+2C3h], ax
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_8A571;                    // jns cseg_8A571

    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_883DD();                           // call cseg_883DD
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2

cseg_8A66F:;
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 109;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 6Dh
    A0 = eax;                               // mov A0, eax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 237;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0EDh
    A1 = eax;                               // mov A1, eax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_8A6A3:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&A0;
        int16_t srcSigned = 2;
        word res = dstSigned + srcSigned;
        *(word *)&A0 = res;
    }                                       // add word ptr A0, 2
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 18;                                // mov bx, 12h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_8A6A3;                    // jns short cseg_8A6A3

    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 237;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0EDh
    A0 = eax;                               // mov A0, eax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A1 = eax;                               // mov A1, eax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_8A737:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int16_t *)&A0)++;                    // inc word ptr A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8A737;                    // jns short cseg_8A737

    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 355, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+163h], 1
    if (flags.zero)
        return;                             // jz short cseg_8A7BE

    ax = (word)readMemory(esi + 465, 2);    // mov ax, [esi+1D1h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_8A7BE

    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    writeMemory(esi, 2, ax);                // mov [esi], ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 2, 2, ax);            // mov [esi+2], ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8A7BF()
{
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 355, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+163h], 1
    if (!flags.zero)
        goto cseg_8A7E2;                    // jnz short cseg_8A7E2

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8A8DC;                    // jnz cseg_8A8DC

cseg_8A7E2:;
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_2ACAE();                           // call cseg_2ACAE
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 347, 2);    // mov ax, [esi+15Bh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8A84B;                    // jnz short cseg_8A84B

    {
        word src = (word)readMemory(esi + 355, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+163h], 1
    if (flags.zero)
        goto cseg_8A88C;                    // jz short cseg_8A88C

    ax = (word)readMemory(esi + 465, 2);    // mov ax, [esi+1D1h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8A88C;                    // jz short cseg_8A88C

cseg_8A84B:;
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    writeMemory(esi, 2, ax);                // mov [esi], ax
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 2, 2, ax);            // mov [esi+2], ax

cseg_8A88C:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 45, 1);     // mov al, [esi+2Dh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = g_memByte[28229];                  // mov al, worldCup
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto cseg_8A8DC;                    // jnz short cseg_8A8DC

    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_8A94F();                           // call cseg_8A94F
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2

cseg_8A8DC:;
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A0 = eax;                               // mov A0, eax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A1 = eax;                               // mov A1, eax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 347, 2);    // mov ax, [esi+15Bh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8A921;                    // jz short cseg_8A921

    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1

cseg_8A921:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_8A929:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8A929;                    // jns short cseg_8A929
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8A94F()
{
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_8AC00

    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 355, 2);    // mov ax, [esi+163h]
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D3 = eax;                               // mov D3, eax
    dx = *(word *)((byte *)&D3 + 2);        // mov dx, word ptr D3+2
    {
        word src = (word)readMemory(esi + 361, 2);
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / src);
        word rem = (word)(dividend % src);
        ax = quot;
        dx = rem;
    }                                       // div word ptr [esi+169h]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    *(word *)((byte *)&D3 + 2) = dx;        // mov word ptr D3+2, dx
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 109;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 6Dh
    A1 = eax;                               // mov A1, eax
    *(word *)&D4 = 9000;                    // mov word ptr D4, 2328h
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

cseg_8A9C7:;
    *(word *)&D2 = 0;                       // mov word ptr D2, 0

cseg_8A9D0:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto cseg_8AA27;                    // jz short cseg_8AA27

    if (!flags.carry && !flags.zero)
        goto cseg_8AA49;                    // ja short cseg_8AA49

    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    ax = D4;                                // mov ax, word ptr D4
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 707, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 707, 2, src);
    }                                       // add [esi+2C3h], ax
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 100;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 64h
    goto cseg_8AA49;                        // jmp short cseg_8AA49

cseg_8AA27:;
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 707, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1000;
        word res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 707, 2, src);
    }                                       // add word ptr [esi+2C3h], 3E8h

cseg_8AA49:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto cseg_8A9D0;                    // jnz cseg_8A9D0

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    ax = (word)readMemory(esi + 79, 2);     // mov ax, [esi+4Fh]
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto cseg_8A9C7;                    // jnz cseg_8A9C7

    writeMemory(esi + 79, 2, 1);            // mov word ptr [esi+4Fh], 1
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    writeMemory(esi + 81, 2, ax);           // mov [esi+51h], ax
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_883DD();                           // call cseg_883DD
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 281;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 119h
    A6 = eax;                               // mov A6, eax
    *(word *)&D2 = 3;                       // mov word ptr D2, 3
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 133;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 85h
    A1 = eax;                               // mov A1, eax

cseg_8AB03:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A5;                               // mov eax, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 18;                                // mov bx, 12h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    esi = A6;                               // mov esi, A6
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    al = (byte)readMemory(esi + eax, 1);    // mov al, [esi+eax]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&D1 = 6;                       // mov word ptr D1, 6
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    ax = D1;                                // mov ax, word ptr D1
    bx = 100;                               // mov bx, 64h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 707, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        src = res;
        writeMemory(esi + 707, 2, src);
    }                                       // add [esi+2C3h], ax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_8AB03;                    // jns cseg_8AB03

    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_883DD();                           // call cseg_883DD
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8AC02()
{
    *(word *)&g_memByte[317675] = 0;        // mov dseg_10EAE1, 0
    *(word *)&g_memByte[317671] = 0;        // mov dseg_10EADD, 0
    *(word *)&g_memByte[318645] = 0;        // mov dseg_10EEAB, 0
    *(word *)&g_memByte[317655] = 0;        // mov dseg_10EACD, 0
    *(word *)&g_memByte[317657] = 0;        // mov dseg_10EACF, 0
    *(word *)&g_memByte[317645] = 65535;    // mov dseg_10EAC3, 0FFFFh
    *(word *)&g_memByte[317590] = 1;        // mov dseg_10EA8C, 1
    A0 = 317677;                            // mov A0, offset dseg_10EAE3
    *(byte *)&D1 = 0;                       // mov byte ptr D1, 0
    *(word *)&D0 = 63;                      // mov word ptr D0, 63

cseg_8AC64:;
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8AC64;                    // jns short cseg_8AC64

    cseg_258E4();                           // call cseg_258E4
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8AC90()
{
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 57, 2, 65535);        // mov word ptr [esi+39h], 0FFFFh
    writeMemory(esi + 67, 2, 0);            // mov word ptr [esi+43h], 0
    writeMemory(esi + 69, 2, 0);            // mov word ptr [esi+45h], 0
    writeMemory(esi + 73, 2, 0);            // mov word ptr [esi+49h], 0
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    writeMemory(esi + 79, 2, ax);           // mov [esi+4Fh], ax
    writeMemory(esi + 81, 2, ax);           // mov [esi+51h], ax
    writeMemory(esi + 99, 2, 0);            // mov word ptr [esi+63h], 0
    writeMemory(esi + 83, 2, 0);            // mov word ptr [esi+53h], 0
    writeMemory(esi + 87, 2, 0);            // mov word ptr [esi+57h], 0
    writeMemory(esi + 85, 2, 0);            // mov word ptr [esi+55h], 0
    writeMemory(esi + 329, 2, 0);           // mov word ptr [esi+149h], 0
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ax = (word)readMemory(esi + eax + 101, 2); // mov ax, [esi+eax+65h]
    writeMemory(esi + 331, 2, ax);          // mov [esi+14Bh], ax
    {
        word src = (word)readMemory(esi + 79, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+4Fh], 1
    if (!flags.zero)
        goto cseg_8AD5A;                    // jnz short cseg_8AD5A

    {
        word src = (word)readMemory(esi + 331, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+14Bh], 2
    if (flags.zero)
        goto cseg_8AD5A;                    // jz short cseg_8AD5A

    writeMemory(esi + 331, 2, 0);           // mov word ptr [esi+14Bh], 0

cseg_8AD5A:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 815, 2, 0);           // mov word ptr [esi+32Fh], 0
    writeMemory(esi + 813, 2, 0);           // mov word ptr [esi+32Dh], 0
    writeMemory(esi + 821, 2, 0);           // mov word ptr [esi+335h], 0
    writeMemory(esi + 817, 2, 0);           // mov word ptr [esi+331h], 0
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A0 = eax;                               // mov A0, eax
    *(byte *)&D1 = 0;                       // mov byte ptr D1, 0
    *(word *)&D0 = 63;                      // mov word ptr D0, 3Fh

cseg_8ADA3:;
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8ADA3;                    // jns short cseg_8ADA3

    *(byte *)&D1 = 0;                       // mov byte ptr D1, 0
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 137;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 89h
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 31;                      // mov word ptr D0, 1Fh

cseg_8ADE5:;
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8ADE5;                    // jns short cseg_8ADE5

    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 55, 1);     // mov al, [esi+37h]
    writeMemory(esi + 46, 1, al);           // mov [esi+2Eh], al
    g_memByte[129466] = al;                 // mov dseg_E0048, al
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    writeMemory(esi + 75, 2, 0);            // mov word ptr [esi+4Bh], 0
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A1 = eax;                               // mov A1, eax
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 24Dh
    A3 = eax;                               // mov A3, eax
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_8AE6B:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    esi = A3;                               // mov esi, A3
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_8AEC1;                    // jz short cseg_8AEC1

    esi = A2;                               // mov esi, A2
    {
        word src = (word)readMemory(esi + 75, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        src = res;
        writeMemory(esi + 75, 2, src);
    }                                       // add word ptr [esi+4Bh], 1

cseg_8AEC1:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_8AE6B;                    // jns short cseg_8AE6B

    cseg_28139();                           // call cseg_28139
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8AED0()
{
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 67, 2, 0);            // mov word ptr [esi+43h], 0
    writeMemory(esi + 69, 2, 0);            // mov word ptr [esi+45h], 0
    writeMemory(esi + 57, 2, 65535);        // mov word ptr [esi+39h], 0FFFFh
    writeMemory(esi + 445, 2, 0);           // mov word ptr [esi+1BDh], 0
    writeMemory(esi + 91, 2, 0);            // mov word ptr [esi+5Bh], 0
    writeMemory(esi + 459, 2, 0);           // mov word ptr [esi+1CBh], 0
    writeMemory(esi + 457, 2, 0);           // mov word ptr [esi+1C9h], 0
    writeMemory(esi + 449, 2, 0);           // mov word ptr [esi+1C1h], 0
    writeMemory(esi + 447, 2, 0);           // mov word ptr [esi+1BFh], 0
    ax = (word)readMemory(esi + 105, 2);    // mov ax, [esi+69h]
    writeMemory(esi + 107, 2, ax);          // mov [esi+6Bh], ax
    ax = (word)readMemory(esi + 93, 2);     // mov ax, [esi+5Dh]
    writeMemory(esi + 95, 2, ax);           // mov [esi+5Fh], ax
    *(word *)&D0 = 63;                      // mov word ptr D0, 3Fh

cseg_8AF3E:;
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 695, 2, 0);           // mov word ptr [esi+2B7h], 0
    writeMemory(esi + 697, 2, 0);           // mov word ptr [esi+2B9h], 0
    writeMemory(esi + 699, 2, 0);           // mov word ptr [esi+2BBh], 0
    writeMemory(esi + 701, 2, 0);           // mov word ptr [esi+2BDh], 0
    writeMemory(esi + 703, 2, 0);           // mov word ptr [esi+2BFh], 0
    writeMemory(esi + 705, 2, 0);           // mov word ptr [esi+2C1h], 0
    writeMemory(esi + 707, 2, 0);           // mov word ptr [esi+2C3h], 0
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 18;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A2 = res;
    }                                       // add A2, 12h
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8AF3E;                    // jns short cseg_8AF3E

    A0 = 318880;                            // mov A0, offset dseg_10EF96
    A1 = 318752;                            // mov A1, offset dseg_10EF16
    *(byte *)&D1 = 0;                       // mov byte ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    *(word *)&D0 = 63;                      // mov word ptr D0, 3Fh

cseg_8AFC0:;
    al = D1;                                // mov al, byte ptr D1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    ax = D2;                                // mov ax, word ptr D2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 18;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 12h
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8AFC0;                    // jns short cseg_8AFC0

    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 55, 1);     // mov al, [esi+37h]
    writeMemory(esi + 46, 1, al);           // mov [esi+2Eh], al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    g_memByte[129466] = al;                 // mov dseg_E0048, al
    cseg_28243();                           // call cseg_28243
}

// =============== S U B R O U T I N E =======================================

// in:
//    A0 ->
//
void InitNewSeason()
{
    *(word *)&g_memByte[529336] = 65535;    // mov dseg_180588, 0FFFFh
    *(word *)&g_memByte[91346] = 0;         // mov retired, 0
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    g_memByte[131744] = al;                 // mov compCountryNumber, al
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[91726] = ax;        // mov dseg_D6CDC, ax
    A0 = 99944;                             // mov A0, offset arrayOfPointers
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 126568);            // mov dword ptr [esi], offset competitionFileBuffer
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 99964);             // mov dword ptr [esi], offset dseg_D8D0A
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 102862);            // mov dword ptr [esi], offset dseg_D985C
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 105044);            // mov dword ptr [esi], offset dseg_DA0E2
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 103953);            // mov dword ptr [esi], offset dseg_D9C9F
    *(dword *)&g_memByte[99868] = 0;        // mov dseg_D8CAA, 0
    *(dword *)&g_memByte[99872] = 0;        // mov dseg_D8CAE, 0
    *(dword *)&g_memByte[99876] = 0;        // mov dseg_D8CB2, 0
    *(dword *)&g_memByte[99880] = 0;        // mov dseg_D8CB6, 0
    *(dword *)&g_memByte[99884] = 0;        // mov dseg_D8CBA, 0
    *(word *)&g_memByte[109908] = 0;        // mov dseg_DB3E2, 0
    *(word *)&g_memByte[109904] = 0;        // mov dseg_DB3DE, 0
    *(word *)&g_memByte[109906] = 0;        // mov dseg_DB3E0, 0
    *(word *)&g_memByte[109910] = 0;        // mov dseg_DB3E4, 0
    al = D7;                                // mov al, byte ptr D7
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A6 = 33933;                             // mov A6, offset competitionsTable
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A6 = eax;                               // mov A6, eax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A6 = res;
    }                                       // add A6, 4
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    push(A6);                               // push A6
    cseg_8B2D3();                           // call cseg_8B2D3
    pop(A6);                                // pop A6
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 4
    esi = A6;                               // mov esi, A6
    {
        dword src = readMemory(esi, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi], 0FFFFFFFFh
    if (flags.zero)
        goto cseg_8B22C;                    // jz short cseg_8B22C

    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A6 = res;
    }                                       // add A6, 4
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(A6);                               // push A6
    cseg_8B2D3();                           // call cseg_8B2D3
    pop(A6);                                // pop A6
    esi = A6;                               // mov esi, A6
    {
        dword src = readMemory(esi, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi], 0FFFFFFFFh
    if (flags.zero)
        goto cseg_8B22C;                    // jz short cseg_8B22C

    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(A6);                               // push A6
    cseg_8B2D3();                           // call cseg_8B2D3
    pop(A6);                                // pop A6

cseg_8B22C:;
    *(word *)&g_memByte[99864] = 0;         // mov seasonFinished, 0
    *(word *)&g_memByte[99866] = 0;         // mov careerFinished, 0
    *(word *)&g_memByte[99894] = 0;         // mov seasonNumberOfSquads, 0
    A1 = 99896;                             // mov A1, offset dseg_D8CC6
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax

cseg_8B26F:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_8B29C;                    // jz short cseg_8B29C

    {
        word src = *(word *)&g_memByte[99894];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[99894] = src;
    }                                       // add seasonNumberOfSquads, 1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2

cseg_8B29C:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 684
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8B26F;                    // jns short cseg_8B26F

    ax = *(word *)&g_memByte[99894];        // mov ax, seasonNumberOfSquads
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8B2C3;                    // jnz short cseg_8B2C3

    *(word *)&g_memByte[99866] = 1;         // mov careerFinished, 1

cseg_8B2C3:;
    al = g_memByte[109913];                 // mov al, dseg_DB3E6+1
    g_memByte[129466] = al;                 // mov dseg_E0048, al
    InitTeams();                            // call InitTeams
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8B2D3()
{
    A1 = 99868;                             // mov A1, offset dseg_D8CAA
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    eax = A0;                               // mov eax, A0
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    writeMemory(esi + ebx, 4, eax);         // mov [esi+ebx], eax
    A1 = 99944;                             // mov A1, offset arrayOfPointers
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A1 = eax;                               // mov A1, eax
    {
        word res = *(word *)&D0 >> 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D0, 2
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 43, 2, ax);           // mov [esi+2Bh], ax
    eax = A1;                               // mov eax, A1
    {
        dword tmp = A0;
        A0 = eax;
        eax = tmp;
    }                                       // xchg eax, A0
    A1 = eax;                               // mov A1, eax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    cseg_8B71C();                           // call cseg_8B71C
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    eax = A1;                               // mov eax, A1
    {
        dword tmp = A0;
        A0 = eax;
        eax = tmp;
    }                                       // xchg eax, A0
    A1 = eax;                               // mov A1, eax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto cseg_8B403;                    // jz short cseg_8B403

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (flags.zero)
        goto cseg_8B3F1;                    // jz short cseg_8B3F1

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 3
    if (flags.zero)
        goto cseg_8B413;                    // jz short cseg_8B413

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8B3DF;                    // jz short cseg_8B3DF

    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 0
    if (flags.zero)
        goto cseg_8B413;                    // jz short cseg_8B413

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 2
    if (flags.zero)
        goto cseg_8B413;                    // jz short cseg_8B413

cseg_8B3DF:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 1
    if (!flags.zero)
        goto cseg_8B6AD;                    // jnz cseg_8B6AD

    goto cseg_8B413;                        // jmp short cseg_8B413

cseg_8B3F1:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 1
    if (!flags.zero)
        goto cseg_8B6AD;                    // jnz cseg_8B6AD

    goto cseg_8B413;                        // jmp short cseg_8B413

cseg_8B403:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 1
    if (flags.zero)
        goto cseg_8B6AD;                    // jz cseg_8B6AD

cseg_8B413:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (!flags.zero)
        goto cseg_8B46E;                    // jnz short cseg_8B46E

    A3 = 319232;                            // mov A3, offset dseg_10F0F6
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 10, 1);     // mov al, [esi+0Ah]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D3 = res;
    }                                       // sub word ptr D3, 1

cseg_8B44A:;
    ax = *(word *)&g_memByte[92798];        // mov ax, word ptr careerTeam
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A3 = res;
    }                                       // add A3, 2
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_8B44A;                    // jns short cseg_8B44A

    goto cseg_8B575;                        // jmp cseg_8B575

cseg_8B46E:;
    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8B4F3;                    // jz short cseg_8B4F3

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    A3 = 318944;                            // mov A3, offset dseg_10EFD6
    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D3, 0
    if (flags.zero)
        goto cseg_8B4BB;                    // jz short cseg_8B4BB

    A3 = 319232;                            // mov A3, offset dseg_10F0F6
    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D3, 1
    if (flags.zero)
        goto cseg_8B4BB;                    // jz short cseg_8B4BB

    A3 = 317741;                            // mov A3, offset dseg_10EB23

cseg_8B4BB:;
    push(D0);                               // push D0
    push(A0);                               // push A0
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A3;                               // mov eax, A3
    A0 = eax;                               // mov A0, eax
    cseg_87D60();                           // call cseg_87D60
    pop(A0);                                // pop A0
    pop(D0);                                // pop D0
    goto cseg_8B575;                        // jmp cseg_8B575

cseg_8B4F3:;
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(A0);                               // push A0
    push(A1);                               // push A1
    cseg_31F58();                           // call cseg_31F58
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(A0);                               // push A0
    push(A1);                               // push A1
    cseg_8C607();                           // call cseg_8C607
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

cseg_8B575:;
    eax = D1;                               // mov eax, D1
    {
        dword tmp = D0;
        D0 = eax;
        eax = tmp;
    }                                       // xchg eax, D0
    D1 = eax;                               // mov D1, eax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(A0);                               // push A0
    push(A1);                               // push A1
    cseg_883B8();                           // call cseg_883B8
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    eax = D1;                               // mov eax, D1
    {
        dword tmp = D0;
        D0 = eax;
        eax = tmp;
    }                                       // xchg eax, D0
    D1 = eax;                               // mov D1, eax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[317631] = ax;       // mov dseg_10EAB5, ax
    *(word *)&g_memByte[318686] = ax;       // mov dseg_10EED4, ax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    eax = A1;                               // mov eax, A1
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    push(D2);                               // push D2
    push(A0);                               // push A0
    cseg_8B7EA();                           // call cseg_8B7EA
    pop(A0);                                // pop A0
    pop(D2);                                // pop D2
    pop(D0);                                // pop D0
    push(D0);                               // push D0
    push(D2);                               // push D2
    push(A0);                               // push A0
    cseg_8BF89();                           // call cseg_8BF89
    pop(A0);                                // pop A0
    pop(D2);                                // pop D2
    pop(D0);                                // pop D0
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (flags.zero)
        return;                             // jz short cseg_8B6AC

    push(D0);                               // push D0
    push(D2);                               // push D2
    push(A0);                               // push A0
    cseg_8B71C();                           // call cseg_8B71C
    pop(A0);                                // pop A0
    pop(D2);                                // pop D2
    pop(D0);                                // pop D0
    cseg_8B8B8();                           // call cseg_8B8B8

cseg_8B6AC:;
    return;                                 // retn

cseg_8B6AD:;
    debugBreak();                           // int 3

cseg_8B6AE:;
    goto cseg_8B6AE;                        // jmp short cseg_8B6AE
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8B6B0()
{
    A0 = 126568;                            // mov A0, offset competitionFileBuffer
    cseg_8B71C();                           // jmp short cseg_8B71C
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8B6CB()
{
    A0 = 99964;                             // mov A0, offset dseg_D8D0A
    cseg_8B71C();                           // jmp short cseg_8B71C
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8B6E6()
{
    A0 = 102862;                            // mov A0, offset dseg_D985C
    cseg_8B71C();                           // jmp short cseg_8B71C
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8B701()
{
    A0 = 105044;                            // mov A0, offset dseg_DA0E2
    cseg_8B71C();                           // jmp short cseg_8B71C
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8B71C()
{
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8B766;                    // jnz short cseg_8B766

    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    *(word *)&D0 = 1842;                    // mov word ptr D0, 732h

cseg_8B73D:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8B73D;                    // jns short cseg_8B73D

    return;                                 // retn

cseg_8B766:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (!flags.zero)
        goto cseg_8B7AE;                    // jnz short cseg_8B7AE

    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    *(word *)&D0 = 1090;                    // mov word ptr D0, 442h

cseg_8B785:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8B785;                    // jns short cseg_8B785

    return;                                 // retn

cseg_8B7AE:;
    A1 = 317588;                            // mov A1, offset diyFileBufferCopy
    *(word *)&D0 = 2897;                    // mov word ptr D0, 0B51h

cseg_8B7C1:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8B7C1;                    // jns short cseg_8B7C1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8B7EA()
{
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8B834;                    // jnz short cseg_8B834

    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    *(word *)&D0 = 1842;                    // mov word ptr D0, 732h

cseg_8B80B:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8B80B;                    // jns short cseg_8B80B

    return;                                 // retn

cseg_8B834:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (!flags.zero)
        goto cseg_8B87C;                    // jnz short cseg_8B87C

    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    *(word *)&D0 = 1090;                    // mov word ptr D0, 442h

cseg_8B853:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8B853;                    // jns short cseg_8B853

    return;                                 // retn

cseg_8B87C:;
    A1 = 317588;                            // mov A1, offset diyFileBufferCopy
    *(word *)&D0 = 2897;                    // mov word ptr D0, 0B51h

cseg_8B88F:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8B88F;                    // jns short cseg_8B88F
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8B8B8()
{
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 0
    if (flags.zero)
        { cseg_8B8D9(); return; }           // jz short cseg_8B8D9

    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (flags.zero)
        { cseg_8BBFD(); return; }           // jz cseg_8BBFD

    cseg_8BF1A();                           // jmp cseg_8BF1A
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8B8D9()
{
    A6 = 318643;                            // mov A6, offset DIY_competitionStart
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+5Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_8BBFC

    A4 = 109912;                            // mov A4, offset dseg_DB3E6
    ax = *(word *)&g_memByte[109908];       // mov ax, dseg_DB3E2
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1
    ax = *(word *)&g_memByte[317671];       // mov ax, dseg_10EADD
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+2Bh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_8B930:;
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto cseg_8B960;                    // jnz short cseg_8B960

    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8B97C;                    // jz short cseg_8B97C

    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto cseg_8B97C;                    // jz short cseg_8B97C

cseg_8B960:;
    esi = A4;                               // mov esi, A4
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A4 = res;
    }                                       // add A4, eax
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_8B930;                    // jns short cseg_8B930

    debugBreak();                           // int 3

cseg_8B97A:;
    goto cseg_8B97A;                        // jmp short cseg_8B97A

cseg_8B97C:;
    eax = A4;                               // mov eax, A4
    A3 = eax;                               // mov A3, eax

cseg_8B986:;
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_89758();                           // call cseg_89758
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_8922B();                           // call cseg_8922B
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+2B3h]
    A1 = eax;                               // mov A1, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+2B3h]
    A2 = eax;                               // mov A2, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, eax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (!flags.zero)
        goto cseg_8BB56;                    // jnz short cseg_8BB56

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_8BBD3;                    // jz cseg_8BBD3

    {
        dword src = *(dword *)&g_memByte[318682];
        int32_t dstSigned = src;
        int32_t srcSigned = 7200;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10EED0, offset aFriendly_0
    if (flags.zero)
        goto cseg_8BB4A;                    // jz short cseg_8BB4A

    {
        word src = *(word *)&g_memByte[318736];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp diyLeaguePlayEachTeam, 1
    if (flags.zero)
        goto cseg_8BB78;                    // jz short cseg_8BB78

cseg_8BB4A:;
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 10, 1, 2);            // mov byte ptr [esi+0Ah], 2
    goto cseg_8BB82;                        // jmp short cseg_8BB82

cseg_8BB56:;
    {
        dword src = *(dword *)&g_memByte[318682];
        int32_t dstSigned = src;
        int32_t srcSigned = 7200;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_10EED0, offset aFriendly_0
    if (flags.zero)
        goto cseg_8BB6C;                    // jz short cseg_8BB6C

    {
        word src = *(word *)&g_memByte[318736];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp diyLeaguePlayEachTeam, 1
    if (flags.zero)
        goto cseg_8BB78;                    // jz short cseg_8BB78

cseg_8BB6C:;
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 10, 1, 1);            // mov byte ptr [esi+0Ah], 1
    goto cseg_8BB82;                        // jmp short cseg_8BB82

cseg_8BB78:;
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 10, 1, 0);            // mov byte ptr [esi+0Ah], 0

cseg_8BB82:;
    esi = A4;                               // mov esi, A4
    {
        byte src = (byte)readMemory(esi + 5, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 5, 1, src);
    }                                       // add byte ptr [esi+5], 1
    {
        byte src = (byte)readMemory(esi + 6, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 6, 1, src);
    }                                       // add byte ptr [esi+6], 1
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 11, 1, 0);            // mov byte ptr [esi+0Bh], 0
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 12, 2, ax);           // mov [esi+0Ch], ax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A3;                               // mov esi, A3
    writeMemory(esi + 14, 2, ax);           // mov [esi+0Eh], ax
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 12;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0Ch
    A3 = eax;                               // mov A3, eax

cseg_8BBD3:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 447, 2);    // mov ax, [esi+1BFh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8B986;                    // jz cseg_8B986

    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+5Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8B960;                    // jnz cseg_8B960
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8BBFD()
{
    *(word *)&D7 = 0;                       // mov word ptr D7, 0

    cseg_8BC06();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8BC06()
{
_l_start:;
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+55h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_8BEA0

    {
        word src = (word)readMemory(esi + 329, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+149h], 1
    if (flags.zero)
        return;                             // jz cseg_8BEA0

    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = (word)readMemory(esi + 71, 2);     // mov ax, [esi+47h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8BC50;                    // jz short cseg_8BC50

    ax = *(word *)&g_memByte[317671];       // mov ax, dseg_10EADD
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_8BC50:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+2Bh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A6 = 109912;                            // mov A6, offset dseg_DB3E6
    ax = *(word *)&g_memByte[109908];       // mov ax, dseg_DB3E2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_8BC7E:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto cseg_8BC9F;                    // jnz short cseg_8BC9F

    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto cseg_8BCBB;                    // jz short cseg_8BCBB

cseg_8BC9F:;
    esi = A6;                               // mov esi, A6
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A6 = res;
    }                                       // add A6, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_8BC7E;                    // jns short cseg_8BC7E

    debugBreak();                           // int 3

cseg_8BCB9:;
    goto cseg_8BCB9;                        // jmp short cseg_8BCB9

cseg_8BCBB:;
    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8BCD4;                    // jz short cseg_8BCD4

    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 2
    if (!flags.zero)
        goto cseg_8BC9F;                    // jnz short cseg_8BC9F

    goto cseg_8BD16;                        // jmp short cseg_8BD16

cseg_8BCD4:;
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 1
    if (flags.zero)
        goto cseg_8BD16;                    // jz short cseg_8BD16

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 815, 2);    // mov ax, [esi+32Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8BD00;                    // jnz short cseg_8BD00

    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 3
    if (flags.zero)
        goto cseg_8BC9F;                    // jz short cseg_8BC9F

    goto cseg_8BD16;                        // jmp short cseg_8BD16

cseg_8BD00:;
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 3;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 3
    if (!flags.zero)
        goto cseg_8BC9F;                    // jnz short cseg_8BC9F

    writeMemory(esi + 4, 1, 0);             // mov byte ptr [esi+4], 0

cseg_8BD16:;
    eax = A6;                               // mov eax, A6
    A5 = eax;                               // mov A5, eax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 5, 1, 0);             // mov byte ptr [esi+5], 0
    writeMemory(esi + 6, 1, 0);             // mov byte ptr [esi+6], 0
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A1 = eax;                               // mov A1, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_8BD5B:;
    cseg_8BEA1();                           // call cseg_8BEA1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    eax = A0;                               // mov eax, A0
    A3 = eax;                               // mov A3, eax
    cseg_8BEA1();                           // call cseg_8BEA1
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 2
    if (!flags.zero)
        goto cseg_8BDA7;                    // jnz short cseg_8BDA7

    eax = D0;                               // mov eax, D0
    {
        dword tmp = D3;
        D3 = eax;
        eax = tmp;
    }                                       // xchg eax, D3
    D0 = eax;                               // mov D0, eax
    eax = A0;                               // mov eax, A0
    {
        dword tmp = A3;
        A3 = eax;
        eax = tmp;
    }                                       // xchg eax, A3
    A0 = eax;                               // mov A0, eax

cseg_8BDA7:;
    esi = A3;                               // mov esi, A3
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (!flags.zero)
        goto cseg_8BDE1;                    // jnz short cseg_8BDE1

    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        goto cseg_8BE54;                    // jz cseg_8BE54

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 331, 2);    // mov ax, [esi+14Bh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8BDFF;                    // jz short cseg_8BDFF

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 10, 1, 2);            // mov byte ptr [esi+0Ah], 2
    goto cseg_8BE09;                        // jmp short cseg_8BE09

cseg_8BDE1:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 331, 2);    // mov ax, [esi+14Bh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8BDFF;                    // jz short cseg_8BDFF

    esi = A5;                               // mov esi, A5
    writeMemory(esi + 10, 1, 1);            // mov byte ptr [esi+0Ah], 1
    goto cseg_8BE09;                        // jmp short cseg_8BE09

cseg_8BDFF:;
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 10, 1, 0);            // mov byte ptr [esi+0Ah], 0

cseg_8BE09:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 14, 2, ax);           // mov [esi+0Eh], ax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A5;                               // mov esi, A5
    writeMemory(esi + 12, 2, ax);           // mov [esi+0Ch], ax
    writeMemory(esi + 11, 1, 0);            // mov byte ptr [esi+0Bh], 0
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 5, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 5, 1, src);
    }                                       // add byte ptr [esi+5], 1
    {
        byte src = (byte)readMemory(esi + 6, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 6, 1, src);
    }                                       // add byte ptr [esi+6], 1
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 12;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A5 = res;
    }                                       // add A5, 0Ch

cseg_8BE54:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_8BD5B;                    // jns cseg_8BD5B

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_8BE87;                    // jnz short cseg_8BE87

    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 75, 2);     // mov ax, [esi+4Bh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8BE87;                    // jz short cseg_8BE87

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 6, 1, 255);           // mov byte ptr [esi+6], 0FFh

cseg_8BE87:;
    *(word *)&D7 = 1;                       // mov word ptr D7, 1
    esi = A6;                               // mov esi, A6
    {
        byte src = (byte)readMemory(esi + 8, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+8], 1
    if (flags.zero)
        goto _l_start;                      // jz cseg_8BC06
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8BEA1()
{
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 4;                                 // mov bx, 4
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 835;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 343h
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8BF1A()
{
    A0 = 317588;                            // mov A0, offset diyFileBufferCopy
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short cseg_8BF88

    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    bx = 118;                               // mov bx, 76h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        { cseg_8BBFD(); return; }           // jz cseg_8BBFD

    cseg_8B8D9();                           // call cseg_8B8D9
    cseg_31B94();                           // jmp cseg_31B94
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8BF89()
{
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 0
    if (flags.zero)
        goto cseg_8BFAA;                    // jz short cseg_8BFAA

    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (flags.zero)
        goto cseg_8C0B6;                    // jz cseg_8C0B6

    { cseg_8C2AE(); return; }               // jmp cseg_8C2AE

cseg_8BFAA:;
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (!flags.zero)
        goto cseg_8BFC9;                    // jnz short cseg_8BFC9

    *(word *)&D5 = 22;                      // mov word ptr D5, 16h
    goto cseg_8C014;                        // jmp short cseg_8C014

cseg_8BFC9:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    {
        word res = *(word *)&D5 >> 1;
        *(word *)&D5 = res;
    }                                       // shr word ptr D5, 1
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 24;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, 18h
    if (flags.carry || flags.zero)
        goto cseg_8BFF3;                    // jbe short cseg_8BFF3

    *(word *)&D5 = 24;                      // mov word ptr D5, 18h

cseg_8BFF3:;
    ax = D5;                                // mov ax, word ptr D5
    bx = 12;                                // mov bx, 0Ch
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    *(word *)((byte *)&D5 + 2) = dx;        // mov word ptr D5+2, dx
    {
        int32_t dstSigned = D5;
        int32_t srcSigned = 10;
        dword res = dstSigned + srcSigned;
        D5 = res;
    }                                       // add D5, 0Ah

cseg_8C014:;
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 461;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 1CDh
    A5 = eax;                               // mov A5, eax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 451, 2);    // mov ax, [esi+1C3h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_8C03E:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_8C516();                           // call cseg_8C516
    {
        word src = *(word *)&g_memByte[109908];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[109908] = src;
    }                                       // add dseg_DB3E2, 1
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;                    // inc A5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 1, 1, al);            // mov [esi+1], al
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+2Bh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 1, al);                // mov [esi], al
    ax = D5;                                // mov ax, word ptr D5
    writeMemory(esi + 2, 2, ax);            // mov [esi+2], ax
    writeMemory(esi + 4, 1, 0);             // mov byte ptr [esi+4], 0
    writeMemory(esi + 5, 1, 0);             // mov byte ptr [esi+5], 0
    writeMemory(esi + 6, 1, 0);             // mov byte ptr [esi+6], 0
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A4 = res;
    }                                       // add A4, eax
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_8C03E;                    // jns short cseg_8C03E

    return;                                 // retn

cseg_8C0B6:;
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+2Bh]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 823;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 337h
    A5 = eax;                               // mov A5, eax
    eax = A6;                               // mov eax, A6
    A3 = eax;                               // mov A3, eax
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax

cseg_8C112:;
    {
        word res = *(word *)&D6 >> 1;
        *(word *)&D6 = res;
    }                                       // shr word ptr D6, 1
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (!flags.zero)
        goto cseg_8C12E;                    // jnz short cseg_8C12E

    *(word *)&D5 = 22;                      // mov word ptr D5, 16h
    goto cseg_8C16E;                        // jmp short cseg_8C16E

cseg_8C12E:;
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 24;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, 18h
    if (flags.carry || flags.zero)
        goto cseg_8C14D;                    // jbe short cseg_8C14D

    *(word *)&D5 = 24;                      // mov word ptr D5, 18h

cseg_8C14D:;
    ax = D5;                                // mov ax, word ptr D5
    bx = 12;                                // mov bx, 0Ch
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    *(word *)((byte *)&D5 + 2) = dx;        // mov word ptr D5+2, dx
    {
        int32_t dstSigned = D5;
        int32_t srcSigned = 10;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D5 = res;
    }                                       // add D5, 0Ah

cseg_8C16E:;
    cseg_8C21C();                           // call cseg_8C21C
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 101, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+65h], 2
    if (flags.zero)
        goto cseg_8C1C0;                    // jz short cseg_8C1C0

    esi = A4;                               // mov esi, A4
    writeMemory(esi + 8, 1, 0);             // mov byte ptr [esi+8], 0
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, eax
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi + 125, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+7Dh], 1
    if (flags.zero)
        goto cseg_8C1F9;                    // jz short cseg_8C1F9

    cseg_8C21C();                           // call cseg_8C21C
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 8, 1, 3);             // mov byte ptr [esi+8], 3
    writeMemory(esi + 4, 1, 1);             // mov byte ptr [esi+4], 1
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // add A4, eax
    goto cseg_8C1F9;                        // jmp short cseg_8C1F9

cseg_8C1C0:;
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 8, 1, 1);             // mov byte ptr [esi+8], 1
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // add A4, eax
    cseg_8C21C();                           // call cseg_8C21C
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 8, 1, 2);             // mov byte ptr [esi+8], 2
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, eax

cseg_8C1F9:;
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 2
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 1
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (!flags.zero)
        goto cseg_8C112;                    // jnz cseg_8C112
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8C21C()
{
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_8C516();                           // call cseg_8C516
    {
        word src = *(word *)&g_memByte[109908];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        src = res;
        *(word *)&g_memByte[109908] = src;
    }                                       // add dseg_DB3E2, 1
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;
    flags.sign = (*(int32_t *)&A5 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A5 == 0;      // inc A5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 1, 1, al);            // mov [esi+1], al
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 91, 2);     // mov ax, [esi+5Bh]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    cseg_280C0();                           // call cseg_280C0
    al = D0;                                // mov al, byte ptr D0
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 9, 1, al);            // mov [esi+9], al
    al = D3;                                // mov al, byte ptr D3
    writeMemory(esi + 7, 1, al);            // mov [esi+7], al
    al = D4;                                // mov al, byte ptr D4
    writeMemory(esi, 1, al);                // mov [esi], al
    ax = D5;                                // mov ax, word ptr D5
    writeMemory(esi + 2, 2, ax);            // mov [esi+2], ax
    writeMemory(esi + 4, 1, 0);             // mov byte ptr [esi+4], 0
    writeMemory(esi + 5, 1, 0);             // mov byte ptr [esi+5], 0
    writeMemory(esi + 6, 1, 0);             // mov byte ptr [esi+6], 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8C2AE()
{
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 345, 2);    // mov ax, [esi+159h]
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = (word)readMemory(esi + 43, 2);     // mov ax, [esi+2Bh]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    A4 = 109912;                            // mov A4, offset dseg_DB3E6
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_8C2FE:;
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (!flags.zero)
        goto cseg_8C313;                    // jnz short cseg_8C313

    *(word *)&D5 = 22;                      // mov word ptr D5, 16h
    goto cseg_8C362;                        // jmp short cseg_8C362

cseg_8C313:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    {
        word res = *(word *)&D5 >> 1;
        *(word *)&D5 = res;
    }                                       // shr word ptr D5, 1
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 24;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, 18h
    if (flags.carry || flags.zero)
        goto cseg_8C340;                    // jbe short cseg_8C340

    *(word *)&D5 = 24;                      // mov word ptr D5, 18h

cseg_8C340:;
    ax = D5;                                // mov ax, word ptr D5
    bx = 12;                                // mov bx, 0Ch
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    *(word *)((byte *)&D5 + 2) = dx;        // mov word ptr D5+2, dx
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 10;
        word res = dstSigned + srcSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 0Ah

cseg_8C362:;
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 373;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 175h
    A5 = eax;                               // mov A5, eax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8C3EC;                    // jnz short cseg_8C3EC

    cseg_8C452();                           // call cseg_8C452
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 365, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+16Dh], 2
    if (flags.zero)
        goto cseg_8C3D1;                    // jz short cseg_8C3D1

    esi = A4;                               // mov esi, A4
    writeMemory(esi + 8, 1, 0);             // mov byte ptr [esi+8], 0
    esi = A6;                               // mov esi, A6
    {
        word src = (word)readMemory(esi + 369, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+171h], 1
    if (flags.zero)
        goto cseg_8C42F;                    // jz short cseg_8C42F

    cseg_8C452();                           // call cseg_8C452
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 8, 1, 3);             // mov byte ptr [esi+8], 3
    writeMemory(esi + 4, 1, 1);             // mov byte ptr [esi+4], 1
    goto cseg_8C42F;                        // jmp short cseg_8C42F

cseg_8C3D1:;
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 8, 1, 1);             // mov byte ptr [esi+8], 1
    cseg_8C452();                           // call cseg_8C452
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 8, 1, 2);             // mov byte ptr [esi+8], 2
    goto cseg_8C42F;                        // jmp short cseg_8C42F

cseg_8C3EC:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 371, 2);    // mov ax, [esi+173h]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1

cseg_8C407:;
    cseg_8C452();                           // call cseg_8C452
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 8, 1, 0);             // mov byte ptr [esi+8], 0
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A4 = res;
    }                                       // add A4, eax
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto cseg_8C407;                    // jns short cseg_8C407

cseg_8C42F:;
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 118;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 76h
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 1
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (!flags.zero)
        goto cseg_8C2FE;                    // jnz cseg_8C2FE
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8C452()
{
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_8C516();                           // call cseg_8C516
    {
        word src = *(word *)&g_memByte[109908];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        src = res;
        *(word *)&g_memByte[109908] = src;
    }                                       // add dseg_DB3E2, 1
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A5)++;
    flags.sign = (*(int32_t *)&A5 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A5 == 0;      // inc A5
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 1, 1, al);            // mov [esi+1], al
    push(D2);                               // push small [word ptr D2]
    push(D3);                               // push small [word ptr D3]
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    ax = (word)readMemory(esi + 353, 2);    // mov ax, [esi+161h]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    cseg_283BD();                           // call cseg_283BD
    {
        int32_t val = stack[stackTop++];
        *(word *)&D3 = val;
    }                                       // pop small [word ptr D3]
    {
        int32_t val = stack[stackTop++];
        *(word *)&D2 = val;
    }                                       // pop small [word ptr D2]
    al = D0;                                // mov al, byte ptr D0
    esi = A4;                               // mov esi, A4
    writeMemory(esi + 9, 1, al);            // mov [esi+9], al
    al = D3;                                // mov al, byte ptr D3
    writeMemory(esi + 7, 1, al);            // mov [esi+7], al
    al = D2;                                // mov al, byte ptr D2
    writeMemory(esi, 1, al);                // mov [esi], al
    ax = D5;                                // mov ax, word ptr D5
    writeMemory(esi + 2, 2, ax);            // mov [esi+2], ax
    writeMemory(esi + 4, 1, 0);             // mov byte ptr [esi+4], 0
    writeMemory(esi + 5, 1, 0);             // mov byte ptr [esi+5], 0
    writeMemory(esi + 6, 1, 0);             // mov byte ptr [esi+6], 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8C516()
{
    A4 = 109912;                            // mov A4, offset dseg_DB3E6
    ax = *(word *)&g_memByte[109908];       // mov ax, dseg_DB3E2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_8C573

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_8C539:;
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry)
        goto cseg_8C574;                    // jb short cseg_8C574

    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A4 = res;
    }                                       // add A4, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_8C539;                    // jns short cseg_8C539

    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 126566;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, offset dseg_DF4F4
    if (!flags.carry && !flags.zero)
        goto cseg_8C604;                    // ja cseg_8C604

cseg_8C573:;
    return;                                 // retn

cseg_8C574:;
    eax = A4;                               // mov eax, A4
    A0 = eax;                               // mov A0, eax

cseg_8C57E:;
    esi = A0;                               // mov esi, A0
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_8C57E;                    // jns short cseg_8C57E

    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D5;                     // movzx ebx, word ptr D5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 126566;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset dseg_DF4F4
    if (!flags.carry && !flags.zero)
        goto cseg_8C604;                    // ja short cseg_8C604

    eax = A0;                               // mov eax, A0
    D1 = eax;                               // mov D1, eax
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        D1 = res;
    }                                       // sub D1, eax
    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_8C5DA:;
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned - srcSigned;
        A0 = res;
    }                                       // sub A0, 2
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        A1 = res;
    }                                       // sub A1, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_8C5DA;                    // jns short cseg_8C5DA

    return;                                 // retn

cseg_8C604:;
    debugBreak();                           // int 3

cseg_8C605:;
    goto cseg_8C605;                        // jmp short cseg_8C605
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8C607()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (!flags.zero)
        return;                             // jnz short @@out

    ax = *(word *)&g_memByte[92020];        // mov ax, numForeignMarketPlayers2
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    cseg_8C64C();                           // call cseg_8C64C
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8C623()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (!flags.zero)
        return;                             // jnz short cseg_8C64B

    ax = *(word *)&g_memByte[92020];        // mov ax, numForeignMarketPlayers2
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    ax = *(word *)&g_memByte[92022];        // mov ax, dseg_D6E04
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    cseg_8C64C();                           // call cseg_8C64C
}

// =============== S U B R O U T I N E =======================================

// in:
//     D7 - number of... teams?
//
void cseg_8C64C()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        return;                             // jnz @@out

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1
    if (flags.sign)
        return;                             // js @@out

    A6 = 111782;                            // mov A6, offset careerForeignMarketPlayers

cseg_8C672:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A5 = eax;                               // mov A5, eax
    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D3 = res;
    }                                       // sub word ptr D3, 1

cseg_8C6AB:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D5;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D5, al
    if (!flags.zero)
        goto l_next_team;                   // jnz @@next_team

    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D4, al
    if (!flags.zero)
        goto l_next_team;                   // jnz @@next_team

    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 38
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 76;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 76
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A4 = eax;                               // mov A4, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4
    A3 = eax;                               // mov A3, eax
    *(word *)&D0 = 18;                      // mov word ptr D0, 18

cseg_8C735:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 2
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A4 = res;
    }                                       // add A4, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8C735;                    // jns short cseg_8C735

l_next_team:;
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 684
    A5 = eax;                               // mov A5, eax
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto cseg_8C6AB;                    // jns cseg_8C6AB

    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 42;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 42
    A6 = eax;                               // mov A6, eax
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_8C672;                    // jns cseg_8C672
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - selected team country number
//
void InitCareer()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)&g_memByte[91714] = 594;       // mov dseg_D6CD0, 594
    A0 = 96218;                             // mov A0, offset someLeaguesTable
    *(word *)&D0 = 1999;                    // mov word ptr D0, 1999

l_init_leagues_table_loop:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_init_leagues_table_loop;     // jns short @@init_leagues_table_loop

    cseg_8CC0A();                           // call cseg_8CC0A
    *(word *)&g_memByte[91684] = 0;         // mov dseg_D6CB2, 0
    *(word *)&g_memByte[92018] = 0;         // mov dseg_D6E00, 0
    *(word *)&g_memByte[91588] = 0;         // mov dseg_D6C52, 0
    *(word *)&g_memByte[91590] = 0;         // mov dseg_D6C54, 0
    *(word *)&g_memByte[91592] = 0;         // mov dseg_D6C56, 0
    *(word *)&g_memByte[91594] = 0;         // mov dseg_D6C58, 0
    *(word *)&g_memByte[91596] = 0;         // mov dseg_D6C5A, 0
    *(word *)&g_memByte[91630] = 0;         // mov gamesPlayed, 0
    *(word *)&g_memByte[91632] = 0;         // mov numWins, 0
    *(word *)&g_memByte[91634] = 0;         // mov numDrawn, 0
    *(word *)&g_memByte[91636] = 0;         // mov numLost, 0
    *(word *)&g_memByte[91638] = 0;         // mov goalsScored, 0
    *(word *)&g_memByte[91640] = 0;         // mov goalsTaken, 0
    *(word *)&g_memByte[91770] = 0;         // mov dseg_D6D08, 0
    *(word *)&g_memByte[91764] = 0;         // mov dseg_D6D02, 0
    *(word *)&g_memByte[91766] = 0;         // mov dseg_D6D04, 0
    *(word *)&g_memByte[91768] = 0;         // mov dseg_D6D06, 0
    *(word *)&g_memByte[91730] = 0;         // mov playPromotedAnimation, 0
    *(word *)&g_memByte[91732] = 0;         // mov playRelegatedAnimation, 0
    *(word *)&g_memByte[323894] = 0;        // mov teamsLoaded, 0
    *(word *)&g_memByte[323896] = 0;        // mov poolplyrLoaded, 0
    *(word *)&g_memByte[36606] = 0;         // mov careerFileBuffer, 0
    *(word *)&g_memByte[91598] = -1;        // mov dseg_D6C5C, -1
    *(word *)&g_memByte[91600] = 0;         // mov playWinCupAnimation, 0
    *(word *)&g_memByte[91602] = 0;         // mov dseg_D6C60, 0
    *(word *)&g_memByte[91604] = 0;         // mov dseg_D6C62, 0
    *(word *)&g_memByte[91606] = 0;         // mov dseg_D6C64, 0
    *(word *)&g_memByte[91608] = 0;         // mov dseg_D6C66, 0
    *(word *)&g_memByte[91610] = 0;         // mov dseg_D6C68, 0
    *(word *)&g_memByte[91612] = 0;         // mov dseg_D6C6A, 0
    *(word *)&g_memByte[91614] = 0;         // mov dseg_D6C6C, 0
    *(word *)&g_memByte[91618] = 0;         // mov dseg_D6C70, 0
    *(word *)&g_memByte[91620] = 0;         // mov dseg_D6C72, 0
    *(word *)&g_memByte[91622] = 0;         // mov dseg_D6C74, 0
    *(word *)&g_memByte[91624] = 0;         // mov dseg_D6C76, 0
    *(word *)&g_memByte[91616] = 0;         // mov dseg_D6C6E, 0
    push(D7);                               // push D7
    cseg_8CB18();                           // call cseg_8CB18
    pop(D7);                                // pop D7
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    CareerInitVars();                       // call CareerInitVars
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D0);                               // push D0
    push(D7);                               // push D7
    CalculateStartingBalance();             // call CalculateStartingBalance
    pop(D7);                                // pop D7
    pop(D0);                                // pop D0
    cseg_5DB56();                           // call cseg_5DB56
    *(word *)&g_memByte[36606] = 0;         // mov careerFileBuffer, 0
    A0 = 27854;                             // mov A0, offset euroCup
    LoadSomeEuroCup();                      // call LoadSomeEuroCup
    A0 = 27933;                             // mov A0, offset cupWinnersCup
    LoadSomeEuroCup();                      // call LoadSomeEuroCup
    A0 = 28025;                             // mov A0, offset uefaCup
    LoadSomeEuroCup();                      // call LoadSomeEuroCup
    A2 = 27459;                             // mov A2, offset careerContests

l_next_contest:;
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 4
    A0 = eax;                               // mov A0, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, -1
    if (flags.zero)
        goto l_contests_copied;             // jz short @@contests_copied

    esi = A2;                               // mov esi, A2
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 4
    A1 = eax;                               // mov A1, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

l_init_contests_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_init_contests_loop;          // jns short @@init_contests_loop

    goto l_next_contest;                    // jmp short @@next_contest

l_contests_copied:;
    *(word *)&g_memByte[323894] = 0;        // mov teamsLoaded, 0
    *(word *)&g_memByte[126629] = 5;        // mov dseg_DF533, 5
    *(word *)&g_memByte[126631] = 2;        // mov dseg_DF535, 2
    *(word *)&g_memByte[126633] = 8;        // mov dseg_DF537, 8
    *(word *)&g_memByte[100025] = 5;        // mov dseg_D8D47, 5
    *(word *)&g_memByte[100027] = 2;        // mov dseg_D8D49, 2
    *(word *)&g_memByte[100029] = 8;        // mov dseg_D8D4B, 8
    *(word *)&g_memByte[102923] = 5;        // mov dseg_D9899, 5
    *(word *)&g_memByte[102925] = 2;        // mov dseg_D989B, 2
    *(word *)&g_memByte[102927] = 8;        // mov dseg_D989D, 8
    *(word *)&g_memByte[105105] = 5;        // mov dseg_DA11F, 5
    *(word *)&g_memByte[105107] = 2;        // mov dseg_DA121, 2
    *(word *)&g_memByte[105109] = 8;        // mov dseg_DA123, 8
    *(word *)&g_memByte[91330] = -1;        // mov currentSeasonShowing, -1
    {
        byte src = g_memByte[129467];
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        g_memByte[129467] = src;
    }                                       // sub seasonPlaying, 1
    InitializeNewSeason();                  // call InitializeNewSeason
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    A0 = 4159;                              // mov A0, offset cseg_8CB09
    *(word *)&D1 = 21;                      // mov word ptr D1, 21

cseg_8CAD5:;
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.carry)
        goto cseg_8CAD5;                    // jnb short cseg_8CAD5

    ax = D1;                                // mov ax, word ptr D1
    *(word *)&g_memByte[91328] = ax;        // mov dseg_D6B4E, ax
    *(word *)&g_memByte[129476] = 0;        // mov dseg_E0052, 0
}

// DATA XREF: InitCareer+32Co

// =============== S U B R O U T I N E =======================================
//
void cseg_8CB18()
{
    *(word *)&g_memByte[92300] = 0;         // mov numPlayersOnTransferMarket, 0
    *(word *)&g_memByte[92020] = 0;         // mov numForeignMarketPlayers2, 0
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Fh
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[92324] = ax;        // mov dseg_D6F32, ax
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Fh
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[92326] = ax;        // mov dseg_D6F34, ax
    *(word *)&g_memByte[92328] = 0;         // mov dseg_D6F36, 0
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Fh
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[92322] = ax;        // mov dseg_D6F30, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8CC0A()
{
    *(word *)&D0 = 1999;                    // mov word ptr D0, 1999
    A0 = 96218;                             // mov A0, offset someLeaguesTable
    A1 = 353800;                            // mov A1, offset leaguesTableCopy

l_copy_loop:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_loop;                   // jns short @@copy_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8CC4E()
{
    *(word *)&D0 = 1999;                    // mov word ptr D0, 1999
    A0 = 96218;                             // mov A0, offset someLeaguesTable
    A1 = 353800;                            // mov A1, offset leaguesTableCopy

cseg_8CC6B:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8CC6B;                    // jns short cseg_8CC6B
}

// =============== S U B R O U T I N E =======================================
//
void InitializeNewSeason()
{
    *(word *)&g_memByte[323894] = 0;        // mov teamsLoaded, 0
    {
        word src = *(word *)&g_memByte[91330];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91330] = src;
    }                                       // add currentSeasonShowing, 1
    {
        word src = *(word *)&g_memByte[91330];
        int16_t dstSigned = src;
        int16_t srcSigned = 20;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp currentSeasonShowing, 20
    if (!flags.zero)
        goto cseg_8CCB6;                    // jnz short cseg_8CCB6

    *(word *)&g_memByte[91330] = 0;         // mov currentSeasonShowing, 0

cseg_8CCB6:;
    *(word *)&g_memByte[94092] = 65535;     // mov dseg_D761A, 0FFFFh
    A0 = 92330;                             // mov A0, offset dseg_D6F38
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, -1);                // mov word ptr [esi], -1
    writeMemory(esi + 4, 2, -1);            // mov word ptr [esi+4], -1
    writeMemory(esi + 8, 2, -1);            // mov word ptr [esi+8], -1
    writeMemory(esi + 12, 2, -1);           // mov word ptr [esi+12], -1
    *(word *)&g_memByte[91346] = 0;         // mov retired, 0
    *(word *)&g_memByte[91344] = 0;         // mov youreSacked, 0
    *(word *)&g_memByte[91348] = 0;         // mov dseg_D6B62, 0
    {
        word src = *(word *)&g_memByte[91332];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91332] = src;
    }                                       // add stayingInOldClub, 1
    {
        byte src = g_memByte[129467];
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        src = res;
        g_memByte[129467] = src;
    }                                       // add seasonPlaying, 1
    {
        byte src = g_memByte[129467];
        int8_t dstSigned = src;
        int8_t srcSigned = 100;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp seasonPlaying, 100
    if (!flags.zero)
        goto cseg_8CD32;                    // jnz short cseg_8CD32

    g_memByte[129467] = 0;                  // mov seasonPlaying, 0

cseg_8CD32:;
    cseg_8CC4E();                           // call cseg_8CC4E
    *(word *)&g_memByte[91642] = 0;         // mov dseg_D6C88, 0
    *(word *)&g_memByte[91644] = 0;         // mov dseg_D6C8A, 0
    *(word *)&g_memByte[91646] = 0;         // mov dseg_D6C8C, 0
    *(word *)&g_memByte[91648] = 0;         // mov dseg_D6C8E, 0
    *(word *)&g_memByte[91650] = 0;         // mov dseg_D6C90, 0
    *(word *)&g_memByte[91652] = 0;         // mov dseg_D6C92, 0
    *(word *)&g_memByte[91654] = 0;         // mov dseg_D6C94, 0
    *(word *)&g_memByte[91656] = 0;         // mov dseg_D6C96, 0
    *(word *)&g_memByte[91658] = 0;         // mov dseg_D6C98, 0
    *(word *)&g_memByte[91660] = 0;         // mov dseg_D6C9A, 0
    *(word *)&g_memByte[91662] = 0;         // mov dseg_D6C9C, 0
    *(word *)&g_memByte[91664] = 0;         // mov dseg_D6C9E, 0
    GetCurrentSeasonPointer();              // call GetCurrentSeasonPointer
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    writeMemory(esi + 22, 4, 0);            // mov [esi+SeasonInformations.leagueStringOffset], 0
    writeMemory(esi + 26, 4, 0);            // mov [esi+SeasonInformations.strOffset1], 0
    writeMemory(esi + 30, 4, 0);            // mov [esi+SeasonInformations.strOffset2], 0
    writeMemory(esi + 34, 4, 0);            // mov [esi+SeasonInformations.field_22], 0
    writeMemory(esi + 86, 1, 0);            // mov [esi+SeasonInformations.field_56], 0
    writeMemory(esi + 87, 1, 0);            // mov [esi+SeasonInformations.finalPosition], 0
    writeMemory(esi + 88, 1, 0);            // mov [esi+SeasonInformations.field_58], 0
    writeMemory(esi + 89, 1, 0);            // mov [esi+SeasonInformations.field_59], 0
    writeMemory(esi + 40, 1, 0);            // mov [esi+SeasonInformations.bestScorerName], 0
    writeMemory(esi + 105, 1, 0);           // mov [esi+SeasonInformations.managerStatus], 0
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, SeasonInformations.clubName
    A1 = eax;                               // mov A1, eax
    A0 = 92803;                             // mov A0, (offset careerTeam+5)
    StringCopy();                           // call StringCopy
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+TeamFile.globalTeamNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A1 = 96218;                             // mov A1, offset someLeaguesTable
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91724];        // mov ax, careerTeamLeague
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[91726] = ax;        // mov dseg_D6CDC, ax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 25, 1, al);           // mov [esi+TeamFile.league], al
    *(word *)&g_memByte[91666] = 0;         // mov dseg_D6CA0, 0
    *(word *)&g_memByte[94094] = 0;         // mov dseg_D761C, 0
    cseg_8D839();                           // call cseg_8D839
    *(word *)&g_memByte[126566] = 0;        // mov dseg_DF4F4, 0
    *(word *)&g_memByte[91626] = 0;         // mov isCareer, 0
    *(word *)&g_memByte[91628] = 0;         // mov dseg_D6C7A, 0
    *(word *)&g_memByte[92034] = 0;         // mov numNewJobOffers, 0
    *(word *)&g_memByte[92166] = 0;         // mov numJobOffers, 0
    *(word *)&g_memByte[91350] = 0;         // mov dseg_D6B64, 0
    *(word *)&g_memByte[337240] = 0;        // mov currentMessage, 0
    A0 = 99686;                             // mov A0, offset dseg_D8BF4
    *(word *)&D0 = 177;                     // mov word ptr D0, 177

cseg_8CEE4:;
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 1, 255);               // mov byte ptr [esi], 0FFh
    (*(int32_t *)&A0)++;                    // inc A0
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8CEE4;                    // jns short cseg_8CEE4

    A0 = 99944;                             // mov A0, offset arrayOfPointers
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 126568);            // mov dword ptr [esi], offset competitionFileBuffer
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 99964);             // mov dword ptr [esi], offset dseg_D8D0A
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 102862);            // mov dword ptr [esi], offset dseg_D985C
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 105044);            // mov dword ptr [esi], offset dseg_DA0E2
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 4, 103953);            // mov dword ptr [esi], offset dseg_D9C9F
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    *(dword *)&g_memByte[99868] = 0;        // mov dseg_D8CAA, 0
    *(dword *)&g_memByte[99872] = 0;        // mov dseg_D8CAE, 0
    *(dword *)&g_memByte[99876] = 0;        // mov dseg_D8CB2, 0
    *(dword *)&g_memByte[99880] = 0;        // mov dseg_D8CB6, 0
    *(dword *)&g_memByte[99884] = 0;        // mov dseg_D8CBA, 0
    *(word *)&g_memByte[131757] = 1;        // mov g_numSelectedTeams, 1
    *(word *)&g_memByte[109908] = 0;        // mov dseg_DB3E2, 0
    *(word *)&g_memByte[109904] = 0;        // mov dseg_DB3DE, 0
    *(word *)&g_memByte[109906] = 0;        // mov dseg_DB3E0, 0
    *(word *)&g_memByte[109910] = 0;        // mov dseg_DB3E4, 0
    *(word *)&g_memByte[91676] = 0;         // mov isNationalSelector, 0
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    ah = 0;                                 // mov ah, 0
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 80;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, CN_EUROPE
    if (flags.carry)
        goto l_club_selector;               // jb @@club_selector

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 85;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, CN_OCEANIA
    if (!flags.carry && !flags.zero)
        goto l_club_selector;               // ja @@club_selector

    *(word *)&g_memByte[91676] = 1;         // mov isNationalSelector, 1
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91680];        // mov ax, lastNationalityCall
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_8D024;                    // jnz short cseg_8D024

    *(word *)&g_memByte[91684] = 1;         // mov dseg_D6CB2, 1

cseg_8D024:;
    A0 = 4174;                              // mov A0, offset cseg_8D821
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 80;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 80
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    ax = *(word *)&g_memByte[91330];        // mov ax, currentSeasonShowing
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    g_memByte[91678] = al;                  // mov someTeamFlags, al
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetNationalityAndTeamFile();            // call GetNationalityAndTeamFile
    al = D0;                                // mov al, byte ptr D0
    g_memByte[91682] = al;                  // mov dseg_D6CB0, al
    al = D1;                                // mov al, byte ptr D1
    g_memByte[91683] = al;                  // mov dseg_D6CB1, al
    ax = *(word *)&g_memByte[91330];        // mov ax, currentSeasonShowing
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    A0 = 33865;                             // mov A0, offset dseg_C8AD8
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)&g_memByte[91716] = ax;        // mov dseg_D6CD2, ax
    A0 = 33875;                             // mov A0, offset dseg_C8AE2
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)&g_memByte[91718] = ax;        // mov dseg_D6CD4, ax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    cseg_664BB();                           // call cseg_664BB
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    A6 = 91694;                             // mov A6, offset dseg_D6CBC
    goto cseg_8D209;                        // jmp short cseg_8D209

l_club_selector:;
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    g_memByte[91690] = al;                  // mov dseg_D6CB8, al
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    g_memByte[131744] = al;                 // mov compCountryNumber, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    A6 = 33933;                             // mov A6, offset competitionsTable
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A6 = eax;                               // mov A6, eax

cseg_8D209:;
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_8D7B4();                           // call cseg_8D7B4
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    push(*(dword *)&g_memByte[126629]);     // push small [dseg_DF533]
    push(*(dword *)&g_memByte[126631]);     // push small [dseg_DF535]
    push(*(dword *)&g_memByte[126633]);     // push small [dseg_DF537]
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A6 = res;
    }                                       // add A6, 4
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(A6);                               // push A6
    cseg_8B2D3();                           // call cseg_8B2D3
    pop(A6);                                // pop A6
    GetCurrentSeasonPointer();              // call GetCurrentSeasonPointer
    eax = *(dword *)&g_memByte[126607];     // mov eax, dseg_DF51D
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned - srcSigned;
        eax = res;
    }                                       // sub eax, offset aChairmanScenes
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 22, 4, eax);          // mov [esi+SeasonInformations.leagueStringOffset], eax
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[126633] = val;
    }                                       // pop small [dseg_DF537]
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[126631] = val;
    }                                       // pop small [dseg_DF535]
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[126629] = val;
    }                                       // pop small [dseg_DF533]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 4
    esi = A6;                               // mov esi, A6
    {
        dword src = readMemory(esi, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi], 0FFFFFFFFh
    if (flags.zero)
        goto cseg_8D465;                    // jz cseg_8D465

    push(*(dword *)&g_memByte[100025]);     // push small [dseg_D8D47]
    push(*(dword *)&g_memByte[100027]);     // push small [dseg_D8D49]
    push(*(dword *)&g_memByte[100029]);     // push small [dseg_D8D4B]
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A6 = res;
    }                                       // add A6, 4
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(A6);                               // push A6
    cseg_8B2D3();                           // call cseg_8B2D3
    pop(A6);                                // pop A6
    GetCurrentSeasonPointer();              // call GetCurrentSeasonPointer
    eax = *(dword *)&g_memByte[100003];     // mov eax, dseg_D8D31
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned - srcSigned;
        eax = res;
    }                                       // sub eax, offset aChairmanScenes
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 26, 4, eax);          // mov [esi+26], eax
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[100029] = val;
    }                                       // pop small [dseg_D8D4B]
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[100027] = val;
    }                                       // pop small [dseg_D8D49]
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[100025] = val;
    }                                       // pop small [dseg_D8D47]
    esi = A6;                               // mov esi, A6
    {
        dword src = readMemory(esi, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi], 0FFFFFFFFh
    if (flags.zero)
        goto cseg_8D465;                    // jz short cseg_8D465

    push(*(dword *)&g_memByte[102923]);     // push small [dseg_D9899]
    push(*(dword *)&g_memByte[102925]);     // push small [dseg_D989B]
    push(*(dword *)&g_memByte[102927]);     // push small [dseg_D989D]
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 2;                       // mov word ptr D0, 2
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(A6);                               // push A6
    cseg_8B2D3();                           // call cseg_8B2D3
    pop(A6);                                // pop A6
    GetCurrentSeasonPointer();              // call GetCurrentSeasonPointer
    eax = *(dword *)&g_memByte[102901];     // mov eax, dseg_D9883
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // sub eax, offset aChairmanScenes
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 30, 4, eax);          // mov [esi+1Eh], eax
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[102927] = val;
    }                                       // pop small [dseg_D989D]
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[102925] = val;
    }                                       // pop small [dseg_D989B]
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[102923] = val;
    }                                       // pop small [dseg_D9899]

cseg_8D465:;
    A0 = 108070;                            // mov A0, offset euroCupCopy
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    cseg_8D661();                           // call cseg_8D661
    if (flags.zero)
        goto cseg_8D4BE;                    // jz short cseg_8D4BE

    A0 = 108149;                            // mov A0, offset cupWinnersCupCopy
    *(word *)&D7 = 1;                       // mov word ptr D7, 1
    cseg_8D661();                           // call cseg_8D661
    if (flags.zero)
        goto cseg_8D4BE;                    // jz short cseg_8D4BE

    A0 = 108241;                            // mov A0, offset uefaCupCopy
    *(word *)&D7 = 2;                       // mov word ptr D7, 2
    cseg_8D661();                           // call cseg_8D661
    if (flags.zero)
        goto cseg_8D4BE;                    // jz short cseg_8D4BE

    *(word *)&g_memByte[131745] = 65535;    // mov dseg_E092F, 0FFFFh
    goto cseg_8D4CA;                        // jmp short cseg_8D4CA

cseg_8D4BE:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&g_memByte[131745] = ax;       // mov dseg_E092F, ax

cseg_8D4CA:;
    cseg_8DAC3();                           // call cseg_8DAC3
    cseg_90FF2();                           // call cseg_90FF2
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 0
    if (!flags.zero)
        goto cseg_8D501;                    // jnz short cseg_8D501

    al = (byte)readMemory(esi + 9, 1);      // mov al, [esi+9]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al

cseg_8D501:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[91728] = ax;        // mov dseg_D6CDE, ax
    *(word *)&g_memByte[99864] = 0;         // mov seasonFinished, 0
    *(word *)&g_memByte[99866] = 0;         // mov careerFinished, 0
    al = g_memByte[109913];                 // mov al, dseg_DB3E6+1
    g_memByte[129466] = al;                 // mov dseg_E0048, al
    A0 = 109912;                            // mov A0, offset dseg_DB3E6
    ax = *(word *)&g_memByte[109908];       // mov ax, dseg_DB3E2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_8D547:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_8D547;                    // jns short cseg_8D547

    al = g_memByte[109913];                 // mov al, dseg_DB3E6+1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0FFh
    if (!flags.zero)
        goto cseg_8D58D;                    // jnz short cseg_8D58D

    *(word *)&D0 = 1;                       // mov word ptr D0, 1

cseg_8D58D:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[91668] = ax;        // mov dseg_D6CA2, ax
    al = g_memByte[109913];                 // mov al, dseg_DB3E6+1
    g_memByte[96216] = al;                  // mov byte ptr dseg_D7E66, al
    InitTeams();                            // call InitTeams
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 36;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, TeamFile.coachName
    A1 = eax;                               // mov A1, eax
    A0 = 91741;                             // mov A0, offset managerNameBuffer
    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    A0 = 91750;                             // mov A0, offset managerSurnameBuffer
    StringCopy();                           // call StringCopy
    FillForeignMarketPlayers();             // call FillForeignMarketPlayers
    FillCareerTeamPlayers();                // call FillCareerTeamPlayers
    cseg_5DEB9();                           // call cseg_5DEB9
    cseg_3D204();                           // call cseg_3D204
    ax = *(word *)&g_memByte[91332];        // mov ax, stayingInOldClub
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_new_club;                    // jz short @@new_club

    {
        word src = *(word *)&g_memByte[91330];
        int16_t dstSigned = src;
        int16_t srcSigned = 19;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp currentSeasonShowing, 19
    if (!flags.zero)
        goto l_not_last_season;             // jnz short @@not_last_season

    ShowEnjoyLastSeasonMessage();           // call ShowEnjoyLastSeasonMessage
    goto l_message_shown;                   // jmp short @@message_shown

l_not_last_season:;
    ShowWishYouSuccessMessage();            // call ShowWishYouSuccessMessage
    goto l_message_shown;                   // jmp short @@message_shown

l_new_club:;
    {
        word src = *(word *)&g_memByte[91330];
        int16_t dstSigned = src;
        int16_t srcSigned = 19;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp currentSeasonShowing, 19
    if (!flags.zero)
        goto l_show_greeting_message;       // jnz short @@show_greeting_message

    ShowLastSeasonMessage();                // call ShowLastSeasonMessage
    goto l_message_shown;                   // jmp short @@message_shown

l_show_greeting_message:;
    ShowGreetingMessage();                  // call ShowGreetingMessage

l_message_shown:;
    ax = *(word *)&g_memByte[91332];        // mov ax, stayingInOldClub
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    cseg_64A65();                           // call cseg_64A65
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short @@out

    cseg_5CDF2();                           // call cseg_5CDF2
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8D661()
{
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 1
    if (flags.zero)
        goto cseg_8D6C2;                    // jz short cseg_8D6C2

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 2
    if (flags.zero)
        goto cseg_8D6D4;                    // jz short cseg_8D6D4

    al = (byte)readMemory(esi + 13, 1);     // mov al, [esi+0Dh]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    goto cseg_8D6E2;                        // jmp short cseg_8D6E2

cseg_8D6C2:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 10, 1);     // mov al, [esi+0Ah]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    goto cseg_8D6E2;                        // jmp short cseg_8D6E2

cseg_8D6D4:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 15, 1);     // mov al, [esi+0Fh]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al

cseg_8D6E2:;
    al = D1;                                // mov al, byte ptr D1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_8D6F7:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto cseg_8D72A;                    // jz short cseg_8D72A

    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_8D6F7;                    // jns short cseg_8D6F7

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    return;                                 // retn

cseg_8D72A:;
    push(*(dword *)&g_memByte[105105]);     // push small [dseg_DA11F]
    push(*(dword *)&g_memByte[105107]);     // push small [dseg_DA121]
    push(*(dword *)&g_memByte[105109]);     // push small [dseg_DA123]
    *(word *)&D0 = 3;                       // mov word ptr D0, 3
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(D7);                               // push D7
    push(D6);                               // push D6
    cseg_8B2D3();                           // call cseg_8B2D3
    pop(D6);                                // pop D6
    pop(D7);                                // pop D7
    GetCurrentSeasonPointer();              // call GetCurrentSeasonPointer
    eax = *(dword *)&g_memByte[105083];     // mov eax, dseg_DA109
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned - srcSigned;
        eax = res;
    }                                       // sub eax, offset aChairmanScenes
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 34, 4, eax);          // mov [esi+34], eax
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[105109] = val;
    }                                       // pop small [dseg_DA123]
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[105107] = val;
    }                                       // pop small [dseg_DA121]
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[105105] = val;
    }                                       // pop small [dseg_DA11F]
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&g_memByte[99888] = ax;        // mov dseg_D8CBE, ax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8D7B4()
{
    al = g_memByte[91763];                  // mov al, plNationality
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 255;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 255
    if (flags.zero)
        goto l_nationality_other;           // jz short @@nationality_other

    GetNationalTeamNumber();                // call GetNationalTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, -1
    if (!flags.zero)
        goto l_got_nationality;             // jnz short @@got_nationality

l_nationality_other:;
    *(word *)&D0 = -1;                      // mov word ptr D0, -1
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_got_nationality;             // jnz short @@got_nationality

    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_5C46D();                           // call cseg_5C46D

l_got_nationality:;
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_8D811;                    // jnz short cseg_8D811

    *(word *)&D0 = -1;                      // mov word ptr D0, -1

cseg_8D811:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[91680] = ax;        // mov lastNationalityCall, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8D839()
{
    *(word *)&g_memByte[92298] = 6;         // mov timeToNegotiate, 6
    *(word *)&g_memByte[91786] = 0;         // mov numOffers, 0
    *(word *)&g_memByte[92030] = 0;         // mov dseg_D6E0C, 0
    *(word *)&g_memByte[92032] = 0;         // mov dseg_D6E0E, 0
    *(word *)&g_memByte[92312] = -1;        // mov dseg_D6F26, -1
    *(word *)&g_memByte[92320] = 0;         // mov dseg_D6F2E, 0
    *(word *)&D0 = 7;                       // mov word ptr D0, 7
    ax = *(word *)&g_memByte[92018];        // mov ax, dseg_D6E00
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    bx = 16;                                // mov bx, 16
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D1 = 20;                      // mov word ptr D1, 20
    ax = *(word *)&g_memByte[91330];        // mov ax, currentSeasonShowing
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, ax
    *(word *)&D7 = 352;                     // mov word ptr D7, 352
    ax = *(word *)&g_memByte[92020];        // mov ax, numForeignMarketPlayers2
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    ax = D7;                                // mov ax, word ptr D7
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D7 = eax;                               // mov D7, eax
    dx = *(word *)((byte *)&D7 + 2);        // mov dx, word ptr D7+2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / *(word *)&D1);
        word rem = (word)(dividend % *(word *)&D1);
        ax = quot;
        dx = rem;
    }                                       // div word ptr D1
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    *(word *)&g_memByte[92024] = ax;        // mov dseg_D6E06, ax
    *(word *)&g_memByte[92022] = 0;         // mov dseg_D6E04, 0
    ax = *(word *)&g_memByte[92024];        // mov ax, dseg_D6E06
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[92028] = ax;        // mov dseg_D6E0A, ax
    ax = *(word *)&g_memByte[92024];        // mov ax, dseg_D6E06
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    flags.carry = *(int16_t *)&D0 != 0;
    *(int16_t *)&D0 = -*(int16_t *)&D0;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // neg word ptr D0
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[92026] = ax;        // mov dseg_D6E08, ax
    *(word *)&g_memByte[91776] = 0;         // mov dseg_D6D0E, 0
    *(word *)&g_memByte[91778] = 0;         // mov dseg_D6D10, 0
    *(word *)&g_memByte[91780] = 0;         // mov dseg_D6D12, 0
    *(word *)&g_memByte[91772] = 0;         // mov dseg_D6D0A, 0
    *(word *)&g_memByte[91774] = 0;         // mov dseg_D6D0C, 0
}

// =============== S U B R O U T I N E =======================================
//
void FillForeignMarketPlayers()
{
    LoadPoolplyrDat();                      // call LoadPoolplyrDat
    *(word *)&g_memByte[91782] = 0;         // mov numForeignMarketPlayers, 0
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short @@out

    *(word *)&D7 = 15;                      // mov word ptr D7, 15
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    if (flags.zero || flags.sign != flags.overflow)
        return;                             // jle short @@out

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

l_add_player_loop:;
    AddRandomForeignMarketPlayer();         // call AddRandomForeignMarketPlayer
    (*(int16_t *)&D7)--;
    flags.overflow = (int16_t)(*(int16_t *)&D7) == INT16_MIN;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_add_player_loop;             // jns short @@add_player_loop
}

// =============== S U B R O U T I N E =======================================
//
void FillCareerTeamPlayers()
{
    *(word *)&g_memByte[91784] = 0;         // mov numHomeMarketPlayers, 0
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    bx = 16;                                // mov bx, 16
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    bx = 40;                                // mov bx, 40
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz @@out

    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 31;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1Fh
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D7;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        dword res = D0 >> 8;
        D0 = res;
    }                                       // shr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 25
    if (flags.carry || flags.zero)
        goto cseg_8DAAC;                    // jbe short cseg_8DAAC

    *(word *)&D7 = 25;                      // mov word ptr D7, 25
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, ax

cseg_8DAAC:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

l_fill_players_loop:;
    AddCareerTeamPlayer();                  // call AddCareerTeamPlayer
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_fill_players_loop;           // jns short @@fill_players_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8DAC3()
{
    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 0
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    bx = 6;                                 // mov bx, 6
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A1;                               // mov eax, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 18, 1);     // mov al, [esi+12h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        return;                             // jz short @@out

    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 18;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 12h
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, 4
    A0 = eax;                               // mov A0, eax
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    *(dword *)&g_memByte[99890] = eax;      // mov dseg_D8CC0, eax
    *(word *)&D0 = 4;                       // mov word ptr D0, 4
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_8B2D3();                           // call cseg_8B2D3
}

// =============== S U B R O U T I N E =======================================
//
void AddCareerTeamPlayer()
{
    GetLowestAndHighestPlayerPrice();       // call GetLowestAndHighestPlayerPrice
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 3
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    *(word *)&D6 = 1;                       // mov word ptr D6, 1
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 1;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test word ptr D0, 1
    if (flags.zero)
        goto l_decrease_team_index;         // jz short @@decrease_team_index

    ax = *(word *)&g_memByte[131757];       // mov ax, g_numSelectedTeams
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        word res = *(word *)&D6 >> 1;
        *(word *)&D6 = res;
    }                                       // shr word ptr D6, 1

l_decrease_team_index:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_next_random_team_loop;       // jnz short @@next_random_team_loop

    {
        word src = *(word *)&g_memByte[337186];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[337186] = src;
    }                                       // add writeOnlyCareerVar001, 1

l_next_random_team_loop:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = *(word *)&g_memByte[131757];
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul g_numSelectedTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    bx = 684;                               // mov bx, size TeamFile
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    A0 = eax;                               // mov A0, eax
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi+TeamFile.countryNumber]
    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D3, al
    if (!flags.zero)
        goto l_next_random_team_loop;       // jnz short @@next_random_team_loop

    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (flags.zero)
        goto l_next_random_team_loop;       // jz @@next_random_team_loop

    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0Fh
    eax = D0;                               // mov eax, D0
    {
        dword tmp = D1;
        D1 = eax;
        eax = tmp;
    }                                       // xchg eax, D1
    D0 = eax;                               // mov D0, eax
    ax = D1;                                // mov ax, word ptr D1
    bx = 38;                                // mov bx, size PlayerFile
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_check_team;                  // jz short @@check_team

    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    al = (byte)readMemory(esi + ebx + 108, 1); // mov al, [esi+ebx+TeamFile.players.price]
    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D4, al
    if (!flags.carry && !flags.zero)
        goto l_decrease_team_index;         // ja @@decrease_team_index

    al = (byte)readMemory(esi + ebx + 108, 1); // mov al, [esi+ebx+TeamFile.players.price]
    {
        int8_t dstSigned = *(byte *)&D5;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D5, al
    if (flags.carry)
        goto l_decrease_team_index;         // jb @@decrease_team_index

    {
        byte src = (byte)readMemory(esi + ebx + 2, 1);
        byte res = src & 4;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test [esi+ebx+PlayerFile.shirtNumber], 4
    if (!flags.zero)
        goto l_decrease_team_index;         // jnz @@decrease_team_index

l_check_team:;
    push(D0);                               // push D0
    push(D1);                               // push D1
    IsPlayerInCareerContest();              // call IsPlayerInCareerContest
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    if (flags.zero)
        goto l_next_random_team_loop;       // jz @@next_random_team_loop

    AddPlayerToCareerContest();             // call AddPlayerToCareerContest
}

// =============== S U B R O U T I N E =======================================

// Add a random player to the foreign market. 25% chance to pick up a player
// within the limits of the selected team (or slightly better).
//
void AddRandomForeignMarketPlayer()
{
    GetLowestAndHighestPlayerPrice();       // call GetLowestAndHighestPlayerPrice
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 3;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 3
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    *(word *)&D6 = 1;                       // mov word ptr D6, 1
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 3
    if (!flags.zero)
        goto l_next_price_restricted_player; // jnz short @@next_price_restricted_player

    *(word *)&D6 = 180;                     // mov word ptr D6, 180

l_next_price_restricted_player:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1
    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_next_player_loop;            // jnz short @@next_player_loop

    {
        word src = *(word *)&g_memByte[337184];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[337184] = src;
    }                                       // add writeOnlyCareerVar002, 1

l_next_player_loop:;
    GetRandomWord();                        // call GetRandomWord
    ax = D0;                                // mov ax, word ptr D0
    bx = 900;                               // mov bx, 900
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        dword res = D0 >> 8;
        D0 = res;
    }                                       // shr D0, 8
    {
        dword res = D0 >> 8;
        D0 = res;
    }                                       // shr D0, 8
    ax = D0;                                // mov ax, word ptr D0
    bx = 58;                                // mov bx, size PoolPlayer
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A0 = 200176;                            // mov A0, offset poolplyrDatBuffer
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, byte ptr [esi+PoolPlayer.teamId]
    {
        int8_t dstSigned = *(byte *)&D3;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D3, al
    if (flags.zero)
        goto l_next_player_loop;            // jz short @@next_player_loop

    ax = (word)readMemory(esi, 2);          // mov ax, [esi+PoolPlayer.teamId]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+PoolPlayer.playerOrdinal]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_try_adding_the_player;       // jz short @@try_adding_the_player

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = -56;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, -56
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+108]
    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D4, al
    if (!flags.carry && !flags.zero)
        goto l_next_price_restricted_player; // ja @@next_price_restricted_player

    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+108]
    {
        int8_t dstSigned = *(byte *)&D5;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D5, al
    if (flags.carry)
        goto l_next_price_restricted_player; // jb @@next_price_restricted_player

l_try_adding_the_player:;
    push(D0);                               // push D0
    push(D1);                               // push D1
    FindForeignMarketPlayer();              // call FindForeignMarketPlayer
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    if (flags.zero)
        goto l_next_player_loop;            // jz @@next_player_loop

    AddForeignMarketPlayer();               // call AddForeignMarketPlayer
}

// =============== S U B R O U T I N E =======================================
//
void LoadPoolplyrDat()
{
    ax = *(word *)&g_memByte[323896];       // mov ax, poolplyrLoaded
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_pool_players_loaded;         // jnz short @@pool_players_loaded

    *(word *)&g_memByte[323896] = 1;        // mov poolplyrLoaded, 1
    A0 = 337250;                            // mov A0, offset aDataPoolplyr_d
    A1 = 200176;                            // mov A1, offset poolplyrDatBuffer
    SWOS::LoadFile();                       // call LoadFile

l_pool_players_loaded:;
    FillForeignMarketPlayersData();         // call FillForeignMarketPlayersData
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0 - team number
//     D1 - player ordinal
// out:
//     zero flag: set = full, can't add
//                clear = added OK
//
void AddPlayerToCareerContest()
{
    {
        word src = *(word *)&g_memByte[91784];
        int16_t dstSigned = src;
        int16_t srcSigned = 25;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numHomeMarketPlayers, 25
    if (flags.zero)
        return;                             // jz short @@out

    A1 = 91848;                             // mov A1, offset homeMarketPlayers
    ax = *(word *)&g_memByte[91784];        // mov ax, numHomeMarketPlayers
    bx = 4;                                 // mov bx, 4
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    eax = D2;                               // mov eax, D2
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    al = D1;                                // mov al, byte ptr D1
    writeMemory(esi + 2, 1, al);            // mov [esi+2], al
    {
        word src = *(word *)&g_memByte[91784];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91784] = src;
    }                                       // add numHomeMarketPlayers, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8DF16()
{
    IsPlayerInCareerContest();              // call IsPlayerInCareerContest
    if (!flags.zero)
        return;                             // jnz cseg_8DFB5

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    ax = *(word *)&g_memByte[91784];        // mov ax, numHomeMarketPlayers
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto cseg_8DFAD;                    // jz short cseg_8DFAD

    A2 = 91848;                             // mov A2, offset homeMarketPlayers
    ax = *(word *)&g_memByte[91784];        // mov ax, numHomeMarketPlayers
    bx = 4;                                 // mov bx, 4
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, eax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4
    A0 = eax;                               // mov A0, eax

cseg_8DF80:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, eax
    if (!flags.zero)
        goto cseg_8DF80;                    // jnz short cseg_8DF80

cseg_8DFAD:;
    {
        word src = *(word *)&g_memByte[91784];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91784] = src;
    }                                       // sub numHomeMarketPlayers, 1
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0 - team number
//     D1 - player ordinal
// out:
//     zero flag: set = success, found
//                clear = not found
//
void IsPlayerInCareerContest()
{
    A1 = 91848;                             // mov A1, offset homeMarketPlayers
    ax = *(word *)&g_memByte[91784];        // mov ax, numHomeMarketPlayers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_return_false;                // jz short @@return_false

    *(word *)&D2 = 0;                       // mov word ptr D2, 0

l_test_team:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_go_to_next_team;             // jnz short @@go_to_next_team

    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        return;                             // jz short @@out

l_go_to_next_team:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4
    A1 = eax;                               // mov A1, eax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    ax = *(word *)&g_memByte[91784];        // mov ax, numHomeMarketPlayers
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto l_test_team;                   // jnz short @@test_team

l_return_false:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0 - team id
//     D1 - player ordinal
// out:
//     zero flag: set = not added, full
//                clear = added OK
//
void AddForeignMarketPlayer()
{
    {
        word src = *(word *)&g_memByte[91782];
        int16_t dstSigned = src;
        int16_t srcSigned = 15;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp numForeignMarketPlayers, 15
    if (flags.zero)
        return;                             // jz short @@out

    A1 = 91788;                             // mov A1, offset foreignMarketPlayers
    ax = *(word *)&g_memByte[91782];        // mov ax, numForeignMarketPlayers
    bx = 4;                                 // mov bx, 4
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    eax = D2;                               // mov eax, D2
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    ax = D0;                                // mov ax, word ptr D0
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    al = D1;                                // mov al, byte ptr D1
    writeMemory(esi + 2, 1, al);            // mov [esi+2], al
    {
        word src = *(word *)&g_memByte[91782];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91782] = src;
    }                                       // add numForeignMarketPlayers, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8E09A()
{
    FindForeignMarketPlayer();              // call FindForeignMarketPlayer
    if (!flags.zero)
        return;                             // jnz cseg_8E139

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    ax = *(word *)&g_memByte[91782];        // mov ax, numForeignMarketPlayers
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.zero)
        goto cseg_8E131;                    // jz short cseg_8E131

    A2 = 91788;                             // mov A2, offset foreignMarketPlayers
    ax = *(word *)&g_memByte[91782];        // mov ax, numForeignMarketPlayers
    bx = 4;                                 // mov bx, 4
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, eax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4
    A0 = eax;                               // mov A0, eax

cseg_8E104:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, eax
    if (!flags.zero)
        goto cseg_8E104;                    // jnz short cseg_8E104

cseg_8E131:;
    {
        word src = *(word *)&g_memByte[91782];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91782] = src;
    }                                       // sub numForeignMarketPlayers, 1
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0 - team id
//     D1 - player ordinal
// out:
//     zero flag: set = found
//                clear = not found
//
void FindForeignMarketPlayer()
{
    A1 = 91788;                             // mov A1, offset foreignMarketPlayers
    ax = *(word *)&g_memByte[91782];        // mov ax, numForeignMarketPlayers
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_return_false;                // jz short @@return_false

    *(word *)&D2 = 0;                       // mov word ptr D2, 0

l_test_player:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto l_go_to_next_player;           // jnz short @@go_to_next_player

    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        return;                             // jz short @@out

l_go_to_next_player:;
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4
    A1 = eax;                               // mov A1, eax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    ax = *(word *)&g_memByte[91782];        // mov ax, numForeignMarketPlayers
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.zero)
        goto l_test_player;                 // jnz short @@test_player

l_return_false:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================

// out:
//      D4 - lowest player price
//      D5 - highest player price
//
// Find lowest and highest player price in the selected career team.
//
void GetLowestAndHighestPlayerPrice()
{
    *(word *)&D4 = 255;                     // mov word ptr D4, 255
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

l_players_loop:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    GetPlayerAtIndex();                     // call GetPlayerAtIndex
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D4;                                // mov al, byte ptr D4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.carry)
        goto l_min_price_set;               // jnb short @@min_price_set

    al = D0;                                // mov al, byte ptr D0
    *(byte *)&D4 = al;                      // mov byte ptr D4, al

l_min_price_set:;
    al = D5;                                // mov al, byte ptr D5
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.carry || flags.zero)
        goto l_go_to_next_player;           // jbe short @@go_to_next_player

    al = D0;                                // mov al, byte ptr D0
    *(byte *)&D5 = al;                      // mov byte ptr D5, al

l_go_to_next_player:;
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto l_players_loop;                // jns short @@players_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8E23A()
{
    GetPlayer();                            // call GetPlayer
    cseg_2484B();                           // call cseg_2484B
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    A0 = 332160;                            // mov A0, offset avgTeamValueBases
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
}

// =============== S U B R O U T I N E =======================================
//
void FillForeignMarketPlayersData()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        return;                             // jnz @@out

    ax = *(word *)&g_memByte[92020];        // mov ax, numForeignMarketPlayers2
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1
    if (flags.sign)
        return;                             // js @@out

    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    A6 = 111782;                            // mov A6, offset careerForeignMarketPlayers

l_domestic_players_loop:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, byte ptr [esi+MarketPlayer.teamId]
    {
        int8_t dstSigned = *(byte *)&D5;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D5, al
    if (flags.zero)
        goto l_next_domestic_player;        // jz @@next_domestic_player

    ax = (word)readMemory(esi, 2);          // mov ax, [esi+MarketPlayer.teamId]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+MarketPlayer.playerOrdinal]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    A5 = 200176;                            // mov A5, offset poolplyrDatBuffer
    *(word *)&D6 = 899;                     // mov word ptr D6, 899

l_test_pool_player:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi+PoolPlayer.teamId]
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (!flags.zero)
        goto l_next_pool_player;            // jnz short @@next_pool_player

    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+PoolPlayer.playerOrdinal]
    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D4, al
    if (!flags.zero)
        goto l_next_pool_player;            // jnz short @@next_pool_player

    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 4
    A0 = eax;                               // mov A0, eax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 20;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, PoolPlayer.player
    A1 = eax;                               // mov A1, eax
    *(word *)&D0 = 18;                      // mov word ptr D0, 18

l_copy_player_loop:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_copy_player_loop;            // jns short @@copy_player_loop

    goto l_next_domestic_player;            // jmp short @@next_domestic_player

l_next_pool_player:;
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 58;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, size PoolPlayer
    A5 = eax;                               // mov A5, eax
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto l_test_pool_player;            // jns @@test_pool_player

l_next_domestic_player:;
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 42;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, size MarketPlayer
    A6 = eax;                               // mov A6, eax
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto l_domestic_players_loop;       // jns @@domestic_players_loop
}

// =============== S U B R O U T I N E =======================================

// out:
//     D0 - random 16-bit int
//
void GetRandomWord()
{
    push(D1);                               // push small [word ptr D1]
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 << 8;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 8
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;
    flags.carry = false;
    flags.sign = (*(word *)&D0 & 0x8000) != 0;
    flags.zero = *(word *)&D0 == 0;         // or word ptr D0, ax
    {
        int32_t val = stack[stackTop++];
        *(word *)&D1 = val;
    }                                       // pop small [word ptr D1]
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8E3DA()
{
    ax = *(word *)&g_memByte[99866];        // mov ax, careerFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_impossible;                  // jnz @@impossible

    cseg_8EA56();                           // call cseg_8EA56

cseg_8E3EE:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 6, 1);      // mov al, [esi+6]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_8E3FD;                    // js short cseg_8E3FD

    if (!flags.zero)
        goto cseg_8E409;                    // jnz short cseg_8E409

cseg_8E3FD:;
    cseg_8E841();                           // call cseg_8E841
    cseg_8EA82();                           // call cseg_8EA82
    goto cseg_8E3EE;                        // jmp short cseg_8E3EE

cseg_8E409:;
    cseg_8E796();                           // call cseg_8E796
    *(word *)&D2 = 1;                       // mov word ptr D2, 1
    cseg_8E539();                           // call cseg_8E539
    ax = *(word *)&g_memByte[109910];       // mov ax, dseg_DB3E4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8E447;                    // jnz short cseg_8E447

    cseg_8EA56();                           // call cseg_8EA56
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 6, 1);      // mov al, [esi+6]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_8E442;                    // js short cseg_8E442

    if (flags.zero)
        goto cseg_8E442;                    // jz short cseg_8E442

    cseg_8E796();                           // call cseg_8E796
    goto cseg_8E44C;                        // jmp short cseg_8E44C

cseg_8E442:;
    cseg_8E841();                           // call cseg_8E841

cseg_8E447:;
    cseg_8EA82();                           // call cseg_8EA82

cseg_8E44C:;
    cseg_8EC2B();                           // call cseg_8EC2B
    cseg_8EA56();                           // call cseg_8EA56
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    g_memByte[129466] = al;                 // mov dseg_E0048, al
    return;                                 // retn

l_impossible:;
    debugBreak();                           // int 3

cseg_8E467:;
    goto cseg_8E467;                        // jmp short cseg_8E467
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8E469()
{
    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_aye;                         // jnz @@aye

    cseg_8EA56();                           // call cseg_8EA56
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 99944;                             // mov A0, offset arrayOfPointers
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8E4DF;                    // jnz short cseg_8E4DF

    ax = (word)readMemory(esi + 103, 2);    // mov ax, [esi+103]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { cseg_8E3DA(); return; }           // jnz cseg_8E3DA

cseg_8E4DF:;
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    cseg_8E539();                           // call cseg_8E539
    ax = *(word *)&g_memByte[109910];       // mov ax, dseg_DB3E4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8E518;                    // jnz short cseg_8E518

    cseg_8EA56();                           // call cseg_8EA56
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 6, 1);      // mov al, [esi+6]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_8E513;                    // js short cseg_8E513

    if (flags.zero)
        goto cseg_8E513;                    // jz short cseg_8E513

    cseg_8E796();                           // call cseg_8E796
    goto cseg_8E51D;                        // jmp short cseg_8E51D

cseg_8E513:;
    cseg_8E841();                           // call cseg_8E841

cseg_8E518:;
    cseg_8EA82();                           // call cseg_8EA82

cseg_8E51D:;
    cseg_8EC2B();                           // call cseg_8EC2B
    cseg_8EA56();                           // call cseg_8EA56
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    g_memByte[129466] = al;                 // mov dseg_E0048, al
    return;                                 // retn

l_aye:;
    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8E539()
{
    *(word *)&g_memByte[91628] = 0;         // mov dseg_D6C7A, 0
    push(D2);                               // push D2
    cseg_8EA56();                           // call cseg_8EA56
    pop(D2);                                // pop D2
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    g_memByte[129466] = al;                 // mov dseg_E0048, al
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    A0 = 99944;                             // mov A0, offset arrayOfPointers
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    A0 = eax;                               // mov A0, eax
    push(D2);                               // push D2
    push(A0);                               // push A0
    cseg_8B71C();                           // call cseg_8B71C
    pop(A0);                                // pop A0
    pop(D2);                                // pop D2
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (flags.zero)
        goto cseg_8E5FF;                    // jz short cseg_8E5FF

    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 2
    if (flags.zero)
        goto cseg_8E640;                    // jz short cseg_8E640

    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    push(A0);                               // push A0
    ShowDiyLeaguesTournamentMenu();         // call ShowDiyLeaguesTournamentMenu
    pop(A0);                                // pop A0
    goto cseg_8E67F;                        // jmp cseg_8E67F

cseg_8E5FF:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    push(A0);                               // push A0
    cseg_45B51();                           // call cseg_45B51
    pop(A0);                                // pop A0
    ax = *(word *)&g_memByte[318726];       // mov ax, dseg_10EEFC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8E67F;                    // jz short cseg_8E67F

    push(A0);                               // push A0
    cseg_284D8();                           // call cseg_284D8
    pop(A0);                                // pop A0
    goto cseg_8E67F;                        // jmp short cseg_8E67F

cseg_8E640:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    push(A0);                               // push A0
    cseg_89B5C();                           // call cseg_89B5C
    pop(A0);                                // pop A0
    ax = *(word *)&g_memByte[317673];       // mov ax, dseg_10EADF
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8E67F;                    // jz short cseg_8E67F

    push(A0);                               // push A0
    cseg_8A147();                           // call cseg_8A147
    pop(A0);                                // pop A0

cseg_8E67F:;
    push(A0);                               // push A0
    cseg_8B7EA();                           // call cseg_8B7EA
    pop(A0);                                // pop A0
    ax = *(word *)&g_memByte[91628];        // mov ax, dseg_D6C7A
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8E768;                    // jz cseg_8E768

    cseg_95ACD();                           // call cseg_95ACD
    cseg_3E608();                           // call cseg_3E608
    if (!flags.zero)
        goto cseg_8E768;                    // jnz cseg_8E768

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_31C4C();                           // call cseg_31C4C
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

cseg_8E768:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 43, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2Bh], 0
    if (!flags.zero)
        return;                             // jnz short cseg_8E795

    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 0
    if (!flags.zero)
        return;                             // jnz short cseg_8E795

    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+5Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short cseg_8E795

    cseg_8ECAE();                           // call cseg_8ECAE
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8E796()
{
    cseg_8EA56();                           // call cseg_8EA56
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    A0 = 99944;                             // mov A0, offset arrayOfPointers
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    A0 = eax;                               // mov A0, eax
    push(A0);                               // push A0
    cseg_8B71C();                           // call cseg_8B71C
    pop(A0);                                // pop A0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (flags.zero)
        goto cseg_8E818;                    // jz short cseg_8E818

    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 2
    if (flags.zero)
        goto cseg_8E82B;                    // jz short cseg_8E82B

    push(A0);                               // push A0
    cseg_8EF7B();                           // call cseg_8EF7B
    pop(A0);                                // pop A0
    goto cseg_8E83C;                        // jmp short cseg_8E83C

cseg_8E818:;
    push(A0);                               // push A0
    cseg_8EFE2();                           // call cseg_8EFE2
    pop(A0);                                // pop A0
    goto cseg_8E83C;                        // jmp short cseg_8E83C

cseg_8E82B:;
    push(A0);                               // push A0
    cseg_8F048();                           // call cseg_8F048
    pop(A0);                                // pop A0

cseg_8E83C:;
    cseg_8B7EA();                           // jmp cseg_8B7EA
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8E841()
{
    cseg_8EA56();                           // call cseg_8EA56
    ax = *(word *)&g_memByte[109910];       // mov ax, dseg_DB3E4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_int3;                        // jnz @@int3

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    A0 = 99944;                             // mov A0, offset arrayOfPointers
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    eax = readMemory(esi + eax, 4);         // mov eax, [esi+eax]
    A0 = eax;                               // mov A0, eax
    push(A0);                               // push A0
    cseg_8B71C();                           // call cseg_8B71C
    pop(A0);                                // pop A0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (flags.zero)
        goto cseg_8E904;                    // jz short cseg_8E904

    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 2
    if (flags.zero)
        goto cseg_8E928;                    // jz short cseg_8E928

    push(A0);                               // push A0
    cseg_8F0A2();                           // call cseg_8F0A2
    pop(A0);                                // pop A0
    push(A0);                               // push A0
    cseg_8B7EA();                           // call cseg_8B7EA
    pop(A0);                                // pop A0
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 43, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+2Bh], 0
    if (!flags.zero)
        return;                             // jnz short cseg_8E902

    ax = (word)readMemory(esi + 95, 2);     // mov ax, [esi+5Fh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short cseg_8E902

    cseg_8ECAE();                           // call cseg_8ECAE

cseg_8E902:;
    return;                                 // retn

cseg_8E904:;
    push(A0);                               // push A0
    cseg_8F0E6();                           // call cseg_8F0E6
    pop(A0);                                // pop A0
    push(A0);                               // push A0
    cseg_8B7EA();                           // call cseg_8B7EA
    pop(A0);                                // pop A0
    return;                                 // retn

cseg_8E928:;
    push(A0);                               // push A0
    cseg_8F120();                           // call cseg_8F120
    pop(A0);                                // pop A0
    push(A0);                               // push A0
    cseg_8B7EA();                           // call cseg_8B7EA
    pop(A0);                                // pop A0
    return;                                 // retn

l_int3:;
    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8E94F()
{
    cseg_8E98E();                           // call cseg_8E98E
    eax = A0;                               // mov eax, A0
    A1 = eax;                               // mov A1, eax
    {
        word res = *(word *)&D1 & 255;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0FFh
    ax = D1;                                // mov ax, word ptr D1
    bx = 12;                                // mov bx, 12
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    eax = D1;                               // mov eax, D1
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A1 = res;
    }                                       // add A1, eax
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 -
//
void cseg_8E98E()
{
    A0 = 109912;                            // mov A0, offset dseg_DB3E6
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0FFh
    if (flags.zero)
        return;                             // jz short @@out

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_8E9AB:;
    esi = A0;                               // mov esi, A0
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, eax
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_8E9AB;                    // jns short cseg_8E9AB
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8EA56()
{
    A0 = 109912;                            // mov A0, offset dseg_DB3E6
    ax = *(word *)&g_memByte[109906];       // mov ax, dseg_DB3E0
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        dword res = D0 & 65535;
        D0 = res;
    }                                       // and D0, 0FFFFh
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, eax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8EA82()
{
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, GAME_TYPE_CAREER
    if (!flags.zero)
        goto cseg_8EAB5;                    // jnz short cseg_8EAB5

    {
        word src = *(word *)&g_memByte[91776];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91776] = src;
    }                                       // add dseg_D6D0E, 1
    {
        word src = *(word *)&g_memByte[91778];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[91778] = src;
    }                                       // add dseg_D6D10, 1
    {
        word src = *(word *)&g_memByte[91780];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[91780] = src;
    }                                       // add dseg_D6D12, 1
    push(A0);                               // push A0
    cseg_94DB1();                           // call cseg_94DB1
    pop(A0);                                // pop A0

cseg_8EAB5:;
    *(word *)&g_memByte[109910] = 0;        // mov dseg_DB3E4, 0
    *(word *)&g_memByte[126566] = 0;        // mov dseg_DF4F4, 0
    A0 = 109912;                            // mov A0, offset dseg_DB3E6
    ax = *(word *)&g_memByte[109906];       // mov ax, dseg_DB3E0
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        dword res = D0 & 65535;
        D0 = res;
    }                                       // and D0, 0FFFFh
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    ax = *(word *)&g_memByte[109904];       // mov ax, dseg_DB3DE
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_8EAFE:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    ax = *(word *)&g_memByte[109908];       // mov ax, dseg_DB3E2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_8EB5F;                    // jz short cseg_8EB5F

    esi = A0;                               // mov esi, A0
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 4, 1);      // mov al, [esi+4]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_8EAFE;                    // jnz short cseg_8EAFE

    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[109904] = ax;       // mov dseg_DB3DE, ax
    eax = A0;                               // mov eax, A0
    D0 = eax;                               // mov D0, eax
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 109912;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D0 = res;
    }                                       // sub D0, offset dseg_DB3E6
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[109906] = ax;       // mov dseg_DB3E0, ax
    return;                                 // retn

cseg_8EB5F:;
    *(word *)&g_memByte[99864] = 1;         // mov seasonFinished, 1
    *(word *)&g_memByte[99866] = 1;         // mov careerFinished, 1
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_39392();                           // call cseg_39392
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8EC2B()
{
    ax = *(word *)&g_memByte[99864];        // mov ax, seasonFinished
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8EC9A;                    // jnz short cseg_8EC9A

    cseg_8EA56();                           // call cseg_8EA56
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 6, 1);      // mov al, [esi+6]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_8ECA4;                    // jnz short cseg_8ECA4

    cseg_8EA56();                           // call cseg_8EA56
    ax = *(word *)&g_memByte[109904];       // mov ax, dseg_DB3DE
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_8EC59:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 4, 1);      // mov al, [esi+4]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_8EC73;                    // jnz short cseg_8EC73

    al = (byte)readMemory(esi + 6, 1);      // mov al, [esi+6]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_8ECA4;                    // jnz short cseg_8ECA4

cseg_8EC73:;
    esi = A0;                               // mov esi, A0
    eax = (word)readMemory(esi + 2, 2);     // movzx eax, word ptr [esi+2]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    ax = *(word *)&g_memByte[109908];       // mov ax, dseg_DB3E2
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, ax
    if (!flags.zero)
        goto cseg_8EC59;                    // jnz short cseg_8EC59

cseg_8EC9A:;
    *(word *)&g_memByte[99866] = 1;         // mov careerFinished, 1
    return;                                 // retn

cseg_8ECA4:;
    *(word *)&g_memByte[99866] = 0;         // mov careerFinished, 0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8ECAE()
{
    {
        dword src = *(dword *)&g_memByte[99884];
        int32_t dstSigned = src;
        int32_t srcSigned = 0;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D8CBA, 0
    if (flags.zero)
        return;                             // jz cseg_8EF2B

    eax = *(dword *)&g_memByte[99890];      // mov eax, dseg_D8CC0
    A6 = eax;                               // mov A6, eax
    A5 = 337242;                            // mov A5, offset dseg_114EE4
    A4 = 103953;                            // mov A4, offset dseg_D9C9F
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_8ECF1:;
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 4
    A0 = eax;                               // mov A0, eax
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 4
    D0 = eax;                               // mov D0, eax
    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, eax
    if (!flags.zero)
        goto cseg_8ED49;                    // jnz short cseg_8ED49

    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_8ED49;                    // jnz short cseg_8ED49

    A1 = 126568;                            // mov A1, offset competitionFileBuffer
    cseg_8EF2C();                           // call cseg_8EF2C
    goto cseg_8EE5D;                        // jmp cseg_8EE5D

cseg_8ED49:;
    *(word *)&g_memByte[317172] = 1;        // mov dseg_10E846, 1
    push(D0);                               // push D0
    push(A0);                               // push A0
    push(A1);                               // push A1
    SaveSelectedTeams();                    // call SaveSelectedTeams
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D0);                                // pop D0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_3ABB2();                           // call cseg_3ABB2
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    push(A1);                               // push A1
    RestoreSelectedTeams();                 // call RestoreSelectedTeams
    pop(A1);                                // pop A1
    *(word *)&g_memByte[317172] = 0;        // mov dseg_10E846, 0
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    cseg_8EF2C();                           // call cseg_8EF2C

cseg_8EE5D:;
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_8ECF1;                    // jns cseg_8ECF1

    push(D7);                               // push D7
    push(A6);                               // push A6
    A6 = 337242;                            // mov A6, offset dseg_114EE4
    eax = A4;                               // mov eax, A4
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 24Dh
    A2 = eax;                               // mov A2, eax
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    cseg_32E15();                           // call cseg_32E15
    pop(A6);                                // pop A6
    pop(D7);                                // pop D7
    A0 = 103953;                            // mov A0, offset dseg_D9C9F
    push(A0);                               // push A0
    cseg_8B71C();                           // call cseg_8B71C
    pop(A0);                                // pop A0
    push(A0);                               // push A0
    cseg_27436();                           // call cseg_27436
    pop(A0);                                // pop A0
    push(A0);                               // push A0
    cseg_8B8B8();                           // call cseg_8B8B8
    pop(A0);                                // pop A0
    push(A0);                               // push A0
    cseg_8B7EA();                           // call cseg_8B7EA
    pop(A0);                                // pop A0
    *(word *)&g_memByte[91348] = 1;         // mov dseg_D6B62, 1
    ax = *(word *)&g_memByte[126629];       // mov ax, dseg_DF533
    *(word *)&g_memByte[104014] = ax;       // mov dseg_D9CDC, ax
    ax = *(word *)&g_memByte[126631];       // mov ax, dseg_DF535
    *(word *)&g_memByte[104016] = ax;       // mov dseg_D9CDE, ax
    ax = *(word *)&g_memByte[126633];       // mov ax, dseg_DF537
    *(word *)&g_memByte[104018] = ax;       // mov dseg_D9CE0, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8EF2C()
{
    esi = A6;                               // mov esi, A6
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A6 = res;
    }                                       // add A6, 4
    D0 = eax;                               // mov D0, eax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 429;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 1ADh
    A0 = eax;                               // mov A0, eax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A0;                               // mov esi, A0
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ax = (word)readMemory(esi + eax, 2);    // mov ax, [esi+eax]
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A5 = res;
    }                                       // add A5, 2
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8EF7B()
{
_l_start:;
    cseg_89758();                           // call cseg_89758
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+2B3h]
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (!flags.zero)
        return;                             // jnz short cseg_8EFE0

    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+2B3h]
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (!flags.zero)
        return;                             // jnz short cseg_8EFE0

    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    cseg_88A12();                           // call cseg_88A12
    goto _l_start;                          // jmp short cseg_8EF7B
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8EFE2()
{
_l_start:;
    cseg_288E2();                           // call cseg_288E2
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi + 835, 4);         // mov eax, [esi+343h]
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (!flags.zero)
        return;                             // jnz short cseg_8F047

    esi = A2;                               // mov esi, A2
    eax = readMemory(esi + 835, 4);         // mov eax, [esi+343h]
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (!flags.zero)
        return;                             // jnz short cseg_8F047

    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    cseg_28E76();                           // call cseg_28E76
    goto _l_start;                          // jmp short cseg_8EFE2
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8F048()
{
    A0 = 317588;                            // mov A0, offset diyFileBufferCopy
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    bx = 118;                               // mov bx, 76h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        { cseg_8EF7B(); return; }           // jnz cseg_8EF7B

    cseg_8EFE2();                           // jmp cseg_8EFE2
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8F0A2()
{
_l_start:;
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 447, 2);    // mov ax, [esi+447]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8F0C9;                    // jz short cseg_8F0C9

    ax = *(word *)&g_memByte[109910];       // mov ax, dseg_DB3E4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short cseg_8F0E5

cseg_8F0C9:;
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    push(A0);                               // push A0
    cseg_88A12();                           // call cseg_88A12
    pop(A0);                                // pop A0
    goto _l_start;                          // jmp short cseg_8F0A2
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8F0E6()
{
_l_start:;
    A0 = 318643;                            // mov A0, offset DIY_competitionStart
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_8F10A;                    // jz short cseg_8F10A

    ax = *(word *)&g_memByte[109910];       // mov ax, dseg_DB3E4
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8F11A;                    // jnz short cseg_8F11A

cseg_8F10A:;
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    cseg_28E76();                           // call cseg_28E76
    goto _l_start;                          // jmp short cseg_8F0E6

cseg_8F11A:;
    cseg_284D8();                           // call cseg_284D8
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8F120()
{
    A0 = 317588;                            // mov A0, offset diyFileBufferCopy
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    bx = 118;                               // mov bx, 76h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8F1B8;                    // jnz short cseg_8F1B8

    cseg_8F0E6();                           // call cseg_8F0E6
    ax = *(word *)&g_memByte[318710];       // mov ax, dseg_10EEEC
    *(word *)&g_memByte[317655] = ax;       // mov dseg_10EACD, ax
    ax = *(word *)&g_memByte[318712];       // mov ax, dseg_10EEEE
    *(word *)&g_memByte[317657] = ax;       // mov dseg_10EACF, ax
    ax = *(word *)&g_memByte[318700];       // mov ax, dseg_10EEE2
    *(word *)&g_memByte[317645] = ax;       // mov dseg_10EAC3, ax
    ax = *(word *)&g_memByte[318718];       // mov ax, dseg_10EEF4
    *(word *)&g_memByte[317659] = ax;       // mov dseg_10EAD1, ax
    ax = *(word *)&g_memByte[318728];       // mov ax, dseg_10EEFE
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_8F1F1

    cseg_8A147();                           // call cseg_8A147
    return;                                 // retn

cseg_8F1B8:;
    cseg_8F0A2();                           // call cseg_8F0A2
    ax = *(word *)&g_memByte[318710];       // mov ax, dseg_10EEEC
    *(word *)&g_memByte[317655] = ax;       // mov dseg_10EACD, ax
    ax = *(word *)&g_memByte[318712];       // mov ax, dseg_10EEEE
    *(word *)&g_memByte[317657] = ax;       // mov dseg_10EACF, ax
    ax = *(word *)&g_memByte[318700];       // mov ax, dseg_10EEE2
    *(word *)&g_memByte[317645] = ax;       // mov dseg_10EAC3, ax
    ax = *(word *)&g_memByte[318738];       // mov ax, diyMinSubstitutes
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz short cseg_8F1F1

    cseg_8A147();                           // call cseg_8A147
}

// =============== S U B R O U T I N E =======================================
//
void cseg_8F1F2()
{
    ax = D0;                                // mov ax, word ptr D0
    bx = 6;                                 // mov bx, 6
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        byte src = (byte)readMemory(esi + ebx + 13, 1);
        byte res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+ebx+0Dh], 1
    if (flags.zero)
        goto cseg_8F223;                    // jz short cseg_8F223

    debugBreak();                           // int 3

cseg_8F221:;
    goto cseg_8F221;                        // jmp short cseg_8F221

cseg_8F223:;
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 6;                                 // mov bx, 6
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    A5 = eax;                               // mov A5, eax
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    push(D7);                               // push D7
    push(A5);                               // push A5
    cseg_26395();                           // call cseg_26395
    pop(A5);                                // pop A5
    pop(D7);                                // pop D7
    A6 = 318643;                            // mov A6, offset DIY_competitionStart
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 59, 2, 1);            // mov word ptr [esi+3Bh], 1
    A1 = 27119;                             // mov A1, offset dseg_C707E

cseg_8F297:;
    esi = A1;                               // mov esi, A1
    {
        dword src = readMemory(esi, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi], 0FFFFFFFFh
    if (flags.zero)
        goto cseg_8F2C5;                    // jz short cseg_8F2C5

    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 4
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A5, eax
    if (!flags.zero)
        goto cseg_8F297;                    // jnz short cseg_8F297

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 59, 2, 0);            // mov word ptr [esi+3Bh], 0

cseg_8F2C5:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 45, 1, al);           // mov [esi+2Dh], al
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 3, 1);      // mov al, [esi+3]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 55, 1, al);           // mov [esi+37h], al
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 4, 1);      // mov al, [esi+4]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 56, 1, al);           // mov [esi+38h], al
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 10, 1);     // mov al, [esi+0Ah]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.sign)
        goto cseg_8F313;                    // jns short cseg_8F313

    esi = A6;                               // mov esi, A6
    writeMemory(esi + 103, 2, 1);           // mov word ptr [esi+67h], 1

cseg_8F313:;
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 51, 2, 1);            // mov word ptr [esi+33h], 1
    {
        word src = *(word *)&g_memByte[131708];
        int16_t dstSigned = src;
        int16_t srcSigned = 65534;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_pitchType, SEASONAL
    if (flags.zero)
        goto cseg_8F345;                    // jz short cseg_8F345

    writeMemory(esi + 51, 2, 0);            // mov word ptr [esi+33h], 0
    ax = *(word *)&g_memByte[131708];       // mov ax, g_pitchType
    writeMemory(esi + 53, 2, ax);           // mov [esi+35h], ax

cseg_8F345:;
    ax = D7;                                // mov ax, word ptr D7
    bx = 6;                                 // mov bx, 6
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx + 14, 1); // mov al, [esi+ebx+0Eh]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    ax = D1;                                // mov ax, word ptr D1
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 83, 2, ax);           // mov [esi+53h], ax
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + ebx + 15, 1); // mov al, [esi+ebx+0Fh]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.sign)
        goto cseg_8F3C1;                    // jns short cseg_8F3C1

    *(int8_t *)&D1 = -*(int8_t *)&D1;       // neg byte ptr D1
    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1

cseg_8F3C1:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 85, 2, ax);           // mov [esi+55h], ax
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx + 16, 1); // mov al, [esi+ebx+10h]
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 87, 2, ax);           // mov [esi+57h], ax
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + ebx + 17, 1); // mov al, [esi+ebx+11h]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.sign)
        goto cseg_8F41E;                    // jns short cseg_8F41E

    *(int8_t *)&D1 = -*(int8_t *)&D1;       // neg byte ptr D1
    {
        word res = *(word *)&D1 >> 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1

cseg_8F41E:;
    ax = D1;                                // mov ax, word ptr D1
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 89, 2, ax);           // mov [esi+59h], ax
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx + 13, 1); // mov al, [esi+ebx+0Dh]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 49, 2, ax);           // mov [esi+31h], ax
    writeMemory(esi + 79, 2, 1);            // mov word ptr [esi+4Fh], 1
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 4
    A1 = eax;                               // mov A1, eax
    cseg_95C18();                           // call cseg_95C18
    if (flags.zero)
        goto cseg_8F4F3;                    // jz short cseg_8F4F3

    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 2, 1);      // mov al, [esi+2]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 24755;                             // mov A0, offset countriesTable
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 1
    A0 = eax;                               // mov A0, eax

cseg_8F4CC:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_8F4CC;                    // jnz short cseg_8F4CC

    StringCopy();                           // call StringCopy
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 32);                // mov byte ptr [esi], 20h
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 1;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 1

cseg_8F4F3:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 5, 1);      // mov al, [esi+5]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_8F565;                    // jz short cseg_8F565

    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 3;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 3
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 4201;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, offset aChairmanScenes
    A0 = eax;                               // mov A0, eax
    goto cseg_8F598;                        // jmp short cseg_8F598

cseg_8F565:;
    A0 = 331832;                            // mov A0, offset divisionsTable
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        flags.carry = ((word)*(word *)&D0 >> 14) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 2
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax

cseg_8F598:;
    eax = A0;                               // mov eax, A0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 39, 4, eax);          // mov [esi+27h], eax
    StringCopy();                           // call StringCopy
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 11, 1);     // mov al, [esi+0Bh]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 97, 2, ax);           // mov [esi+61h], ax
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 10, 1);     // mov al, [esi+0Ah]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.sign)
        goto cseg_8F5EF;                    // jns short cseg_8F5EF

    *(byte *)&D0 = 1;                       // mov byte ptr D0, 1

cseg_8F5EF:;
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 93, 2, ax);           // mov [esi+5Dh], ax
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 12, 1);     // mov al, [esi+0Ch]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 240;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0F0h
    {
        word res = *(word *)&D0 >> 4;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 4
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 99, 2, ax);           // mov [esi+63h], ax
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 12, 1);     // mov al, [esi+0Ch]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 0Fh
    ax = D0;                                // mov ax, word ptr D0
    esi = A6;                               // mov esi, A6
    writeMemory(esi + 101, 2, ax);          // mov [esi+65h], ax
    cseg_2653B();                           // call cseg_2653B
    cseg_28243();                           // call cseg_28243
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team (file)
//      D0 - max substitutes
//
void SetupTeamSubstitutes()
{
    *(word *)&g_memByte[456230] = 1;        // mov skillDiv, 1
    *(word *)&D5 = 0;                       // mov word ptr D5, 0
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_no_players;                  // jz @@no_players

    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D3 = res;
    }                                       // sub word ptr D3, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    *(word *)&D7 = 11;                      // mov word ptr D7, 11

l_loop:;
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    cseg_8FA09();                           // call cseg_8FA09
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 4;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 4
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, 0
    if (!flags.zero)
        goto cseg_8F723;                    // jnz short cseg_8F723

    {
        word res = *(word *)&D0 >> 2;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 2
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 3

cseg_8F723:;
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto l_loop;                        // jns @@loop

    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = D2;                                // mov bx, word ptr D2
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D5 = ax;                      // mov word ptr D5, ax

l_no_players:;
    *(word *)&D7 = 0;                       // mov word ptr D7, 0

cseg_8F7AA:;
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    cseg_8FA09();                           // call cseg_8FA09
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    ax = D0;                                // mov ax, word ptr D0
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_8F7F0;                    // jnz short cseg_8F7F0

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0
    if (flags.zero)
        goto cseg_8F7F0;                    // jz short cseg_8F7F0

    {
        word src = *(word *)&g_memByte[456230];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[456230] = src;
    }                                       // add skillDiv, 1

cseg_8F7F0:;
    ax = D0;                                // mov ax, word ptr D0
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 11
    if (!flags.zero)
        goto cseg_8F7AA;                    // jnz short cseg_8F7AA

    ax = D5;                                // mov ax, word ptr D5
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 15;                                // mov bx, 15
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto cseg_8F86F;                    // jnz short cseg_8F86F

    esi = A0;                               // mov esi, A0
    ebx = 92766;                            // mov ebx, offset currentMatchPlayers
    {
        int32_t dstSigned = ebx;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        ebx = res;
    }                                       // sub ebx, offset careerTeam
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    goto cseg_8F87D;                        // jmp short cseg_8F87D

cseg_8F86F:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 60, 1);     // mov al, [esi+TeamFile.playerNumbers]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al

cseg_8F87D:;
    al = D1;                                // mov al, byte ptr D1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 38
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    eax = A0;                               // mov eax, A0
    ebx = D1;                               // mov ebx, D1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+102]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 224;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0E0h
    {
        word res = *(word *)&D1 >> 5;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 5
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, 0
    if (flags.zero)
        goto cseg_8F8E5;                    // jz short cseg_8F8E5

    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1

cseg_8F8E5:;
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = *(word *)&g_memByte[456230];       // mov bx, skillDiv
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&g_memByte[378786] = ax;       // mov oldPlayerSkill, ax
    esi = A0;                               // mov esi, A0
    writeMemory(esi + 59, 1, 0);            // mov [esi+TeamFile.someFlag], 0
    {
        word src = *(word *)&g_memByte[456266];
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp someFlag2, 0
    if (flags.zero)
        return;                             // jz @@out

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 5;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 5
    A1 = eax;                               // mov A1, eax
    *(word *)&D7 = 0;                       // mov word ptr D7, 0

cseg_8F94F:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    esi = A1;                               // mov esi, A1
    (*(int32_t *)&A1)++;                    // inc A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto cseg_8F94F;                    // jnz short cseg_8F94F

    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 4;
        dword res = dstSigned - srcSigned;
        A1 = res;
    }                                       // sub A1, 4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    (*(int32_t *)&A1)++;                    // inc A1
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D1 = eax;                               // mov D1, eax
    dx = *(word *)((byte *)&D1 + 2);        // mov dx, word ptr D1+2
    bx = 10;                                // mov bx, 10
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = '0';
        byte res = dstSigned + srcSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, '0'
    al = D1;                                // mov al, byte ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = '0';
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, '0'
    al = D1;                                // mov al, byte ptr D1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;
    flags.sign = (*(int32_t *)&A1 & 0x80000000) != 0;
    flags.zero = *(int32_t *)&A1 == 0;      // inc A1
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 0);                 // mov byte ptr [esi], 0
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team (file)
//      D7 - player index
// out:
//      D1 - position index
//
void cseg_8FA09()
{
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto l_not_a_career_team;           // jnz short @@not_a_career_team

    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    {
        int32_t dstSigned = ebx;
        int32_t srcSigned = 92766;
        dword res = dstSigned + srcSigned;
        ebx = res;
    }                                       // add ebx, offset currentMatchPlayers
    {
        int32_t dstSigned = ebx;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        ebx = res;
    }                                       // sub ebx, offset careerTeam
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    goto cseg_8FA4E;                        // jmp short cseg_8FA4E

l_not_a_career_team:;
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    al = (byte)readMemory(esi + ebx + 60, 1); // mov al, [esi+ebx+TeamFile.playerNumbers]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al

cseg_8FA4E:;
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    bx = 38;                                // mov bx, size PlayerFile
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 59, 1);     // mov al, [esi+TeamFile.someFlag]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (!flags.zero)
        goto l_maybe_right_team;            // jnz short @@maybe_right_team

    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 77, 1);     // mov al, [esi+(PlayerFile.field_1+4Ch)]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 224;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0E0h
    {
        word res = *(word *)&D1 >> 5;
        flags.carry = ((word)*(word *)&D1 >> 11) & 1;
        *(word *)&D1 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D1, 5
    A2 = 378790;                            // mov A2, offset playerPositionsArray
    al = D0;                                // mov al, byte ptr D0
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    return;                                 // retn

l_maybe_right_team:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_pl_num_not_zero;             // jnz short @@pl_num_not_zero

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, POS_GOALKEEPER
    if (flags.zero)
        goto l_goal_keeper;                 // jz short @@goal_keeper

    goto l_player;                          // jmp short @@player

l_pl_num_not_zero:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 11
    if (!flags.carry)
        goto l_pl_num_11_or_greater;        // jnb short @@pl_num_11_or_greater

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, POS_GOALKEEPER
    if (flags.zero)
        goto l_goalkeeper;                  // jz short @@goalkeeper

    goto l_common_player;                   // jmp @@common_player

l_player:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    goto l_team_not_selected;               // jmp @@team_not_selected

l_goal_keeper:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    goto l_player_price;                    // jmp short @@player_price

l_goalkeeper:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    goto l_team_not_selected;               // jmp @@team_not_selected

l_pl_num_11_or_greater:;
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 0
    if (flags.zero)
        goto l_reserve_goalkepper;          // jz short @@reserve_goalkepper

    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    goto l_player_price;                    // jmp short @@player_price

l_reserve_goalkepper:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    goto l_player_price;                    // jmp short @@player_price

l_common_player:;
    push(D6);                               // push D6
    GetPlayerPrice();                       // call GetPlayerPrice
    pop(D6);                                // pop D6

l_player_price:;
    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_price_at_least_25k;          // jnz short @@price_at_least_25k

    *(word *)&D7 = 1;                       // mov word ptr D7, 1

l_price_at_least_25k:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], 1
    if (flags.zero)
        goto l_team_not_selected;           // jz short @@team_not_selected

    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 2;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test [esi+(PlayerFile.positionAndFace+4Ch)], 2
    if (flags.zero)
        goto cseg_8FC26;                    // jz short cseg_8FC26

    *(word *)&D7 = 1;                       // mov word ptr D7, 1

cseg_8FC26:;
    eax = A1;                               // mov eax, A1
    {
        dword tmp = A0;
        A0 = eax;
        eax = tmp;
    }                                       // xchg eax, A0
    A1 = eax;                               // mov A1, eax
    ax = *(word *)&g_memByte[131753];       // mov ax, inEditTactics
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    IsPlayerInjured();                      // call IsPlayerInjured
    pop(D1);                                // pop D1
    if (flags.zero)
        goto cseg_8FC5E;                    // jz short cseg_8FC5E

    *(word *)&D7 = 0;                       // mov word ptr D7, 0

cseg_8FC5E:;
    eax = A1;                               // mov eax, A1
    {
        dword tmp = A0;
        A0 = eax;
        eax = tmp;
    }                                       // xchg eax, A0
    A1 = eax;                               // mov A1, eax

l_team_not_selected:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    writeMemory(esi + 77, 1, al);           // mov [esi+(PlayerFile.field_1+4Ch)], al
    A2 = 378790;                            // mov A2, offset playerPositionsArray
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    {
        word src = *(word *)&g_memByte[456266];
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp someFlag2, 0
    if (flags.zero)
        goto l_out;                         // jz @@out

    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, PlayerFile.playerName+4Ch
    A2 = eax;                               // mov A2, eax
    ecx = 23;                               // mov ecx, 23

l_skip_player_name_loop:;
    esi = A2;                               // mov esi, A2
    (*(int32_t *)&A2)++;                    // inc A2
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = ' ';
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], ' '
    if (flags.zero)
        goto l_space_encountered;           // jz short @@space_encountered

    if (--ecx)
        goto l_skip_player_name_loop;       // loop @@skip_player_name_loop

    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 79;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, PlayerFile.playerName+4Ch
    A2 = eax;                               // mov A2, eax

l_space_encountered:;
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D1 = eax;                               // mov D1, eax
    dx = *(word *)((byte *)&D1 + 2);        // mov dx, word ptr D1+2
    bx = 10;                                // mov bx, 10
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = '0';
        byte res = dstSigned + srcSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, '0'
    al = D1;                                // mov al, byte ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 1, 1, al);            // mov [esi+1], al
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = '0';
        byte res = dstSigned + srcSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, '0'
    al = D1;                                // mov al, byte ptr D1
    writeMemory(esi + 2, 1, al);            // mov [esi+2], al
    writeMemory(esi + 3, 1, ' ');           // mov byte ptr [esi+3], ' '
    writeMemory(esi, 1, ' ');               // mov byte ptr [esi], ' '
    writeMemory(esi + 4, 1, '-');           // mov byte ptr [esi+4], '-'
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D1 = eax;                               // mov D1, eax
    dx = *(word *)((byte *)&D1 + 2);        // mov dx, word ptr D1+2
    bx = 10;                                // mov bx, 10
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = '0';
        byte res = dstSigned + srcSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, '0'
    al = D1;                                // mov al, byte ptr D1
    esi = A2;                               // mov esi, A2
    writeMemory(esi + 5, 1, al);            // mov [esi+5], al
    {
        word tmp = *(word *)((byte *)&D1 + 2);
        *(word *)((byte *)&D1 + 2) = ax;
        ax = tmp;
    }                                       // xchg ax, word ptr D1+2
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = '0';
        byte res = dstSigned + srcSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, '0'
    al = D1;                                // mov al, byte ptr D1
    writeMemory(esi + 6, 1, al);            // mov [esi+6], al
    writeMemory(esi + 7, 1, ' ');           // mov byte ptr [esi+7], ' '

l_out:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        word res = *(word *)&D1 & 224;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 0E0h
    {
        word res = *(word *)&D1 >> 5;
        flags.carry = ((word)*(word *)&D1 >> 11) & 1;
        *(word *)&D1 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D1, 5
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> team (file)
//      A1 -> player (file)
//      D7 = player number (position)
// out:
//      D7 - player price
//
// Calculate and return player's price. Deduce tactics from player's team.
//
void GetPlayerPrice()
{
    push(A1);                               // push A1
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+(PlayerFile.positionAndFace+4Ch)]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ebx = 35;                               // mov ebx, 35
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    D0 = eax;                               // mov D0, eax
    A5 = 366744;                            // mov A5, offset skillsPerQuadrant
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = D0;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 35;
        dword res = dstSigned - srcSigned;
        eax = res;
    }                                       // sub eax, 35
    A5 = eax;                               // mov A5, eax
    ax = (word)readMemory(esi + 104, 2);    // mov ax, word ptr [esi+(PlayerFile.passing+4Ch)]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)((byte *)&D5 + 2) = ax;        // mov word ptr D5+2, ax
    ax = (word)readMemory(esi + 106, 2);    // mov ax, word ptr [esi+(PlayerFile.tacklingBallControl+4Ch)]
    {
        byte tmp = ah;
        ah = al;
        al = tmp;
    }                                       // xchg al, ah
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    {
        dword res = D5 & 125269879;
        D5 = res;
    }                                       // and D5, 7777777h
    {
        int32_t dstSigned = D5;
        int32_t srcSigned = 17895697;
        dword res = dstSigned + srcSigned;
        D5 = res;
    }                                       // add D5, 1111111h
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+TeamFile.tactics]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A3 = 372768;                            // mov A3, offset g_tacticsTable
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A3 = eax;                               // mov A3, eax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 9;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 9
    eax = A3;                               // mov eax, A3
    *(dword *)&g_memByte[379836] = eax;     // mov plPositions, eax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    ebx = 35;                               // mov ebx, 35
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    D7 = eax;                               // mov D7, eax
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = D7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, D7
    A3 = eax;                               // mov A3, eax
    A4 = 372984;                            // mov A4, offset quadrantCoordinatesToBallQuadrant
    A2 = 368218;                            // mov A2, (offset quadrantDistanceFactor+4A6h)
    *(word *)&g_memByte[379614] = 0;        // mov totalSkillsFactorSum, 0
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    *(word *)&D3 = 34;                      // mov word ptr D3, 34

l_ball_quadrants_loop:;
    push(D3);                               // push small [word ptr D3]
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    esi = A4;                               // mov esi, A4
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        goto l_check_skill_bitmask;         // jz @@check_skill_bitmask

    *(word *)&g_memByte[379612] = 1;        // mov numPlayersAtQuadrant, 1
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 5;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 5
    if (flags.carry)
        goto l_check_skill_bitmask;         // jb @@check_skill_bitmask

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 30
    if (!flags.carry)
        goto l_check_skill_bitmask;         // jnb @@check_skill_bitmask

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 7;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 7
    if (flags.zero)
        goto l_check_skill_bitmask;         // jz @@check_skill_bitmask

    eax = *(dword *)&g_memByte[379836];     // mov eax, plPositions
    A6 = eax;                               // mov A6, eax
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    *(word *)&D1 = 9;                       // mov word ptr D1, 9

l_player_positions_loop:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    esi = A4;                               // mov esi, A4
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D6;                                // mov al, byte ptr D6
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto l_next_player;                 // jnz short @@next_player

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1

l_next_player:;
    {
        int32_t dstSigned = A6;
        int32_t srcSigned = 35;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A6 = res;
    }                                       // add A6, 35
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto l_player_positions_loop;       // jns short @@player_positions_loop

    ax = D2;                                // mov ax, word ptr D2
    *(word *)&g_memByte[379612] = ax;       // mov numPlayersAtQuadrant, ax

l_check_skill_bitmask:;
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        word res = *(word *)&D3 << 2;
        *(word *)&D3 = res;
    }                                       // shl word ptr D3, 2
    A6 = 372844;                            // mov A6, offset priceSkillPonders
    esi = A6;                               // mov esi, A6
    ebx = *(word *)&D3;                     // movzx ebx, word ptr D3
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    D3 = eax;                               // mov D3, eax
    A1 = 529338;                            // mov A1, offset skillValuePonders
    eax = D5;                               // mov eax, D5
    D2 = eax;                               // mov D2, eax
    *(word *)&D4 = 6;                       // mov word ptr D4, 6

l_skills_loop:;
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 & 15;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0Fh
    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 & 15;
        *(word *)&D1 = res;
        flags.carry = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D1, 0Fh
    if (flags.zero)
        goto l_next_skill;                  // jz short @@next_skill

    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ebx = *(byte *)&D1;                     // movzx ebx, byte ptr D1
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    D0 = eax;                               // mov D0, eax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, ax

l_next_skill:;
    {
        dword res = D2 >> 4;
        D2 = res;
    }                                       // shr D2, 4
    {
        dword res = D3 >> 4;
        flags.carry = ((dword)D3 >> 28) & 1;
        D3 = res;
    }                                       // shr D3, 4
    (*(int16_t *)&D4)--;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto l_skills_loop;                 // jns short @@skills_loop

    {
        word res = *(word *)&D7 >> 1;
        *(word *)&D7 = res;
    }                                       // shr word ptr D7, 1
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    D7 = eax;                               // mov D7, eax
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    D7 = eax;                               // mov D7, eax
    {
        dword res = D7 >> 3;
        D7 = res;
    }                                       // shr D7, 3
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        goto l_skip_num_players_divide;     // jz short @@skip_num_players_divide

    ax = *(word *)&g_memByte[379612];       // mov ax, numPlayersAtQuadrant
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    if (flags.zero)
        goto l_skip_num_players_divide;     // jz short @@skip_num_players_divide

    edx ^= edx;                             // xor edx, edx
    eax = D7;                               // mov eax, D7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D7 = eax;                               // mov D7, eax

l_skip_num_players_divide:;
    {
        int32_t val = stack[stackTop++];
        *(word *)&D3 = val;
    }                                       // pop small [word ptr D3]
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        goto cseg_901EB;                    // jz short cseg_901EB

    CountNearnessFactor();                  // call CountNearnessFactor

cseg_901EB:;
    ax = D7;                                // mov ax, word ptr D7
    {
        word src = *(word *)&g_memByte[379614];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[379614] = src;
    }                                       // add totalSkillsFactorSum, ax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 35;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        A2 = res;
    }                                       // sub A2, 35
    (*(int16_t *)&D3)--;
    flags.sign = (*(int16_t *)&D3 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D3 == 0;      // dec word ptr D3
    if (!flags.sign)
        goto l_ball_quadrants_loop;         // jns @@ball_quadrants_loop

    ax = *(word *)&g_memByte[379614];       // mov ax, totalSkillsFactorSum
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    edx ^= edx;                             // xor edx, edx
    ebx = 350;                              // mov ebx, 350
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D7 = eax;                               // mov D7, eax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 8;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 8
    if (!flags.sign)
        goto l_test_upper_bound;            // jns short @@test_upper_bound

    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    goto l_bounds_tested;                   // jmp short @@bounds_tested

l_test_upper_bound:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 49;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, 49
    if (flags.carry || flags.zero)
        goto l_bounds_tested;               // jbe short @@bounds_tested

    *(word *)&D7 = 49;                      // mov word ptr D7, 49

l_bounds_tested:;
    pop(A1);                                // pop A1
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    if (flags.sign)
        return;                             // js short @@out

    A5 = 529346;                            // mov A5, offset plPricesIncreaseTable
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D7 = al;                      // mov byte ptr D7, al
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+(PlayerFile.price+4Ch)]
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D7 = res;
    }                                       // add byte ptr D7, al
}

// =============== S U B R O U T I N E =======================================

// in:
//      D3 -  current ball quadrant
//      D6 -  destination ball quadrant
//      D7 -  price currently calculated value
//      A2 -> quadrant distance factor table for current ball quadrant
//      A3 -> players positions (from tactics)
//      A4 -> player coordinates to quadrants table
// out:
//      D7 - fixed price value, with destination quadrants factor included
//
// Multiply price value with ratio of near quadrants to near destination quadrants. It's <= 1.
//
void CountNearnessFactor()
{
    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(word *)&D0;                     // movzx eax, word ptr D0
    ebx = 35;                               // mov ebx, 35
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    D0 = eax;                               // mov D0, eax
    A1 = 367028;                            // mov A1, offset quadrantDistanceFactor
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = D0;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, D0
    A1 = eax;                               // mov A1, eax
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    *(word *)&D4 = 0;                       // mov word ptr D4, 0
    *(word *)&D0 = 34;                      // mov word ptr D0, 34

l_quadrants_loop:;
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_next_quadrant;               // jz short @@next_quadrant

    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        byte src = (byte)readMemory(esi + ebx, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 8;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+ebx], 8
    if (flags.carry)
        goto l_next_quadrant;               // jb short @@next_quadrant

    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D2 = res;
    }                                       // add word ptr D2, 1
    esi = A3;                               // mov esi, A3
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    esi = A4;                               // mov esi, A4
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D4;                     // movzx ebx, word ptr D4
    {
        byte src = (byte)readMemory(esi + ebx, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 4;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+ebx], 4
    if (flags.carry)
        goto l_next_quadrant;               // jb short @@next_quadrant

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1

l_next_quadrant:;
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_quadrants_loop;              // jns short @@quadrants_loop

    eax = *(word *)&D7;                     // movzx eax, word ptr D7
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    {
        uint64_t res = (uint64_t)eax * ebx;
        eax = res & 0xffffffff;
        edx = res >> 32;
    }                                       // mul ebx
    edx ^= edx;                             // xor edx, edx
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        uint64_t dividend = ((uint64_t)edx << 32) | eax;
        dword quot = (dword)(dividend / ebx);
        dword rem = (dword)(dividend % ebx);
        eax = quot;
        edx = rem;
    }                                       // div ebx
    D7 = eax;                               // mov D7, eax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_903B1()
{
    ax = *(word *)&g_memByte[465960];       // mov ax, g_trainingGame
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_90729

    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+4], 1
    if (flags.zero)
        return;                             // jz cseg_90729

    *(word *)&D0 = 65535;                   // mov word ptr D0, 0FFFFh
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    push(A1);                               // push A1
    GetNumberOfAvailablePlayers();          // call GetNumberOfAvailablePlayers
    pop(A1);                                // pop A1
    *(word *)&D5 = 4;                       // mov word ptr D5, 4
    {
        word src = *(word *)&g_memByte[129472];
        int16_t dstSigned = src;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp g_gameType, 4
    if (flags.zero)
        goto cseg_9040F;                    // jz short cseg_9040F

    *(word *)&D5 = 2;                       // mov word ptr D5, 2

cseg_9040F:;
    ax = D6;                                // mov ax, word ptr D6
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, ax
    if (flags.zero)
        return;                             // jz cseg_90729

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 3Ch
    A5 = eax;                               // mov A5, eax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto cseg_90445;                    // jnz short cseg_90445

    A5 = 92766;                             // mov A5, offset currentMatchPlayers

cseg_90445:;
    *(word *)&D7 = 10;                      // mov word ptr D7, 0Ah

cseg_9044E:;
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    SWOS::Rand2();                          // call Rand2
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D6;                     // movzx ebx, word ptr D6
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_904A7;                    // js short cseg_904A7

    {
        byte res = *(byte *)&D0 & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr D0, 1
    if (!flags.zero)
        goto cseg_904A7;                    // jnz short cseg_904A7

    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D6 = al;                      // mov byte ptr D6, al

cseg_904A7:;
    ax = D6;                                // mov ax, word ptr D6
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A6 = eax;                               // mov A6, eax
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    *(byte *)&D2 = al;                      // mov byte ptr D2, al
    {
        word res = *(word *)&D1 & 28;
        *(word *)&D1 = res;
    }                                       // and word ptr D1, 1Ch
    {
        word res = *(word *)&D2 & 3;
        *(word *)&D2 = res;
    }                                       // and word ptr D2, 3
    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_90523;                    // jnz short cseg_90523

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 2
    if (!flags.carry)
        goto cseg_9071C;                    // jnb cseg_9071C

    goto cseg_90531;                        // jmp short cseg_90531

cseg_90523:;
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 10h
    if (!flags.carry)
        goto cseg_9071C;                    // jnb cseg_9071C

cseg_90531:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 0
    if (!flags.zero)
        goto cseg_905C7;                    // jnz short cseg_905C7

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D7);                               // push D7
    push(A1);                               // push A1
    *(word *)&D0 = 65535;                   // mov word ptr D0, 0FFFFh
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    push(D5);                               // push D5
    cseg_9072A();                           // call cseg_9072A
    pop(D5);                                // pop D5
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = D6;                                // mov ax, word ptr D6
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_9071C;                    // jnz cseg_9071C

cseg_905C7:;
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 31;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1Fh
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 29;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1Dh
    if (flags.carry)
        goto cseg_90640;                    // jb short cseg_90640

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 30;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1Eh
    if (flags.carry)
        goto cseg_90625;                    // jb short cseg_90625

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 31;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 1Fh
    if (flags.carry)
        goto cseg_90614;                    // jb short cseg_90614

    ax = *(word *)&g_memByte[131753];       // mov ax, inEditTactics
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_9069E;                    // jnz cseg_9069E

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0
    if (!flags.zero)
        goto cseg_9068C;                    // jnz cseg_9068C

    goto cseg_9068C;                        // jmp short cseg_9068C

cseg_90614:;
    ax = *(word *)&g_memByte[131753];       // mov ax, inEditTactics
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_9069E;                    // jnz short cseg_9069E

    goto cseg_9068C;                        // jmp short cseg_9068C

cseg_90625:;
    ax = *(word *)&g_memByte[131753];       // mov ax, inEditTactics
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_9069E;                    // jnz short cseg_9069E

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0
    if (!flags.zero)
        goto cseg_9068C;                    // jnz short cseg_9068C

    goto cseg_9067A;                        // jmp short cseg_9067A

cseg_90640:;
    ax = *(word *)&g_memByte[131753];       // mov ax, inEditTactics
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_9071C;                    // jnz cseg_9071C

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D1, 0
    if (!flags.zero)
        goto cseg_9066F;                    // jnz short cseg_9066F

    cseg_3E608();                           // call cseg_3E608
    if (flags.zero)
        goto cseg_90709;                    // jz cseg_90709

    *(word *)&D1 = 4;                       // mov word ptr D1, 4
    goto cseg_906A7;                        // jmp short cseg_906A7

cseg_9066F:;
    *(word *)&D1 = 8;                       // mov word ptr D1, 8
    goto cseg_906A7;                        // jmp short cseg_906A7

cseg_9067A:;
    cseg_3E608();                           // call cseg_3E608
    if (flags.zero)
        goto cseg_9066F;                    // jz short cseg_9066F

    *(word *)&D1 = 12;                      // mov word ptr D1, 0Ch
    goto cseg_906A7;                        // jmp short cseg_906A7

cseg_9068C:;
    cseg_3E608();                           // call cseg_3E608
    if (flags.zero)
        goto cseg_9066F;                    // jz short cseg_9066F

    *(word *)&D1 = 16;                      // mov word ptr D1, 10h
    goto cseg_906A7;                        // jmp short cseg_906A7

cseg_9069E:;
    *(word *)&D2 = 2;                       // mov word ptr D2, 2

cseg_906A7:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 65507;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFE3h
    ax = D1;                                // mov ax, word ptr D1
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 103, 1, al);          // mov [esi+67h], al
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 65532;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFFCh
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 |= ax;                     // or word ptr D0, ax
    al = D0;                                // mov al, byte ptr D0
    writeMemory(esi + 103, 1, al);          // mov [esi+67h], al

cseg_90709:;
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D5 = res;
    }                                       // sub word ptr D5, 1
    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz short cseg_90729

cseg_9071C:;
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_9044E;                    // jns cseg_9044E
}

// =============== S U B R O U T I N E =======================================
//
void cseg_9072A()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 60;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 3Ch
    A2 = eax;                               // mov A2, eax
    *(word *)&D1 = 16;                      // mov word ptr D1, 10h
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto cseg_9076E;                    // jnz short cseg_9076E

    A2 = 92766;                             // mov A2, offset currentMatchPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D1 = ax;                      // mov word ptr D1, ax

cseg_9076E:;
    *(word *)&D6 = 0;                       // mov word ptr D6, 0
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_90788:;
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (!flags.zero)
        goto cseg_908A6;                    // jnz cseg_908A6

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto cseg_90837;                    // jz short cseg_90837

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 20h
    if (!flags.zero)
        goto cseg_90896;                    // jnz short cseg_90896

cseg_90837:;
    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D5, 1
    if (flags.zero)
        goto cseg_90876;                    // jz short cseg_90876

    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 28;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1Ch
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto cseg_9086B;                    // jz short cseg_9086B

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 4;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 4
    if (!flags.zero)
        goto cseg_90896;                    // jnz short cseg_90896

cseg_9086B:;
    ax = D5;                                // mov ax, word ptr D5
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.sign)
        goto cseg_908A6;                    // jns short cseg_908A6

cseg_90876:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 3
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto cseg_908A6;                    // jz short cseg_908A6

cseg_90896:;
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D6 = res;
    }                                       // add word ptr D6, 1
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_908A6:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_90788;                    // jns cseg_90788
}

// =============== S U B R O U T I N E =======================================
//
void cseg_908B4()
{
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_90E66

    A6 = 379734;                            // mov A6, offset dseg_11F93E
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, offset careerTeam
    if (flags.zero)
        goto cseg_908F3;                    // jz short cseg_908F3

    eax = D1;                               // mov eax, D1
    {
        dword tmp = D2;
        D2 = eax;
        eax = tmp;
    }                                       // xchg eax, D2
    D1 = eax;                               // mov D1, eax
    A6 = 379766;                            // mov A6, offset dseg_11F95E

cseg_908F3:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 59, 2);     // mov ax, [esi+3Bh]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 318643;
        dword res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT32_MIN : srcSigned < dstSigned - INT32_MAX;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset DIY_competitionStart
    if (flags.zero)
        goto cseg_90921;                    // jz short cseg_90921

    ax = (word)readMemory(esi + 101, 2);    // mov ax, [esi+65h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    goto cseg_90931;                        // jmp short cseg_90931

cseg_90921:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 97, 2);     // mov ax, [esi+61h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax

cseg_90931:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 11;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 0Bh
    push(A0);                               // push A0
    A0 = 92798;                             // mov A0, offset careerTeam
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    {
        word res = *(word *)&D0 >> 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 17;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 11h
    if (flags.carry || flags.zero)
        goto cseg_90A04;                    // jbe short cseg_90A04

    *(word *)&D0 = 17;                      // mov word ptr D0, 11h

cseg_90A04:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[529590] = ax;       // mov dseg_180686, ax
    pop(A0);                                // pop A0
    A1 = 92766;                             // mov A1, offset currentMatchPlayers
    *(word *)&D3 = 0;                       // mov word ptr D3, 0

cseg_90A29:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A6;                               // mov eax, A6
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    ax = D0;                                // mov ax, word ptr D0
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A0 = 92798;                             // mov A0, offset careerTeam
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_90E4B;                    // jz cseg_90E4B

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (flags.zero)
        goto cseg_90E4B;                    // jz cseg_90E4B

    ax = D6;                                // mov ax, word ptr D6
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    IsPlayerInjured();                      // call IsPlayerInjured
    pop(D1);                                // pop D1
    if (!flags.zero)
        goto cseg_90C07;                    // jnz cseg_90C07

    ax = D3;                                // mov ax, word ptr D3
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_90BB1;                    // jz cseg_90BB1

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 11;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 0Bh
    if (flags.carry)
        goto cseg_90C26;                    // jb cseg_90C26

    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (flags.carry)
        goto cseg_90B42;                    // jb short cseg_90B42

    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 85;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 55h
    if (!flags.carry && !flags.zero)
        goto cseg_90E1F;                    // ja cseg_90E1F

    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    {
        word res = *(word *)&D4 & 1;
        *(word *)&D4 = res;
    }                                       // and word ptr D4, 1
    *(int16_t *)&D4 = -*(int16_t *)&D4;     // neg word ptr D4
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 1
    goto cseg_90D5F;                        // jmp cseg_90D5F

cseg_90B42:;
    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 51;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 33h
    if (!flags.carry && !flags.zero)
        goto cseg_90E1F;                    // ja cseg_90E1F

    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 102, 1);    // mov al, [esi+66h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 224;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0E0h
    {
        word res = *(word *)&D0 >> 5;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto cseg_90B8C;                    // jz short cseg_90B8C

    *(word *)&D4 = 65535;                   // mov word ptr D4, 0FFFFh
    goto cseg_90D5F;                        // jmp cseg_90D5F

cseg_90B8C:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    {
        word res = *(word *)&D4 & 1;
        *(word *)&D4 = res;
    }                                       // and word ptr D4, 1
    flags.carry = *(int16_t *)&D4 != 0;
    flags.overflow = *(int16_t *)&D4 == INT16_MIN;
    *(int16_t *)&D4 = -*(int16_t *)&D4;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // neg word ptr D4
    goto cseg_90D5F;                        // jmp cseg_90D5F

cseg_90BB1:;
    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 51;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 33h
    if (!flags.carry && !flags.zero)
        goto cseg_90E1F;                    // ja cseg_90E1F

    *(word *)&D4 = 4;                       // mov word ptr D4, 4
    ax = D2;                                // mov ax, word ptr D2
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_90D5F;                    // jz cseg_90D5F

    bx = 65535;                             // mov bx, 0FFFFh
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
        flags.carry = res != (int16_t)ax != 0;
    }                                       // imul bx
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)((byte *)&D4 + 2) = dx;        // mov word ptr D4+2, dx
    goto cseg_90D5F;                        // jmp cseg_90D5F

cseg_90C07:;
    SWOS::Rand2();                          // call Rand2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 51;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 33h
    if (!flags.carry && !flags.zero)
        goto cseg_90E1F;                    // ja cseg_90E1F

    *(byte *)&D4 = 255;                     // mov byte ptr D4, 0FFh
    goto cseg_90D5F;                        // jmp cseg_90D5F

cseg_90C26:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 113, 1);    // mov al, [esi+71h]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D4 = eax;                               // mov D4, eax
    dx = *(word *)((byte *)&D4 + 2);        // mov dx, word ptr D4+2
    bx = 10;                                // mov bx, 0Ah
    {
        int32_t dividend = ((int16_t)dx << 16) | (int16_t)ax;
        int16_t quot = (int16_t)(dividend / (int16_t)bx);
        int16_t rem = (int16_t)(dividend % (int16_t)bx);
        ax = quot;
        dx = rem;
    }                                       // idiv bx
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    *(word *)((byte *)&D4 + 2) = dx;        // mov word ptr D4+2, dx
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+6Ch]
    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        *(byte *)&D4 = res;
    }                                       // add byte ptr D4, al
    al = (byte)readMemory(esi + 77, 1);     // mov al, [esi+4Dh]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = D4;                                // mov al, byte ptr D4
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    al = D0;                                // mov al, byte ptr D0
    A2 = 529396;                            // mov A2, offset dseg_1805C4
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.sign)
        goto cseg_90D08;                    // js short cseg_90D08

    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 17;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 11h
    if (flags.carry || flags.zero)
        goto cseg_90CCF;                    // jbe short cseg_90CCF

    *(word *)&D4 = 17;                      // mov word ptr D4, 11h

cseg_90CCF:;
    SWOS::Rand();                           // call Rand
    {
        word res = *(word *)&D4 << 3;
        *(word *)&D4 = res;
    }                                       // shl word ptr D4, 3
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    goto cseg_90D5F;                        // jmp short cseg_90D5F

cseg_90D08:;
    *(int16_t *)&D4 = -*(int16_t *)&D4;     // neg word ptr D4
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 17;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, 11h
    if (flags.carry || flags.zero)
        goto cseg_90D22;                    // jbe short cseg_90D22

    *(word *)&D4 = 17;                      // mov word ptr D4, 11h

cseg_90D22:;
    SWOS::Rand();                           // call Rand
    {
        word res = *(word *)&D4 << 3;
        *(word *)&D4 = res;
    }                                       // shl word ptr D4, 3
    {
        word res = *(word *)&D0 & 7;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 7
    ax = D4;                                // mov ax, word ptr D4
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D4 = al;                      // mov byte ptr D4, al
    *(int8_t *)&D4 = -*(int8_t *)&D4;       // neg byte ptr D4

cseg_90D5F:;
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    *(byte *)&D5 = al;                      // mov byte ptr D5, al
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_90DAC;                    // jz short cseg_90DAC

    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D4 = res;
    }                                       // add byte ptr D4, 1
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 1;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 1
    if (flags.zero)
        goto cseg_90D8D;                    // jz short cseg_90D8D

    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        *(byte *)&D4 = res;
    }                                       // add byte ptr D4, 1

cseg_90D8D:;
    {
        int8_t dstSigned = *(byte *)&D5;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D5, 1
    if (flags.zero)
        goto cseg_90DAC;                    // jz short cseg_90DAC

    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 3;
        *(word *)&D0 = res;
        flags.carry = false;
        flags.overflow = false;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // and word ptr D0, 3
    if (!flags.zero)
        goto cseg_90DAC;                    // jnz short cseg_90DAC

    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D4 = res;
    }                                       // add byte ptr D4, 1

cseg_90DAC:;
    SWOS::Rand2();                          // call Rand2
    {
        word res = *(word *)&D0 & 1;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    al = D0;                                // mov al, byte ptr D0
    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D4, al
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_90DD8;                    // jle short cseg_90DD8

    *(byte *)&D4 = al;                      // mov byte ptr D4, al

cseg_90DD8:;
    *(int16_t *)&D0 = -*(int16_t *)&D0;     // neg word ptr D0
    al = D0;                                // mov al, byte ptr D0
    {
        int8_t dstSigned = *(byte *)&D4;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D4, al
    if (flags.sign == flags.overflow)
        goto cseg_90DF6;                    // jge short cseg_90DF6

    *(byte *)&D4 = al;                      // mov byte ptr D4, al

cseg_90DF6:;
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 9Bh
    if (flags.zero)
        goto cseg_90E08;                    // jz short cseg_90E08

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 9Ah
    if (!flags.zero)
        goto cseg_90E11;                    // jnz short cseg_90E11

cseg_90E08:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0

cseg_90E11:;
    al = D4;                                // mov al, byte ptr D4
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + 113, 1, src);
    }                                       // add [esi+71h], al

cseg_90E1F:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 156;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ch
    if (flags.sign == flags.overflow)
        goto cseg_90E35;                    // jge short cseg_90E35

    writeMemory(esi + 113, 1, 156);         // mov byte ptr [esi+71h], 9Ch

cseg_90E35:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 100;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 64h
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_90E4B;                    // jle short cseg_90E4B

    writeMemory(esi + 113, 1, 100);         // mov byte ptr [esi+71h], 64h

cseg_90E4B:;
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 1
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, ax
    if (!flags.zero)
        goto cseg_90A29;                    // jnz cseg_90A29
}

// =============== S U B R O U T I N E =======================================

// in:
//      D0 - average player price in team
//
void GetTeamValueBase()
{
    al = D0;                                // mov al, byte ptr D0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 332362;                            // mov A0, offset avgTeamValues
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    A0 = 332160;                            // mov A0, offset avgTeamValueBases
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
}

// =============== S U B R O U T I N E =======================================
//
void ShowLeavingMessage()
{
    *(word *)&D0 = 32;                      // mov word ptr D0, THANKS_FOR_ALL_YOUR_HELP
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_club_selector;               // jnz short @@club_selector

    *(word *)&D0 = 18;                      // mov word ptr D0, THANKS_FOR_ALL_HELP

l_club_selector:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[337240] = ax;       // mov currentMessage, ax
    ShowChairmanMessage();                  // jmp ShowChairmanMessage
}

// =============== S U B R O U T I N E =======================================
//
void ShowGreetingMessage()
{
_l_start:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    {
        word res = ax & 7;
        ax = res;
    }                                       // and ax, 7
    dx ^= dx;                               // xor dx, dx
    bx = 3;                                 // mov bx, 3
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    {
        word src = *(word *)&g_memByte[131742];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp chairmanIndex, ax
    if (flags.zero)
        goto _l_start;                      // jz short ShowGreetingMessage

    *(word *)&g_memByte[131742] = ax;       // mov chairmanIndex, ax
    *(word *)&D0 = 33;                      // mov word ptr D0, WELCOME_WE_LOOK_FORWARD
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_club_selector;               // jnz short @@club_selector

    *(word *)&D0 = 19;                      // mov word ptr D0, WELCOME_TO_OUR_CLUB

l_club_selector:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[337240] = ax;       // mov currentMessage, ax
    ShowChairmanMessage();                  // jmp ShowChairmanMessage
}

// =============== S U B R O U T I N E =======================================
//
void ShowLastSeasonMessage()
{
_l_start:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    {
        word res = ax & 7;
        ax = res;
    }                                       // and ax, 7
    dx ^= dx;                               // xor dx, dx
    bx = 3;                                 // mov bx, 3
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    {
        word src = *(word *)&g_memByte[131742];
        int16_t dstSigned = src;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp chairmanIndex, ax
    if (flags.zero)
        goto _l_start;                      // jz short ShowLastSeasonMessage

    *(word *)&g_memByte[131742] = ax;       // mov chairmanIndex, ax
    *(word *)&D0 = 34;                      // mov word ptr D0, WELCOME_ENJOY_YOUR_LAST_SEASON
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_90F85;                    // jnz short cseg_90F85

    *(word *)&D0 = 20;                      // mov word ptr D0, LAST_SEASON_BEFORE_RETIREMENT

cseg_90F85:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[337240] = ax;       // mov currentMessage, ax
    ShowChairmanMessage();                  // jmp ShowChairmanMessage
}

// =============== S U B R O U T I N E =======================================
//
void ShowWishYouSuccessMessage()
{
    *(word *)&D0 = 35;                      // mov word ptr D0, WISH_YOU_SUCESS
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_club_selector;               // jnz short @@club_selector

    *(word *)&D0 = 21;                      // mov word ptr D0, WISH_YOU_EVERY_SUCCESS

l_club_selector:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[337240] = ax;       // mov currentMessage, ax
    ShowChairmanMessage();                  // jmp ShowChairmanMessage
}

// =============== S U B R O U T I N E =======================================
//
void ShowEnjoyLastSeasonMessage()
{
    *(word *)&D0 = 36;                      // mov word ptr D0, ENJOY_LAST_SEASON_BEFORE
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_club_selector;               // jnz short @@club_selector

    *(word *)&D0 = 22;                      // mov word ptr D0, ENJOY_LAST_SEASON

l_club_selector:;
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&g_memByte[337240] = ax;       // mov currentMessage, ax
    ShowChairmanMessage();                  // jmp ShowChairmanMessage
}

// =============== S U B R O U T I N E =======================================
//
void cseg_90FF2()
{
    A6 = 126568;                            // mov A6, offset competitionFileBuffer
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 301;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 12Dh
    A5 = eax;                               // mov A5, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 237;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 0EDh
    A4 = eax;                               // mov A4, eax
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 0
    if (flags.zero)
        goto cseg_9107C;                    // jz short cseg_9107C

    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 24Dh
    A5 = eax;                               // mov A5, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A4 = eax;                               // mov A4, eax
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (flags.zero)
        goto cseg_9107C;                    // jz short cseg_9107C

    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 153;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 99h
    A5 = eax;                               // mov A5, eax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A4 = eax;                               // mov A4, eax

cseg_9107C:;
    A3 = 529599;                            // mov A3, offset dseg_18068F
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1

cseg_9108E:;
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 << 1;
        flags.carry = ((word)*(word *)&D1 >> 15) & 1;
        *(word *)&D1 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D1, 1
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D1);                               // push D1
    push(D6);                               // push D6
    push(A5);                               // push A5
    GetMoreExpensiveTeamsCount();           // call GetMoreExpensiveTeamsCount
    pop(A5);                                // pop A5
    pop(D6);                                // pop D6
    pop(D1);                                // pop D1
    {
        word res = *(word *)&D1 >> 1;
        flags.carry = ((word)*(word *)&D1 >> 15) & 1;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 1
    al = D2;                                // mov al, byte ptr D2
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto cseg_9108E;                    // jns cseg_9108E
}

// =============== S U B R O U T I N E =======================================
//
void cseg_9111F()
{
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(A6);                               // push A6
    GetMoreExpensiveTeamsCount();           // call GetMoreExpensiveTeamsCount
    pop(A6);                                // pop A6
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 0
    if (flags.zero)
        goto cseg_91169;                    // jz short cseg_91169

    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 1
    if (flags.zero)
        goto cseg_9119F;                    // jz short cseg_9119F

    goto cseg_91202;                        // jmp cseg_91202

cseg_91169:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1
    ax = D7;                                // mov ax, word ptr D7
    {
        word src = (word)readMemory(esi + 93, 2);
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
        flags.carry = dx != 0 != 0;
    }                                       // mul word ptr [esi+5Dh]
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    *(word *)((byte *)&D7 + 2) = dx;        // mov word ptr D7+2, dx
    return;                                 // retn

cseg_9119F:;
    *(word *)&D7 = 0;                       // mov word ptr D7, 0
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 101;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 65h
    A0 = eax;                               // mov A0, eax

cseg_911B5:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
    }                                       // cmp word ptr [esi], 2
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A0 = res;
    }                                       // add A0, 2
    if (!flags.zero)
        goto cseg_911D8;                    // jnz short cseg_911D8

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1

cseg_911D8:;
    {
        word res = *(word *)&D3 >> 1;
        *(word *)&D3 = res;
    }                                       // shr word ptr D3, 1
    ax = D3;                                // mov ax, word ptr D3
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.carry)
        return;                             // jnb cseg_912D9

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D3, 1
    if (flags.zero)
        return;                             // jz cseg_912D9

    goto cseg_911B5;                        // jmp short cseg_911B5

cseg_91202:;
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 81, 2);     // mov ax, [esi+51h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    eax = A6;                               // mov eax, A6
    A0 = eax;                               // mov A0, eax
    *(word *)&D7 = 0;                       // mov word ptr D7, 0

cseg_9122D:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_91289;                    // jz short cseg_91289

    ax = (word)readMemory(esi + 363, 2);    // mov ax, [esi+16Bh]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    ax = D0;                                // mov ax, word ptr D0
    {
        word src = (word)readMemory(esi + 357, 2);
        tmp = ax * src;
        ax = tmp.lo16;
        dx = tmp.hi16;
    }                                       // mul word ptr [esi+165h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, ax
    goto cseg_912A9;                        // jmp short cseg_912A9

cseg_91289:;
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 365, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+16Dh], 2
    if (!flags.zero)
        goto cseg_912A9;                    // jnz short cseg_912A9

    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1

cseg_912A9:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 355, 2);    // mov ax, [esi+163h]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (!flags.carry)
        return;                             // jnb short cseg_912D9

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 118;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 76h
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_9122D;                    // jns cseg_9122D
}

// =============== S U B R O U T I N E =======================================

// in:
//     D0 -  team number
//     A6 -> diy competition
// out:
//     D2 -  number of more expensive teams in the competition
//
// Returns the number of teams that have higher average price than the given team.
//
void GetMoreExpensiveTeamsCount()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+DIY_Competition.numTeams]
    *(word *)&D6 = ax;                      // mov word ptr D6, ax
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 301;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 301
    A5 = eax;                               // mov A5, eax
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+DIY_Competition.competitionType], DIY_LEAGUE
    if (flags.zero)
        goto l_get_average_price;           // jz short @@get_average_price

    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 589
    A5 = eax;                               // mov A5, eax
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+DIY_Competition.competitionType], DIY_CUP
    if (flags.zero)
        goto l_get_average_price;           // jz short @@get_average_price

    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 153;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 153
    A5 = eax;                               // mov A5, eax

l_get_average_price:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D5 = ax;                      // mov word ptr D5, ax
    *(word *)&D3 = 0;                       // mov word ptr D3, 0
    {
        int16_t dstSigned = *(word *)&D6;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D6 = res;
    }                                       // sub word ptr D6, 1

l_teams_loop:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D7;                                // mov ax, word ptr D7
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto l_next_team;                   // jz short @@next_team

    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    ax = D5;                                // mov ax, word ptr D5
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.carry || flags.zero)
        goto l_next_team;                   // jbe short @@next_team

    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        *(word *)&D3 = res;
    }                                       // add word ptr D3, 1

l_next_team:;
    (*(int16_t *)&D6)--;
    flags.sign = (*(int16_t *)&D6 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D6 == 0;      // dec word ptr D6
    if (!flags.sign)
        goto l_teams_loop;                  // jns short @@teams_loop

    ax = D3;                                // mov ax, word ptr D3
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)&g_memByte[456344] = ax;       // mov moreExpensiveTeamsCount, ax
}

// =============== S U B R O U T I N E =======================================
//
void ContinueCareerNextSeason()
{
    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, -1
    if (flags.zero)
        goto l_no_jobs;                     // jz short @@no_jobs

    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto l_sacked_no_message;           // jnz short @@sacked_no_message

    ShowLeavingMessage();                   // call ShowLeavingMessage

l_sacked_no_message:;
    cseg_91428();                           // call cseg_91428
    ax = *(word *)&g_memByte[91670];        // mov ax, teamNoOfferAccepted
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = *(dword *)&g_memByte[91672];      // mov eax, teamFundsAccepted
    D1 = eax;                               // mov D1, eax
    cseg_942F2();                           // call cseg_942F2
    { InitializeNewSeason(); return; }      // jmp InitializeNewSeason

l_no_jobs:;
    ShowChairmanOpinionAboutTheSeason();    // call ShowChairmanOpinionAboutTheSeason
    cseg_91428();                           // call cseg_91428
    cseg_943FA();                           // call cseg_943FA
    PlayNewSeasonAnimations();              // call PlayNewSeasonAnimations
    InitializeNewSeason();                  // jmp InitializeNewSeason
}

// =============== S U B R O U T I N E =======================================
//
void cseg_91428()
{
    cseg_8CC0A();                           // call cseg_8CC0A
    *(word *)&g_memByte[91730] = 0;         // mov playPromotedAnimation, 0
    *(word *)&g_memByte[91732] = 0;         // mov playRelegatedAnimation, 0
    cseg_936C0();                           // call cseg_936C0
    SaveSelectedTeams();                    // call SaveSelectedTeams
    *(word *)&g_memByte[317174] = 1;        // mov dseg_10E848, 1
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_91470;                    // jz short cseg_91470

    {
        byte src = g_memByte[91720];
        int8_t dstSigned = src;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr selTeamNumber, 50h
    if (!flags.zero)
        goto cseg_9146B;                    // jnz short cseg_9146B

    cseg_94E85();                           // call cseg_94E85

cseg_9146B:;
    cseg_95298();                           // call cseg_95298

cseg_91470:;
    cseg_92D55();                           // call cseg_92D55
    cseg_9307A();                           // call cseg_9307A
    cseg_9339D();                           // call cseg_9339D
    *(word *)&g_memByte[36606] = 0;         // mov careerFileBuffer, 0
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_914A7;                    // jnz short cseg_914A7

    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    cseg_9153F();                           // call cseg_9153F
    cseg_93974();                           // call cseg_93974

cseg_914A7:;
    A6 = 36267;                             // mov A6, offset dseg_C943A

cseg_914B1:;
    esi = A6;                               // mov esi, A6
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A6)++;                    // inc A6
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 255;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, 0FFh
    if (flags.zero)
        goto cseg_914F1;                    // jz short cseg_914F1

    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_914E5;                    // jnz short cseg_914E5

    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        goto cseg_914B1;                    // jz short cseg_914B1

cseg_914E5:;
    cseg_9153F();                           // call cseg_9153F
    cseg_93974();                           // call cseg_93974
    goto cseg_914B1;                        // jmp short cseg_914B1

cseg_914F1:;
    {
        word src = *(word *)&g_memByte[36606];
        int16_t dstSigned = src;
        int16_t srcSigned = 80;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerFileBuffer, 50h
    if (!flags.zero)
        goto l_fatal_error;                 // jnz short @@fatal_error

    cseg_92BBF();                           // call cseg_92BBF
    *(word *)&g_memByte[317174] = 0;        // mov dseg_10E848, 0
    RestoreSelectedTeams();                 // call RestoreSelectedTeams
    {
        word src = *(word *)&g_memByte[529844];
        int16_t dstSigned = src;
        int16_t srcSigned = 16;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_180784, 10h
    if (!flags.zero)
        goto l_fatal_error;                 // jnz short @@fatal_error

    {
        word src = *(word *)&g_memByte[529846];
        int16_t dstSigned = src;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_180786, 20h
    if (!flags.zero)
        goto l_fatal_error;                 // jnz short @@fatal_error

    {
        word src = *(word *)&g_memByte[529848];
        int16_t dstSigned = src;
        int16_t srcSigned = 32;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_180788, 20h
    if (!flags.zero)
        goto l_fatal_error;                 // jnz short @@fatal_error

    {
        word src = *(word *)&g_memByte[36606];
        int16_t dstSigned = src;
        int16_t srcSigned = 80;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp careerFileBuffer, CN_EUROPE
    if (!flags.zero)
        goto l_fatal_error;                 // jnz short @@fatal_error

    cseg_3934F();                           // call cseg_3934F
    return;                                 // retn

l_fatal_error:;
    debugBreak();                           // int 3

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_9153F()
{
    al = D0;                                // mov al, byte ptr D0
    g_memByte[529842] = al;                 // mov dseg_180782, al
    *(word *)&g_memByte[529757] = 65535;    // mov dseg_18072D, 0FFFFh
    A5 = 33933;                             // mov A5, offset competitionsTable
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A5 = eax;                               // mov A5, eax
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A5 = res;
    }                                       // add A5, 4
    A4 = eax;                               // mov A4, eax
    cseg_91D4D();                           // call cseg_91D4D
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 4
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 4
    A4 = eax;                               // mov A4, eax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, 0FFFFFFFFh
    if (flags.zero)
        goto cseg_915E6;                    // jz short cseg_915E6

    cseg_91857();                           // call cseg_91857
    esi = A5;                               // mov esi, A5
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A5 = res;
    }                                       // add A5, 4
    A4 = eax;                               // mov A4, eax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, 0FFFFFFFFh
    if (flags.zero)
        goto cseg_915E6;                    // jz short cseg_915E6

    cseg_91AD0();                           // call cseg_91AD0

cseg_915E6:;
    cseg_9487A();                           // call cseg_9487A
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_16()
{
}

// =============== S U B R O U T I N E =======================================
//
void cseg_915ED()
{
    nullsub_16();                           // call nullsub_16
    eax = A4;                               // mov eax, A4
    A0 = eax;                               // mov A0, eax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_3ABB2();                           // call cseg_3ABB2
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_916C2()
{
    nullsub_16();                           // call nullsub_16
    eax = A4;                               // mov eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_3ACAB();                           // call cseg_3ACAB
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_9178B()
{
    nullsub_16();                           // call nullsub_16
    eax = A4;                               // mov eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_3ADAE();                           // call cseg_3ADAE
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_91854()
{

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_91857()
{
    esi = A4;                               // mov esi, A4
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 1
    if (!flags.zero)
        { cseg_91854(); return; }           // jnz short cseg_91854

    eax = *(dword *)&g_memByte[99872];      // mov eax, dseg_D8CAE
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (!flags.zero)
        goto cseg_91A11;                    // jnz cseg_91A11

    RestoreSelectedTeams();                 // call RestoreSelectedTeams
    cseg_8B6CB();                           // call cseg_8B6CB
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_45B51();                           // call cseg_45B51
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_928CC();                           // call cseg_928CC
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    SaveSelectedTeams();                    // call SaveSelectedTeams
    return;                                 // retn

cseg_91A11:;
    cseg_916C2();                           // call cseg_916C2
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_928CC();                           // call cseg_928CC
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_91AD0()
{
    esi = A4;                               // mov esi, A4
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 1
    if (!flags.zero)
        { cseg_91854(); return; }           // jnz cseg_91854

    eax = *(dword *)&g_memByte[99876];      // mov eax, dseg_D8CB2
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (!flags.zero)
        goto cseg_91C8E;                    // jnz cseg_91C8E

    RestoreSelectedTeams();                 // call RestoreSelectedTeams
    cseg_8B6E6();                           // call cseg_8B6E6
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_45B51();                           // call cseg_45B51
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_92A63();                           // call cseg_92A63
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    SaveSelectedTeams();                    // call SaveSelectedTeams
    return;                                 // retn

cseg_91C8E:;
    cseg_916C2();                           // call cseg_916C2
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_92A63();                           // call cseg_92A63
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================
//
void cseg_91D4D()
{
    esi = A4;                               // mov esi, A4
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 0
    if (flags.zero)
        goto cseg_91E68;                    // jz cseg_91E68

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 2
    if (!flags.zero)
        { cseg_91854(); return; }           // jnz cseg_91854

    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (!flags.zero)
        goto cseg_91E62;                    // jnz cseg_91E62

    RestoreSelectedTeams();                 // call RestoreSelectedTeams
    cseg_8B6B0();                           // call cseg_8B6B0
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_89B5C();                           // call cseg_89B5C
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    SaveSelectedTeams();                    // call SaveSelectedTeams
    return;                                 // retn

cseg_91E62:;
    cseg_9178B();                           // call cseg_9178B
    return;                                 // retn

cseg_91E68:;
    A3 = 529874;                            // mov A3, offset dseg_1807A2
    *(word *)&D7 = 0;                       // mov word ptr D7, 0

cseg_91E7B:;
    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (!flags.zero)
        goto cseg_9204F;                    // jnz cseg_9204F

    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D7, ax
    if (!flags.zero)
        goto cseg_9204F;                    // jnz cseg_9204F

    RestoreSelectedTeams();                 // call RestoreSelectedTeams
    cseg_8B6B0();                           // call cseg_8B6B0
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ShowDiyLeaguesTournamentMenu();         // call ShowDiyLeaguesTournamentMenu
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_92045;                    // jnz cseg_92045

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_927A2();                           // call cseg_927A2
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

cseg_92045:;
    SaveSelectedTeams();                    // call SaveSelectedTeams
    goto cseg_9211C;                        // jmp cseg_9211C

cseg_9204F:;
    cseg_915ED();                           // call cseg_915ED
    ax = D7;                                // mov ax, word ptr D7
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_9211C;                    // jnz cseg_9211C

    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_927A2();                           // call cseg_927A2
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

cseg_9211C:;
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_93FD8();                           // call cseg_93FD8
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    cseg_9221F();                           // call cseg_9221F
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 9, 1);      // mov al, [esi+9]
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, al
    if (!flags.zero)
        goto cseg_91E7B;                    // jnz cseg_91E7B

    *(word *)&D7 = 0;                       // mov word ptr D7, 0

cseg_92200:;
    cseg_9228D();                           // call cseg_9228D
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D7 = res;
    }                                       // add word ptr D7, 1
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 9, 1);      // mov al, [esi+9]
    {
        int8_t dstSigned = *(byte *)&D7;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D7, al
    if (!flags.zero)
        goto cseg_92200;                    // jnz short cseg_92200
}

// =============== S U B R O U T I N E =======================================
//
void cseg_9221F()
{
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 85, 2);     // mov ax, [esi+55h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = (word)readMemory(esi + 89, 2);     // mov ax, [esi+59h]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, ax
    if (flags.zero)
        return;                             // jz short cseg_9228C

    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 429;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 1ADh
    A0 = eax;                               // mov A0, eax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1

cseg_92263:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A3 = res;
    }                                       // add A3, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_92263;                    // jns short cseg_92263
}

// =============== S U B R O U T I N E =======================================
//
void cseg_9228D()
{
    ax = D7;                                // mov ax, word ptr D7
    bx = 6;                                 // mov bx, 6
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A4;                               // mov eax, A4
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A2 = eax;                               // mov A2, eax
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 18, 1);     // mov al, [esi+12h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        return;                             // jz cseg_925C8

    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D1 = res;
    }                                       // add word ptr D1, 1
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi + 9, 1);      // mov al, [esi+9]
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto cseg_92327;                    // jz short cseg_92327

    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 24, 1);     // mov al, [esi+18h]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = 6;
        byte res = dstSigned + srcSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, 6
    al = D1;                                // mov al, byte ptr D1
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (flags.zero)
        return;                             // jz cseg_925C8

cseg_92327:;
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 18;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 12h
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A2 = eax;                               // mov A2, eax
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 4
    A1 = eax;                               // mov A1, eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 4
    ax = *(word *)&g_memByte[91344];        // mov ax, youreSacked
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_924A9;                    // jnz cseg_924A9

    eax = *(dword *)&g_memByte[99884];      // mov eax, dseg_D8CBA
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A1, eax
    if (!flags.zero)
        goto cseg_924A9;                    // jnz cseg_924A9

    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 10, 1);     // mov al, [esi+0Ah]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A2;                               // mov eax, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A2 = eax;                               // mov A2, eax
    RestoreSelectedTeams();                 // call RestoreSelectedTeams
    A0 = 103953;                            // mov A0, offset dseg_D9C9F
    cseg_8B71C();                           // call cseg_8B71C
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_45B51();                           // call cseg_45B51
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    cseg_925C9();                           // call cseg_925C9
    SaveSelectedTeams();                    // call SaveSelectedTeams
    return;                                 // retn

cseg_924A9:;
    push(*(dword *)&g_memByte[91720]);      // push small [selTeamNumber]
    al = g_memByte[92802];                  // mov al, careerTeam+4
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    push(D0);                               // push small [word ptr D0]
    *(word *)&g_memByte[91720] = -1;        // mov selTeamNumber, -1
    g_memByte[92802] = 1;                   // mov careerTeam+4, 1
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        { cseg_91854(); return; }           // jz cseg_91854

    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    al = (byte)readMemory(esi + 10, 1);     // mov al, [esi+0Ah]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_92529:;
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A2 = res;
    }                                       // add A2, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    A3 = 529874;                            // mov A3, offset dseg_1807A2
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A0 = res;
    }                                       // add A0, 2
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_92529;                    // jns short cseg_92529

    eax = A1;                               // mov eax, A1
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A1 = eax;                               // mov A1, eax
    push(A1);                               // push A1
    cseg_916C2();                           // call cseg_916C2
    pop(A1);                                // pop A1
    eax = A1;                               // mov eax, A1
    {
        dword tmp = A4;
        A4 = eax;
        eax = tmp;
    }                                       // xchg eax, A4
    A1 = eax;                               // mov A1, eax
    cseg_925C9();                           // call cseg_925C9
    {
        int32_t val = stack[stackTop++];
        *(word *)&D0 = val;
    }                                       // pop small [word ptr D0]
    al = D0;                                // mov al, byte ptr D0
    g_memByte[92802] = al;                  // mov careerTeam+4, al
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[91720] = val;
    }                                       // pop small [selTeamNumber]
}

// =============== S U B R O U T I N E =======================================
//
void cseg_925C9()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2ACAE();                           // call cseg_2ACAE
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    A3 = 353800;                            // mov A3, offset leaguesTableCopy
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A1 = eax;                               // mov A1, eax

cseg_926BD:;
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A1)++;                    // inc A1
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D3 = al;                      // mov byte ptr D3, al
    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.zero)
        goto cseg_92775;                    // jz short cseg_92775

    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    A0 = 319232;                            // mov A0, offset dseg_10F0F6
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    al = D3;                                // mov al, byte ptr D3
    esi = A3;                               // mov esi, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        byte src = (byte)readMemory(esi + ebx, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + ebx, 1, src);
    }                                       // add [esi+ebx], al
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto cseg_92775;                    // jnz short cseg_92775

    flags.carry = false;
    flags.sign = (al & 0x80) != 0;
    flags.zero = al == 0;                   // or al, al
    if (flags.sign)
        goto cseg_9276C;                    // js short cseg_9276C

    *(word *)&g_memByte[91732] = 1;         // mov playRelegatedAnimation, 1
    goto cseg_92775;                        // jmp short cseg_92775

cseg_9276C:;
    *(word *)&g_memByte[91730] = 1;         // mov playPromotedAnimation, 1

cseg_92775:;
    ax = *(word *)&g_memByte[318692];       // mov ax, diyLeagueNumTeams
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A2;                               // mov eax, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, ebx
    A2 = eax;                               // mov A2, eax
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_926BD;                    // jns cseg_926BD
}

// =============== S U B R O U T I N E =======================================
//
void cseg_927A2()
{
    A1 = 529906;                            // mov A1, offset dseg_1807C2
    A3 = 529733;                            // mov A3, offset dseg_180715
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 109;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 6Dh
    A4 = eax;                               // mov A4, eax
    *(word *)&D2 = 9;                       // mov word ptr D2, 9
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, ax
    if (flags.carry || flags.zero)
        goto cseg_927F9;                    // jbe short cseg_927F9

    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D2 = ax;                      // mov word ptr D2, ax

cseg_927F9:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_92801:;
    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 2
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 18;                                // mov bx, 12h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 301;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 12Dh
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A3 = res;
    }                                       // add A3, 2
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    *(word *)&D0 = 341;                     // mov word ptr D0, 155h

cseg_92895:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_92895;                    // jns short cseg_92895

    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_92801;                    // jns cseg_92801
}

// =============== S U B R O U T I N E =======================================
//
void cseg_928CC()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2ACAE();                           // call cseg_2ACAE
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    A1 = 536062;                            // mov A1, offset dseg_181FCE
    A3 = 529751;                            // mov A3, offset dseg_180727
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 717;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2CDh
    A4 = eax;                               // mov A4, eax
    *(word *)&D2 = 2;                       // mov word ptr D2, 2

cseg_929BB:;
    esi = A4;                               // mov esi, A4
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A4)++;                    // inc A4
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 24Dh
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A3 = res;
    }                                       // add A3, 2
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    *(word *)&D0 = 341;                     // mov word ptr D0, 155h

cseg_92A2C:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_92A2C;                    // jns short cseg_92A2C

    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_929BB;                    // jns cseg_929BB
}

// =============== S U B R O U T I N E =======================================
//
void cseg_92A63()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2ACAE();                           // call cseg_2ACAE
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 717, 1);    // mov al, [esi+2CDh]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 24Dh
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[529757] = ax;       // mov dseg_18072D, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    A1 = 538114;                            // mov A1, offset dseg_1827D2
    *(word *)&D0 = 341;                     // mov word ptr D0, 155h

cseg_92B95:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_92B95;                    // jns short cseg_92B95
}

// =============== S U B R O U T I N E =======================================
//
void cseg_92BBF()
{
    ax = *(word *)&g_memByte[529727];       // mov ax, dseg_18070F
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    A3 = 538798;                            // mov A3, offset dseg_182A7E
    eax = *(dword *)&g_memByte[529850];     // mov eax, dseg_18078A
    A2 = eax;                               // mov A2, eax
    ax = *(word *)&g_memByte[529844];       // mov ax, dseg_180784
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    cseg_92C4D();                           // call cseg_92C4D
    ax = *(word *)&g_memByte[529729];       // mov ax, dseg_180711
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    A3 = 539482;                            // mov A3, offset dseg_182D2A
    eax = *(dword *)&g_memByte[529854];     // mov eax, dseg_18078E
    A2 = eax;                               // mov A2, eax
    ax = *(word *)&g_memByte[529846];       // mov ax, dseg_180786
    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    cseg_92C4D();                           // call cseg_92C4D
    ax = *(word *)&g_memByte[529731];       // mov ax, dseg_180713
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    A3 = 540166;                            // mov A3, offset dseg_182FD6
    eax = *(dword *)&g_memByte[529858];     // mov eax, dseg_180792
    A2 = eax;                               // mov A2, eax
    ax = *(word *)&g_memByte[529848];       // mov ax, dseg_180788
    *(word *)&D3 = ax;                      // mov word ptr D3, ax

    cseg_92C4D();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_92C4D()
{
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 0FFFFh
    if (flags.zero)
        return;                             // jz cseg_92D54

    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    {
        word res = *(word *)&D4 >> 8;
        flags.carry = ((word)*(word *)&D4 >> 8) & 1;
        *(word *)&D4 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shr word ptr D4, 8

cseg_92C6F:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D3;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        word res = *(word *)&D1 >> 8;
        *(word *)&D1 = res;
    }                                       // shr word ptr D1, 8
    al = D4;                                // mov al, byte ptr D4
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto cseg_92C6F;                    // jz short cseg_92C6F

    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, 0FFFFh
    if (flags.zero)
        goto cseg_92CE2;                    // jz short cseg_92CE2

    al = g_memByte[91670];                  // mov al, byte ptr teamNoOfferAccepted
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto cseg_92C6F;                    // jz short cseg_92C6F

    goto cseg_92CEF;                        // jmp short cseg_92CEF

cseg_92CE2:;
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (flags.zero)
        goto cseg_92C6F;                    // jz short cseg_92C6F

cseg_92CEF:;
    eax = A2;                               // mov eax, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, ebx
    A2 = eax;                               // mov A2, eax
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D2;                                // mov ax, word ptr D2
    writeMemory(esi, 2, ax);                // mov [esi], ax
    push(*(dword *)&g_memByte[36606]);      // push small [careerFileBuffer]
    cseg_9423A();                           // call cseg_9423A
    eax = A3;                               // mov eax, A3
    A0 = eax;                               // mov A0, eax
    cseg_94193();                           // call cseg_94193
    {
        int32_t val = stack[stackTop++];
        *(word *)&D0 = val;
    }                                       // pop small [word ptr D0]
    ax = *(word *)&g_memByte[36606];        // mov ax, careerFileBuffer
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        return;                             // jz short cseg_92D54

    debugBreak();                           // int 3

cseg_92D52:;
    goto cseg_92D52;                        // jmp short cseg_92D52
}

// =============== S U B R O U T I N E =======================================
//
void cseg_92D55()
{
    A4 = 108070;                            // mov A4, offset euroCupCopy
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (!flags.zero)
        goto cseg_92E59;                    // jnz cseg_92E59

    RestoreSelectedTeams();                 // call RestoreSelectedTeams
    cseg_8B701();                           // call cseg_8B701
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_89B5C();                           // call cseg_89B5C
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    cseg_92F1C();                           // call cseg_92F1C
    SaveSelectedTeams();                    // call SaveSelectedTeams
    return;                                 // retn

cseg_92E59:;
    eax = A4;                               // mov eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_3ADAE();                           // call cseg_3ADAE
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

    cseg_92F1C();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_92F1C()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2ACAE();                           // call cseg_2ACAE
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 717, 1);    // mov al, [esi+2CDh]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 24Dh
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[529727] = ax;       // mov dseg_18070F, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    A1 = 538798;                            // mov A1, offset dseg_182A7E
    *(word *)&D0 = 341;                     // mov word ptr D0, 155h

cseg_93050:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_93050;                    // jns short cseg_93050
}

// =============== S U B R O U T I N E =======================================
//
void cseg_9307A()
{
    A4 = 108149;                            // mov A4, offset cupWinnersCupCopy
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (!flags.zero)
        goto cseg_9317E;                    // jnz cseg_9317E

    RestoreSelectedTeams();                 // call RestoreSelectedTeams
    cseg_8B701();                           // call cseg_8B701
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_45B51();                           // call cseg_45B51
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    cseg_93241();                           // call cseg_93241
    SaveSelectedTeams();                    // call SaveSelectedTeams
    return;                                 // retn

cseg_9317E:;
    eax = A4;                               // mov eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_3ACAB();                           // call cseg_3ACAB
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

    cseg_93241();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93241()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2ACAE();                           // call cseg_2ACAE
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 717, 1);    // mov al, [esi+2CDh]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 24Dh
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[529729] = ax;       // mov dseg_180711, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    A1 = 539482;                            // mov A1, offset dseg_182D2A
    *(word *)&D0 = 341;                     // mov word ptr D0, 155h

cseg_93373:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_93373;                    // jns short cseg_93373
}

// =============== S U B R O U T I N E =======================================
//
void cseg_9339D()
{
    A4 = 108241;                            // mov A4, offset uefaCupCopy
    eax = *(dword *)&g_memByte[99880];      // mov eax, dseg_D8CB6
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (!flags.zero)
        goto cseg_934A1;                    // jnz cseg_934A1

    RestoreSelectedTeams();                 // call RestoreSelectedTeams
    cseg_8B701();                           // call cseg_8B701
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_45B51();                           // call cseg_45B51
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    cseg_93564();                           // call cseg_93564
    SaveSelectedTeams();                    // call SaveSelectedTeams
    return;                                 // retn

cseg_934A1:;
    eax = A4;                               // mov eax, A4
    A0 = eax;                               // mov A0, eax
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_3ACAB();                           // call cseg_3ACAB
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

    cseg_93564();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93564()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_2ACAE();                           // call cseg_2ACAE
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    A2 = 318643;                            // mov A2, offset DIY_competitionStart
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi + 717, 1);    // mov al, [esi+2CDh]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A2;                               // mov eax, A2
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 589;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 24Dh
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)&g_memByte[529731] = ax;       // mov dseg_180713, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    A1 = 540166;                            // mov A1, offset dseg_182FD6
    *(word *)&D0 = 341;                     // mov word ptr D0, 155h

cseg_93696:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_93696;                    // jns short cseg_93696
}

// =============== S U B R O U T I N E =======================================
//
void cseg_936C0()
{
    push(*(dword *)&g_memByte[91720]);      // push small [selTeamNumber]
    push(*(dword *)&g_memByte[91676]);      // push small [isNationalSelector]
    {
        word src = *(word *)&g_memByte[91670];
        int16_t dstSigned = src;
        int16_t srcSigned = -1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp teamNoOfferAccepted, -1
    if (flags.zero)
        goto cseg_93707;                    // jz short cseg_93707

    ax = *(word *)&g_memByte[91670];        // mov ax, teamNoOfferAccepted
    *(word *)&g_memByte[91720] = ax;        // mov selTeamNumber, ax
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 80;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, CN_EUROPE
    if (flags.carry)
        goto cseg_93707;                    // jb short cseg_93707

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 85;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, CN_OCEANIA
    if (!flags.carry && !flags.zero)
        goto cseg_93707;                    // ja short cseg_93707

    g_memByte[91676] = 1;                   // mov byte ptr isNationalSelector, 1

cseg_93707:;
    A0 = 108070;                            // mov A0, offset euroCupCopy
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    *(dword *)&g_memByte[529850] = eax;     // mov dseg_18078A, eax
    *(dword *)&g_memByte[529862] = eax;     // mov dseg_180796, eax
    *(word *)&g_memByte[529844] = 0;        // mov dseg_180784, 0
    A0 = 36333;                             // mov A0, offset dseg_C947C
    A1 = 529759;                            // mov A1, offset dseg_18072F
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A2 = 24755;                             // mov A2, offset countriesTable
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A2 = eax;                               // mov A2, eax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_937D1;                    // jnz short cseg_937D1

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 0
    if (!flags.zero)
        goto cseg_937D1;                    // jnz short cseg_937D1

    *(word *)&D0 = 1;                       // mov word ptr D0, 1

cseg_937D1:;
    cseg_93E36();                           // call cseg_93E36
    A0 = 108149;                            // mov A0, offset cupWinnersCupCopy
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    *(dword *)&g_memByte[529854] = eax;     // mov dseg_18078E, eax
    *(dword *)&g_memByte[529866] = eax;     // mov dseg_18079A, eax
    *(word *)&g_memByte[529846] = 0;        // mov dseg_180786, 0
    A0 = 36412;                             // mov A0, offset dseg_C94CB
    A1 = 529776;                            // mov A1, offset dseg_180740
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A2 = 24755;                             // mov A2, offset countriesTable
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A2 = eax;                               // mov A2, eax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_938A0;                    // jnz short cseg_938A0

    esi = A2;                               // mov esi, A2
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 0
    if (!flags.zero)
        goto cseg_938A0;                    // jnz short cseg_938A0

    *(word *)&D0 = 1;                       // mov word ptr D0, 1

cseg_938A0:;
    cseg_93E36();                           // call cseg_93E36
    A0 = 108241;                            // mov A0, offset uefaCupCopy
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    *(dword *)&g_memByte[529858] = eax;     // mov dseg_180792, eax
    *(dword *)&g_memByte[529870] = eax;     // mov dseg_18079E, eax
    *(word *)&g_memByte[529848] = 0;        // mov dseg_180788, 0
    eax = *(dword *)&g_memByte[36491];      // mov eax, dseg_C951A
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_9394C;                    // jnz short cseg_9394C

    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D1 = al;                      // mov byte ptr D1, al

cseg_93921:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 255;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 0FFh
    if (flags.zero)
        goto cseg_9394C;                    // jz short cseg_9394C

    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D1, al
    if (!flags.zero)
        goto cseg_93921;                    // jnz short cseg_93921

    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 1
    goto cseg_93921;                        // jmp short cseg_93921

cseg_9394C:;
    A0 = 36491;                             // mov A0, offset dseg_C951A
    A1 = 529809;                            // mov A1, offset dseg_180761
    cseg_93E36();                           // call cseg_93E36
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[91676] = val;
    }                                       // pop small [isNationalSelector]
    {
        int32_t val = stack[stackTop++];
        *(word *)&g_memByte[91720] = val;
    }                                       // pop small [selTeamNumber]
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93974()
{
    al = g_memByte[529842];                 // mov al, dseg_180782
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    A0 = 24755;                             // mov A0, offset countriesTable
    esi = A0;                               // mov esi, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    eax = readMemory(esi + ebx, 4);         // mov eax, [esi+ebx]
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 0
    if (!flags.zero)
        return;                             // jnz short cseg_939C8

    cseg_939C9();                           // call cseg_939C9
    cseg_939FE();                           // call cseg_939FE
    cseg_93A60();                           // call cseg_93A60
}

// =============== S U B R O U T I N E =======================================
//
void cseg_939C9()
{
    A0 = 529759;                            // mov A0, offset dseg_18072F
    cseg_93B30();                           // call cseg_93B30
    if (!flags.zero)
        return;                             // jnz short cseg_939FD

    A5 = 529906;                            // mov A5, offset dseg_1807C2
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_93BCE();                           // call cseg_93BCE
    cseg_93C19();                           // call cseg_93C19
}

// =============== S U B R O U T I N E =======================================
//
void cseg_939FE()
{
    A0 = 529776;                            // mov A0, offset dseg_180740
    cseg_93B30();                           // call cseg_93B30
    if (!flags.zero)
        return;                             // jnz short cseg_93A5F

    A5 = 535378;                            // mov A5, offset dseg_181D22

cseg_93A19:;
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2ACh
    A5 = eax;                               // mov A5, eax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[529733];       // mov ax, dseg_180715
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_93A19;                    // jz short cseg_93A19

    ax = *(word *)&g_memByte[529727];       // mov ax, dseg_18070F
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_93A19;                    // jz short cseg_93A19

    cseg_93BCE();                           // call cseg_93BCE
    cseg_93C3C();                           // call cseg_93C3C
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93A60()
{
    A5 = 538114;                            // mov A5, offset dseg_1827D2
    {
        word src = *(word *)&g_memByte[529757];
        int16_t dstSigned = src;
        int16_t srcSigned = 65535;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_18072D, 0FFFFh
    if (!flags.zero)
        goto cseg_93A7E;                    // jnz short cseg_93A7E

    A5 = 530590;                            // mov A5, offset dseg_180A6E

cseg_93A7E:;
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = -684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        eax = res;
    }                                       // add eax, 0FFFFFD54h
    A5 = eax;                               // mov A5, eax

cseg_93A8D:;
    A0 = 529809;                            // mov A0, offset dseg_180761
    cseg_93B30();                           // call cseg_93B30
    if (!flags.zero)
        return;                             // jnz cseg_93B2F

cseg_93AA2:;
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2ACh
    A5 = eax;                               // mov A5, eax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 538798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A5, offset dseg_182A7E
    if (!flags.zero)
        goto cseg_93AC7;                    // jnz short cseg_93AC7

    A5 = 530590;                            // mov A5, offset dseg_180A6E

cseg_93AC7:;
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[529733];       // mov ax, dseg_180715
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_93AA2;                    // jz short cseg_93AA2

    ax = *(word *)&g_memByte[529751];       // mov ax, dseg_180727
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_93AA2;                    // jz short cseg_93AA2

    ax = *(word *)&g_memByte[529727];       // mov ax, dseg_18070F
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_93AA2;                    // jz short cseg_93AA2

    ax = *(word *)&g_memByte[529729];       // mov ax, dseg_180711
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_93AA2;                    // jz short cseg_93AA2

    cseg_93B9C();                           // call cseg_93B9C
    if (flags.zero)
        goto cseg_93AA2;                    // jz short cseg_93AA2

    cseg_93BB5();                           // call cseg_93BB5
    if (flags.zero)
        goto cseg_93AA2;                    // jz short cseg_93AA2

    cseg_93BCE();                           // call cseg_93BCE
    cseg_93C5F();                           // call cseg_93C5F
    goto cseg_93A8D;                        // jmp cseg_93A8D
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93B30()
{
    al = g_memByte[529842];                 // mov al, dseg_180782
    *(byte *)&D0 = al;                      // mov byte ptr D0, al

cseg_93B3A:;
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 255;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi], 0FFh
    if (flags.zero)
        goto cseg_93B72;                    // jz short cseg_93B72

    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D0, al
    if (!flags.zero)
        goto cseg_93B3A;                    // jnz short cseg_93B3A

    esi = A0;                               // mov esi, A0
    writeMemory(esi + -1, 1, 254);          // mov byte ptr [esi-1], 0FEh
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

cseg_93B72:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93B9C()
{
    A1 = 529854;                            // mov A1, offset dseg_18078E
    A3 = 529846;                            // mov A3, offset dseg_180786
    cseg_93D0B();                           // jmp cseg_93D0B
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93BB5()
{
    A1 = 529858;                            // mov A1, offset dseg_180792
    A3 = 529848;                            // mov A3, offset dseg_180788
    cseg_93D0B();                           // jmp cseg_93D0B
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93BCE()
{
    ax = *(word *)&g_memByte[529727];       // mov ax, dseg_18070F
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_93BE7;                    // jnz short cseg_93BE7

    *(word *)&g_memByte[529727] = 65535;    // mov dseg_18070F, 0FFFFh
    return;                                 // retn

cseg_93BE7:;
    ax = *(word *)&g_memByte[529729];       // mov ax, dseg_180711
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_93C00;                    // jnz short cseg_93C00

    *(word *)&g_memByte[529729] = 65535;    // mov dseg_180711, 0FFFFh
    return;                                 // retn

cseg_93C00:;
    ax = *(word *)&g_memByte[529731];       // mov ax, dseg_180713
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        return;                             // jnz short cseg_93C18

    *(word *)&g_memByte[529731] = 65535;    // mov dseg_180713, 0FFFFh
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93C19()
{
    eax = A5;                               // mov eax, A5
    A0 = eax;                               // mov A0, eax
    A1 = 529862;                            // mov A1, offset dseg_180796
    A3 = 529844;                            // mov A3, offset dseg_180784
    cseg_93D67();                           // jmp cseg_93D67
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93C3C()
{
    eax = A5;                               // mov eax, A5
    A0 = eax;                               // mov A0, eax
    A1 = 529866;                            // mov A1, offset dseg_18079A
    A3 = 529846;                            // mov A3, offset dseg_180786
    cseg_93D67();                           // jmp cseg_93D67
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93C5F()
{
    eax = A5;                               // mov eax, A5
    A0 = eax;                               // mov A0, eax
    flags.carry = false;
    flags.sign = (eax & 0x80000000) != 0;
    flags.zero = eax == 0;                  // or eax, eax
    A1 = 529870;                            // mov A1, offset dseg_18079E
    A3 = 529848;                            // mov A3, offset dseg_180788
    { cseg_93D67(); return; }               // jmp cseg_93D67

    A1 = 529850;                            // mov A1, offset dseg_18078A
    A2 = 529862;                            // mov A2, offset dseg_180796
    A3 = 529844;                            // mov A3, offset dseg_180784
    { cseg_93DAA(); return; }               // jmp cseg_93DAA

    A1 = 529854;                            // mov A1, offset dseg_18078E
    A2 = 529866;                            // mov A2, offset dseg_18079A
    A3 = 529846;                            // mov A3, offset dseg_180786
    { cseg_93DAA(); return; }               // jmp cseg_93DAA

    A1 = 529858;                            // mov A1, offset dseg_180792
    A2 = 529870;                            // mov A2, offset dseg_18079E
    A3 = 529848;                            // mov A3, offset dseg_180788
    cseg_93DAA();                           // jmp cseg_93DAA
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93D0B()
{
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A0 = eax;                               // mov A0, eax
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_93D56;                    // jz short cseg_93D56

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_93D34:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        return;                             // jz short cseg_93D66

    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_93D34;                    // jns short cseg_93D34

cseg_93D56:;
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93D67()
{
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A4 = eax;                               // mov A4, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    esi = A4;                               // mov esi, A4
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 2
    eax = A4;                               // mov eax, A4
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 4, eax);               // mov [esi], eax
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        writeMemory(esi, 2, src);
    }                                       // add word ptr [esi], 1
    cseg_94193();                           // call cseg_94193
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93DAA()
{
    esi = A1;                               // mov esi, A1
    eax = readMemory(esi, 4);               // mov eax, [esi]
    A4 = eax;                               // mov A4, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax

cseg_93DC6:;
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (flags.zero)
        return;                             // jz short cseg_93E35

    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A4 = res;
    }                                       // add A4, 2
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (!flags.zero)
        goto cseg_93DC6;                    // jnz short cseg_93DC6

    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi, 2, src);
    }                                       // sub word ptr [esi], 1
    esi = A2;                               // mov esi, A2
    {
        dword src = readMemory(esi, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = 2;
        dword res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi, 4, src);
    }                                       // sub dword ptr [esi], 2
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned - srcSigned;
        A4 = res;
    }                                       // sub A4, 2

cseg_93E09:;
    esi = A2;                               // mov esi, A2
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (flags.zero)
        return;                             // jz short cseg_93E35

    esi = A4;                               // mov esi, A4
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A4 = res;
    }                                       // add A4, 2
    goto cseg_93E09;                        // jmp short cseg_93E09
}

// =============== S U B R O U T I N E =======================================

// in:
//      A0 -> pointer table
//      A1 -> table
//
void cseg_93E36()
{
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    al = g_memByte[91720];                  // mov al, byte ptr selTeamNumber
    *(byte *)&D6 = al;                      // mov byte ptr D6, al
    *(word *)&D5 = 0;                       // mov word ptr D5, 0

cseg_93E55:;
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    A2 = eax;                               // mov A2, eax
    {
        int32_t dstSigned = A2;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A2, -1
    if (flags.zero)
        goto cseg_93F98;                    // jz cseg_93F98

    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    *(word *)&D4 = ax;                      // mov word ptr D4, ax
    ax = D2;                                // mov ax, word ptr D2
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D4, ax
    if (flags.zero)
        goto cseg_93F45;                    // jz cseg_93F45

    *(word *)&D3 = ax;                      // mov word ptr D3, ax
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, 1

cseg_93ECB:;
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D3;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D3
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        flags.carry = ((word)*(word *)&D0 >> 8) & 1;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ebx = *(word *)&D2;                     // movzx ebx, word ptr D2
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    al = D1;                                // mov al, byte ptr D1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    writeMemory(esi + ebx, 1, al);          // mov [esi+ebx], al
    (*(int16_t *)&D2)--;
    flags.sign = (*(int16_t *)&D2 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D2 == 0;      // dec word ptr D2
    if (!flags.sign)
        goto cseg_93ECB;                    // jns short cseg_93ECB

cseg_93F45:;
    {
        int16_t dstSigned = *(word *)&D4;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D4 = res;
    }                                       // sub word ptr D4, 1

cseg_93F4D:;
    esi = A2;                               // mov esi, A2
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A2)++;                    // inc A2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int32_t *)&A1)++;                    // inc A1
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + -1, 1);     // mov al, [esi-1]
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D6, al
    if (!flags.zero)
        goto cseg_93F8A;                    // jnz short cseg_93F8A

    {
        int16_t dstSigned = *(word *)&D5;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        *(word *)&D5 = res;
    }                                       // add word ptr D5, 1
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_93F8A:;
    (*(int16_t *)&D4)--;
    flags.sign = (*(int16_t *)&D4 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D4 == 0;      // dec word ptr D4
    if (!flags.sign)
        goto cseg_93F4D;                    // jns short cseg_93F4D

    goto cseg_93E55;                        // jmp cseg_93E55

cseg_93F98:;
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 1, 255);               // mov byte ptr [esi], 0FFh
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1
    if (flags.sign)
        return;                             // js short cseg_93FD7

cseg_93FAB:;
    (*(int32_t *)&A1)--;                    // dec A1
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    {
        int8_t dstSigned = *(byte *)&D6;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr D6, al
    if (flags.zero)
        goto cseg_93FAB;                    // jz short cseg_93FAB

    al = D6;                                // mov al, byte ptr D6
    writeMemory(esi, 1, al);                // mov [esi], al
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_93FAB;                    // jns short cseg_93FAB
}

// =============== S U B R O U T I N E =======================================
//
void cseg_93FD8()
{
    A3 = 318643;                            // mov A3, offset DIY_competitionStart
    esi = A3;                               // mov esi, A3
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi], 0
    if (!flags.zero)
        return;                             // jnz cseg_94192

    A2 = 353800;                            // mov A2, offset leaguesTableCopy
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_940B2;                    // jz cseg_940B2

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 109;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 6Dh
    A1 = eax;                               // mov A1, eax

cseg_9402A:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A3;                               // mov eax, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+2B3h]
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        byte src = (byte)readMemory(esi + ebx, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        src = res;
        writeMemory(esi + ebx, 1, src);
    }                                       // sub byte ptr [esi+ebx], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto cseg_940A5;                    // jnz short cseg_940A5

    *(word *)&g_memByte[91730] = 1;         // mov playPromotedAnimation, 1

cseg_940A5:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_9402A;                    // jns cseg_9402A

cseg_940B2:;
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 87, 2);     // mov ax, [esi+57h]
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_94192

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    eax = A3;                               // mov eax, A3
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 109;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 6Dh
    A1 = eax;                               // mov A1, eax
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+31h]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    eax = A1;                               // mov eax, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax

cseg_9410A:;
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned - srcSigned;
        A1 = res;
    }                                       // sub A1, 2
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    eax = A3;                               // mov eax, A3
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A0;                               // mov esi, A0
    eax = readMemory(esi + 691, 4);         // mov eax, [esi+2B3h]
    A0 = eax;                               // mov A0, eax
    eax = *(dword *)&g_memByte[131738];     // mov eax, selTeamsPtr
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, eax
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+2]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        byte src = (byte)readMemory(esi + ebx, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned + srcSigned;
        src = res;
        writeMemory(esi + ebx, 1, src);
    }                                       // add byte ptr [esi+ebx], 1
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A0, offset careerTeam
    if (!flags.zero)
        goto cseg_94185;                    // jnz short cseg_94185

    *(word *)&g_memByte[91732] = 1;         // mov playRelegatedAnimation, 1

cseg_94185:;
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_9410A;                    // jns cseg_9410A
}

// =============== S U B R O U T I N E =======================================
//
void cseg_94193()
{
    push(D0);                               // push D0
    push(A0);                               // push A0
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    SearchTeamInTmdFile();                  // call SearchTeamInTmdFile
    pop(A0);                                // pop A0
    pop(D0);                                // pop D0
    if (!flags.zero)
        goto cseg_941C4;                    // jnz short cseg_941C4

    debugBreak();                           // int 3

cseg_941C2:;
    goto cseg_941C2;                        // jmp short cseg_941C2

cseg_941C4:;
    ax = *(word *)&g_memByte[36606];        // mov ax, careerFileBuffer
    bx = 684;                               // mov bx, 2ACh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    A1 = 36608;                             // mov A1, offset tmdFileBuffer
    eax = D1;                               // mov eax, D1
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, eax
    *(word *)&D1 = 341;                     // mov word ptr D1, 155h

cseg_94208:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    esi = A1;                               // mov esi, A1
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A1 = res;
    }                                       // add A1, 2
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_94208;                    // jns short cseg_94208

    {
        word src = *(word *)&g_memByte[36606];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[36606] = src;
    }                                       // add careerFileBuffer, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_9423A()
{
    ax = *(word *)&g_memByte[36606];        // mov ax, careerFileBuffer
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_942F1

    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    A0 = 36608;                             // mov A0, offset tmdFileBuffer

cseg_94261:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, ax
    if (flags.zero)
        goto cseg_9428C;                    // jz short cseg_9428C

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        eax = res;
    }                                       // add eax, 2ACh
    A0 = eax;                               // mov A0, eax
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_94261;                    // jns short cseg_94261

    return;                                 // retn

cseg_9428C:;
    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_942E9;                    // jz short cseg_942E9

    eax = A0;                               // mov eax, A0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 684;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2ACh
    A1 = eax;                               // mov A1, eax
    ax = D1;                                // mov ax, word ptr D1
    bx = 342;                               // mov bx, 156h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx

cseg_942C0:;
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A1;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A1 = res;
    }                                       // add A1, 2
    esi = A0;                               // mov esi, A0
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = 1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        D1 = res;
    }                                       // sub D1, 1
    if (!flags.zero)
        goto cseg_942C0;                    // jnz short cseg_942C0

cseg_942E9:;
    {
        word src = *(word *)&g_memByte[36606];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(word *)&g_memByte[36606] = src;
    }                                       // sub careerFileBuffer, 1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_942F2()
{
    *(word *)&g_memByte[92300] = 0;         // mov numPlayersOnTransferMarket, 0
    {
        word src = *(word *)&g_memByte[92018];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        src = res;
        *(word *)&g_memByte[92018] = src;
    }                                       // add dseg_D6E00, 1
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    ax = *(word *)&g_memByte[91676];        // mov ax, isNationalSelector
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        goto cseg_94337;                    // jnz short cseg_94337

    push(D1);                               // push D1
    push(D7);                               // push D7
    cseg_5A6A1();                           // call cseg_5A6A1
    pop(D7);                                // pop D7
    pop(D1);                                // pop D1

cseg_94337:;
    {
        int32_t dstSigned = D1;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp D1, -1
    if (flags.zero)
        goto cseg_943E9;                    // jz cseg_943E9

    ax = D1;                                // mov ax, word ptr D1
    dx = *(word *)((byte *)&D1 + 2);        // mov dx, word ptr D1+2
    bx = 1000;                              // mov bx, 1000
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 25;                                // mov bx, 25
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 80;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 50h
    ax = D1;                                // mov ax, word ptr D1
    tmp = ax * *(word *)&D0;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D0
    bx = 100;                               // mov bx, 100
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    bx = 1000;                              // mov bx, 1000
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    *(word *)((byte *)&D1 + 2) = dx;        // mov word ptr D1+2, dx

cseg_943E9:;
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    cseg_5DB56();                           // jmp cseg_5DB56
}

// =============== S U B R O U T I N E =======================================
//
void cseg_943FA()
{
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    VerifyTeamLoaded();                     // call VerifyTeamLoaded
    GetAveragePlayerPrice();                // call GetAveragePlayerPrice
    GetTeamValueBase();                     // call GetTeamValueBase
    ax = D0;                                // mov ax, word ptr D0
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    A6 = 126568;                            // mov A6, offset competitionFileBuffer
    ax = *(word *)&g_memByte[91720];        // mov ax, selTeamNumber
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    FindTeamInDIY();                        // call FindTeamInDIY
    ax = *(word *)&g_memByte[91586];        // mov ax, dseg_D6C50
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, ax
    ax = D0;                                // mov ax, word ptr D0
    bx = 100;                               // mov bx, 100
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    bx = *(word *)&g_memByte[126617];       // mov bx, numDiyTeams
    {
        int32_t dividend = ((int16_t)dx << 16) | (int16_t)ax;
        int16_t quot = (int16_t)(dividend / (int16_t)bx);
        int16_t rem = (int16_t)(dividend % (int16_t)bx);
        ax = quot;
        dx = rem;
    }                                       // idiv bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t res = *(int16_t *)&D0 >> 1;
        *(int16_t *)&D0 = res;
    }                                       // sar word ptr D0, 1
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 100;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 64h
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D2;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D2
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    SWOS::Rand2();                          // call Rand2
    ax = D0;                                // mov ax, word ptr D0
    bx = 20;                                // mov bx, 14h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 >> 8;
        *(word *)&D0 = res;
    }                                       // shr word ptr D0, 8
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 90;
        word res = dstSigned + srcSigned;
        *(word *)&D0 = res;
    }                                       // add word ptr D0, 5Ah
    ax = D0;                                // mov ax, word ptr D0
    tmp = ax * *(word *)&D1;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul word ptr D1
    bx = 100;                               // mov bx, 64h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    bx = 1000;                              // mov bx, 3E8h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    *(dword *)&g_memByte[91382] = eax;      // mov startingBalance, eax
    ax = *(word *)&g_memByte[91600];        // mov ax, playWinCupAnimation
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_94640;                    // jz cseg_94640

    al = g_memByte[126615];                 // mov al, dseg_DF525
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_94610;                    // jz short cseg_94610

    {
        word src = *(word *)&g_memByte[91726];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6CDC, 1
    if (flags.zero)
        goto cseg_945F4;                    // jz short cseg_945F4

    {
        word src = *(word *)&g_memByte[91726];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6CDC, 2
    if (flags.zero)
        goto cseg_945D8;                    // jz short cseg_945D8

    ax = D0;                                // mov ax, word ptr D0
    bx = 25000;                             // mov bx, 61A8h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    goto cseg_94635;                        // jmp short cseg_94635

cseg_945D8:;
    ax = D0;                                // mov ax, word ptr D0
    bx = 32733;                             // mov bx, 7FDDh
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    goto cseg_94635;                        // jmp short cseg_94635

cseg_945F4:;
    ax = D0;                                // mov ax, word ptr D0
    bx = 46880;                             // mov bx, 0B720h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    goto cseg_94635;                        // jmp short cseg_94635

cseg_94610:;
    ax = D0;                                // mov ax, word ptr D0
    bx = 60872;                             // mov bx, 0EDC8h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        dword src = *(dword *)&g_memByte[91382];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91382] = src;
    }                                       // add startingBalance, eax

cseg_94635:;
    eax = D0;                               // mov eax, D0
    {
        dword src = *(dword *)&g_memByte[91382];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91382] = src;
    }                                       // add startingBalance, eax

cseg_94640:;
    ax = *(word *)&g_memByte[91602];        // mov ax, dseg_D6C60
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_94687;                    // jz short cseg_94687

    al = g_memByte[100011];                 // mov al, dseg_D8D39
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 52944;                             // mov bx, 0CED0h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        dword src = *(dword *)&g_memByte[91382];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91382] = src;
    }                                       // add startingBalance, eax

cseg_94687:;
    ax = *(word *)&g_memByte[91604];        // mov ax, dseg_D6C62
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_946CE;                    // jz short cseg_946CE

    al = g_memByte[102909];                 // mov al, dseg_D988B
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 17649;                             // mov bx, 44F1h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        dword src = *(dword *)&g_memByte[91382];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91382] = src;
    }                                       // add startingBalance, eax

cseg_946CE:;
    ax = *(word *)&g_memByte[91606];        // mov ax, dseg_D6C64
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_94720;                    // jz short cseg_94720

    al = g_memByte[105091];                 // mov al, dseg_DA111
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 62502;                             // mov bx, 0F426h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        dword src = *(dword *)&g_memByte[91382];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91382] = src;
    }                                       // add startingBalance, eax
    {
        dword src = *(dword *)&g_memByte[91382];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91382] = src;
    }                                       // add startingBalance, eax

cseg_94720:;
    ax = *(word *)&g_memByte[91608];        // mov ax, dseg_D6C66
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_94774;                    // jz short cseg_94774

    al = g_memByte[105091];                 // mov al, dseg_DA111
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 31252;                             // mov bx, 7A14h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        dword src = *(dword *)&g_memByte[91382];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91382] = src;
    }                                       // add startingBalance, eax
    {
        dword src = *(dword *)&g_memByte[91382];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91382] = src;
    }                                       // add startingBalance, eax

cseg_94774:;
    ax = *(word *)&g_memByte[91610];        // mov ax, dseg_D6C68
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_947C6;                    // jz short cseg_947C6

    al = g_memByte[105091];                 // mov al, dseg_DA111
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 45456;                             // mov bx, 0B190h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = D0;                               // mov eax, D0
    {
        dword src = *(dword *)&g_memByte[91382];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91382] = src;
    }                                       // add startingBalance, eax
    {
        dword src = *(dword *)&g_memByte[91382];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91382] = src;
    }                                       // add startingBalance, eax

cseg_947C6:;
    ax = *(word *)&g_memByte[91600];        // mov ax, playWinCupAnimation
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (!flags.zero)
        return;                             // jnz cseg_94879

    ax = *(word *)&g_memByte[91730];        // mov ax, playPromotedAnimation
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        return;                             // jz cseg_94879

    al = g_memByte[126615];                 // mov al, dseg_DF525
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    ax = *(word *)&g_memByte[91726];        // mov ax, dseg_D6CDC
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_9486E;                    // jz short cseg_9486E

    {
        word src = *(word *)&g_memByte[91726];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6CDC, 1
    if (flags.zero)
        goto cseg_94852;                    // jz short cseg_94852

    {
        word src = *(word *)&g_memByte[91726];
        int16_t dstSigned = src;
        int16_t srcSigned = 2;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dseg_D6CDC, 2
    if (flags.zero)
        goto cseg_94836;                    // jz short cseg_94836

    ax = D0;                                // mov ax, word ptr D0
    bx = 12500;                             // mov bx, 30D4h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    goto cseg_9486E;                        // jmp short cseg_9486E

cseg_94836:;
    ax = D0;                                // mov ax, word ptr D0
    bx = 18185;                             // mov bx, 4709h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    goto cseg_9486E;                        // jmp short cseg_9486E

cseg_94852:;
    ax = D0;                                // mov ax, word ptr D0
    bx = 28128;                             // mov bx, 6DE0h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;
    flags.carry = dx != 0 != 0;             // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx

cseg_9486E:;
    eax = D0;                               // mov eax, D0
    {
        dword src = *(dword *)&g_memByte[91382];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        src = res;
        *(dword *)&g_memByte[91382] = src;
    }                                       // add startingBalance, eax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_9487A()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    *(word *)&D1 = 0;                       // mov word ptr D1, 0
    *(word *)&D0 = 1999;                    // mov word ptr D0, 1999
    A0 = 353800;                            // mov A0, offset leaguesTableCopy

l_check_loop1:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, al
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_check_loop1;                 // jns short @@check_loop1

    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_table_empty_ok;              // jz short @@table_empty_ok

    debugBreak();                           // int 3

cseg_94919:;
    goto cseg_94919;                        // jmp short cseg_94919

l_table_empty_ok:;
    ax = *(word *)&g_memByte[323894];       // mov ax, teamsLoaded
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_out;                         // jz @@out

    A6 = 252466;                            // mov A6, offset teamFileBuffer
    eax = A6;                               // mov eax, A6
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 2
    A5 = eax;                               // mov A5, eax
    esi = A5;                               // mov esi, A5
    ax = (word)readMemory(esi + 2, 2);      // mov ax, [esi+TeamFile.globalTeamNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    A0 = 353800;                            // mov A0, offset leaguesTableCopy
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A0 = eax;                               // mov A0, eax
    esi = A6;                               // mov esi, A6
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        byte tmp = al;
        al = ah;
        ah = tmp;
    }                                       // xchg ah, al
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    *(word *)&D1 = 0;                       // mov word ptr D1, 0

l_check_loop2:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    {
        int8_t dstSigned = *(byte *)&D1;
        int8_t srcSigned = al;
        byte res = dstSigned + srcSigned;
        flags.carry = (byte)(dstSigned + srcSigned) < (byte)dstSigned;
        *(byte *)&D1 = res;
    }                                       // add byte ptr D1, al
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto l_check_loop2;                 // jns short @@check_loop2

    ax = D1;                                // mov ax, word ptr D1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto l_out;                         // jz short @@out

    debugBreak();                           // int 3

cseg_949B9:;
    goto cseg_949B9;                        // jmp short cseg_949B9

l_out:;
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
}

// =============== S U B R O U T I N E =======================================

// in:
//     A0 -> DIY competition
//     A1 -> team (file)
// out:
//     D0 - some % about teams more expensive than this one, -25..25
//
void cseg_94A16()
{
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+DIY_Competition.competitionType], DIY_LEAGUE
    if (!flags.zero)
        goto l_out;                         // jnz @@out

    esi = A1;                               // mov esi, A1
    {
        byte src = (byte)readMemory(esi + 4, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT8_MIN : srcSigned < dstSigned - INT8_MAX;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp [esi+TeamFile.teamControls], TEAM_COMPUTER
    if (flags.zero)
        goto l_cpu_team;                    // jz short @@cpu_team

    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 695, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 10;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+695], 10
    if (flags.carry)
        goto l_out;                         // jb @@out

    goto cseg_94A5C;                        // jmp short cseg_94A5C

l_cpu_team:;
    esi = A0;                               // mov esi, A0
    {
        word src = (word)readMemory(esi + 695, 2);
        int16_t dstSigned = src;
        int16_t srcSigned = 3;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr [esi+695], 3
    if (flags.carry)
        goto l_out;                         // jb @@out

cseg_94A5C:;
    eax = A0;                               // mov eax, A0
    A6 = eax;                               // mov A6, eax
    esi = A1;                               // mov esi, A1
    ax = (word)readMemory(esi, 2);          // mov ax, word ptr [esi+TeamFile.countryNumber]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    push(D0);                               // push D0
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    FindTeamInDIY();                        // call FindTeamInDIY
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D0);                                // pop D0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    GetMoreExpensiveTeamsCount();           // call GetMoreExpensiveTeamsCount
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = D1;                                // mov ax, word ptr D1
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = ax;
        word res = dstSigned - srcSigned;
        *(word *)&D2 = res;
    }                                       // sub word ptr D2, ax
    ax = D2;                                // mov ax, word ptr D2
    bx = 100;                               // mov bx, 100
    {
        int32_t res = (int16_t)ax * (int16_t)bx;
        ax = res & 0xffff;
        dx = res >> 16;
    }                                       // imul bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi + 49, 2);     // mov ax, [esi+DIY_Competition.numTeams]
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D0 = res;
    }                                       // sub word ptr D0, 1
    if (flags.zero)
        goto l_out;                         // jz short @@out

    ax = D2;                                // mov ax, word ptr D2
    bx = D0;                                // mov bx, word ptr D0
    {
        int32_t dividend = ((int16_t)dx << 16) | (int16_t)ax;
        int16_t quot = (int16_t)(dividend / (int16_t)bx);
        int16_t rem = (int16_t)(dividend % (int16_t)bx);
        ax = quot;
        dx = rem;
    }                                       // idiv bx
    *(word *)&D2 = ax;                      // mov word ptr D2, ax
    *(word *)((byte *)&D2 + 2) = dx;        // mov word ptr D2+2, dx
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = 50;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, 50
    if (flags.zero || flags.sign != flags.overflow)
        goto cseg_94C47;                    // jle short cseg_94C47

    *(word *)&D2 = 50;                      // mov word ptr D2, 50

cseg_94C47:;
    {
        int16_t dstSigned = *(word *)&D2;
        int16_t srcSigned = -50;
        word res = dstSigned - srcSigned;
        flags.overflow = dstSigned < 0 ? srcSigned > dstSigned - INT16_MIN : srcSigned < dstSigned - INT16_MAX;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D2, -50
    if (flags.sign == flags.overflow)
        goto cseg_94C5A;                    // jge short cseg_94C5A

    *(word *)&D2 = -50;                     // mov word ptr D2, -50

cseg_94C5A:;
    {
        int16_t res = *(int16_t *)&D2 >> 1;
        *(int16_t *)&D2 = res;
    }                                       // sar word ptr D2, 1
    ax = D2;                                // mov ax, word ptr D2
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    return;                                 // retn

l_out:;
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    ax ^= ax;
    flags.carry = false;
    flags.overflow = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void cseg_94C7E()
{
    push(D1);                               // push D1
    push(A1);                               // push A1
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 108, 1);    // mov al, [esi+108]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    A1 = 529540;                            // mov A1, offset dseg_180654
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D1;                     // movzx ebx, word ptr D1
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    esi = A0;                               // mov esi, A0
    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 155;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Bh
    if (flags.zero)
        goto cseg_94CDC;                    // jz short cseg_94CDC

    {
        byte src = (byte)readMemory(esi + 113, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 154;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+71h], 9Ah
    if (!flags.zero)
        goto cseg_94D46;                    // jnz short cseg_94D46

cseg_94CDC:;
    eax = A0;                               // mov eax, A0
    D0 = eax;                               // mov D0, eax
    {
        int32_t dstSigned = D0;
        int32_t srcSigned = 92798;
        dword res = dstSigned - srcSigned;
        D0 = res;
    }                                       // sub D0, offset careerTeam
    ax = D0;                                // mov ax, word ptr D0
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 38;                                // mov bx, 26h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    A1 = 91544;                             // mov A1, offset dseg_D6C26
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        flags.carry = ((word)*(word *)&D0 >> 15) & 1;
        *(word *)&D0 = res;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // shl word ptr D0, 1
    goto cseg_94D74;                        // jmp short cseg_94D74

cseg_94D46:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 113, 1);    // mov al, [esi+71h]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        byte src = (byte)readMemory(esi + 102, 1);
        byte res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test byte ptr [esi+66h], 1
    if (flags.zero)
        goto cseg_94D74;                    // jz short cseg_94D74

    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1

cseg_94D74:;
    ax = D0;                                // mov ax, word ptr D0
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = D1;                                // mov bx, word ptr D1
    {
        int32_t dividend = ((int16_t)dx << 16) | (int16_t)ax;
        int16_t quot = (int16_t)(dividend / (int16_t)bx);
        int16_t rem = (int16_t)(dividend % (int16_t)bx);
        ax = quot;
        dx = rem;
    }                                       // idiv bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    pop(A1);                                // pop A1
    pop(D1);                                // pop D1
}

// =============== S U B R O U T I N E =======================================
//
void cseg_94DB1()
{
    cseg_8EA56();                           // call cseg_8EA56
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    al = g_memByte[96216];                  // mov al, byte ptr dseg_D7E66
    *(byte *)&D1 = al;                      // mov byte ptr D1, al
    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = al;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, al
    if (flags.carry)
        goto cseg_94E7A;                    // jb cseg_94E7A

    if (flags.zero)
        goto cseg_94E67;                    // jz cseg_94E67

    {
        int8_t dstSigned = *(byte *)&D0;
        int8_t srcSigned = 1;
        byte res = dstSigned - srcSigned;
        *(byte *)&D0 = res;
    }                                       // sub byte ptr D0, 1
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh

cseg_94DF5:;
    eax = *(dword *)&g_memByte[91408];      // mov eax, dseg_D6B9E
    {
        dword src = *(dword *)&g_memByte[91374];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91374] = src;
    }                                       // add playerWagesBill, eax
    {
        dword src = *(dword *)&g_memByte[91354];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        src = res;
        *(dword *)&g_memByte[91354] = src;
    }                                       // sub newBalance, eax
    {
        dword src = *(dword *)&g_memByte[492495];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[492495] = src;
    }                                       // add dseg_1750D0, eax
    eax = *(dword *)&g_memByte[91404];      // mov eax, dseg_D6B9A
    D1 = eax;                               // mov D1, eax
    {
        dword src = *(dword *)&g_memByte[91370];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[91370] = src;
    }                                       // add generalRunningCosts, eax
    {
        dword src = *(dword *)&g_memByte[91354];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        src = res;
        *(dword *)&g_memByte[91354] = src;
    }                                       // sub newBalance, eax
    {
        dword src = *(dword *)&g_memByte[492491];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[492491] = src;
    }                                       // add dseg_1750CC, eax
    {
        dword src = *(dword *)&g_memByte[492511];
        int32_t dstSigned = src;
        int32_t srcSigned = eax;
        dword res = dstSigned + srcSigned;
        src = res;
        *(dword *)&g_memByte[492511] = src;
    }                                       // add dseg_1750E0, eax
    {
        word src = *(word *)&g_memByte[492505];
        int16_t dstSigned = src;
        int16_t srcSigned = 1;
        word res = dstSigned + srcSigned;
        flags.carry = (word)(dstSigned + srcSigned) < (word)dstSigned;
        src = res;
        *(word *)&g_memByte[492505] = src;
    }                                       // add dseg_1750DA, 1
    (*(int16_t *)&D0)--;
    flags.sign = (*(int16_t *)&D0 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D0 == 0;      // dec word ptr D0
    if (!flags.sign)
        goto cseg_94DF5;                    // jns short cseg_94DF5

cseg_94E67:;
    cseg_8EA56();                           // call cseg_8EA56
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi + 1, 1);      // mov al, [esi+1]
    g_memByte[96216] = al;                  // mov byte ptr dseg_D7E66, al

cseg_94E7A:;
    cseg_3B7F8();                           // call cseg_3B7F8
    cseg_3B842();                           // call cseg_3B842
}

// =============== S U B R O U T I N E =======================================
//
void cseg_94E85()
{
    {
        byte src = g_memByte[91678];
        byte res = src & 1;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 1
    if (flags.zero)
        return;                             // jz cseg_94F69

    A5 = 108445;                            // mov A5, offset europeanChampionships2Copy
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    ax = *(word *)&g_memByte[91718];        // mov ax, dseg_D6CD4
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A5 = res;
    }                                       // add A5, 2
    *(word *)&D7 = 2;                       // mov word ptr D7, 2
    A4 = 108523;                            // mov A4, offset e_c_qualifying_group_1_copy
    cseg_94F6A();                           // call cseg_94F6A
    A4 = 108563;                            // mov A4, offset e_c_qualifying_group_2_copy
    cseg_94F6A();                           // call cseg_94F6A
    A4 = 108603;                            // mov A4, offset e_c_qualifying_group_3_copy
    cseg_94F6A();                           // call cseg_94F6A
    A4 = 108643;                            // mov A4, offset e_c_qualifying_group_4_copy
    cseg_94F6A();                           // call cseg_94F6A
    A4 = 108683;                            // mov A4, offset e_c_qualifying_group_5_copy
    cseg_94F6A();                           // call cseg_94F6A
    A4 = 108723;                            // mov A4, offset e_c_qualifying_group_6_copy
    cseg_94F6A();                           // call cseg_94F6A
    A4 = 108763;                            // mov A4, offset e_c_qualifying_group_7_copy
    cseg_94F6A();                           // call cseg_94F6A
    *(word *)&D7 = 1;                       // mov word ptr D7, 1
    A4 = 108803;                            // mov A4, offset e_c_qualifying_group_8_copy
    cseg_94F6A();                           // call cseg_94F6A
}

// =============== S U B R O U T I N E =======================================
//
void cseg_94F6A()
{
    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (!flags.zero)
        goto cseg_95064;                    // jnz cseg_95064

    RestoreSelectedTeams();                 // call RestoreSelectedTeams
    cseg_8B6B0();                           // call cseg_8B6B0
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ShowDiyLeaguesTournamentMenu();         // call ShowDiyLeaguesTournamentMenu
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    cseg_95130();                           // call cseg_95130
    SaveSelectedTeams();                    // call SaveSelectedTeams
    return;                                 // retn

cseg_95064:;
    eax = A4;                               // mov eax, A4
    A0 = eax;                               // mov A0, eax
    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_3ABB2();                           // call cseg_3ABB2
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

    cseg_95130();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_95130()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_883DD();                           // call cseg_883DD
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 109;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 6Dh
    A0 = eax;                               // mov A0, eax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 301;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 12Dh
    A1 = eax;                               // mov A1, eax
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1

cseg_95223:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 18;                                // mov bx, 12h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A5 = res;
    }                                       // add A5, 2
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_95223;                    // jns short cseg_95223
}

// =============== S U B R O U T I N E =======================================
//
void cseg_95298()
{
    {
        byte src = g_memByte[91678];
        byte res = src & 128;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 80h
    if (flags.zero)
        goto cseg_952AD;                    // jz short cseg_952AD

    ax = *(word *)&g_memByte[126625];       // mov ax, dseg_DF52F
    *(word *)&g_memByte[91714] = ax;        // mov dseg_D6CD0, ax

cseg_952AD:;
    {
        byte src = g_memByte[91678];
        byte res = src & 64;
        flags.carry = false;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // test someTeamFlags, 40h
    if (flags.zero)
        return;                             // jz cseg_95400

    A5 = 109079;                            // mov A5, offset worldCup2Copy
    esi = A5;                               // mov esi, A5
    al = (byte)readMemory(esi + 7, 1);      // mov al, [esi+7]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 255;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 0FFh
    eax = A5;                               // mov eax, A5
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 7;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 7
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A5 = eax;                               // mov A5, eax
    ax = *(word *)&g_memByte[91714];        // mov ax, dseg_D6CD0
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
        A5 = res;
    }                                       // add A5, 2
    *(word *)&D7 = 2;                       // mov word ptr D7, 2
    A4 = 109191;                            // mov A4, offset world_cup_qualifying_group_1_copy
    cseg_95401();                           // call cseg_95401
    A4 = 109231;                            // mov A4, offset world_cup_qualifying_group_2_copy
    cseg_95401();                           // call cseg_95401
    A4 = 109271;                            // mov A4, offset world_cup_qualifying_group_3_copy
    cseg_95401();                           // call cseg_95401
    A4 = 109311;                            // mov A4, offset world_cup_qualifying_group_4_copy
    cseg_95401();                           // call cseg_95401
    A4 = 109351;                            // mov A4, offset world_cup_qualifying_group_5_copy
    cseg_95401();                           // call cseg_95401
    A4 = 109391;                            // mov A4, offset world_cup_qualifying_group_6_copy
    cseg_95401();                           // call cseg_95401
    A4 = 109431;                            // mov A4, offset world_cup_qualifying_group_7_copy
    cseg_95401();                           // call cseg_95401
    A4 = 109471;                            // mov A4, offset world_cup_qualifying_group_8_copy
    cseg_95401();                           // call cseg_95401
    *(word *)&D7 = 3;                       // mov word ptr D7, 3
    A4 = 109511;                            // mov A4, offset north_america_world_cup_qualification_copy
    cseg_95401();                           // call cseg_95401
    *(word *)&D7 = 4;                       // mov word ptr D7, 4
    A4 = 109583;                            // mov A4, offset south_america_world_cup_qualification_copy
    cseg_95401();                           // call cseg_95401
    *(word *)&D7 = 5;                       // mov word ptr D7, 5
    A4 = 109647;                            // mov A4, offset africa_world_cup_qualification_copy
    cseg_95401();                           // call cseg_95401
    *(word *)&D7 = 2;                       // mov word ptr D7, 2
    A4 = 109759;                            // mov A4, offset asiaWorldCupQualificationCopy
    cseg_95401();                           // call cseg_95401
    *(word *)&D7 = 1;                       // mov word ptr D7, 1
    A4 = 109867;                            // mov A4, offset oceaniaWorldCupQualificationCopy
    cseg_95401();                           // call cseg_95401
}

// =============== S U B R O U T I N E =======================================
//
void cseg_95401()
{
    eax = *(dword *)&g_memByte[99868];      // mov eax, dseg_D8CAA
    {
        int32_t dstSigned = A4;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A4, eax
    if (!flags.zero)
        goto cseg_955FF;                    // jnz cseg_955FF

    RestoreSelectedTeams();                 // call RestoreSelectedTeams
    esi = A4;                               // mov esi, A4
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 2
    if (flags.zero)
        goto cseg_9551B;                    // jz cseg_9551B

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 0
    if (!flags.zero)
        { cseg_95ACA(); return; }           // jnz cseg_95ACA

    cseg_8B6B0();                           // call cseg_8B6B0
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    ShowDiyLeaguesTournamentMenu();         // call ShowDiyLeaguesTournamentMenu
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    cseg_956EB();                           // call cseg_956EB
    SaveSelectedTeams();                    // call SaveSelectedTeams
    return;                                 // retn

cseg_9551B:;
    cseg_8B6B0();                           // call cseg_8B6B0
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    *(word *)&D1 = 1;                       // mov word ptr D1, 1
    *(word *)&D2 = 0;                       // mov word ptr D2, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_89B5C();                           // call cseg_89B5C
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    cseg_9590C();                           // call cseg_9590C
    SaveSelectedTeams();                    // call SaveSelectedTeams
    return;                                 // retn

cseg_955FF:;
    eax = A4;                               // mov eax, A4
    A0 = eax;                               // mov A0, eax
    esi = A4;                               // mov esi, A4
    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 2;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 2
    if (flags.zero)
        { cseg_95853(); return; }           // jz cseg_95853

    {
        byte src = (byte)readMemory(esi + 1, 1);
        int8_t dstSigned = src;
        int8_t srcSigned = 0;
        byte res = dstSigned - srcSigned;
        flags.carry = (byte)(dstSigned - srcSigned) > (byte)dstSigned;
        flags.sign = (res & 0x80) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp byte ptr [esi+1], 0
    if (!flags.zero)
        { cseg_95ACA(); return; }           // jnz cseg_95ACA

    *(word *)&D0 = 0;                       // mov word ptr D0, 0
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_3ABB2();                           // call cseg_3ABB2
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

    cseg_956EB();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_956EB()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_883DD();                           // call cseg_883DD
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    A1 = 318643;                            // mov A1, offset DIY_competitionStart
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 109;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 6Dh
    A0 = eax;                               // mov A0, eax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 301;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 12Dh
    A1 = eax;                               // mov A1, eax

cseg_957DE:;
    esi = A0;                               // mov esi, A0
    ax = (word)readMemory(esi, 2);          // mov ax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 2
    eax.hi16 = (int16_t)ax < 0 ? -1 : 0;    // cwde
    D0 = eax;                               // mov D0, eax
    dx = *(word *)((byte *)&D0 + 2);        // mov dx, word ptr D0+2
    bx = 18;                                // mov bx, 12h
    {
        dword dividend = (dx << 16) | ax;
        word quot = (word)(dividend / bx);
        word rem = (word)(dividend % bx);
        ax = quot;
        dx = rem;
    }                                       // div bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A5 = res;
    }                                       // add A5, 2
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_957DE;                    // jns short cseg_957DE
}

// =============== S U B R O U T I N E =======================================
//
void cseg_95853()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_3ADAE();                           // call cseg_3ADAE
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0

    cseg_9590C();
}

// =============== S U B R O U T I N E =======================================
//
void cseg_9590C()
{
    push(D0);                               // push D0
    push(D1);                               // push D1
    push(D2);                               // push D2
    push(D3);                               // push D3
    push(D4);                               // push D4
    push(D5);                               // push D5
    push(D6);                               // push D6
    push(D7);                               // push D7
    push(A0);                               // push A0
    push(A1);                               // push A1
    push(A2);                               // push A2
    push(A3);                               // push A3
    push(A4);                               // push A4
    push(A5);                               // push A5
    push(A6);                               // push A6
    cseg_95A51();                           // call cseg_95A51
    pop(A6);                                // pop A6
    pop(A5);                                // pop A5
    pop(A4);                                // pop A4
    pop(A3);                                // pop A3
    pop(A2);                                // pop A2
    pop(A1);                                // pop A1
    pop(A0);                                // pop A0
    pop(D7);                                // pop D7
    pop(D6);                                // pop D6
    pop(D5);                                // pop D5
    pop(D4);                                // pop D4
    pop(D3);                                // pop D3
    pop(D2);                                // pop D2
    pop(D1);                                // pop D1
    pop(D0);                                // pop D0
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D1 = ax;                      // mov word ptr D1, ax
    {
        int16_t dstSigned = *(word *)&D1;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D1 = res;
    }                                       // sub word ptr D1, 1
    A1 = 317588;                            // mov A1, offset diyFileBufferCopy
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 89;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 59h
    A0 = eax;                               // mov A0, eax
    eax = A1;                               // mov eax, A1
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = 153;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, 99h
    A1 = eax;                               // mov A1, eax

cseg_959FF:;
    esi = A0;                               // mov esi, A0
    al = (byte)readMemory(esi, 1);          // mov al, [esi]
    (*(int32_t *)&A0)++;                    // inc A0
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 1;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 1
    esi = A1;                               // mov esi, A1
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    esi = A5;                               // mov esi, A5
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        flags.carry = (dword)(dstSigned + srcSigned) < (dword)dstSigned;
        A5 = res;
    }                                       // add A5, 2
    (*(int16_t *)&D1)--;
    flags.sign = (*(int16_t *)&D1 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D1 == 0;      // dec word ptr D1
    if (!flags.sign)
        goto cseg_959FF;                    // jns short cseg_959FF
}

// =============== S U B R O U T I N E =======================================
//
void cseg_95A51()
{
    A2 = 317588;                            // mov A2, offset diyFileBufferCopy
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + 83, 2);     // mov ax, [esi+53h]
    bx = 118;                               // mov bx, 76h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A2;                               // mov eax, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A3 = eax;                               // mov A3, eax
    A4 = 318643;                            // mov A4, offset DIY_competitionStart
    A5 = 318643;                            // mov A5, offset DIY_competitionStart
    esi = A3;                               // mov esi, A3
    ax = (word)readMemory(esi + 349, 2);    // mov ax, [esi+15Dh]
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
    if (flags.zero)
        goto cseg_95AC4;                    // jz short cseg_95AC4

    cseg_8A2CE();                           // call cseg_8A2CE
    return;                                 // retn

cseg_95AC4:;
    cseg_8A7BF();                           // call cseg_8A7BF
}

// =============== S U B R O U T I N E =======================================
//
void cseg_95ACA()
{

l_endless_loop:;
    goto l_endless_loop;                    // jmp short @@endless_loop
}

// =============== S U B R O U T I N E =======================================
//
void cseg_95ACD()
{
    A3 = 92330;                             // mov A3, offset dseg_D6F38
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 2, 65535);             // mov word ptr [esi], 0FFFFh
    writeMemory(esi + 4, 2, 65535);         // mov word ptr [esi+4], 0FFFFh
    writeMemory(esi + 8, 2, 65535);         // mov word ptr [esi+8], 0FFFFh
    writeMemory(esi + 12, 2, 65535);        // mov word ptr [esi+0Ch], 0FFFFh
    cseg_3E608();                           // call cseg_3E608
    if (!flags.zero)
        return;                             // jnz cseg_95C17

    *(word *)&D3 = 4;                       // mov word ptr D3, 4
    A0 = 92798;                             // mov A0, offset careerTeam
    A5 = 92766;                             // mov A5, offset currentMatchPlayers
    ax = *(word *)&g_memByte[94090];        // mov ax, careerNumPlayers
    *(word *)&D7 = ax;                      // mov word ptr D7, ax
    {
        int16_t dstSigned = *(word *)&D7;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        *(word *)&D7 = res;
    }                                       // sub word ptr D7, 1

cseg_95B30:;
    esi = A5;                               // mov esi, A5
    ebx = *(word *)&D7;                     // movzx ebx, word ptr D7
    al = (byte)readMemory(esi + ebx, 1);    // mov al, [esi+ebx]
    ah = (int8_t)al < 0 ? -1 : 0;           // cbw
    bx = 38;                                // mov bx, 26h
    tmp = ax * bx;
    ax = tmp.lo16;
    dx = tmp.hi16;                          // mul bx
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    *(word *)((byte *)&D0 + 2) = dx;        // mov word ptr D0+2, dx
    eax = A0;                               // mov eax, A0
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    {
        int32_t dstSigned = eax;
        int32_t srcSigned = ebx;
        dword res = dstSigned + srcSigned;
        eax = res;
    }                                       // add eax, ebx
    A1 = eax;                               // mov A1, eax
    esi = A1;                               // mov esi, A1
    al = (byte)readMemory(esi + 103, 1);    // mov al, [esi+67h]
    *(byte *)&D0 = al;                      // mov byte ptr D0, al
    {
        word res = *(word *)&D0 & 28;
        *(word *)&D0 = res;
    }                                       // and word ptr D0, 1Ch
    {
        int16_t dstSigned = *(word *)&D0;
        int16_t srcSigned = 0;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp word ptr D0, 0
    if (flags.zero)
        goto cseg_95C0A;                    // jz short cseg_95C0A

    A2 = 92346;                             // mov A2, offset dseg_D6F48
    ax = D7;                                // mov ax, word ptr D7
    *(word *)&D0 = ax;                      // mov word ptr D0, ax
    {
        word res = *(word *)&D0 << 2;
        *(word *)&D0 = res;
    }                                       // shl word ptr D0, 2
    esi = A2;                               // mov esi, A2
    ebx = *(word *)&D0;                     // movzx ebx, word ptr D0
    ax = (word)readMemory(esi + ebx, 2);    // mov ax, [esi+ebx]
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 2
    esi = A2;                               // mov esi, A2
    ax = (word)readMemory(esi + ebx + 2, 2); // mov ax, [esi+ebx+2]
    esi = A3;                               // mov esi, A3
    writeMemory(esi, 2, ax);                // mov [esi], ax
    {
        int32_t dstSigned = A3;
        int32_t srcSigned = 2;
        dword res = dstSigned + srcSigned;
        A3 = res;
    }                                       // add A3, 2
    {
        int16_t dstSigned = *(word *)&D3;
        int16_t srcSigned = 1;
        word res = dstSigned - srcSigned;
        flags.carry = (word)(dstSigned - srcSigned) > (word)dstSigned;
        flags.sign = (res & 0x8000) != 0;
        flags.zero = res == 0 != 0;
        *(word *)&D3 = res;
    }                                       // sub word ptr D3, 1
    if (flags.zero)
        return;                             // jz short cseg_95C17

cseg_95C0A:;
    (*(int16_t *)&D7)--;
    flags.sign = (*(int16_t *)&D7 & 0x8000) != 0;
    flags.zero = *(int16_t *)&D7 == 0;      // dec word ptr D7
    if (!flags.sign)
        goto cseg_95B30;                    // jns cseg_95B30
}

// =============== S U B R O U T I N E =======================================
//
void cseg_95C18()
{
    A0 = 27303;                             // mov A0, offset dseg_C7136

cseg_95C22:;
    esi = A0;                               // mov esi, A0
    {
        dword src = readMemory(esi, 4);
        int32_t dstSigned = src;
        int32_t srcSigned = -1;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp dword ptr [esi], 0FFFFFFFFh
    if (flags.zero)
        goto cseg_95C48;                    // jz short cseg_95C48

    eax = readMemory(esi, 4);               // mov eax, [esi]
    {
        int32_t dstSigned = A0;
        int32_t srcSigned = 4;
        dword res = dstSigned + srcSigned;
        A0 = res;
    }                                       // add A0, 4
    {
        int32_t dstSigned = A5;
        int32_t srcSigned = eax;
        dword res = dstSigned - srcSigned;
        flags.carry = (dword)(dstSigned - srcSigned) > (dword)dstSigned;
        flags.sign = (res & 0x80000000) != 0;
        flags.zero = res == 0 != 0;
    }                                       // cmp A5, eax
    if (!flags.zero)
        goto cseg_95C22;                    // jnz short cseg_95C22

    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
    return;                                 // retn

cseg_95C48:;
    *(word *)&D0 = 1;                       // mov word ptr D0, 1
    ax = 1;                                 // mov ax, 1
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // or ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void SetZeroFlag2()
{
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

// =============== S U B R O U T I N E =======================================
//
void nullsub_9()
{
}

// =============== S U B R O U T I N E =======================================
//
void SetZeroFlag()
{
    ax ^= ax;
    flags.carry = false;
    flags.sign = (ax & 0x8000) != 0;
    flags.zero = ax == 0;                   // xor ax, ax
}

